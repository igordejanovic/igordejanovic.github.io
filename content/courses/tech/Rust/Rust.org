# -*- ispell-dictionary: "sr"; -*-
#+TITLE: –ü—Ä–æ–≥—Ä–∞–º—Å–∫–∏ —ò–µ–∑–∏–∫ –†–∞—Å—Ç
#+SUBTITLE: –ë–∞–∑–∏—Ä–∞–Ω–æ –Ω–∞ –≤–µ—Ä–∑–∏—ò–∏ 1.65.0. –£ –∏–∑—Ä–∞–¥–∏.
#+EXPORT_FILE_NAME: index.html
#+EXPORT_REVEAL_HLEVEL: 10
#+SETUPFILE: ../../courses-startup-cyr.org

* –£–≤–æ–¥
- –à–µ–∑–∏–∫ –æ–ø—à—Ç–µ –Ω–∞–º–µ–Ω–µ, –∫–æ–º–ø–∞—ò–ª–∏—Ä–∞–Ω –∏ —Å—Ç–∞—Ç–∏—á–∫–∏ —Ç–∏–ø–∏–∑–∏—Ä–∞–Ω —Å–∞ –∏–Ω—Ñ–µ—Ä–µ–Ω—Ü–æ–º —Ç–∏–ø–æ–≤–∞
- –°–∏—Å—Ç–µ–º—Å–∫–æ –ø—Ä–æ–≥—Ä–∞–º–∏—Ä–∞—ö–µ –∞–ª–∏ —Å–∞ –æ—Å–æ–±–∏–Ω–∞–º–∞ –≤–∏—à–µ–≥ –Ω–∏–≤–æ–∞ –∞–ø—Å—Ç—Ä–∞–∫—Ü–∏—ò–µ –∫–∞–æ —à—Ç–æ —Å—É
  —Ñ—É–Ω–∫—Ü–∏–æ–Ω–∞–ª–Ω–æ –ø—Ä–æ–≥—Ä–∞–º–∏—Ä–∞—ö–µ
- 2010, Graydon Hoare, Mozilla Research
- –ü–µ—Ä—Ñ–æ—Ä–º–∞–Ω—Å–µ –∏ —Å–∏–≥—É—Ä–Ω–æ—Å—Ç
- –ù–µ –∫–æ—Ä–∏—Å—Ç–∏ /garbage collector/ –∞–ª–∏ –æ–±–µ–∑–±–µ—í—É—ò–µ –º–µ–º–æ—Ä–∏—ò—Å–∫—É —Å–∏–≥—É—Ä–Ω–æ—Å—Ç –∫—Ä–æ–∑ /borrow
  checker/
- –°–∏–Ω—Ç–∞–∫—Å–Ω–æ —Å–ª–∏—á–∞–Ω C++. –£—Ç–∏—Ü–∞—ò –∏ OCaml-–∞, Haskell-–∞ –∏ Erlang-–∞.
- –ö–æ—Ä–∏—Å—Ç–∏ —Å–µ —É –≤–µ–ª–∏–∫–∏–º —Ñ–∏—Ä–º–∞–º–∞: Amazon, Facebook, Google, Microsoft...
- –í–∏—à–µ –≥–æ–¥–∏–Ω–∞ –∑–∞ —Ä–µ–¥–æ–º –Ω–∞ SO —É–ø–∏—Ç–Ω–∏–∫—É –ø—Ä–≤–∏ —É –∫–∞—Ç–µ–≥–æ—Ä–∏—ò–∏ /"most loved programming
  languages"/

* –ò–Ω—Å—Ç–∞–ª–∞—Ü–∏—ò–∞ –∏ –ø–æ–¥–µ—à–∞–≤–∞—ö–µ
** –ò–Ω—Å—Ç–∞–ª–∞—Ü–∏—ò–∞
- –†–∞—Å—Ç —Å—Ç–∏–∂–µ —Å–∞ –∞–ª–∞—Ç–æ–º –∑–∞ —É–ø—Ä–∞–≤—ô–∞—ö–µ –ª–∞–Ω—Ü–µ–º –∞–ª–∞—Ç–∞ (–µ–Ω–≥. /toolchain/) -- =rustup=

#+begin_src sh
$ curl --proto '=https' --tlsv1.2 https://sh.rustup.rs -sSf | sh
#+end_src

- –ü—Ä–æ–≤–µ—Ä–∞ –∏–Ω—Å—Ç–∞–ª–∞—Ü–∏—ò–µ:

#+begin_src sh
~> rustc --version
rustc 1.65.0 (897e37553 2022-11-02)
#+end_src

** –ü—Ä–µ–≥–ª–µ–¥ –∏–Ω—Å—Ç–∞–ª–∞—Ü–∏—ò–µ
#+begin_src sh
~> rustup show
Default host: x86_64-unknown-linux-gnu
rustup home:  /home/igor/.rustup

installed toolchains
--------------------

stable-x86_64-unknown-linux-gnu (default)
nightly-x86_64-unknown-linux-gnu

active toolchain
----------------

stable-x86_64-unknown-linux-gnu (default)
rustc 1.58.1 (db9d1b20b 2022-01-20)
#+end_src

** –ê–∂—É—Ä–∏—Ä–∞—ö–µ
–ó–∞ –∞–∂—É—Ä–∏—Ä–∞—ö–µ –∏–Ω—Å—Ç–∞–ª–∞—Ü–∏—ò–µ –Ω–∞ –Ω–∞—ò–Ω–æ–≤–∏—ò—É –≤–µ—Ä–∑–∏—ò—É:

#+begin_src sh
rustup update
#+end_src

** –î–æ–∫—É–º–µ–Ω—Ç–∞—Ü–∏—ò–∞
–†–∞—Å—Ç —Å—Ç–∏–∂–µ —Å–∞ –≤–µ–æ–º–∞ –¥–æ–±—Ä–æ–º –¥–æ–∫—É–º–µ–Ω—Ç–∞—Ü–∏—ò–æ–º –∏ –∫—ö–∏–≥–∞–º–∞ –∫–æ—ò–µ —Å—É –¥–æ—Å—Ç—É–ø–Ω–µ –¥–∏—Ä–µ–∫—Ç–Ω–æ –∏–∑
–∏–Ω—Å—Ç–∞–ª–∞—Ü–∏—ò–µ:

#+begin_src sh
rustup doc
#+end_src

* –ü–æ—á–µ—Ç–∞–∫
** Hello, World!
#+begin_src sh
$ mkdir hello_world
$ cd hello_world
#+end_src

File =main.rs=:
#+begin_src rust
fn main() {
    println!("Hello, world!");
}
#+end_src

** –ö–æ–º–ø–∞—ò–ª–∏—Ä–∞—ö–µ –∏ –ø–æ–∫—Ä–µ—Ç–∞—ö–µ
#+begin_src sh
$ rustc main.rs
$ ./main
Hello, world!
#+end_src

** Hello, Cargo!
- –ê–ª–∞—Ç –∑–∞ —Ä–∞–∑—Ä–µ—à–∞–≤–∞—ö–µ –∑–∞–≤–∏—Å–Ω–æ—Å—Ç–∏ –∏ —É–ø—Ä–∞–≤—ô–∞—ö–µ –ø—Ä–æ—ò–µ–∫—Ç–æ–º.

#+begin_src sh
~> cargo --version
cargo 1.65.0 (4bc8f24d3 2022-10-20)
#+end_src

- –ö—Ä–µ–∏—Ä–∞—ö–µ –ø—Ä–æ—ò–µ–∫—Ç–∞ —Å–∞ =cargo= –∞–ª–∞—Ç–æ–º:

#+begin_src sh
$ cargo new hello_cargo
$ cd hello_cargo
#+end_src

** –°–∞–¥—Ä–∂–∞—ò –∫—Ä–µ–∏—Ä–∞–Ω–æ–≥ –ø—Ä–æ—ò–µ–∫—Ç–∞
–§–∞—ò–ª =cargo.toml= —á—É–≤–∞ –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—ò—É –ø—Ä–æ—ò–µ–∫—Ç–∞. –§–æ—Ä–º–∞—Ç —ò–µ [[https://toml.io/en/][TOML]] (/Tom‚Äôs Obvious,
Minimal Language/):

#+begin_src toml
[package]
name = "hello_cargo"
version = "0.1.0"
edition = "2021"

[dependencies]
#+end_src

Fajl =src/main.rs=:
#+begin_src rust
fn main() {
    println!("Hello, world!");
}
#+end_src

** –ü–æ–∫—Ä–µ—Ç–∞—ö–µ
#+begin_src rust
$ cargo build
   Compiling hello_cargo v0.1.0 (file:///projects/hello_cargo)
    Finished dev [unoptimized + debuginfo] target(s) in 2.85 secs
#+end_src

–ò–∑–≤—Ä—à–Ω–∏ —Ñ–∞—ò–ª —Å–µ –º–æ–∂–µ –Ω–∞—õ–∏ –Ω–∞ –ª–æ–∫–∞—Ü–∏—ò–∏ =target/debug/hello_cargo=:

#+begin_src sh
$ ./target/debug/hello_cargo
Hello, world!
#+end_src

–ê–ª–∏ =cargo= –æ–º–æ–≥—É—õ–∞–≤–∞ –∏ —ò–µ–¥–Ω–æ—Å—Ç–∞–≤–Ω–∏—ò–∏ –Ω–∞—á–∏–Ω –ø–æ–∫—Ä–µ—Ç–∞—ö–∞:
#+begin_src sh
$ cargo run
    Finished dev [unoptimized + debuginfo] target(s) in 0.0 secs
     Running `target/debug/hello_cargo`
Hello, world!
#+end_src

** –ü—Ä–æ–≤–µ—Ä–∞
–¢–∞–∫–æ—í–µ —ò–µ –º–æ–≥—É—õ–µ –±—Ä–∑–æ –ø—Ä–æ–≤–µ—Ä–∏—Ç–∏ –¥–∞ –ª–∏ —Å–µ –∫–æ–¥ –∫–æ–º–ø–∞—ò–ª–∏—Ä–∞:

#+begin_src sh
$ cargo check
   Checking hello_cargo v0.1.0 (file:///projects/hello_cargo)
    Finished dev [unoptimized + debuginfo] target(s) in 0.32 secs
#+end_src

** –ò–∑–≥—Ä–∞–¥—ö–∞ —Ñ–∏–Ω–∞–ª–Ω–µ –≤–µ—Ä–∑–∏—ò–µ
- –£ —Ç–æ–∫—É —Ä–∞–∑–≤–æ—ò–∞ –∫–æ—Ä–∏—Å—Ç–∏–º–æ –∏–∑–≥—Ä–∞–¥—ö—É –∑–∞ –¥–µ–±–∞–≥–æ–≤–∞—ö–µ –∫–æ—ò–∞ —Å–µ –±—Ä–∂–µ –∑–∞–≤—Ä—à–∏ –∞–ª–∏
  –≥–µ–Ω–µ—Ä–∏—Å–∞–Ω–∏ –∏–∑–≤—Ä—à–Ω–∏ –∫–æ–¥ –Ω–∏—ò–µ –æ–ø—Ç–∏–º–∞–ª–∞–Ω.

- –ó–∞ —Ñ–∏–Ω–∞–ª–Ω—É –≤–µ—Ä–∑–∏—ò—É —ò–µ –ø–æ—Ç—Ä–µ–±–Ω–æ –∏–∑–≥—Ä–∞–¥—ö—É –æ–±–∞–≤–∏—Ç–∏ –Ω–∞ —Å–ª–µ–¥–µ—õ–∏ –Ω–∞—á–∏–Ω:

    #+begin_src rust
    cargo build --release
    #+end_src

- –û–≤–æ —õ–µ –æ–±–∞–≤–∏—Ç–∏ –¥–æ–¥–∞—Ç–Ω–µ –æ–ø—Ç–∏–º–∏–∑–∞—Ü–∏—ò–µ –∫–æ—ò–µ —õ–µ –¥—É–∂–µ —Ç—Ä–∞—ò–∞—Ç–∏ –∞–ª–∏ —õ–µ –∫—Ä–∞—ò—ö–∏ –∫–æ–¥
  –±–∏—Ç–∏ –æ–ø—Ç–∏–º–∏–∑–æ–≤–∞–Ω.

** =cargo= –∫–∞–æ –∫–æ–Ω–≤–µ–Ω—Ü–∏—ò–∞
–ü—Ä–∞–∫—Ç–∏—á–Ω–æ —Å–≤–∏ –†–∞—Å—Ç –ø—Ä–æ—ò–µ–∫—Ç–∏ –∫–æ—Ä–∏—Å—Ç–µ =cargo= —Ç–∞–∫–æ –¥–∞ —ò–µ —É–Ω–∏—Ñ–∏–∫–æ–≤–∞–Ω –Ω–∞—á–∏–Ω –∏–∑–≥—Ä–∞–¥—ö–µ
–ø—Ä–æ—ò–µ–∫–∞—Ç–∞. –£–≥–ª–∞–≤–Ω–æ–º —Å–µ —Å–≤–æ–¥–∏ –Ω–∞:

#+begin_src sh
$ git clone example.org/someproject
$ cd someproject
$ cargo build
#+end_src
* –ò–≥—Ä–∞ –ø–æ–≥–∞—í–∞—ö–∞ –±—Ä–æ—ò–µ–≤–∞
** –ü–æ–¥–µ—à–∞–≤–∞—ö–µ –ø—Ä–æ—ò–µ–∫—Ç–∞
#+begin_src rust
$ cargo new guessing_game
$ cd guessing_game
#+end_src

–§–∞—ò–ª =Cargo.toml=:
#+begin_src toml
[package]
name = "guessing_game"
version = "0.1.0"
edition = "2021"

[dependencies]
#+end_src

–§–∞—ò–ª =src/main.rs=:
#+begin_src rust
fn main() {
    println!("Hello, world!");
}
#+end_src

#+REVEAL: split

#+begin_src sh
$ cargo run
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
    Finished dev [unoptimized + debuginfo] target(s) in 1.50s
     Running `target/debug/guessing_game`
Hello, world!
#+end_src

** –ü—Ä–µ—É–∑–∏–º–∞—ö–µ –±—Ä–æ—ò–∞ —Å–∞ —Å—Ç–∞–Ω–¥–∞—Ä–¥–Ω–æ–≥ —É–ª–∞–∑–∞
#+begin_src rust
use std::io;

fn main() {
    println!("Guess the number!");

    println!("Please input your guess.");

    let mut guess = String::new();

    io::stdin()
        .read_line(&mut guess)
        .expect("Failed to read line");

    println!("You guessed: {}", guess);
}
#+end_src

** –ü—Ä–æ–º–µ–Ω—ô–∏–≤–æ—Å—Ç (/mutability/)
- –í–∞—Ä–∏—ò–∞–±–ª–µ —Å—É –ø–æ–¥—Ä–∞–∑—É–º–µ–≤–∞–Ω–æ –Ω–µ–ø—Ä–æ–º–µ—ö–∏–≤–µ (/immutable/).
- –£–∫–æ–ª–∏–∫–æ –∂–µ–ª–∏–º–æ –≤–∞—Ä–∏—ò–∞–±–ª—É —á–∏—ò–∞ –≤—Ä–µ–¥–Ω–æ—Å—Ç –º–æ–∂–µ –¥–∞ —Å–µ –º–µ—ö–∞ –∫–æ—Ä–∏—Å—Ç–∏–º–æ –∫—ô—É—á–Ω—É —Ä–µ—á
  =mut=.

  #+begin_src rust
  let apples = 5; // immutable
  let mut bananas = 5; // mutable
  #+end_src

- –ò—Å—Ç–æ –≤–∞–∂–∏ –∏ –∑–∞ –ø–∞—Ä–∞–º–µ—Ç—Ä–µ –∏ –∞—Ä–≥—É–º–µ–Ω—Ç–µ —Ñ—É–Ω–∫—Ü–∏—ò–∞:

  #+begin_src rust
  io::stdin()
      .read_line(&mut guess)
  #+end_src

** –û–±—Ä–∞–¥–∞ –º–æ–≥—É—õ–∏—Ö –≥—Ä–µ—à–∞–∫–∞ —É–ø–æ—Ç—Ä–µ–±–æ–º =Result= —Ç–∏–ø–∞
=read_line= –º–æ–∂–µ –¥–∞ –∑–∞–≤—Ä—à–∏ –Ω–µ—É—Å–ø–µ—à–Ω–æ. –ó–∞—Ç–æ –≤—Ä–∞—õ–∞ =io::Result= —Ç–∏–ø –∫–æ—ò–∏ –ø—Ä–µ–¥—Å—Ç–∞–≤—ô–∞
—Ç–∏–ø –µ–Ω—É–º–µ—Ä–∞—Ü–∏—ò–µ (/enum/) –∏ –∏–º–∞ –¥–≤–µ –º–æ–≥—É—õ–µ –≤—Ä–µ–¥–Ω–æ—Å—Ç–∏: =Ok= –∏ =Err=.

#+begin_src rust
io::stdin()
    .read_line(&mut guess)
    .expect("Failed to read line");
#+end_src

=expect= je –∏–º–ø–ª–µ–º–µ–Ω—Ç–∏—Ä–∞–Ω —Ç–∞–∫–æ –¥–∞ —õ–µ —É —Å–ª—É—á–∞—ò—É =Ok= –≤–∞—Ä–∏—ò–∞–Ω—Ç–µ –≤—Ä–∞—Ç–∏—Ç–∏ –≤—Ä–µ–¥–Ω–æ—Å—Ç –∫–æ—ò–∞
—ò–µ —Å–∞–¥—Ä–∂–∞–Ω–∞ —É–Ω—É—Ç–∞—Ä –≤–∞—Ä–∏—ò–∞–Ω—Ç–µ –¥–æ–∫ —õ–µ —É —Å–ª—É—á–∞—ò—É =Err= –≤–∞—Ä–∏—ò–∞–Ω—Ç–µ –ø—Ä–µ–∫–∏–Ω—É—Ç–∏ –∏–∑–≤—Ä—à–∞–≤–∞—ö–µ
–ø—Ä–æ–≥—Ä–∞–º–∞.

#+begin_src rust
pub fn expect(self, msg: &str) -> T
    where
        E: fmt::Debug,
    {
        match self {
            Ok(t) => t,
            Err(e) => unwrap_failed(msg, &e),
        }
    }
#+end_src

** –ü–æ–∫—Ä–µ—Ç–∞—ö–µ
#+begin_src rust
$ cargo run
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
    Finished dev [unoptimized + debuginfo] target(s) in 6.44s
     Running `target/debug/guessing_game`
Guess the number!
Please input your guess.
6
You guessed: 6
#+end_src

** –ì–µ–Ω–µ—Ä–∏—Å–∞—ö–µ —Å–ª—É—á–∞—ò–Ω–æ–≥ –±—Ä–æ—ò–∞
–ö–æ—Ä–∏—Å—Ç–∏–º–æ =rand= –ø–∞–∫–µ—Ç (—Å–∞–Ω–¥—É–∫ - /crate/ —É —Ç–µ—Ä–º–∏–Ω–æ–ª–æ–≥–∏—ò–∏ /Cargo/-a).

–°–µ–∫—Ü–∏—ò–∞ =[dependencies]= —É —Ñ–∞—ò–ª—É =Cargo.toml=:
#+begin_src toml
[dependencies]
rand = "0.8.3"
#+end_src

#+begin_src sh
$ cargo build
    Updating crates.io index
  Downloaded rand v0.8.3
  Downloaded libc v0.2.86
  ...
   Compiling rand_chacha v0.3.0
   Compiling rand v0.8.3
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
    Finished dev [unoptimized + debuginfo] target(s) in 2.53s
#+end_src

/Cargo/ –∫–æ—Ä–∏—Å—Ç–∏ [[https://semver.org/][Semantic Versioning]]. –†–∞—Å—Ç –ø–∞–∫–µ—Ç–∏ —Å–µ –ø—Ä–µ—É–∑–∏–º–∞—ò—É —Å–∞ —Å–∞—ò—Ç–∞ [[https://crates.io/][crates.io]]
–∏ –∫–µ—à–∏—Ä–∞—ò—É –ª–æ–∫–∞–ª–Ω–æ.

** –ü–æ–Ω–æ–≤—ô–∏–≤–æ—Å—Ç –∏–∑–≥—Ä–∞–¥—ö–µ - /Cargo.lock/
- –°–≤–∞–∫–æ —Å–ª–µ–¥–µ—õ–µ –ø–æ–∫—Ä–µ—Ç–∞—ö–µ –∏–∑–≥—Ä–∞–¥—ö–µ –∫–æ—Ä–∏—Å—Ç–∏ –∏—Å—Ç–µ –≤–µ—Ä–∑–∏—ò–µ.
- –ü—Ä–≤–∏ –ø—É—Ç –∫–∞–¥–∞ —Å–µ –ø–æ–∫—Ä–µ–Ω–µ =cargo build= –∫—Ä–µ–∏—Ä–∞ —Å–µ —Ñ–∞—ò–ª =Cargo.lock= —Å–∞
  –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—ò–∞–º–∞ –æ –≤–µ—Ä–∑–∏—ò–∞–º–∞ —Å–≤–∏—Ö —Å–∞–Ω–¥—É–∫–∞ –∫–æ—ò–∏ —Å—É –∏–Ω—Å—Ç–∞–ª–∏—Ä–∞–Ω–∏.
- =Cargo.lock= —ò–µ –ø–æ—Ç—Ä–µ–±–Ω–æ —á—É–≤–∞—Ç–∏ —É —Å–∏—Å—Ç–µ–º—É –∫–æ–Ω—Ç—Ä–æ–ª–µ –≤–µ—Ä–∑–∏—ò–∞ (–Ω–ø—Ä. =git=) –¥–∞ –±–∏ —Å–µ
  –æ—Å–∏–≥—É—Ä–∞–ª–∞ –ø–æ–Ω–æ–≤—ô–∏–≤–æ—Å—Ç.

** –ê–∂—É—Ä–∏—Ä–∞—ö–µ —Å–∞–Ω–¥—É–∫–∞
- –ê–∂—É—Ä–∏—Ä–∞—ö–µ –Ω–∞ –Ω–æ–≤–µ –≤–µ—Ä–∑–∏—ò–µ —Å–∞–Ω–¥—É–∫–∞ —Å–µ –æ–±–∞–≤—ô–∞ —Å–∞:

  #+begin_src sh
  $ cargo update
    Updating crates.io index
    Updating rand v0.8.3 -> v0.8.4
  #+end_src
- –ü–æ—à—Ç—É—ò–µ —Å–µ —Å–µ–º–∞–Ω—Ç–∏—á–∫–æ –≤–µ—Ä–∑–∏–æ–Ω–∏—Ä–∞—ö–µ —Ç—ò. –∞—É—Ç–æ–º–∞—Ç—Å–∫–∏ —Å–µ –∞–∂—É—Ä–∏—Ä–∞ –Ω–∞ —Å–ª–µ–¥–µ—õ—É
  –≤–µ—Ä–∑–∏—ò—É –∫–æ—ò–∞ —ò–µ –º–∞—ö–∞ –æ–¥ –Ω–∞—Ä–µ–¥–Ω–µ –≥–ª–∞–≤–Ω–µ (/major/) –≤–µ—Ä–∑–∏—ò–µ.
- –ê–∫–æ –ø—Ä–µ–ª–∞–∑–∏–º–æ –Ω–∞ –Ω–æ–≤—É –≥–ª–∞–≤–Ω—É –≤–µ—Ä–∑–∏—ò—É —Ç–æ –º–æ—Ä–∞–º–æ —É—Ä–∞–¥–∏—Ç–∏ –∏–∑–º–µ–Ω–æ–º –≤–µ—Ä–∑–∏—ò–µ —É
  =Cargo.toml= —Ñ–∞—ò–ª—É.

** –ì–µ–Ω–µ—Ä–∏—Å–∞—ö–µ —Å–ª—É—á–∞—ò–Ω–æ–≥ –±—Ä–æ—ò–∞
–§–∞—ò–ª =src/main.rs=:
#+begin_src rust
use std::io;
use rand::Rng;

fn main() {
    println!("Guess the number!");

    let secret_number = rand::thread_rng().gen_range(1..101);

    println!("The secret number is: {}", secret_number);

    println!("Please input your guess.");

    let mut guess = String::new();

    io::stdin()
        .read_line(&mut guess)
        .expect("Failed to read line");

    println!("You guessed: {}", guess);
}
#+end_src

–£ =gen_range= –∫–æ—Ä–∏—Å—Ç–∏–º–æ –∏–∑—Ä–∞–∑ –æ–ø—Å–µ–≥–∞ (/range expression/). –ò–Ω—Ç–µ—Ä–≤–∞–ª —ò–µ –∑–∞—Ç–≤–æ—Ä–µ–Ω –Ω–∞
–¥–æ—ö–æ—ò –≥—Ä–∞–Ω–∏—Ü–∏ –∏ –æ—Ç–≤–æ—Ä–µ–Ω –Ω–∞ –≥–æ—Ä—ö–æ—ò. –ó–∞ –∏–Ω—Ç–µ—Ä–≤–∞–ª –∑–∞—Ç–≤–æ—Ä–µ–Ω –∏ –æ–¥ –≥–æ—Ä–µ –º–æ–∂–µ–º–æ
–ø–∏—Å–∞—Ç–∏ ~1..=100~.

** –î–æ–∫—É–º–µ–Ω—Ç–∞—Ü–∏—ò–∞ –∑–∞ –ª–æ–∫–∞–ª–Ω–µ —Å–∞–Ω–¥—É–∫–µ
–î–∞ –±–∏ –∑–Ω–∞–ª–∏ –∫–æ—ò–µ –º–µ—Ç–æ–¥–µ –∏ —Ñ—É–Ω–∫—Ü–∏—ò–µ —Å—É –Ω–∞–º –¥–æ—Å—Ç—É–ø–Ω–µ –º–æ–∂–µ–º–æ –∫–æ—Ä–∏—Å—Ç–∏—Ç–∏ —É–≥—Ä–∞—í–µ–Ω—É
–¥–æ–∫—É–º–µ–Ω—Ç–∞—Ü–∏—ò—É –∑–∞ —Å–∞–Ω–¥—É–∫–µ –ø—Ä–æ—ò–µ–∫—Ç–∞. –î–æ–∫—É–º–µ–Ω—Ç–∞—Ü–∏—ò—É –¥–æ–±–∏—ò–∞–º–æ —Å–∞:

#+begin_src sh
cargo doc --open
#+end_src

** –ü–æ–∫—Ä–µ—Ç–∞—ö–µ –ø—Ä–æ–≥—Ä–∞–º–∞
#+begin_src sh
$ cargo run
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
    Finished dev [unoptimized + debuginfo] target(s) in 2.53s
     Running `target/debug/guessing_game`
Guess the number!
The secret number is: 7
Please input your guess.
4
You guessed: 4
#+end_src

** –ü–æ—Ä–µ—í–µ—ö–µ —Ç–∞—ò–Ω–æ–≥ –±—Ä–æ—ò–∞ —Å–∞ –∑–∞–¥–∞—Ç–∏–º
–§–∞—ò–ª =src/main.rs=
#+begin_src rust
use rand::Rng;
use std::cmp::Ordering;
use std::io;

fn main() {
    // --snip--

    println!("You guessed: {}", guess);

    match guess.cmp(&secret_number) {
        Ordering::Less => println!("Too small!"),
        Ordering::Greater => println!("Too big!"),
        Ordering::Equal => println!("You win!"),
    }
}
#+end_src
- –ö–æ—Ä–∏—Å—Ç–∏–º–æ =std::cmp::Ordering= –µ–Ω—É–º–µ—Ä–∏—Å–∞–Ω–∏ —Ç–∏–ø –∫–æ—ò–∏ –∏–º–∞ –≤–∞—Ä–∏—ò–∞–Ω—Ç–µ =Less=, =Greater=
  –∏ =Equal=
- =match= –∏–∑—Ä–∞–∑ –ø–æ—Ä–µ–¥–∏ –∑–∞–¥–∞—Ç—É –≤—Ä–µ–¥–Ω–æ—Å—Ç —Å–∞ –≤—Ä–µ–¥–Ω–æ—Å—Ç–∏–º–∞ –∑–∞–¥–∞—Ç–∏–º —É —Ç–µ–ª—É –∏ –∏–∑–≤—Ä—à–∞–≤–∞
  –≥—Ä–∞–Ω—É –∫–æ—ò–∞ —Å–µ –ø–æ–¥—É–¥–∞—Ä–∞. –ì—Ä–∞–Ω–µ =match= –∏–∑—Ä–∞–∑–∞ —Å–µ —É –†–∞—Å—Ç —Ç–µ—Ä–º–∏–Ω–æ–ª–æ–≥–∏—ò–∏ –∑–æ–≤—É "—Ä—É–∫–µ"
  (/arms/).

** –ü–æ–ø—Ä–∞–≤–∫–∞ —Ç–∏–ø–æ–≤–∞
–ö–æ–¥ —Å–∞ –ø—Ä–µ—Ç—Ö–æ–¥–Ω–æ–≥ —Å–ª–∞—ò–¥–∞ –Ω–∏—ò–µ –∏—Å–ø—Ä–∞–≤–∞–Ω:
#+begin_src sh
$ cargo build
   Compiling libc v0.2.86
   ...
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
error[E0308]: mismatched types
  --> src/main.rs:22:21
   |
22 |     match guess.cmp(&secret_number) {
   |                     ^^^^^^^^^^^^^^ expected struct `String`, found integer
   |
   = note: expected reference `&String`
              found reference `&{integer}`

error[E0283]: type annotations needed for `{integer}`
   --> src/main.rs:8:44
    |
8   |     let secret_number = rand::thread_rng().gen_range(1..101);
    |         -------------                      ^^^^^^^^^ cannot infer type for type `{integer}`
    |         |
    |         consider giving `secret_number` a type
    |
    = note: multiple `impl`s satisfying `{integer}: SampleUniform` found in the `rand` crate:
            - impl SampleUniform for i128;
            - impl SampleUniform for i16;
            - impl SampleUniform for i32;
            - impl SampleUniform for i64;
            and 8 more
...
#+end_src

#+REVEAL: split

–û—Å–Ω–æ–≤–∞ –≥—Ä–µ—à–∫–µ —ò–µ –Ω–µ—Å–ª–∞–≥–∞—ö–µ —Ç–∏–ø–æ–≤–∞. –°–∞ —É–ª–∞–∑–∞ –ø—Ä–∏—Ö–≤–∞—Ç–∞–º–æ =String= –¥–æ–∫ –Ω–∞–º —ò–µ —Ç–∞—ò–Ω–∏
–±—Ä–æ—ò =integer=.

** –ö–æ–Ω–≤–µ—Ä–∑–∏—ò–∞ —Å—Ç—Ä–∏–Ω–≥–∞ —É –±—Ä–æ—ò
–ü—Ä–æ–±–ª–µ–º —Ä–µ—à–∞–≤–∞–º–æ –∫–æ–Ω–≤–µ—Ä–∑–∏—ò–æ–º —Å—Ç—Ä–∏–Ω–≥–∞ —Å–∞ —É–ª–∞–∑–∞ —É –±—Ä–æ—ò–Ω–∏ —Ç–∏–ø.

#+begin_src rust
// --snip--

    let mut guess = String::new();

    io::stdin()
        .read_line(&mut guess)
        .expect("Failed to read line");

    let guess: u32 = guess.trim().parse().expect("Please type a number!");

    println!("You guessed: {}", guess);

    match guess.cmp(&secret_number) {
        Ordering::Less => println!("Too small!"),
        Ordering::Greater => println!("Too big!"),
        Ordering::Equal => println!("You win!"),
    }
#+end_src

#+REVEAL: split

–°–∞–¥–∞ —Å–µ –ø—Ä–æ–≥—Ä–∞–º –∫–æ–º–ø–∞—ò–ª–∏—Ä–∞.

#+begin_src sh
$ cargo run
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
    Finished dev [unoptimized + debuginfo] target(s) in 0.43s
     Running `target/debug/guessing_game`
Guess the number!
The secret number is: 58
Please input your guess.
  76
You guessed: 76
Too big!
#+end_src

** –û–º–æ–≥—É—õ–∞–≤–∞—ö–µ –≤–∏—à–µ—Å—Ç—Ä—É–∫–æ–≥ –ø–æ–≥–∞—í–∞—ö–∞ - —É–ø–æ—Ç—Ä–µ–±–∞ –ø–µ—Ç—ô–µ
–§–∞—ò–ª =src/main.rs=:
#+begin_src rust
// --snip--

    println!("The secret number is: {}", secret_number);

    loop {
        println!("Please input your guess.");

        // --snip--

        match guess.cmp(&secret_number) {
            Ordering::Less => println!("Too small!"),
            Ordering::Greater => println!("Too big!"),
            Ordering::Equal => println!("You win!"),
        }
    }
}
#+end_src

** –ü—Ä–µ–∫–∏–¥ —Ä–∞–¥–∞
–ü—Ä–æ–±–ª–µ–º —ò–µ –∫–∞–∫–æ –ø—Ä–µ–∫–∏–Ω—É—Ç–∏ –ø—Ä–æ–≥—Ä–∞–º –∫–∞–¥–∞ –∫–æ—Ä–∏—Å–Ω–∏–∫ –ø–æ–≥–æ–¥–∏ –±—Ä–æ—ò?

#+begin_src rust
// --snip--

        match guess.cmp(&secret_number) {
            Ordering::Less => println!("Too small!"),
            Ordering::Greater => println!("Too big!"),
            Ordering::Equal => {
                println!("You win!");
                break;
            }
        }
    }
}
#+end_src

** –†—É–∫–æ–≤–∞—ö–µ –Ω–µ–∏—Å–ø—Ä–∞–≤–Ω–∏–º —É–ª–∞–∑–æ–º
#+begin_src rust
// --snip--

        io::stdin()
            .read_line(&mut guess)
            .expect("Failed to read line");

        let guess: u32 = match guess.trim().parse() {
            Ok(num) => num,
            Err(_) => continue,
        };

        println!("You guessed: {}", guess);

        // --snip--
#+end_src

–ü–æ—Ç—Ä–µ–±–Ω–æ —ò–µ —ò–æ—à –æ–±—Ä–∏—Å–∞—Ç–∏ –ª–∏–Ω–∏—ò—É –∫–æ—ò–∞ –ø—Ä–∏–∫–∞–∑—É—ò–µ –≥–µ–Ω–µ—Ä–∏—Å–∞–Ω–∏ –±—Ä–æ—ò.

** –§–∏–Ω–∞–ª–Ω–∏ –∫–æ–¥
#+begin_src rust
use rand::Rng;
use std::cmp::Ordering;
use std::io;

fn main() {
    println!("Guess the number!");
    let secret_number = rand::thread_rng().gen_range(1..101);

    loop {
        println!("Please input your guess.");
        let mut guess = String::new();
        io::stdin()
            .read_line(&mut guess)
            .expect("Failed to read line");
        let guess: u32 = match guess.trim().parse() {
            Ok(num) => num,
            Err(_) => continue,
        };
        println!("You guessed: {}", guess);
        match guess.cmp(&secret_number) {
            Ordering::Less => println!("Too small!"),
            Ordering::Greater => println!("Too big!"),
            Ordering::Equal => {
                println!("You win!");
                break;
            }
        }
    }
}
#+end_src

* –û—Å–Ω–æ–≤–Ω–∏ –ø—Ä–æ–≥—Ä–∞–º—Å–∫–∏ –∫–æ–Ω—Ü–µ–ø—Ç–∏
** –í–∞—Ä–∏—ò–∞–±–ª–µ –∏ –ø—Ä–æ–º–µ–Ω—ô–∏–≤–æ—Å—Ç (/mutability/)
*** –í–∞—Ä–∏—ò–∞–±–ª–µ –∏ –ø—Ä–æ–º–µ–Ω—ô–∏–≤–æ—Å—Ç (/mutability/)
- –í–∞—Ä–∏—ò–∞–±–ª–µ —Å—É –ø–æ–¥—Ä–∞–∑—É–º–µ–≤–∞–Ω–æ –Ω–µ–ø—Ä–æ–º–µ—ö–∏–≤–µ.
- –à–µ–¥–Ω–æ–º –∫–∞–¥–∞ –¥–æ–±–∏—ò—É –≤—Ä–µ–¥–Ω–æ—Å—Ç (/binding/) —Ç–∞ –≤—Ä–µ–¥–Ω–æ—Å—Ç —Å–µ –Ω–µ –º–æ–∂–µ –ø—Ä–æ–º–µ–Ω–∏—Ç–∏

  #+begin_src rust
    fn main() {
        let x = 5;
        println!("The value of x is: {}", x);
        x = 6;     // gre≈°ka
        println!("The value of x is: {}", x);
    }
  #+end_src

  #+REVEAL: split

  #+begin_src sh
    $ cargo run
    Compiling variables v0.1.0 (file:///projects/variables)
    error[E0384]: cannot assign twice to immutable variable `x`
    --> src/main.rs:4:5
    |
    2 |     let x = 5;
    |         -
    |         |
    |         first assignment to `x`
    |         help: consider making this binding mutable: `mut x`
    3 |     println!("The value of x is: {}", x);
    4 |     x = 6;
    |     ^^^^^ cannot assign twice to immutable variable

    For more information about this error, try `rustc --explain E0384`.
    error: could not compile `variables` due to previous error
  #+end_src
*** =mut= –∫—ô—É—á–Ω–∞ —Ä–µ—á

#+begin_src rust
fn main() {
    let mut x = 5;
    println!("The value of x is: {}", x);
    x = 6;
    println!("The value of x is: {}", x);
}
#+end_src
** –ö–æ–Ω—Å—Ç–∞–Ω—Ç–µ - =const=
- –°–ª–∏—á–Ω–æ –∫–∞–æ –Ω–µ–ø—Ä–æ–º–µ—ö–∏–≤–µ –≤–∞—Ä–∏—ò–∞–±–ª–µ —Å–∞ —Å–ª–µ–¥–µ—õ–∏–º —Ä–∞–∑–ª–∏–∫–∞–º–∞:
  - –£–≤–µ–∫ —Å—É –Ω–µ–ø—Ä–æ–º–µ—ö–∏–≤–µ
  - –ú–æ–≥—É —Å–µ –∏–Ω–∏—Ü–∏—ò–∞–ª–∏–∑–æ–≤–∞—Ç–∏ —Å–∞–º–æ –∫–æ–Ω—Å—Ç–∞–Ω—Ç–Ω–∏–º –∏–∑—Ä–∞–∑–æ–º (–ø–æ–∑–Ω–∞—Ç–∏–º —É –≤—Ä–µ–º–µ
    –∫–æ–º–ø–∞—ò–ª–∏—Ä–∞—ö–∞)
  - –í–∞–ª–∏–¥–Ω–µ –∑–∞ —Ü–µ–ª–æ–∫—É–ø–Ω–æ –≤—Ä–µ–º–µ –∏–∑–≤—Ä—à–∞–≤–∞—ö–∞ –ø—Ä–æ–≥—Ä–∞–º–∞ —É –æ–ø—Å–µ–≥—É –≤–∞–∂–µ—ö–∞ –≥–¥–µ —Å—É
    –¥–µ—Ñ–∏–Ω–∏—Å–∞–Ω–µ (/scope/)
  - –ú–æ—Ä–∞ —Å–µ –µ–∫—Å–ø–ª–∏—Ü–∏—Ç–Ω–æ –¥–µ—Ñ–∏–Ω–∏—Å–∞—Ç–∏ —Ç–∏–ø
- –ö–æ–º–ø–∞—ò–ª–µ—Ä —õ–µ –∫–æ–Ω—Å—Ç–∞–Ω—Ç–µ "—É–±–∞—Ü–∏—Ç–∏" –Ω–∞ –º–µ—Å—Ç—É —É–ø–æ—Ç—Ä–µ–±–µ
- –ü–æ –∫–æ–Ω–≤–µ–Ω—Ü–∏—ò–∏ –∏–º–µ–Ω–∞ –∫–æ–Ω—Å—Ç–∞–Ω—Ç–∏ —Å–µ –ø–∏—à—É –≤–µ–ª–∏–∫–∏–º —Å–ª–æ–≤–∏–º–∞

  #+begin_src rust
    const THREE_HOURS_IN_SECONDS: u32 = 60 * 60 * 3;
  #+end_src

** –¢–∏–ø–æ–≤–∏ –ø–æ–¥–∞—Ç–∞–∫–∞
*** –¢–∏–ø–æ–≤–∏ –ø–æ–¥–∞—Ç–∞–∫–∞
- –°–≤–∞–∫–∞ –≤—Ä–µ–¥–Ω–æ—Å—Ç —É –†–∞—Å—Ç—É –∏–º–∞ —Ç–∏–ø. –¢–∏–ø–æ–≤–∏ –º–æ—Ä–∞—ò—É –±–∏—Ç–∏ –ø–æ–∑–Ω–∞—Ç–∏ —É –≤—Ä–µ–º–µ
  –∫–æ–º–ø–∞—ò–ª–∏—Ä–∞—ö–∞ (/—Å—Ç–∞—Ç–∏—á–∫–∏ —Ç–∏–ø–∏–∑–∏—Ä–∞–Ω —ò–µ–∑–∏–∫/).
- –ö–æ–º–ø–∞—ò–ª–µ—Ä —õ–µ –ø—Ä–æ–±–∞—Ç–∏ –¥–∞ –æ–¥—Ä–µ–¥–∏ —Ç–∏–ø–æ–≤–µ (/type inference/). –ê–∫–æ –Ω–∏—ò–µ –º–æ–≥—É—õ–µ
  –∑–∞—Ö—Ç–µ–≤–∞ —Å–µ –¥–∞ –¥–µ—Ñ–∏–Ω–∏—à–µ–º–æ —Ç–∏–ø –µ–∫—Å–ø–ª–∏—Ü–∏—Ç–Ω–æ.

  –ù–ø—Ä:
  #+begin_src rust
    let guess: u32 = "42".parse().expect("Not a number!");
  #+end_src
  –û–≤–¥–µ –Ω–∏—ò–µ –º–æ–≥—É—õ–µ –æ–¥—Ä–µ–¥–∏—Ç–∏ —Ç–∏–ø —ò–µ—Ä =str::parse= —Ñ—É–Ω–∫—Ü–∏—ò–∞ –º–æ–∂–µ –≤—Ä–∞—Ç–∏—Ç–∏ —Ä–∞–∑–ª–∏—á–∏—Ç–µ
  –±—Ä–æ—ò–Ω–µ —Ç–∏–ø–æ–≤–µ (—Ñ—É–Ω–∫—Ü–∏—ò–∞ —ò–µ –≥–µ–Ω–µ—Ä–∏—á–∫–∞) –∞ –Ω–µ –ø–æ—Å—Ç–æ—ò–∏ –Ω–∞—á–∏–Ω –¥–∞ —Å–µ —Ç–∏–ø –∞—É—Ç–æ–º–∞—Ç—Å–∫–∏
  –æ–¥—Ä–µ–¥–∏.

  –°–∏–≥–Ω–∞—Ç—É—Ä–∞ —ò–µ:
  #+begin_src rust
    pub fn parse<F>(&self) -> Result<F, <F as FromStr>::Err>
    where
        F: FromStr
  #+end_src
*** /Integer/ —Ç–∏–ø–æ–≤–∏

| –î—É–∂–∏–Ω–∞  | Signed | Unsigned |
|---------+--------+----------|
| 8-bit   | i8     | u8       |
| 16-bit  | i16    | u16      |
| 32-bit  | i32    | u32      |
| 64-bit  | i64    | u64      |
| 128-bit | i128   | u128     |
| arch    | isize  | usize    |

*** –õ–∏—Ç–µ—Ä–∞–ª–∏ –±—Ä–æ—ò–µ–≤–∞

| –õ–∏—Ç–µ—Ä–∞–ª–∏       | –ü—Ä–∏–º–µ—Ä–∏     |
|----------------+-------------|
| Decimal        | 98_222      |
| Hex            | 0xff        |
| Octal          | 0o77        |
| Binary         | 0b1111_0000 |
| Byte (u8 only) | b'A'        |

*** /Floating-Point/ —Ç–∏–ø–æ–≤–∏

#+begin_src rust
fn main() {
    let x = 2.0; // f64

    let y: f32 = 3.0; // f32
}
#+end_src

IEEE-754 —Å—Ç–∞–Ω–¥–∞—Ä–¥

*** –û–ø–µ—Ä–∞—Ü–∏—ò–µ –Ω–∞–¥ –±—Ä–æ—ò–µ–≤–∏–º–∞

#+begin_src rust
fn main() {
    // addition
    let sum = 5 + 10;

    // subtraction
    let difference = 95.5 - 4.3;

    // multiplication
    let product = 4 * 30;

    // division
    let quotient = 56.7 / 32.2;
    let floored = 2 / 3; // Results in 0

    // remainder
    let remainder = 43 % 5;
}
#+end_src

*** /Boolean/ —Ç–∏–ø
#+begin_src rust
fn main() {
    let t = true;

    let f: bool = false; // with explicit type annotation
}
#+end_src

*** –¢–∏–ø –∫–∞—Ä–∞–∫—Ç–µ—Ä–∞

#+begin_src rust
fn main() {
    let c = 'z';
    let z = '‚Ñ§';
    let heart_eyed_cat = 'üòª';
}
#+end_src

*** –¢–æ—Ä–∫–µ (/tuples/)
#+begin_src rust
fn main() {
    let tup: (i32, f64, u8) = (500, 6.4, 1);
}
#+end_src

- –†–∞—Å–ø–∞–∫–∏–≤–∞—ö–µ —Ç–æ—Ä–∫–∏ (/destructuring/):
#+begin_src rust
fn main() {
    let tup = (500, 6.4, 1);

    let (x, y, z) = tup;

    println!("The value of y is: {}", y);
}
#+end_src

#+REVEAL: split

–ü—Ä–∏—Å—Ç—É–ø –µ–ª–µ–º–µ–Ω—Ç–∏–º–∞ —Ç–æ—Ä–∫–µ:
#+begin_src rust
fn main() {
    let x: (i32, f64, u8) = (500, 6.4, 1);

    let five_hundred = x.0;

    let six_point_four = x.1;

    let one = x.2;
}
#+end_src

*** –ù–∏–∑–æ–≤–Ω–∏ —Ç–∏–ø
- –°–≤–∞–∫–∏ –µ–ª–µ–º–µ–Ω—Ç –Ω–∏–∑–æ–≤–Ω–æ–≥ —Ç–∏–ø–∞ –º–æ—Ä–∞ –∏–º–∞—Ç–∏ –∏—Å—Ç–∏ —Ç–∏–ø
- –î–∏–º–µ–Ω–∑–∏—ò–∞ –Ω–∏–∑–∞ —ò–µ –Ω–µ–ø—Ä–æ–º–µ—ö–∏–≤–∞ (–∞–ª–æ—Ü–∏—Ä–∞–Ω —ò–µ –Ω–∞ —Å—Ç–µ–∫—É)
    #+begin_src rust
    fn main() {
        let a = [1, 2, 3, 4, 5];
    }
    #+end_src

- –¢–∏–ø —Å–µ –º–æ–∂–µ –µ–∫—Å–ø–ª–∏—Ü–∏—Ç–Ω–æ –¥–µ—Ñ–∏–Ω–∏—Å–∞—Ç–∏ –Ω–∞ —Å–ª–µ–¥–µ—õ–∏ –Ω–∞—á–∏–Ω (–Ω–∏–∑ –¥—É–∂–∏–Ω–µ =5= —Ç–∏–ø–∞ =i32=):
    #+begin_src rust
    let a: [i32; 5] = [1, 2, 3, 4, 5];
    #+end_src

- –ò–Ω–∏—Ü–∏—ò–∞–ª–∏–∑–∞—Ü–∏—ò–∞ —Å–≤–∏—Ö –µ–ª–µ–º–µ–Ω–∞—Ç–∞ –Ω–∞ –∏—Å—Ç—É –≤—Ä–µ–¥–Ω–æ—Å—Ç —Å–µ –æ–±–∞–≤—ô–∞ –Ω–∞ —Å–ª–µ–¥–µ—õ–∏ –Ω–∞—á–∏–Ω:
  #+begin_src rust
  let a = [3; 5];
  #+end_src
  –ì–¥–µ —ò–µ –≤—Ä–µ–¥–Ω–æ—Å—Ç —Å–≤–∞–∫–æ–≥ –µ–ª–µ–º–µ–Ω—Ç–∞ =3= –∞ –¥—É–∂–∏–Ω–∞ –Ω–∏–∑–∞ =5=.

#+REVEAL: split

–ò–Ω–¥–µ–∫—Å–Ω–∏ –ø—Ä–∏—Å—Ç—É–ø:

#+begin_src rust
fn main() {
    let a = [1, 2, 3, 4, 5];

    let first = a[0];
    let second = a[1];
}
#+end_src

** –§—É–Ω–∫—Ü–∏—ò–µ
*** –§—É–Ω–∫—Ü–∏—ò–µ
#+begin_src rust
fn main() {
    println!("Hello, world!");

    another_function();
}

fn another_function() {
    println!("Another function.");
}
#+end_src
- –ó–∞ –∏–º–µ–Ω–æ–≤–∞—ö–µ —Ñ—É–Ω–∫—Ü–∏—ò–∞ –∫–∞–æ –∏ –≤–∞—Ä–∏—ò–∞–±–ª–∏ –∫–æ—Ä–∏—Å—Ç–∏ —Å–µ /snake_case/.
*** Funkcije - parametri
#+begin_src rust
fn main() {
    print_labeled_measurement(5, 'h');
}

fn print_labeled_measurement(value: i32, unit_label: char) {
    println!("The measurement is: {}{}", value, unit_label);
}
#+end_src

*** –ò—Å–∫–∞–∑–∏ –∏ –∏–∑—Ä–∞–∑–∏
- –†a—Å—Ç —ò–µ —ò–µ–∑–∏–∫ –±–∞–∑–∏—Ä–∞–Ω –Ω–∞ –∏–∑—Ä–∞–∑–∏–º–∞ (/expression-based/)
- –ò—Å–∫–∞–∑–∏ (/statements/) —Å—É —ò–µ–∑–∏—á–∫–µ –∫–æ–Ω—Å—Ç—Ä—É–∫—Ü–∏—ò–µ –∫–æ—ò–µ –Ω–µ–º–∞—ò—É –ø–æ–≤—Ä–∞—Ç–Ω—É –≤—Ä–µ–¥–Ω–æ—Å—Ç.
  –ò–∑—Ä–∞–∑–∏ (/expressions/) —Å–µ –µ–≤–∞–ª—É–∏—Ä–∞—ò—É —É –æ–¥—Ä–µ—í–µ–Ω–∏ —Ä–µ–∑—É–ª—Ç–∞—Ç, —Ç—ò. –∏–º–∞—ò—É –≤—Ä–µ–¥–Ω–æ—Å—Ç.
- –ü—Ä–∏–º–µ—Ä: =let= —ò–µ –∏—Å–∫–∞–∑ —Ç—ò. –Ω–µ–º–∞ –ø–æ–≤—Ä–∞—Ç–Ω—É –≤—Ä–µ–¥–Ω–æ—Å—Ç. –û–≤–æ –º–æ–∂–µ—Ç–µ –ø–∏—Å–∞—Ç–∏:
  #+begin_src rust
  let y = 6;
  #+end_src
  Ali ovo ne:
  #+begin_src rust
  let x = (let y = 6);
  #+end_src

#+REVEAL: split

–ë–ª–æ–∫ –∫–æ–¥–∞ —ò–µ —Ç–∞–∫–æ—í–µ –∏–∑—Ä–∞–∑. –®—Ç–∞ —ò–µ –≤—Ä–µ–¥–Ω–æ—Å—Ç —É –∫–æ—ò—É —Å–µ –µ–≤–∞–ª—É–∏—Ä–∞?

#+begin_src rust
{
    let x = 3;
    x + 1
}
#+end_src

–í—Ä–µ–¥–Ω–æ—Å—Ç –±–ª–æ–∫–∞ —ò–µ –≤—Ä–µ–¥–Ω–æ—Å—Ç –ø–æ—Å–ª–µ–¥—ö–µ–≥ –∏–∑—Ä–∞–∑–∞, —Ç—ò. =x+1=. –ü—Ä–∏–º–µ—Ç–∏—Ç–µ –¥–∞ —Ç—É –Ω–µ
–∫–æ—Ä–∏—Å—Ç–∏–º–æ =;= —ò–µ—Ä —Ç–µ—Ä–º–∏–Ω–∞—Ü–∏—ò–∞ –æ–≤–∏–º –∫–∞—Ä–∞–∫—Ç–µ—Ä–æ–º –ø—Ä–µ—Ç–≤–∞—Ä–∞ –∏–∑—Ä–∞–∑ —É –∏—Å–∫–∞–∑.

#+REVEAL: split

–ó–±–æ–≥ –æ–≤–æ–≥–∞ —ò–µ —Å–∞—Å–≤–∏–º –ª–µ–≥–∞–ª–Ω–æ –¥–∞ –ø–∏—à–µ–º–æ:

#+begin_src rust
fn main() {
    let y = {
        let x = 3;
        x + 1
    };

    println!("The value of y is: {}", y);
}
#+end_src

#+RESULTS:
: The value of y is: 4
*** –ü–æ–≤—Ä–∞—Ç–Ω–µ –≤—Ä–µ–¥–Ω–æ—Å—Ç–∏ —Ñ—É–Ω–∫—Ü–∏—ò–∞
–í—Ä–µ–¥–Ω–æ—Å—Ç —Ñ—É–Ω–∫—Ü–∏—ò–µ —ò–µ –≤—Ä–µ–¥–Ω–æ—Å—Ç –±–ª–æ–∫–∞ –∫–æ—ò–∏ –ø—Ä–µ–¥—Å—Ç–∞–≤—ô–∞ —Ç–µ–ª–æ —Ñ—É–Ω–∫—Ü–∏—ò–µ, –¥–∞–∫–ª–µ
–ø–æ—Å–ª–µ–¥—ö–µ–≥ –∏–∑—Ä–∞–∑–∞ —É–Ω—É—Ç–∞—Ä —Ç–µ–ª–∞ —Ñ—É–Ω–∫—Ü–∏—ò–µ.

#+begin_src rust
fn five() -> i32 {
    5
}

fn main() {
    let x = five();

    println!("The value of x is: {}", x);
}
#+end_src

#+RESULTS:
: The value of x is: 5

#+REVEAL: split

–ò–ª–∏ –Ω–∞ –ø—Ä–∏–º–µ—Ä:
#+begin_src rust
fn main() {
    let x = plus_one(5);

    println!("The value of x is: {}", x);
}

fn plus_one(x: i32) -> i32 {
    x + 1
}
#+end_src

#+RESULTS:
: The value of x is: 6

#+REVEAL: split

–£–∫–æ–ª–∏–∫–æ –∏–∑—Ä–∞–∑ =x+1= —Ç–µ—Ä–º–∏–Ω–∏—Ä–∞–º–æ —Å–∞ =;= –∫–æ–¥ —Å–µ –Ω–µ—õ–µ –∫–æ–º–ø–∞—ò–ª–∏—Ä–∞—Ç–∏ —ò–µ—Ä —Ñ—É–Ω–∫—Ü–∏—ò–∞
–¥–µ–∫–ª–∞—Ä–∏—à–µ –¥–∞ –≤—Ä–∞—õ–∞ —Ç–∏–ø =i32= –¥–æ–∫ —Å–∞–¥–∞ –≤—Ä–∞—õ–∞ =()= (—Ç–∑–≤. /unit type/) –æ–¥–Ω–æ—Å–Ω–æ –Ω–µ–º–∞
–ø–æ–≤—Ä–∞—Ç–Ω—É –≤—Ä–µ–¥–Ω–æ—Å—Ç —ò–µ—Ä —ò–µ –ø–æ—Å–ª–µ–¥—ö–∞ –∏–Ω—Å—Ç—Ä—É–∫—Ü–∏—ò–∞ –∏—Å–∫–∞–∑.

#+begin_src rust
fn main() {
    let x = plus_one(5);

    println!("The value of x is: {}", x);
}

fn plus_one(x: i32) -> i32 {
    x + 1;
}
#+end_src

#+begin_example
error[E0308]: mismatched types
 --> src/main.rs:8:24
  |
8 | fn plus_one(x: i32) -> i32 {
  |    --------            ^^^ expected `i32`, found `()`
  |    |
  |    implicitly returns `()` as its body has no tail or `return` expression
9 |     x + 1;
  |          - help: consider removing this semicolon

For more information about this error, try `rustc --explain E0308`.
error: could not compile `cargo4UyKF0` due to previous error
#+end_example

** –ö–æ–º–µ–Ω—Ç–∞—Ä–∏
–ö–æ–º–µ–Ω—Ç–∞—Ä–∏ —Å–µ –ø–∏—à—É –ø–æ—Å–ª–µ =//= –∏–ª–∏ —É —Ñ–æ—Ä–º–∏ –±–ª–æ–∫ –∫–æ–º–µ–Ω—Ç–∞—Ä–∞ =/*.... */= –∫–∞–æ –∏ —É C++-—É.
–û–≤–æ –±–∏ –±–∏–ª–∏ –≤–∞–ª–∏–¥–Ω–∏ –∫–æ–º–µ–Ω—Ç–∞—Ä–∏:
#+begin_src rust
// So we‚Äôre doing something complicated here, long enough that we need
// multiple lines of comments to do it! Whew! Hopefully, this comment will
// explain what‚Äôs going on.

fn main() {
    let lucky_number = 7; // I‚Äôm feeling lucky today
}
...
fn main() {
    // I‚Äôm feeling lucky today
    let lucky_number = 7;
    /* this is block comment
       which can span multiple lines.
       Nesting is allowed.
     */
}
#+end_src

#+REVEAL: split

–ü–æ—Å—Ç–æ—ò–µ –∏ –∫–æ–º–µ–Ω—Ç–∞—Ä–∏ –∑–∞ –¥–æ–∫—É–º–µ–Ω—Ç–∞—Ü–∏—ò—É –∫–æ—ò–∏ –ø—Ä–µ–¥—Å—Ç–∞–≤—ô–∞—ò—É –ø–æ—Å–µ–±–Ω—É —Å–∏–Ω—Ç–∞–∫—Å—É –∑–∞
–∫–æ–º–µ–Ω—Ç–∞—Ä–µ –∫–æ—ò–∏ —Å—É –¥–µ–æ API –¥–æ–∫—É–º–µ–Ω—Ç–∞—Ü–∏—ò–µ. –û–Ω–∏ —Å–µ –ø–∏—à—É –ø–æ—Å–ª–µ =///=. –ù–∞ –ø—Ä–∏–º–µ—Ä:
#+begin_src rust
/// Adds one to the number given.
///
/// # Examples
///
/// ```
/// let arg = 5;
/// let answer = my_crate::add_one(arg);
///
/// assert_eq!(6, answer);
/// ```
pub fn add_one(x: i32) -> i32 {
    x + 1
}
#+end_src
** –ö–æ–Ω—Ç—Ä–æ–ª–∞ —Ç–æ–∫–∞
*** =if= –∏–∑—Ä–∞–∑–∏
#+begin_src rust
fn main() {
    let number = 3;

    if number < 5 {
        println!("condition was true");
    } else {
        println!("condition was false");
    }
}
#+end_src

*** =if-else=
#+begin_src rust
fn main() {
    let number = 6;

    if number % 4 == 0 {
        println!("number is divisible by 4");
    } else if number % 3 == 0 {
        println!("number is divisible by 3");
    } else if number % 2 == 0 {
        println!("number is divisible by 2");
    } else {
        println!("number is not divisible by 4, 3, or 2");
    }
}
#+end_src
*** =if= —É =let= –∏—Å–∫–∞–∑–∏–º–∞
=if= —ò–µ –∏–∑—Ä–∞–∑ –ø–∞ —Å–µ –º–æ–∂–µ –∫–æ—Ä–∏—Å—Ç–∏—Ç–∏ –≥–¥–µ –≥–æ–¥ –º–æ–∂–µ–º–æ –ø–∏—Å–∞—Ç–∏ –∏ –±–∏–ª–æ –∫–æ—ò–∏ –¥—Ä—É–≥–∏ –∏–∑—Ä–∞–∑.

#+begin_src rust
fn main() {
    let condition = true;
    let number = if condition { 5 } else { 6 };

    println!("The value of number is: {}", number);
}
#+end_src

#+RESULTS:
: The value of number is: 5

#+REVEAL: split

–ê–ª–∏ —Å–µ –≥—Ä–∞–Ω–µ –º–æ—Ä–∞—ò—É —Å–ª–∞–≥–∞—Ç–∏ –ø–æ —Ç–∏–ø—É. –û–≤–æ —ò–µ –ø–æ–≥—Ä–µ—à–Ω–æ —ò–µ—Ä —ò–µ –ø—Ä–≤–∞ –≥—Ä–∞–Ω–∞ —Ç–∏–ø–∞
=i32= –¥–æ–∫ —ò–µ =else= –≥—Ä–∞–Ω–∞ —Ç–∏–ø–∞ =str=.

#+begin_src rust
fn main() {
    let condition = true;

    let number = if condition { 5 } else { "six" };

    println!("The value of number is: {}", number);
}
#+end_src
*** –ü–µ—Ç—ô–µ
–†a—Å—Ç –∏–º–∞ —Ç—Ä–∏ —Ç–∏–ø–∞ –ø–µ—Ç—ô–µ:
- =loop= - –∑–∞ –±–µ—Å–∫–æ–Ω–∞—á–Ω–µ –ø–µ—Ç—ô–µ
- =while= - —É—Å–ª–æ–≤–Ω–∞ –ø–µ—Ç—ô–∞
- =for= - –ø–µ—Ç—ô–∞ –∑–∞ –∏—Ç–µ—Ä–∞—Ü–∏—ò—É –∫—Ä–æ–∑ –µ–ª–µ–º–µ–Ω—Ç–µ –∏—Ç–µ—Ä–∞–±–∏–ª–Ω–∏—Ö —Ç–∏–ø–æ–≤–∞

*** =loop=
#+begin_src rust
fn main() {
    loop {
        println!("again!");
    }
}
#+end_src

*** =loop= –ª–∞–±–µ–ª–µ
–£–∫–æ–ª–∏–∫–æ –∏–º–∞–º–æ —É–≥—ö–µ–∂–¥–µ–Ω–µ =loop= –∏—Å–∫–∞–∑–µ –º–æ–∂–µ–º–æ –∫–æ—Ä–∏—Å—Ç–∏—Ç–∏ –ª–∞–±–µ–ª–µ –ø—Ä–∏–ª–∏–∫–æ–º –∏–∑–ª–∞—Å–∫–∞ —Å–∞
=break= –∏–Ω—Å—Ç—Ä—É–∫—Ü–∏—ò–æ–º.

#+begin_src rust
fn main() {
    let mut count = 0;
    'counting_up: loop {
        println!("count = {}", count);
        let mut remaining = 10;

        loop {
            println!("remaining = {}", remaining);
            if remaining == 9 {
                break;
            }
            if count == 2 {
                break 'counting_up;
            }
            remaining -= 1;
        }

        count += 1;
    }
    println!("End count = {}", count);
}
#+end_src

*** =loop= –∫–∞–æ –∏–∑—Ä–∞–∑
=loop= –º–æ–∂–µ –∏–º–∞—Ç–∏ –ø–æ–≤—Ä–∞—Ç–Ω—É –≤—Ä–µ–¥–Ω–æ—Å—Ç. –ü–æ–≤—Ä–∞—Ç–Ω–∞ –≤—Ä–µ–¥–Ω–æ—Å—Ç —Å–µ –¥–µ—Ñ–∏–Ω–∏—à–µ –∫–∞–æ –ø–∞—Ä–∞–º–µ—Ç–∞—Ä
=break= –∏–Ω—Å—Ç—Ä—É–∫—Ü–∏—ò–µ.

#+begin_src rust
fn main() {
    let mut counter = 0;

    let result = loop {
        counter += 1;

        if counter == 10 {
            break counter * 2;
        }
    };

    println!("The result is {}", result);
}
#+end_src
*** =while=
#+begin_src rust
fn main() {
    let mut number = 3;

    while number != 0 {
        println!("{}!", number);

        number -= 1;
    }

    println!("LIFTOFF!!!");
}
#+end_src
*** =for=
–ò—Ç–µ—Ä–∞—Ü–∏—ò—É –∫—Ä–æ–∑ —É—Ä–µ—í–µ–Ω—É –∫–æ–ª–µ–∫—Ü–∏—ò—É, –∫–∞–æ —à—Ç–æ —ò–µ –Ω–∏–∑, –º–æ–∂–µ–º–æ –æ–±–∞–≤–∏—Ç–∏ —Å–∞ =while= –ø–µ—Ç—ô–æ–º.
#+begin_src rust
fn main() {
    let a = [10, 20, 30, 40, 50];
    let mut index = 0;

    while index < 5 {
        println!("the value is: {}", a[index]);

        index += 1;
    }
}
#+end_src

#+REVEAL: split
–ê–ª–∏ —ò–µ –∑–∞ —Ç—É –Ω–∞–º–µ–Ω—É –ø—Ä–∏—Ä–æ–¥–Ω–∏—ò–µ –∏ —Å–∏–≥—É—Ä–Ω–∏—ò–µ –∫–æ—Ä–∏—Å—Ç–∏—Ç–∏ =for= –ø–µ—Ç—ô—É. –¢–∞–∫–æ—í–µ —õ–µ —Å–µ
–ø—Ä–æ–≥—Ä–∞–º –±—Ä–∂–µ –∏–∑–≤—Ä—à–∞–≤–∞—Ç–∏.

#+begin_src rust
fn main() {
    let a = [10, 20, 30, 40, 50];

    for element in a {
        println!("the value is: {}", element);
    }
}
#+end_src

#+REVEAL: split
=for= –ø–µ—Ç—ô–µ —Å—É –Ω–∞—ò—á–µ—à—õ–∏ –æ–±–ª–∏–∫ –ø–µ—Ç—ô–∏ —É —É–ø–æ—Ç—Ä–µ–±–∏ —É –†–∞—Å—Ç—É. –ö–æ—Ä–∏—Å—Ç–µ —Å–µ –Ω–ø—Ä. –∏ —É
—Å–∏—Ç—É–∞—Ü–∏—ò–∏ –∫–∞–¥–∞ —ò–µ –ø–æ—Ç—Ä–µ–±–Ω–æ –∏–∑–≤—Ä—à–∏—Ç–∏ –ø–µ—Ç—ô—É –æ–¥—Ä–µ—í–µ–Ω–∏ –±—Ä–æ—ò –ø—É—Ç–∞.

#+begin_src rust
fn main() {
    for number in (1..4).rev() {
        println!("{}!", number);
    }
    println!("LIFTOFF!!!");
}
#+end_src

#+RESULTS:
: 3!
: 2!
: 1!
: LIFTOFF!!!
*** =for= –∏ –∏—Ç–µ—Ä–∞—Ç–æ—Ä–∏
–ü—Ä–∏–ª–∏–∫–æ–º –∏—Ç–µ—Ä–∞—Ü–∏—ò–µ —É–ø–æ—Ç—Ä–µ–±–æ–º =for= –∏—Å–∫–∞–∑–∞ –∏–º–ø–ª–∏—Ü–∏—Ç–Ω–æ —Å–µ –ø–æ–∑–∏–≤–∞ –º–µ—Ç–æ–¥–∞
=into_iter()= –Ω–∞–¥ –∫–æ–ª–µ–∫—Ü–∏—ò–æ–º. –û–≤–∞ –º–µ—Ç–æ–¥–∞ –∫–æ–Ω–∑—É–º–∏—Ä–∞ –µ–ª–µ–º–µ–Ω—Ç–µ –∫–æ–ª–µ–∫—Ü–∏—ò–µ.

#+begin_src rust
fn main() {
    let names = vec!["Bob", "Frank", "Ferris"];

    for name in names.into_iter() {
        match name {
            "Ferris" => println!("There is a rustacean among us!"),
            _ => println!("Hello {}", name),
        }
    }

    // println!("names: {:?}", names); -- FIXME: –∫–æ–ª–µ–∫—Ü–∏—ò–∞ –æ–≤–¥–µ –Ω–∏—ò–µ –¥–æ—Å—Ç—É–ø–Ω–∞
}
#+end_src

#+REVEAL: split

#+begin_src rust
fn main() {
    let names = vec!["Bob", "Frank", "Ferris"];

    for name in names.iter() {
        match name {
            &"Ferris" => println!("There is a rustacean among us!"),
            // TODO ^ Try deleting the & and matching just "Ferris"
            _ => println!("Hello {}", name),
        }
    }

    println!("names: {:?}", names);
}
#+end_src

#+RESULTS:
: Hello Bob
: Hello Frank
: There is a rustacean among us!
: names: ["Bob", "Frank", "Ferris"]

#+REVEAL: split

#+begin_src rust
fn main() {
    let mut names = vec!["Bob", "Frank", "Ferris"];

    for name in names.iter_mut() {
        *name = match name {
            &mut "Ferris" => "There is a rustacean among us!",
            _ => "Hello",
        }
    }

    println!("names: {:?}", names);
}
#+end_src

#+RESULTS:
: names: ["Hello", "Hello", "There is a rustacean among us!"]

* –í–ª–∞—Å–Ω–∏—à—Ç–≤–æ –∏ –ø–æ–∑–∞—ò–º—ô–∏–≤–∞—ö–µ (/Ownership and borrowing/)
** –í–ª–∞—Å–Ω–∏—à—Ç–≤–æ
*** –í–ª–∞—Å–Ω–∏—à—Ç–≤–æ
- –à–µ–¥–∞–Ω –æ–¥ –Ω–∞—ò–≤–∞–∂–Ω–∏—ò–∏—Ö –∫–æ–Ω—Ü–µ–ø–∞—Ç–∞ —ò–µ–∑–∏–∫–∞.
- –°–∫—É–ø –ø—Ä–∞–≤–∏–ª–∞ –∫–æ—ò–∏ –æ–º–æ–≥—É—õ–∞–≤–∞—ò—É —É–ø—Ä–∞–≤—ô–∞—ö–µ –º–µ–º–æ—Ä–∏—ò–æ–º.
- –ì–∞—Ä–∞–Ω—Ü–∏—ò–µ –∑–∞ –º–µ–º–æ—Ä–∏—ò—Å–∫—É —Å–∏–≥—É—Ä–Ω–æ—Å—Ç –±–µ–∑ —É–ø–æ—Ç—Ä–µ–±–µ /garbage collector/-–∞
- –°–≤–µ –ø—Ä–æ–≤–µ—Ä–µ —Å–µ –æ–±–∞–≤—ô–∞—ò—É —É –≤—Ä–µ–º–µ –∫–æ–º–ø–∞—ò–ª–∏—Ä–∞—ö–∞ - —Ä–µ–∑—É–ª—Ç—É—ò–µ –æ–¥–ª–∏—á–Ω–∏–º
  –ø–µ—Ä—Ñ–æ—Ä–º–∞–Ω—Å–∞–º–∞ —É –≤—Ä–µ–º–µ –∏–∑–≤—Ä—à–∞–≤–∞—ö–∞.

*** –°—Ç–µ–∫ –∏ —Ö–∏–ø (/Stack and Heap/)
- –°—Ç–µ–∫ - –∞–ª–æ–∫–∞—Ü–∏—ò–∞ –ø—Ä–æ—Å—Ç–æ—Ä–∞ –∑–∞ –ø–æ–¥–∞—Ç–∫–µ —á–∏—ò–∞ —ò–µ –≤–µ–ª–∏—á–∏–Ω–∞ –ø–æ–∑–Ω–∞—Ç–∞ —É –≤—Ä–µ–º–µ
  –∫–æ–º–ø–∞—ò–ª–∏—Ä–∞—ö–∞.
  - –ë—Ä–∂–∞ –∞–ª–æ–∫–∞—Ü–∏—ò–∞ –∏ –¥–µ–∞–ª–æ–∫–∞—Ü–∏—ò–∞ - —ò–µ–¥–Ω–æ—Å—Ç–∞–≤–∞–Ω –º–µ—Ö–∞–Ω–∏–∑–∞–º, LIFO —Å—Ç—Ä—É–∫—Ç—É—Ä–∞.
  - –ë—Ä–∂–∏ –ø—Ä–∏—Å—Ç—É–ø - –ª–æ–∫–∞–ª–Ω–µ –≤–∞—Ä–∏—ò–∞–±–ª–µ, –∫–µ—à–∏—Ä–∞—ö–µ –ø—Ä–∏—Å—Ç—É–ø–∞.
- –•–∏–ø - —Å–ª–æ–±–æ–¥–Ω–∞ –∞–ª–æ–∫–∞—Ü–∏—ò–∞ —É –≤—Ä–µ–º–µ –∏–∑–≤—Ä—à–∞–≤–∞—ö–∞.
  - –°–ø–æ—Ä–∏—ò–∞ –∞–ª–æ–∫–∞—Ü–∏—ò–∞ –∏ –¥–µ–∞–ª–æ–∫–∞—Ü–∏—ò–∞.
  - –°–ø–æ—Ä–∏—ò–∏ –ø—Ä–∏—Å—Ç—É–ø - –ø—Ä–æ–∏–∑–≤–æ—ô–Ω–∞ –ª–æ–∫–∞—Ü–∏—ò–∞.

*** –ü—Ä–∞–≤–∏–ª–∞ –≤–ª–∞—Å–Ω–∏—à—Ç–≤–∞
1. –°–≤–∞–∫–∞ –≤—Ä–µ–¥–Ω–æ—Å—Ç —É –†–∞—Å—Ç—É –∏–º–∞ –≤–∞—Ä–∏—ò–∞–±–ª—É –∫–æ—ò–∞ —Å–µ –Ω–∞–∑–∏–≤–∞ /–≤–ª–∞—Å–Ω–∏–∫–æ–º/ (/owner/).
2. –£ —Å–≤–∞–∫–æ–º —Ç—Ä–µ–Ω—É—Ç–∫—É –ø–æ—Å—Ç–æ—ò–∏ —Å–∞–º–æ —ò–µ–¥–∞–Ω –≤–ª–∞—Å–Ω–∏–∫.
3. –ö–∞–¥–∞ –≤–ª–∞—Å–Ω–∏–∫ –∏–∑–∞—í–µ –∏–∑ –æ–ø—Å–µ–≥–∞ –≤–∞–∂–µ—ö–∞ (/scope/) –≤—Ä–µ–¥–Ω–æ—Å—Ç —Å–µ –¥–µ–∞–ª–æ—Ü–∏—Ä–∞ (/drop/).

*** –û–ø—Å–µ–≥ –≤–∞–∂–µ—ö–∞ –≤–∞—Ä–∏—ò–∞–±–ª–µ (/Variable Scope/)

#+begin_src rust
{                      // s –Ω–∏—ò–µ –≤–∞–ª–∏–¥–Ω–æ –æ–≤–¥–µ —ò–µ—Ä —ò–æ—à –Ω–∏—ò–µ –¥–µ–∫–ª–∞—Ä–∏—Å–∞–Ω–æ
    let s = "hello";   // s —ò–µ –≤–∞–ª–∏–¥–Ω–æ –æ–¥ –æ–≤–µ –ø–æ–∑–∏—Ü–∏—ò–µ

    // –∫–æ—Ä–∏—Å—Ç–∏–º–æ s
}   // –æ–≤–¥–µ –æ–ø—Å–µ–≥ –ø—Ä–µ—Å—Ç–∞—ò–µ –¥–∞ –≤–∞–∂–∏ –∏ s –≤–∏—à–µ –Ω–∏—ò–µ –≤–∞–ª–∏–¥–Ω–æ
#+end_src

*** =String= —Ç–∏–ø

- –î–µ–º–æ–Ω—Å—Ç—Ä–∞—Ü–∏—ò–∞ –≤–ª–∞—Å–Ω–∏—à—Ç–≤–∞ –Ω–∞–¥ —Ç–∏–ø–æ–º –∫–æ—ò–∏ —Å–µ –∞–ª–æ—Ü–∏—Ä–∞ –Ω–∞ —Ö–∏–ø—É.

  #+begin_src rust
  let mut s = String::from("hello");
  s.push_str(", world!"); // push_str() –¥–æ–¥–∞—ò–µ –ª–∏—Ç–µ—Ä–∞–ª –Ω–∞ —Å—Ç—Ä–∏–Ω–≥
  println!("{}", s); // hello, world!`
  #+end_src

- –ú–µ–º–æ—Ä–∏—ò–∞ —Å–µ –∞–ª–æ—Ü–∏—Ä–∞ —Å–∞ —Ö–∏–ø–∞ —É –≤—Ä–µ–º–µ –∏–∑–≤—Ä—à–∞–≤–∞—ö–∞.
- –ú–æ—Ä–∞–º–æ –≤—Ä–∞—Ç–∏—Ç–∏ –º–µ–º–æ—Ä–∏—ò—É –∞–ª–æ–∫–∞—Ç–æ—Ä—É –∫–∞–¥–∞ –Ω–∞–º –≤–∏—à–µ –Ω–∏—ò–µ –ø–æ—Ç—Ä–µ–±–Ω–∞.

#+REVEAL: split

- –ê–ª–æ–∫–∞—Ü–∏—ò–∞ —Å—Ç—Ä–∏–Ω–≥–∞ —Å–µ –æ–±–∞–≤—ô–∞ –Ω–∞ –ª–∏–Ω–∏—ò–∏:

  #+begin_src rust
  let mut s = String::from("hello");
  #+end_src

- –ê–ª–∏ –¥–µ–∞–ª–æ–∫–∞—Ü–∏—ò–∞ —ò–µ —Ç–µ–∂–∞:
  - /Garbage collector/
  - /Memory waste/
  - /Double-free/

#+REVEAL: split

- –†–∞—Å—Ç –∫–æ–º–ø–∞—ò–ª–µ—Ä —õ–µ –¥–æ–¥–∞—Ç–∏ –∫√¥–¥ –∫–æ—ò–∏ —Ä–∞–¥–∏ –¥–µ–∞–ª–æ–∫–∞—Ü–∏—ò—É –∫–∞–¥–∞ –≤–ª–∞—Å–Ω–∏–∫ –Ω–∞–ø—É—Å—Ç–∏ –æ–ø—Å–µ–≥ –≤–∞–∂–µ—ö–∞.
- –ü–æ–∑–∏–≤–∞ —Å–µ —Ñ—É–Ω–∫—Ü–∏—ò–∞ =drop= –Ω–∞–¥ —Ç–∏–ø–æ–º –∏ –æ–≤–∞ —Ñ—É–Ω–∫—Ü–∏—ò–∞ —ò–µ –∑–∞–¥—É–∂–µ–Ω–∞ –¥–∞ –æ–±–∞–≤–∏ –¥–µ–∞–ª–æ–∫–∞—Ü–∏—ò—É.

  #+begin_src rust
  {
        let s = String::from("hello"); // s –ø–æ—Å—Ç–∞—ò–µ –≤–∞–ª–∏–¥–Ω–æ

        // –∫–æ—Ä–∏—Å—Ç–∏–º–æ s
  }  // <- s –∏–∑–ª–∞–∑–∏ –∏–∑ –æ–ø—Å–µ–≥–∞ –∏ –ø–æ–∑–∏–≤–∞ —Å–µ "drop"
  #+end_src

*** –î–æ–¥–µ–ª–∞ –≤—Ä–µ–¥–Ω–æ—Å—Ç–∏
- –ö–æ–ø–∏—Ä–∞—ö–µ –≤—Ä–µ–¥–Ω–æ—Å—Ç–∏ =x= —É =y=. –û–±–µ –≤–∞—Ä–∏—ò–∞–±–ª–µ —Å–∞–¥–∞ –∏–º–∞—ò—É –≤—Ä–µ–¥–Ω–æ—Å—Ç =5=.

  #+begin_src rust
  let x = 5;
  let y = x;
  #+end_src

- –ê–ª–∏ —Å–∞ =String= —Ç–∏–ø–æ–º –¥–µ—à–∞–≤–∞ —Å–µ –Ω–µ—à—Ç–æ –¥—Ä—É–≥–æ.

  #+begin_src rust
  let s1 = String::from("hello");
  #+end_src

#+attr_html: :style height: 400px;
#+ATTR_ORG: :width 300px
[[./images/string-type.png]]

#+REVEAL: split

- –ê–∫–æ –±–∏ —Å–µ –∫–æ–ø–∏—Ä–∞–æ —Å–∞–º–æ —Å–∞–¥—Ä–∂–∞—ò —Å–∞ —Å—Ç–µ–∫–∞ –∏–º–∞–ª–∏ –±–∏—Å–º–æ —Å–ª–µ–¥–µ—õ—É —Å–∏—Ç—É–∞—Ü–∏—ò—É (—Ç–∑–≤.
  /shallow copy/).

  #+begin_src rust
  let s1 = String::from("hello");
  let s2 = s1;
  #+end_src

#+attr_html: :style height: 400px;
#+ATTR_ORG: :width 300px
[[./images/string-type-2.png]]

–®—Ç–æ —ò–µ –ø—Ä–æ–±–ª–µ–º–∞—Ç–∏—á–Ω–æ —ò–µ—Ä –∫–∞–¥–∞ –∏ =s1= –∏ =s2= –Ω–∞–ø—É—Å—Ç–µ –æ–ø—Å–µ–≥ –ø–æ–∫—É—à–∞—õ–µ —Å–µ –¥–≤–æ—Å—Ç—Ä—É–∫–∞
–¥–µ–∞–ª–æ–∫–∞—Ü–∏—ò–∞ –∏—Å—Ç–µ –º–µ–º–æ—Ä–∏—ò–µ –Ω–∞ —Ö–∏–ø—É (/double free/).

#+REVEAL: split

–ê–∫–æ –±–∏ —Å–µ –∏ —Ö–∏–ø –º–µ–º–æ—Ä–∏—ò–∞ –∫–æ–ø–∏—Ä–∞–ª–∞ (tzv. /deep copy/) –∏–º–∞–ª–∏ –±–∏—Å–º–æ –≤–∞–ª–∏–¥–Ω—É —Å–∏—Ç—É–∞—Ü–∏—ò—É
–∞–ª–∏ –±–∏ —Ç–∞–∫–≤–∞ –æ–ø–µ—Ä–∞—Ü–∏—ò–∞ –±–∏–ª–∞ –≤–µ–æ–º–∞ "—Å–∫—É–ø–∞".

#+attr_html: :style height: 500px;
#+ATTR_ORG: :width 300px
[[./images/string-type-3.png]]

*** –ü—Ä–µ–º–µ—à—Ç–∞—ö–µ (/Move/)
–ê–∫–æ –ø—Ä–æ–±–∞–º–æ –¥–∞ –∫–æ–º–ø–∞—ò–ª–∏—Ä–∞–º–æ —Å–ª–µ–¥–µ—õ–∏ –∫–æ–¥:

#+begin_src rust
let s1 = String::from("hello");
let s2 = s1;

println!("{}, world!", s1);
#+end_src

–î–æ–±–∏—õ–µ–º–æ –≥—Ä–µ—à–∫—É:

#+begin_example
$ cargo run
   Compiling ownership v0.1.0 (file:///projects/ownership)
error[E0382]: borrow of moved value: `s1`
 --> src/main.rs:5:28
  |
2 |     let s1 = String::from("hello");
  |         -- move occurs because `s1` has type `String`, which does not implement the `Copy` trait
3 |     let s2 = s1;
  |              -- value moved here
4 |
5 |     println!("{}, world!", s1);
  |                            ^^ value borrowed here after move

For more information about this error, try `rustc --explain E0382`.
error: could not compile `ownership` due to previous error
#+end_example

#+REVEAL: split

–û–Ω–æ —à—Ç–æ –Ω–∞–º –∫–æ–º–ø–∞—ò–ª–µ—Ä –∫–∞–∂–µ —ò–µ –¥–∞ —Å–µ —É –∏—Å–∫–∞–∑—É:

#+begin_src rust
let s2 = s1;
#+end_src

–ø—Ä–æ–º–µ–Ω–∏–æ –≤–ª–∞—Å–Ω–∏–∫ –æ–≤–æ–≥ —Å—Ç—Ä–∏–Ω–≥–∞. –ù–æ–≤–∏ –≤–ª–∞—Å–Ω–∏–∫ —ò–µ —Å–∞–¥–∞ =s2= –¥–æ–∫ —ò–µ –≤–∞—Ä–∏—ò–∞–±–ª–∞ =s1=
–ø–æ—Å—Ç–∞–ª–∞ –Ω–µ–≤–∞–ª–∏–¥–Ω–∞ –∏ –Ω–∏—ò–µ —ò–µ –≤–∏—à–µ –º–æ–≥—É—õ–µ –∫–æ—Ä–∏—Å—Ç–∏—Ç–∏.

–ö–∞–∂–µ–º–æ –¥–∞ —Å–µ –æ–±–∞–≤–∏–ª–æ "–ø—Ä–µ–º–µ—à—Ç–∞—ö–µ" (/move/) –≤—Ä–µ–¥–Ω–æ—Å—Ç–∏ –∏–∑ =s1= —É =s2=.

#+attr_html: :style height: 400px;
#+ATTR_ORG: :width 300px
[[./images/string-type-4.png]]

–ß–∏–º–µ —Å–µ –∏—Å–ø—É—ö–∞–≤–∞ –ø—Ä–≤–æ –ø—Ä–∞–≤–∏–ª–æ –≤–ª–∞—Å–Ω–∏—à—Ç–≤–∞ –∏ —Å–ø—Ä–µ—á–∞–≤–∞ /double free/ –≥—Ä–µ—à–∫–∞.

*** –ö–ª–æ–Ω–∏—Ä–∞—ö–µ
–ü–æ—Å–ª–µ–¥–∏—Ü–∞ –ø—Ä–µ—Ç—Ö–æ–¥–Ω–æ–≥ —ò–µ –¥–∞ –†–∞—Å—Ç –Ω–∏–∫–∞–¥–∞ –Ω–µ—õ–µ –∞—É—Ç–æ–º–∞—Ç—Å–∫–∏ –æ–±–∞–≤–∏—Ç–∏ –¥—É–±–æ–∫–æ –∫–æ–ø–∏—Ä–∞—ö–µ
–≤–∞—Ä–∏—ò–∞–±–ª–µ —ò–µ—Ä –±–∏ —Ç–æ –º–æ–≥–ª–æ –¥–∞ –∏–∑–∞–∑–æ–≤–µ –ª–æ—à–µ –ø–µ—Ä—Ñ–æ—Ä–º–∞–Ω—Å–µ.

–î—É–±–æ–∫–æ –∫–æ–ø–∏—Ä–∞—ö–µ (—Å—Ç–µ–∫+—Ö–∏–ø) —Ä–∞–¥–∏–º–æ —Å–∞ =clone= –º–µ—Ç–æ–¥–æ–º:

#+begin_src rust
let s1 = String::from("hello");
let s2 = s1.clone();

println!("s1 = {}, s2 = {}", s1, s2);
#+end_src

–°–∞–¥–∞ —ò–µ –ª–∞–∫–æ –ø—Ä–æ–Ω–∞—õ–∏ —É –∫–æ–¥—É —Å–≤–∞ –º–µ—Å—Ç–∞ –≥–¥–µ —Å–µ –æ–±–∞–≤—ô–∞ –ø–æ—Ç–µ–Ω—Ü–∏—ò–∞–ª–Ω–æ "—Å–∫—É–ø–∞"
–æ–ø–µ—Ä–∞—Ü–∏—ò–∞ –¥—É–±–æ–∫–æ–≥ –∫–æ–ø–∏—Ä–∞—ö–∞.

*** /Copy/ —Ç–∏–ø–æ–≤–∏
–ö–∞–∫–æ –æ–Ω–¥–∞ —Ä–∞–¥–∏ –ø—Ä–∏–º–µ—Ä –∫–æ—ò–∏ —Å–º–æ –≤–∏–¥–µ–ª–∏ –ø—Ä–µ—Ç—Ö–æ–¥–Ω–æ? –ó–∞—à—Ç–æ –Ω–µ –¥–æ–ª–∞–∑–∏ –¥–æ –ø—Ä–µ–º–µ—à—Ç–∞—ö–∞
–∏ –∏–Ω–≤–∞–ª–∏–¥–∞—Ü–∏—ò–µ =y= –≤–∞—Ä–∏—ò–∞–±–ª–µ?

#+begin_src rust
let x = 5;
let y = x;

println!("x = {}, y = {}", x, y);
#+end_src

- –ö–æ–¥ –ø—Ä–æ—Å—Ç–∏—Ö —Ç–∏–ø–æ–≤–∞ —á–∏—ò–∞ —ò–µ –≤–µ–ª–∏—á–∏–Ω–∞ –ø–æ–∑–Ω–∞—Ç–∞ —É –≤—Ä–µ–º–µ –∫–æ–º–ø–∞—ò–ª–∏—Ä–∞—ö–∞ –∏ –∫–æ—ò–∏ –º–æ–≥—É
  —É —Ü–µ–ª–æ—Å—Ç–∏ —Å—Ç–∞—Ç–∏ –Ω–∞ —Å—Ç–µ–∫ –Ω–µ–º–∞ —Ä–∞–∑–ª–∏–∫–µ –∏–∑–º–µ—í—É –¥—É–±–æ–∫–æ–≥ –∏ –ø–ª–∏—Ç–∫–æ–≥ –∫–æ–ø–∏—Ä–∞—ö–∞.
- –û–≤–∞–∫–≤–∏ —Ç–∏–ø–æ–≤–∏ —Å—É –∞–Ω–æ—Ç–∏—Ä–∞–Ω–∏ —Å–∞ /Copy/ –æ—Å–æ–±–∏–Ω–æ–º (/Trait/). –¢–∏–ø–æ–≤–∏ –∫–æ—ò–∏ —Å—É –Ω–∞ –æ–≤–∞—ò
  –Ω–∞—á–∏–Ω –∞–Ω–æ—Ç–∏—Ä–∞–Ω–∏ –Ω–µ –æ–±–∞–≤—ô–∞—ò—É –ø—Ä–µ–º–µ—à—Ç–∞—ö–µ –≤–µ—õ —É–≤–µ–∫ –∫–æ–ø–∏—Ä–∞—ö–µ.
- –ò–º–ø–ª–∏–∫–∞—Ü–∏—ò–∞ —ò–µ –¥–∞ —Å–µ –≤–∞—Ä–∏—ò–∞–±–ª–∞ —Å–∞ –¥–µ—Å–Ω–µ —Å—Ç—Ä–∞–Ω–µ –¥–æ–¥–µ–ª–µ –º–æ–∂–µ –∫–æ—Ä–∏—Å—Ç–∏—Ç–∏ –∏ –Ω–∞–∫–æ–Ω
  –¥–æ–¥–µ–ª–µ.
- –†–∞—Å—Ç —õ–µ —Å–ø—Ä–µ—á–∏—Ç–∏ /Copy/ –∞–Ω–æ—Ç–∞—Ü–∏—ò—É –∞–∫–æ —Ç–∏–ø –∏–º–ø–ª–µ–º–µ–Ω—Ç–∏—Ä–∞ –∏ /Drop/ —ò–µ—Ä —Ç–æ –∑–Ω–∞—á–∏ –¥–∞
  —Ä–∞–¥–∏ –Ω–µ–∫—É —Å–ø–µ—Ü–∏—ò–∞–ª–Ω—É –∞–ª–æ–∫–∞—Ü–∏—ò—É –ø–∞ –º—É —ò–µ –ø–æ—Ç—Ä–µ–±–Ω–∞ –∏ –ø–æ—Å–µ–±–Ω–∞ –¥–µ–∞–ª–æ–∫–∞—Ü–∏—ò–∞ —à—Ç–æ
  –∑–Ω–∞—á–∏ –¥–∞ –º–æ—Ä–∞ –¥–∞ —Å–µ —Ä–∞–¥–∏ –ø—Ä–µ–º–µ—à—Ç–∞—ö–µ.

*** –í–ª–∞—Å–Ω–∏—à—Ç–≤–æ –∏ —Ñ—É–Ω–∫—Ü–∏—ò–µ
- –°–µ–º–∞–Ω—Ç–∏–∫–∞ –ø—Ä–µ–Ω–æ—Å–∞ –ø–∞—Ä–∞–º–µ—Ç–∞—Ä–∞ –∫–æ–¥ –ø–æ–∑–∏–≤–∞ —Ñ—É–Ω–∫—Ü–∏—ò–∞ —ò–µ —Å–ª–∏—á–Ω–∞ —Å–µ–º–∞–Ω—Ç–∏—Ü–∏ –¥–æ–¥–µ–ª–µ.

#+begin_src rust
fn main() {
    let s = String::from("hello");  // s –ø–æ—Å—Ç–∞—ò–µ –≤–∞–ª–∏–¥–Ω–æ

    takes_ownership(s);             // s –≤—Ä–µ–¥–Ω–æ—Å—Ç —Å–µ –ø—Ä–µ–º–µ—à—Ç–∞ —É —Ñ—É–Ω–∫—Ü–∏—ò—É...
                                    // ... —Ç–∞–∫–æ –¥–∞ s –Ω–∏—ò–µ –≤–∞–ª–∏–¥–Ω–æ –æ–¥ –æ–≤–µ –ø–æ–∑–∏—Ü–∏—ò–µ

    let x = 5;                      // x –ø–æ—Å—Ç–∞—ò–µ –≤–∞–ª–∏–¥–Ω–æ

    makes_copy(x);                  // x –±–∏ —Å–µ –ø—Ä–µ–º–µ—Å—Ç–∏–ª–æ —É —Ñ—É–Ω–∫—Ü–∏—ò—É,
                                    // –∞–ª–∏ i32 —ò–µ Copy, —Ç–∞–∫–æ –¥–∞ —ò–µ ok
                                    // –¥–∞ —Å–µ x –∫–æ—Ä–∏—Å—Ç–∏ –∏ –ø–æ—Å–ª–µ

} // x –∏–∑–ª–∞–∑–∏ –∏–∑ –æ–ø—Å–µ–≥–∞, –∑–∞—Ç–∏–º s. –ê–ª–∏ –ø–æ—à—Ç–æ —ò–µ s –ø—Ä–µ–º–µ—à—Ç–µ–Ω–æ –Ω–∏—à—Ç–∞ –ø–æ—Å–µ–±–Ω–æ —Å–µ
  // –Ω–µ –¥–µ—à–∞–≤–∞.

fn takes_ownership(some_string: String) { // some_string —É–ª–∞–∑–∏ —É –æ–ø—Å–µ–≥
    println!("{}", some_string);
} // some_string –∏–∑–ª–∞–∑–∏ –∏–∑ –æ–ø—Å–µ–≥–∞ –∏ –ø–æ–∑–∏–≤–∞ —Å–µ `drop`. –ú–µ–º–æ—Ä–∏—ò–∞ —Å–∞ —Ö–∏–ø–∞ —Å–µ
  // –æ—Å–ª–æ–±–∞—í–∞.

fn makes_copy(some_integer: i32) { // some_integer —É–ª–∞–∑–∏ —É –æ–ø—Å–µ–≥
    println!("{}", some_integer);
} // some_integer –∏–∑–ª–∞–∑–∏ –∏–∑ –æ–ø—Å–µ–≥–∞. –ü–æ—à—Ç–æ –Ω–∏—ò–µ 'Drop', –Ω–∏—à—Ç–∞ –ø–æ—Å–µ–±–Ω–æ —Å–µ –Ω–µ
  // –¥–æ–≥–∞—í–∞ (–æ—Å–∏–º "—Å–∫–∏–¥–∞—ö–∞" —Å–∞ —Å—Ç–µ–∫–∞ –Ω–∞—Ä–∞–≤–Ω–æ)
#+end_src

*** –ü–æ–≤—Ä–∞—Ç–Ω–µ –≤—Ä–µ–¥–Ω–æ—Å—Ç–∏ –∏ –æ–ø—Å–µ–∑–∏
–ü—Ä–∏–ª–∏–∫–æ–º –≤—Ä–∞—õ–∞—ö–∞ –≤—Ä–µ–¥–Ω–æ—Å—Ç–∏ –∏–∑ —Ñ—É–Ω–∫—Ü–∏—ò–µ —Ç–∞–∫–æ—í–µ –º–æ–∂–µ –¥–æ—õ–∏ –¥–æ –ø—Ä–µ–º–µ—à—Ç–∞—ö–∞ –≤–ª–∞—Å–Ω–∏—à—Ç–≤–∞.

#+begin_src rust
fn main() {
    let s1 = gives_ownership();         // gives_ownership –ø—Ä–µ–º–µ—à—Ç–∞ –ø–æ–≤—Ä–∞—Ç–Ω—É
                                        // –≤—Ä–µ–¥–Ω–æ—Å—Ç —É s1

    let s2 = String::from("hello");     // s2 –ø–æ—Å—Ç–∞—ò–µ –≤–∞–ª–∏–¥–Ω–æ

    let s3 = takes_and_gives_back(s2);  // s2 —Å–µ –ø—Ä–µ–º–µ—à—Ç–∞ —É —Ñ—É–Ω–∫—Ü–∏—ò—É
                                        // takes_and_gives_back, –∫–æ—ò–∞ –ø—Ä–µ–º–µ—à—Ç–∞
                                        // –ø–æ–≤—Ä–∞—Ç–Ω—É –≤—Ä–µ–¥–Ω–æ—Å—Ç —É s3
} // s3 –∏–∑–ª–∞–∑–∏ –∏–∑ –æ–ø—Å–µ–≥–∞ –∏ –ø–æ–∑–∏–≤–∞ —Å–µ `drop`. s2 —ò–µ –ø—Ä–µ–º–µ—à—Ç–µ–Ω–∞ –ø–∞ —Å–µ –Ω–∏—à—Ç–∞
  // –Ω–µ –¥–µ—à–∞–≤–∞. s1 —Ç–∞–∫–æ—í–µ –∏–∑–ª–∞–∑–∏ –∏–∑ –æ–ø—Å–µ–≥–∞ –∏ –¥–µ–∞–ª–æ—Ü–∏—Ä–∞ —Å–µ.

fn gives_ownership() -> String {             // gives_ownership —õ–µ –ø—Ä–µ–º–µ—Å—Ç–∏—Ç–∏
                                             // —Å–≤–æ—ò—É –ø–æ–≤—Ä–∞—Ç–Ω—É –≤—Ä–µ–¥–Ω–æ—Å—Ç —É —Ñ—É–Ω–∫—Ü–∏—ò—É
                                             // –∫–æ—ò–∞ —ò–µ –ø–æ–∑–∏–≤–∞

    let some_string = String::from("yours"); // some_string –ø–æ—Å—Ç–∞—ò–µ –≤–∞–ª–∏–¥–Ω–æ

    some_string                              // some_string —Å–µ –ø—Ä–µ–º–µ—à—Ç–∞
                                             // —É —Ñ—É–Ω–∫—Ü–∏—ò—É –ø–æ–∑–∏–≤–∞–æ—Ü–∞
}

// –û–≤–∞ —Ñ—É–Ω–∫—Ü–∏—ò–∞ —É–∑–∏–º–∞ –≤–ª–∞—Å–Ω–∏—à—Ç–≤–æ –Ω–∞–¥ —Å—Ç—Ä–∏–Ω–≥–æ–º –∏ –≤—Ä–∞—õ–∞ –≥–∞ –Ω–∞–∑–∞–¥
fn takes_and_gives_back(a_string: String) -> String { // a_string –ø–æ—Å—Ç–∞—ò–µ –≤–∞–ª–∏–¥–Ω–æ

    a_string  // a_string —Å–µ –ø—Ä–µ–º–µ—à—Ç–∞ —É —Ñ—É–Ω–∫—Ü–∏—ò—É –ø–æ–∑–∏–≤–∞–æ—Ü–∞
}
#+end_src

#+REVEAL: split

- –ß–µ—Å—Ç–æ –Ω–∞–º —ò–µ –ø–æ—Ç—Ä–µ–±–Ω–æ –¥–∞ –≤–∞—Ä–∏—ò–∞–±–ª—É –∫–æ—Ä–∏—Å—Ç–∏–º–æ –∏ –ø–æ—Å–ª–µ —Å–ª–∞—ö–∞ —É —Ñ—É–Ω–∫—Ü–∏—ò—É.
- –ú–æ–≥–ª–∏ –±–∏ —ò–µ —Å—Ç–∞–ª–æ –≤—Ä–∞—õ–∞—Ç–∏ –∑–∞—ò–µ–¥–Ω–æ —Å–∞ —Ä–µ–∑—É–ª—Ç–∞—Ç–æ–º —Ñ—É–Ω–∫—Ü–∏—ò–µ –Ω–∞ –ø—Ä–∏–º–µ—Ä —É–ø–æ—Ç—Ä–µ–±–æ–º —Ç–æ—Ä–∫–∏.

#+begin_src rust
fn main() {
    let s1 = String::from("hello");

    let (s2, len) = calculate_length(s1);

    println!("The length of '{}' is {}.", s2, len);
}

fn calculate_length(s: String) -> (String, usize) {
    let length = s.len();

    (s, length)
}
#+end_src

–ê–ª–∏ —ò–µ —Ç–æ –Ω–∞–ø–æ—Ä–Ω–æ. –ü–æ—Å—Ç–æ—ò–∏ –∫–æ–Ω—Ü–µ–ø—Ç —É –†–∞—Å—Ç –∫–æ—ò–∏ —ò–µ –Ω–∞–º–µ—ö–µ–Ω –æ–≤–∞–∫–≤–∏–º
—Å–∏—Ç—É–∞—Ü–∏—ò–∞–º–∞ –∏ –±–∞–∑–∏—Ä–∞–Ω —ò–µ –Ω–∞ —Ä–µ—Ñ–µ—Ä–µ–Ω—Ü–∞–º–∞ –∏ –ø–æ–∑–∞—ò–º—ô–∏–≤–∞—ö—É –≤—Ä–µ–¥–Ω–æ—Å—Ç–∏.
** –†–µ—Ñ–µ—Ä–µ–Ω—Ü–µ –∏ –ø–æ–∑–∞—ò–º—ô–∏–≤–∞—ö–µ (/References and Borrowing/)
*** –†–µ—Ñ–µ—Ä–µ–Ω—Ü–µ –∏ –ø–æ–∑–∞—ò–º—ô–∏–≤–∞—ö–µ (/References and Borrowing/)
- –†–µ—Ñ–µ—Ä–µ–Ω—Ü–∞ —ò–µ –ø–æ–ø—É—Ç –ø–æ–∏–Ω—Ç–µ—Ä–∞, —Å–∞–¥—Ä–∂–∏ –∞–¥—Ä–µ—Å—É –≤—Ä–µ–¥–Ω–æ—Å—Ç–∏ –∫–æ—ò—É –ø–æ—Å–µ–¥—É—ò–µ –Ω–µ–∫–∞ –¥—Ä—É–≥–∞
  –≤–∞—Ä–∏—ò–∞–±–ª–∞.
- –ó–∞ —Ä–∞–∑–ª–∏–∫—É –æ–¥ –ø–æ–∏–Ω—Ç–µ—Ä–∞, —Ä–µ—Ñ–µ—Ä–µ–Ω—Ü–µ —É –†–∞—Å—Ç—É —Å—É –≥–∞—Ä–∞–Ω—Ç–æ–≤–∞–Ω–æ –≤–∞–ª–∏–¥–Ω–µ.

#+begin_src rust
fn main() {
    let s1 = String::from("hello");

    let len = calculate_length(&s1);

    println!("The length of '{}' is {}.", s1, len);
}

fn calculate_length(s: &String) -> usize {
    s.len()
}
#+end_src

#+attr_html: :style height: 400px;
#+ATTR_ORG: :width 300px
[[./images/reference.png]]

*** –†–µ—Ñ–µ—Ä–µ–Ω—Ü–∏—Ä–∞—ö–µ
- –ü—Ä–∏–º–µ–Ω–∞ –æ–ø–µ—Ä–∞—Ç–æ—Ä–∞ =&= –Ω–∞–¥ –≤–∞—Ä–∏—ò–∞–±–ª–æ–º –Ω–∞–∑–∏–≤–∞–º–æ /—Ä–µ—Ñ–µ—Ä–µ–Ω—Ü–∏—Ä–∞—ö–µ/.

  #+begin_src rust
  let s1 = String::from("hello");
  let len = calculate_length(&s1);
  #+end_src

- –°–∏–Ω—Ç–∞–∫—Å–∞ =&s1= –Ω–∞–º –æ–º–æ–≥—É—õ–∞–≤–∞ –¥–∞ –∫—Ä–µ–∏—Ä–∞–º–æ —Ä–µ—Ñ–µ—Ä–µ–Ω—Ü—É –Ω–∞ –≤—Ä–µ–¥–Ω–æ—Å—Ç —á–∏—ò–∏ –≤–ª–∞—Å–Ω–∏–∫ —ò–µ
  =s1= –±–µ–∑ —É–∑–∏–º–∞—ö–∞ –≤–ª–∞—Å–Ω–∏—à—Ç–≤–∞.
- –ü–æ—à—Ç–æ —Ä–µ—Ñ–µ—Ä–µ–Ω—Ü–∞ –Ω–∏—ò–µ –≤–ª–∞—Å–Ω–∏–∫ –Ω–µ –¥–æ–ª–∞–∑–∏ –¥–æ –¥–µ–∞–ª–æ–∫–∞—Ü–∏—ò–µ –ø—Ä–∏–ª–∏–∫–æ–º –∏–∑–ª–∞—Å–∫–∞ –∏–∑
  –æ–ø—Å–µ–≥–∞.
- –û–ø–µ—Ä–∞—Ü–∏—ò–∞ –æ–±—Ä–Ω—É—Ç–∞ —Ä–µ—Ñ–µ—Ä–µ–Ω—Ü–∏—Ä–∞—ö—É –Ω–∞–∑–∏–≤–∞ —Å–µ /–¥–µ—Ä–µ—Ñ–µ—Ä–µ–Ω—Ü–∏—Ä–∞—ö–µ/ –∏ –≤—Ä—à–∏ —Å–µ =*=
  –æ–ø–µ—Ä–∞—Ç–æ—Ä–æ–º –Ω–∞–¥ —Ä–µ—Ñ–µ—Ä–µ–Ω—Ü–æ–º (–Ω–ø—Ä. =*s2= —ò–µ –≤—Ä–µ–¥–Ω–æ—Å—Ç –Ω–∞ –∫–æ—ò—É —Ä–µ—Ñ–µ—Ä–µ–Ω—Ü–∏—Ä–∞ =s2=).
- –û–ø–µ—Ä–∞—Ü–∏—ò—É —Ä–µ—Ñ–µ—Ä–µ–Ω—Ü–∏—Ä–∞—ö–∞ –Ω–∞–∑–∏–≤–∞–º–æ –ø–æ–∑–∞—ò–º—ô–∏–≤–∞—ö–µ–º (/borrowing/).

#+REVEAL: split

- –ü–∞—Ä–∞–º–µ—Ç–∞—Ä —Ñ—É–Ω–∫—Ü–∏—ò–µ –º–æ–∂–µ –±–∏—Ç–∏ —Ä–µ—Ñ–µ—Ä–µ–Ω—Ü–∞.
#+begin_src rust
fn calculate_length(s: &String) -> usize { // s —ò–µ —Ä–µ—Ñ–µ—Ä–µ–Ω—Ü–∞ –Ω–∞ String
    s.len()
} // s –∏–∑–ª–∞–∑–∏ –∏–∑ –æ–ø—Å–µ–≥–∞ –∞–ª–∏ –ø–æ—à—Ç–æ –Ω–µ–º–∞ –≤–ª–∞—Å–Ω–∏—à—Ç–≤–æ –Ω–∞–¥ –≤—Ä–µ–¥–Ω–æ—à—õ—É
  // –Ω–∏—à—Ç–∞ —Å–µ –Ω–µ –¥–µ—à–∞–≤–∞.
#+end_src

*** –ü—Ä–æ–º–µ–Ω–∞ –ø–æ–∑–∞—ò–º—ô–µ–Ω–µ –≤—Ä–µ–¥–Ω–æ—Å—Ç–∏
–®—Ç–∞ —Å–µ –¥–µ—à–∞–≤–∞ —É–∫–æ–ª–∏–∫–æ –ø–æ–∫—É—à–∞–º–æ –¥–∞ –º–æ–¥–∏—Ñ–∏–∫—É—ò–µ–º–æ –ø–æ–∑–∞—ò–º—ô–µ–Ω—É –≤—Ä–µ–¥–Ω–æ—Å—Ç?

#+begin_src rust
fn main() {
    let s = String::from("hello");
    change(&s);
}

fn change(some_string: &String) {
    some_string.push_str(", world");
}
#+end_src

#+begin_example
$ cargo run
   Compiling ownership v0.1.0 (file:///projects/ownership)
error[E0596]: cannot borrow `*some_string` as mutable, as it is behind a `&` reference
 --> src/main.rs:8:5
  |
7 | fn change(some_string: &String) {
  |                        ------- help: consider changing this to be a mutable reference: `&mut String`
8 |     some_string.push_str(", world");
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ `some_string` is a `&` reference, so the data it refers
  to cannot be borrowed as mutable

For more information about this error, try `rustc --explain E0596`.
error: could not compile `ownership` due to previous error
#+end_example

*** –ü—Ä–æ–º–µ—ö–∏–≤–µ —Ä–µ—Ñ–µ—Ä–µ–Ω—Ü–µ
–ö–∞–æ –∏ –≤–∞—Ä–∏—ò–∞–±–ª–µ, –∏ —Ä–µ—Ñ–µ—Ä–µ–Ω—Ü–µ —Å—É –ø–æ–¥—Ä–∞–∑—É–º–µ–≤–∞–Ω–æ –Ω–µ–ø—Ä–æ–º–µ—ö–∏–≤–∞ (/immutable/). –ú–æ—Ä–∞–º–æ
–±–∏—Ç–∏ –µ–∫—Å–ø–ª–∏—Ü–∏—Ç–Ω–∏ —É–∫–æ–ª–∏–∫–æ –Ω–∞–º —Ç—Ä–µ–±–∞ –ø—Ä–æ–º–µ—ö–∏–≤–∞ —Ä–µ—Ñ–µ—Ä–µ–Ω—Ü–∞.

#+begin_src rust
fn main() {
    let mut s = String::from("hello");
    change(&mut s);
}

fn change(some_string: &mut String) {
    some_string.push_str(", world");
}
#+end_src

*** –í–∏—à–µ –ø—Ä–æ–º–µ—ö–∏–≤–∏—Ö —Ä–µ—Ñ–µ—Ä–µ–Ω—Ü–∏ –Ω–∞–¥ –∏—Å—Ç–æ–º –≤—Ä–µ–¥–Ω–æ—à—õ—É
–†–∞—Å—Ç –Ω–µ –¥–æ–∑–≤–æ—ô–∞–≤–∞ –¥–∞ –∏—Å—Ç–∏ –ø–æ–¥–∞—Ç–∞–∫ —É —ò–µ–¥–Ω–æ–º —Ç—Ä–µ–Ω—É—Ç–∫—É –∏–º–∞ –≤–∏—à–µ –ø—Ä–æ–º–µ—ö–∏–≤–∏—Ö
—Ä–µ—Ñ–µ—Ä–µ–Ω—Ü–∏.

#+begin_src rust
let mut s = String::from("hello");

let r1 = &mut s;
let r2 = &mut s;

println!("{}, {}", r1, r2);
#+end_src

#+begin_example
$ cargo run
   Compiling ownership v0.1.0 (file:///projects/ownership)
error[E0499]: cannot borrow `s` as mutable more than once at a time
 --> src/main.rs:5:14
  |
4 |     let r1 = &mut s;
  |              ------ first mutable borrow occurs here
5 |     let r2 = &mut s;
  |              ^^^^^^ second mutable borrow occurs here
6 |
7 |     println!("{}, {}", r1, r2);
  |                        -- first borrow later used here

For more information about this error, try `rustc --explain E0499`.
error: could not compile `ownership` due to previous error
#+end_example

#+REVEAL: split

–û–≤–∏–º –æ–≥—Ä–∞–Ω–∏—á–µ—ö–µ–º –†–∞—Å—Ç, —É –≤—Ä–µ–º–µ –∫–æ–º–ø–∞—ò–ª–∏—Ä–∞—ö–∞, —Å–ø—Ä–µ—á–∞–≤–∞ –∫–ª–∞—Å—É –≥—Ä–µ—à–∞–∫–∞ –∫–æ—ò–µ
–¥–æ–≤–æ–¥–µ –¥–æ –Ω–µ–¥–µ—Ñ–∏–Ω–∏—Å–∞–Ω–æ–≥ –ø–æ–Ω–∞—à–∞—ö–∞ –∏ –∫–æ—ò–µ –∑–æ–≤–µ–º–æ /data races/. –û–≤–µ –≥—Ä–µ—à–∫–µ —Å–µ –≤–µ–æ–º–∞
—Ç–µ—à–∫–æ –æ—Ç–∫—Ä–∏–≤–∞—ò—É –∏ –æ—Ç–∫–ª–∞—ö–∞—ò—É –∏ –º–æ–≥—É –Ω–∞—Å—Ç–∞—Ç–∏ —É–∫–æ–ª–∏–∫–æ —Å—É –∑–∞–¥–æ–≤–æ—ô–µ–Ω–∏ —Å–ª–µ–¥–µ—õ–∏
—É—Å–ª–æ–≤–∏:

- –î–≤–∞ –∏–ª–∏ –≤–∏—à–µ –ø–æ–∏–Ω—Ç–µ—Ä–∞ –ø—Ä–∏—Å—Ç—É–ø–∞—ò—É –∏—Å—Ç–∏–º –ø–æ–¥–∞—Ü–∏–º–∞ —É –∏—Å—Ç–æ –≤—Ä–µ–º–µ,
- –ë–∞—Ä —ò–µ–¥–∞–Ω –ø–æ–∏–Ω—Ç–µ—Ä —Å–µ –∫–æ—Ä–∏—Å—Ç–∏ –∑–∞ –∏–∑–º–µ–Ω—É –ø–æ–¥–∞—Ç–∫–∞,
- –ù–µ –ø–æ—Å—Ç–æ—ò–∏ –º–µ—Ö–∞–Ω–∏–∑–∞–º –∑–∞ —Å–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∞—Ü–∏—ò—É –ø—Ä–∏—Å—Ç—É–ø–∞.

#+REVEAL: split

–í–∏—à–µ –ø—Ä–æ–º–µ—ö–∏–≤–∏—Ö —Ä–µ—Ñ–µ—Ä–µ–Ω—Ü–∏ –º–æ–∂–µ–º–æ –∏–º–∞—Ç–∏ –∞–ª–∏ –Ω–µ —É –∏—Å—Ç–æ–º –æ–ø—Å–µ–≥—É:

#+begin_src rust
let mut s = String::from("hello");

{
    let r1 = &mut s;
} // r1 –æ–≤–¥–µ –∏–∑–ª–∞–∑–∏ –∏–∑ –æ–ø—Å–µ–≥–∞ —Ç–∞–∫–æ –¥–∞ –º–æ–∂–µ–º–æ –∫—Ä–∞–∏—Ä–∞—Ç–∏ –Ω–æ–≤–µ —Ä–µ—Ñ–µ—Ä–µ–Ω—Ü–µ

let r2 = &mut s;
#+end_src

*** –ö–æ–º–±–∏–Ω–∞—Ü–∏—ò–∞ –ø—Ä–æ–º–µ—ö–∏–≤–∏—Ö –∏ –Ω–µ–ø—Ä–æ–º–µ—ö–∏–≤–∏—Ö —Ä–µ—Ñ–µ—Ä–µ–Ω—Ü–∏
–°–ª–∏—á–Ω–æ –ø—Ä–∞–≤–∏–ª–æ –ø–æ—Å—Ç–æ—ò–∏ –∏ —É–∫–æ–ª–∏–∫–æ –∏–º–∞–º–æ –∫–æ–º–±–∏–Ω–∞—Ü–∏—ò—É –ø—Ä–æ–º–µ—ö–∏–≤–∏—Ö –∏ –Ω–µ–ø—Ä–æ–º–µ—ö–∏–≤–∏—Ö
—Ä–µ—Ñ–µ—Ä–µ–Ω—Ü–∏:

#+begin_src rust
let mut s = String::from("hello");

let r1 = &s; // ovo je OK
let r2 = &s; // ovo je OK
let r3 = &mut s; // GRE≈†KA!

println!("{}, {}, and {}", r1, r2, r3);
#+end_src

#+begin_example
$ cargo run
   Compiling ownership v0.1.0 (file:///projects/ownership)
error[E0502]: cannot borrow `s` as mutable because it is also borrowed as immutable
 --> src/main.rs:6:14
  |
4 |     let r1 = &s; // no problem
  |              -- immutable borrow occurs here
5 |     let r2 = &s; // no problem
6 |     let r3 = &mut s; // BIG PROBLEM
  |              ^^^^^^ mutable borrow occurs here
7 |
8 |     println!("{}, {}, and {}", r1, r2, r3);
  |                                -- immutable borrow later used here

For more information about this error, try `rustc --explain E0502`.
error: could not compile `ownership` due to previous error
#+end_example

#+REVEAL: split

- –ù–µ –º–æ–∂–µ–º–æ –∏—Å—Ç–æ–≤—Ä–µ–º–µ–Ω–æ –∏–º–∞—Ç–∏ –Ω–µ–ø—Ä–æ–º–µ—ö–∏–≤–µ –∏ –ø—Ä–æ–º–µ—ö–∏–≤–µ —Ä–µ—Ñ–µ—Ä–µ–Ω—Ü–µ —ò–µ—Ä –∫–æ—Ä–∏—Å–Ω–∏—Ü–∏
  –Ω–µ–ø—Ä–æ–º–µ—ö–∏–≤–∏—Ö —Ä–µ—Ñ–µ—Ä–µ–Ω—Ü–∏ –Ω–µ –æ—á–µ–∫—É—ò—É –¥–∞ —Å–µ –ø–æ–¥–∞—Ü–∏ –º–µ—ö–∞—ò—É.
- –ú–æ–∂–µ–º–æ –∏–º–∞—Ç–∏ –≤–∏—à–µ –Ω–µ–ø—Ä–æ–º–µ—ö–∏–≤–∏—Ö —Ä–µ—Ñ–µ—Ä–µ–Ω—Ü–∏ —ò–µ—Ä –Ω–∏–∫–æ –Ω–µ –º–æ–∂–µ –¥–∞ –º–µ—ö–∞ –ø–æ–¥–∞—Ç–∫–µ –∏
  —Ç–∏–º–µ —É—Ç–∏—á–µ –Ω–∞ –¥—Ä—É–≥–µ.
- –ü—Ä–æ–º–µ—ö–∏–≤–µ —Ä–µ—Ñ–µ—Ä–µ–Ω—Ü–µ —á–µ—Å—Ç–æ –∑–æ–≤–µ–º–æ –∏ /—ò–µ–¥–∏–Ω—Å—Ç–≤–µ–Ω–µ —Ä–µ—Ñ–µ—Ä–µ–Ω—Ü–µ/ —ò–µ—Ä –∫–∞–¥–∞ —Å—É –æ–Ω–µ
  –∞–∫—Ç–∏–≤–Ω–µ –Ω–µ –º–æ–∂–µ –ø–æ—Å—Ç–æ—ò–∞—Ç–∏ –¥—Ä—É–≥–∞ —Ä–µ—Ñ–µ—Ä–µ–Ω—Ü–∞ –Ω–∞ –∏—Å—Ç—É –≤—Ä–µ–¥–Ω–æ—Å—Ç.

*** –û–ø—Å–µ–≥ –≤–∞–∂–µ—ö–∞ —Ä–µ—Ñ–µ—Ä–µ–Ω—Ü–µ
–û–ø—Å–µ–≥ –≤–∞–∂–µ—ö–∞ —Ä–µ—Ñ–µ—Ä–µ–Ω—Ü–µ –ø–æ—á–∏—ö–µ –æ–¥ –º–µ—Å—Ç–∞ –≥–¥–µ —ò–µ —É–≤–µ–¥–µ–Ω–∞ –ø–∞ –¥–æ —ö–µ–Ω–µ –ø–æ—Å–ª–µ–¥—ö–µ
—É–ø–æ—Ç—Ä–µ–±–µ. –ù–∞ –ø—Ä–∏–º–µ—Ä, –æ–≤–æ —ò–µ –≤–∞–ª–∏–¥–Ω–æ:

#+begin_src rust
let mut s = String::from("hello");

let r1 = &s; // OK
let r2 = &s; // OK
println!("{} and {}", r1, r2);
// –≤–∞—Ä–∏—ò–∞–±–ª–µ r1 –∏ r2 —Å–µ –Ω–µ –∫–æ—Ä–∏—Å—Ç–µ —É –Ω–∞—Å—Ç–∞–≤–∫—É –ø–∞ —ö–∏—Ö–æ–≤ –æ–ø—Å–µ–≥
// –ø—Ä–µ—Å—Ç–∞—ò–µ –¥–∞ –≤–∞–∂–∏.

let r3 = &mut s; // –∑–∞—Ç–æ —ò–µ –æ–≤–æ OK
println!("{}", r3);
#+end_src

–û–≤–∞ –æ—Å–æ–±–∏–Ω–∞ —Ä–µ—Ñ–µ—Ä–µ–Ω—Ü–∏ —Å–µ –Ω–∞–∑–∏–≤–∞ /Non-Lexical Lifetimes (NLL)/.

*** "–í–∏—Å–µ—õ–µ" —Ä–µ—Ñ–µ—Ä–µ–Ω—Ü–µ
- –£ —ò–µ–∑–∏—Ü–∏–º–∞ —Å–∞ –ø–æ–∏–Ω—Ç–µ—Ä–∏–º–∞ –ª–∞–∫–æ —ò–µ –∫—Ä–µ–∏—Ä–∞—Ç–∏ –ø–æ–∏–Ω—Ç–µ—Ä –Ω–∞ –¥–µ–æ –º–µ–º–æ—Ä–∏—ò–µ –∫–æ—ò–∏ —ò–µ –¥–µ–∞–ª–æ—Ü–∏—Ä–∞–Ω.
- –†–∞—Å—Ç –≥–∞—Ä–∞–Ω—Ç–æ–≤–∞–Ω–æ —Å–ø—Ä–µ—á–∞–≤–∞ –æ–≤–∞–∫–≤–µ –≥—Ä–µ—à–∫–µ. –†–µ—Ñ–µ—Ä–µ–Ω—Ü–µ —Å—É —É–≤–µ–∫ –≤–∞–ª–∏–¥–Ω–µ —É –†–∞—Å—Ç—É.

#+begin_src rust
fn main() {
    let reference_to_nothing = dangle();
}

fn dangle() -> &String {
    let s = String::from("hello");

    &s
}
#+end_src

#+REVEAL: split

#+begin_example
$ cargo run
   Compiling ownership v0.1.0 (file:///projects/ownership)
error[E0106]: missing lifetime specifier
 --> src/main.rs:5:16
  |
5 | fn dangle() -> &String {
  |                ^ expected named lifetime parameter
  |
  = help: this function's return type contains a borrowed value, but there is no value
  for it to be borrowed from
help: consider using the `'static` lifetime
  |
5 | fn dangle() -> &'static String {
  |                ~~~~~~~~

For more information about this error, try `rustc --explain E0106`.
error: could not compile `ownership` due to previous error
#+end_example

- –ú–µ—Ö–∞–Ω–∏–∑–∞–º –∫–æ—ò–∏ –æ–≤–æ —Å–ø—Ä–µ—á–∞–≤–∞ –Ω–∞–∑–∏–≤–∞ —Å–µ "–≤—Ä–µ–º–µ –∂–∏–≤–æ—Ç–∞" (/lifetime/) –∏ –±–∏—õ–µ
  –¥–µ—Ç–∞—ô–Ω–∏—ò–µ –æ–±—Ä–∞—í–µ–Ω–æ —É –Ω–∞—Å—Ç–∞–≤–∫—É.
- –£ –ø—Ä–µ–≤–æ–¥—É –†–∞—Å—Ç –Ω–∞–º –ø–æ—Ä—É—á—É—ò–µ:

  #+begin_quote
  –¢–∏–ø –ø–æ–≤—Ä–∞—Ç–Ω–µ –≤—Ä–µ–¥–Ω–æ—Å—Ç–∏ –æ–≤–µ —Ñ—É–Ω–∫—Ü–∏—ò–µ —ò–µ –ø–æ–∑–∞—ò–º—ô–µ–Ω–∞ –≤—Ä–µ–¥–Ω–æ—Å—Ç, –∞–ª–∏ –Ω–µ –ø–æ—Å—Ç–æ—ò–∏
  —É–ª–∞–∑–Ω–∏ –ø–∞—Ä–∞–º–µ—Ç–∞—Ä –æ–¥ –∫–æ–≥–∞ –º–æ–∂–µ –¥–∞ —Å–µ –ø–æ–∑–∞—ò–º–∏.
  #+end_quote

*** –®—Ç–∞ —Å–µ —Ç–∞—á–Ω–æ –¥–µ—Å–∏–ª–æ?
#+begin_src rust
fn dangle() -> &String { // dangle –≤—Ä–∞—õ–∞ —Ä–µ—Ñ–µ—Ä–µ–Ω—Ü—É –Ω–∞ String

    let s = String::from("hello"); // s —ò–µ –Ω–æ–≤–∏ String

    &s // –í—Ä–∞—õ–∞–º–æ —Ä–µ—Ñ–µ—Ä–µ–Ω—Ü—É –Ω–∞ String s
} // s –∏–∑–ª–∞–∑–∏ –∏–∑ –æ–ø—Å–µ–≥–∞ –∏ –ø–æ–∑–∏–≤–∞ —Å–µ `drop`. –ú–µ–º–æ—Ä–∏—ò–∞ —Å–µ –æ—Å–ª–æ–±–∞—í–∞.
  // –û–ü–ê–°–ù–û–°–¢! –í—Ä–∞—õ–µ–Ω–∞ —Ä–µ—Ñ–µ—Ä–µ–Ω—Ü–∞ —õ–µ –±–∏—Ç–∏ "–≤–∏—Å–µ—õ–∞".
#+end_src

–ö–∞–∫–æ —Å–µ –º–æ–∂–µ —Ä–µ—à–∏—Ç–∏. –í—Ä–∞—Ç–∏—õ–µ–º–æ –ø–æ—Å–µ–¥–æ–≤–∞–Ω—É (/owned/) –≤—Ä–µ–¥–Ω–æ—Å—Ç, —Ç—ò —É—Ä–∞–¥–∏—õ–µ–º–æ
–ø—Ä–µ–º–µ—à—Ç–∞—ö–µ –≤—Ä–µ–¥–Ω–æ—Å—Ç–∏ —É —Ñ—É–Ω–∫—Ü–∏—ò—É –ø–æ–∑–∏–≤–∞–æ—Ü–∞.

#+begin_src rust
fn no_dangle() -> String {
    let s = String::from("hello");

    s
}
#+end_src

*** –ü—Ä–∞–≤–∏–ª–∞ —Ä–µ—Ñ–µ—Ä–µ–Ω—Ü–∏—Ä–∞—ö–∞
1. –£ —Å–≤–∞–∫–æ–º —Ç—Ä–µ–Ω—É—Ç–∫—É –º–æ–∂–µ–º–æ –∏–º–∞—Ç–∏ –∏–ª–∏ —ò–µ–¥–Ω—É –ø—Ä–æ–º–µ—ö–∏–≤—É –∏–ª–∏ –ø—Ä–æ–∏–∑–≤–æ—ô–∞–Ω –±—Ä–æ—ò
   –Ω–µ–ø—Ä–æ–º–µ—ö–∏–≤–∏—Ö —Ä–µ—Ñ–µ—Ä–µ–Ω—Ü–∏.
2. –†–µ—Ñ–µ—Ä–µ–Ω—Ü–µ —É–≤–µ–∫ –º–æ—Ä–∞—ò—É –±–∏—Ç–∏ –≤–∞–ª–∏–¥–Ω–µ.

** –ò—Å–µ—á—Ü–∏ (/Slice/ —Ç–∏–ø)
*** /Slice/
- –ò—Å–µ—á—Ü–∏ (/slices/) –æ–º–æ–≥—É—õ–∞–≤–∞—ò—É —Ä–µ—Ñ–µ—Ä–µ–Ω—Ü–∏—Ä–∞—ö–µ –∫–æ–Ω—Ç–∏–Ω—É–∞–ª–Ω–µ —Å–µ–∫–≤–µ–Ω—Ü–µ —É–Ω—É—Ç–∞—Ä
  –∫–æ–ª–µ–∫—Ü–∏—ò–µ —É–º–µ—Å—Ç–æ —Ü–µ–ª–µ –∫–æ–ª–µ–∫—Ü–∏—ò–µ

*** –ü—Ä–∏–º–µ—Ä
–§—É–Ω–∫—Ü–∏—ò–∞ –∫–æ—ò–∞ –∑–∞ –∑–∞–¥–∞—Ç–∏ —Å—Ç—Ä–∏–Ω–≥ –≤—Ä–∞—õ–∞ –ø—Ä–≤—É —Ä–µ—á.

#+begin_src rust
fn first_word(s: &String) -> usize {
    let bytes = s.as_bytes();

    for (i, &item) in bytes.iter().enumerate() {
        if item == b' ' {
            return i;
        }
    }

    s.len()
}
#+end_src

- –î–∞–∫–ª–µ, –≤—Ä–∞—õ–∞–º–æ –∏–Ω–¥–µ–∫—Å –∫—Ä–∞—ò–∞ —Ä–µ—á–∏. –ü–æ–∑–∏–≤–∞–æ—Ü —Å–∞–¥–∞ –∏–º–∞ –ø–æ—Ç—Ä–µ–±–Ω–µ –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—ò–µ –¥–∞ –¥–æ—í–µ –¥–æ —Ç—Ä–∞–∂–µ–Ω–µ —Ä–µ—á–∏.
- –ü—Ä–æ–±–ª–µ–º: –¥–≤–∞ –ø–æ–¥–∞—Ç–∫–∞ –∫–æ—ò–∞ —Å—É —É –≤–µ–∑–∏ –∞–ª–∏ –º–æ—Ä–∞–º–æ —Ç—É –≤–µ–∑—É —Ä—É—á–Ω–æ –¥–∞ –æ–¥—Ä–∂–∞–≤–∞–º–æ —ò–µ—Ä
  –Ω–µ–º–∞–º–æ –≥–∞—Ä–∞–Ω—Ü–∏—ò—É –¥–∞ —õ–µ –±—Ä–æ—ò –∫–æ—ò–∏ —ò–µ –≤—Ä–∞—õ–µ–Ω –±–∏—Ç–∏ –≤–∞–ª–∏–¥–∞–Ω –∏ —É –±—É–¥—É—õ–Ω–æ—Å—Ç–∏ (–Ω–ø—Ä.
  —Å—Ç—Ä–∏–Ω–≥ –º–æ–∂–µ –¥–∞ —Å–µ –ø—Ä–æ–º–µ–Ω–∏ –∏–ª–∏ –¥–∞ –∏–∑–∞—í–µ –∏–∑ –æ–ø—Å–µ–≥–∞).

#+REVEAL: split

#+begin_src rust
fn main() {
    let mut s = String::from("hello world");

    let word = first_word(&s); // word —õ–µ –¥–æ–±–∏—Ç–∏ –≤—Ä–µ–¥–Ω–æ—Å—Ç 5

    s.clear(); // —Å—Ç—Ä–∏–Ω–≥ s –ø–æ—Å—Ç–∞—ò–µ ""

    // word —ò–µ –∏ –¥–∞—ô–µ 5 –∏–∞–∫–æ —Ç–æ –≤–∏—à–µ –Ω–∏—ò–µ –∏—Å–ø—Ä–∞–≤–Ω–æ
}
#+end_src

#+REVEAL: split

–ü—Ä–æ–±–ª–µ–º –ø–æ—Å—Ç–∞—ò–µ —ò–æ—à –æ–∑–±–∏—ô–Ω–∏—ò–∏ –∞–∫–æ –Ω–ø—Ä. –Ω–∞–ø–∏—à–µ–º–æ —Ñ—É–Ω–∫—Ü–∏—ò—É =second_word= –∫–æ—ò–∞ –≤—Ä–∞—õ–∞
–¥—Ä—É–≥—É —Ä–µ—á –∑–∞–¥–∞—Ç–æ–≥ —Å—Ç—Ä–∏–Ω–≥–∞. –ü–æ –∞–Ω–∞–ª–æ–≥–∏—ò–∏ —Å–∞ –ø—Ä–µ—Ç—Ö–æ–¥–Ω–∏–º, —Ç—Ä–µ–±–∞–ª–∏ –±–∏ –¥–∞ –≤—Ä–∞—Ç–∏–º–æ
–ø–æ—á–µ—Ç–∞–∫ –∏ –∫—Ä–∞—ò –¥—Ä—É–≥–µ —Ä–µ—á–∏.

#+begin_src rust
fn second_word(s: &String) -> (usize, usize) {
#+end_src

–°–∞–¥–∞ –∏–º–∞–º–æ —Ç—Ä–∏ –ø–æ–¥–∞—Ç–∫–∞ –æ –∫–æ—ò–∏–º–∞ –º–æ—Ä–∞–º–æ –¥–∞ –≤–æ–¥–∏–º–æ —Ä–∞—á—É–Ω–∞.

*** –°—Ç—Ä–∏–Ω–≥ –∏—Å–µ—á–∞–∫
–ü—Ä–æ–±–ª–µ–º —Ä–µ—à–∞–≤–∞–º–æ —É–ø–æ—Ç—Ä–µ–±–æ–º –∏—Å–µ—á–∞–∫–∞.

#+begin_src rust
let s = String::from("hello world");

let hello = &s[0..5];
let world = &s[6..11];
#+end_src

#+REVEAL_HTML: <div class="column" style="float:left; width: 55%">
–°–∏–Ω—Ç–∞–∫—Å–∞ =s[x..y]= –∫—Ä–µ–∏—Ä–∞ –∏—Å–µ—á–∞–∫ –Ω–∞–¥ —Å–µ–∫–≤–µ–Ω—Ü–æ–º =s=. –° –æ–±–∑–∏—Ä–æ–º –¥–∞ –æ–≤–∞—ò —Ç–∏–ø (=[T]=) –Ω–µ–º–∞
–ø–æ–∑–Ω–∞—Ç—É –≤–µ–ª–∏—á–∏–Ω—É —É –≤—Ä–µ–º–µ –∫–æ–º–ø–∞—ò–ª–∏—Ä–∞—ö–∞, –Ω–µ –º–æ–∂–µ–º–æ –≥–∞ –∞–ª–æ—Ü–∏—Ä–∞—Ç–∏ –Ω–∞ —Å—Ç–µ–∫—É, –æ–¥–Ω–æ—Å–Ω–æ
–Ω–µ –º–æ–∂–µ–º–æ –≥–∞ –¥–æ–¥–µ–ª–∏—Ç–∏ –ª–æ–∫–∞–ª–Ω–∏–º –≤–∞—Ä–∏—ò–∞–±–ª–∞–º–∞ –∏–ª–∏ –ø—Ä–æ—Å–ª–µ—í–∏–≤–∞—Ç–∏ –∫–∞–æ –ø–∞—Ä–∞–º–µ—Ç–∞—Ä
—Ñ—É–Ω–∫—Ü–∏—ò–µ. –ó–∞—Ç–æ —Å–µ —É –ø—Ä–∞–∫—Å–∏ –∫–æ—Ä–∏—Å—Ç–∏ —Ä–µ—Ñ–µ—Ä–µ–Ω—Ü–∞ –Ω–∞ –∏—Å–µ—á–∞–∫ (=&[T]=) (—á–µ—Å—Ç–æ —Å–µ –∑–æ–≤–µ –∏
/fat pointer/).

–î–∞–∫–ª–µ, —É –ø—Ä–∞–∫—Å–∏ –º–Ω–æ–≥–æ —á–µ—à—õ–µ —Å—Ä–µ—õ–µ–º–æ —Å–∏–Ω—Ç–∞–∫—Å—É =&s[x..y]=.
#+REVEAL_HTML: </div>

#+REVEAL_HTML: <div class="column" style="float:right; width: 45%">
#+attr_html: :style height: 500px;
#+ATTR_ORG: :width 300px
[[./images/slice.png]]
#+REVEAL_HTML: </div>

#+REVEAL_HTML: <div style="clear: both;">

*** –ò—Å–µ—á—Ü–∏ –∏ —Å–∏–Ω—Ç–∞–∫—Å–∞ –æ–ø—Å–µ–≥–∞ (/range/)
#+begin_src rust
let s = String::from("hello");

let slice = &s[0..2];
let slice = &s[..2];
#+end_src

#+begin_src rust
let s = String::from("hello");

let len = s.len();

let slice = &s[3..len];
let slice = &s[3..];
#+end_src

#+begin_src rust
let s = String::from("hello");

let len = s.len();

let slice = &s[0..len];
let slice = &s[..];
#+end_src

*** –ú–æ–¥–∏—Ñ–∏–∫–∞—Ü–∏—ò–∞ –ø—Ä–∏–º–µ—Ä–∞ –¥–∞ –∫–æ—Ä–∏—Å—Ç–∏ —Å—Ç—Ä–∏–Ω–≥ –∏—Å–µ—á–∫–µ
#+begin_src rust
fn first_word(s: &String) -> &str {
    let bytes = s.as_bytes();

    for (i, &item) in bytes.iter().enumerate() {
        if item == b' ' {
            return &s[0..i];
        }
    }

    &s[..]
}
#+end_src

–ò—Å—Ç–∏ API –∏ –∑–∞ =second_word=.

#+begin_src rust
fn second_word(s: &String) -> &str {
#+end_src

#+REVEAL: split

–°–∞–¥–∞ –Ω–∞–º –∫–æ–º–ø–∞—ò–ª–µ—Ä –æ—Å–∏–≥—É—Ä–∞–≤–∞ –¥–∞ —É–≤–µ–∫ –∏–º–∞–º–æ –≤–∞–ª–∏–¥–Ω—É —Ä–µ—Ñ–µ—Ä–µ–Ω—Ü—É –Ω–∞ —Ä–µ—á.
#+begin_src rust
fn main() {
    let mut s = String::from("hello world");

    let word = first_word(&s);

    s.clear(); // –ì–†–ï–®–ö–ê!

    println!("the first word is: {}", word);
}
#+end_src

#+begin_example
$ cargo run
   Compiling ownership v0.1.0 (file:///projects/ownership)
error[E0502]: cannot borrow `s` as mutable because it is also borrowed as immutable
  --> src/main.rs:18:5
   |
16 |     let word = first_word(&s);
   |                           -- immutable borrow occurs here
17 |
18 |     s.clear(); // error!
   |     ^^^^^^^^^ mutable borrow occurs here
19 |
20 |     println!("the first word is: {}", word);
   |                                       ---- immutable borrow later used here

For more information about this error, try `rustc --explain E0502`.
error: could not compile `ownership` due to previous error
#+end_example

–ù–µ —Å–∞–º–æ –¥–∞ —ò–µ API –ª–∞–∫—à–∏ –∑–∞ —É–ø–æ—Ç—Ä–µ–±—É –≤–µ—õ —ò–µ —á–∏—Ç–∞–≤–∞ –∫–ª–∞—Å–∞ –≥—Ä–µ—à–∞–∫–∞ –∫–æ—ò–µ —Å–µ —Ç–µ—à–∫–æ
–æ—Ç–∫—Ä–∏–≤–∞—ò—É –µ–ª–∏–º–∏–Ω–∏—Å–∞–Ω–∞ —É –≤—Ä–µ–º–µ –∫–æ–º–ø–∞—ò–ª–∏—Ä–∞—ö–∞.

*** –°—Ç—Ä–∏–Ω–≥ –ª–∏—Ç–µ—Ä–∞–ª–∏ —Å—É —Ä–µ—Ñ–µ—Ä–µ–Ω—Ü–µ –Ω–∞ –∏—Å–µ—á–∫–µ
#+begin_src rust
let s = "Hello, world!";
#+end_src

–¢–∏–ø –æ–¥ =s= —ò–µ =&str=. =str= —ò–µ —Å—Ç—Ä–∏–Ω–≥ –∏—Å–µ—á–∞–∫.

*** –°—Ç—Ä–∏–Ω–≥ –∏—Å–µ—á—Ü–∏ –∫–∞–æ –ø–∞—Ä–∞–º–µ—Ç—Ä–∏ —Ñ—É–Ω–∫—Ü–∏—ò–∞
#+begin_src rust
fn first_word(s: &String) -> &str {
#+end_src

–ê–ª–∏ —õ–µ –∏—Å–∫—É—Å–Ω–∏ –†–∞—Å—Ç –ø—Ä–æ–≥—Ä–∞–º–µ—Ä–∏ –ø–∏—Å–∞—Ç–∏:

#+begin_src rust
fn first_word(s: &str) -> &str {
#+end_src

–à–µ—Ä —õ–µ –æ–≤–∞ —Ñ—É–Ω–∫—Ü–∏—ò–∞ –º–æ—õ–∏ –¥–∞ —Å–µ –∫–æ—Ä–∏—Å—Ç–∏ –∏ –∑–∞ =&str= –∏ –∑–∞ =&String=. –û–≤–¥–µ —Å–µ
—É–ø–æ—Ç—Ä–µ–±—ô–∞–≤–∞ —Ç–∑–≤. /Deref Coercion/ –æ–¥–Ω–æ—Å–Ω–æ –º–æ–≥—É—õ–Ω–æ—Å—Ç–∏ —Ç–∏–ø–æ–≤–∞ –¥–∞ —Å–µ –¥–µ—Ä–µ—Ñ–µ—Ä–µ–Ω—Ü–∏—Ä–∞—ò—É
—É –¥—Ä—É–≥–∏ —Ç–∏–ø. –ù–ø—Ä. =&String= —õ–µ —Å–µ –∞—É—Ç–æ–º–∞—Ç—Å–∫–∏ –¥–µ—Ä–µ—Ñ–µ—Ä–µ–Ω—Ü–∏—Ä–∞—Ç–∏ —É =&str= —É–∫–æ–ª–∏–∫–æ —ò–µ —Ç–æ
–ø–æ—Ç—Ä–µ–±–Ω–æ. –û–ø–µ—Ä–∞—Ü–∏—ò–∞ —ò–µ –µ—Ñ–∏–∫–∞—Å–Ω–∞.

#+REVEAL: split

#+begin_src rust
fn main() {
    let my_string = String::from("hello world");

    // `first_word` works on slices of `String`s, whether partial or whole
    let word = first_word(&my_string[0..6]);
    let word = first_word(&my_string[..]);
    // `first_word` also works on references to `String`s, which are equivalent
    // to whole slices of `String`s
    let word = first_word(&my_string);

    let my_string_literal = "hello world";

    // `first_word` works on slices of string literals, whether partial or whole
    let word = first_word(&my_string_literal[0..6]);
    let word = first_word(&my_string_literal[..]);

    // Because string literals *are* string slices already,
    // this works too, without the slice syntax!
    let word = first_word(my_string_literal);
}
#+end_src

*** –£–ø–æ—Ç—Ä–µ–±–∞ –∏—Å–µ—á–∞–∫–∞ –Ω–∞–¥ –¥—Ä—É–≥–∏–º —Å—Ç—Ä—É–∫—Ç—É—Ä–∞–º–∞
#+begin_src rust
let a = [1, 2, 3, 4, 5];

let slice = &a[1..3]; // —Ä–µ—Ñ–µ—Ä–µ–Ω—Ü–∞ –Ω–∞ –∏—Å–µ—á–∞–∫ —Ç–∏–ø–∞ &[i32]

assert_eq!(slice, &[2, 3]);
#+end_src

* –°—Ç—Ä—É–∫—Ç—É—Ä–µ
** =struct= —Ç–∏–ø
–ö–æ—Ä–∏—Å–Ω–∏—á–∫–∏ —Ç–∏–ø –∫–æ—ò–∏ –æ–º–æ–≥—É—õ–∞–≤–∞ –≥—Ä—É–ø–∏—Å–∞—ö–µ –≤–∏—à–µ –ª–æ–≥–∏—á–∫–∏ –ø–æ–≤–µ–∑–∞–Ω–∏—Ö –≤—Ä–µ–¥–Ω–æ—Å—Ç–∏ - –ø–æ—ô–∞
(/fields/).

–£ –†–∞—Å—Ç—É –ø–æ—Å—Ç–æ—ò–µ —Ç—Ä–∏ –≤—Ä—Å—Ç–µ —Å—Ç—Ä—É–∫—Ç—É—Ä–∞:
- –°—Ç—Ä—É–∫—Ç—É—Ä–µ —Ç–æ—Ä–∫–∏ (/tuple structs/) - —É –æ—Å–Ω–æ–≤–∏ –ø—Ä–µ–¥—Å—Ç–∞–≤—ô–∞—ò—É –∏–º–µ–Ω–æ–≤–∞–Ω–µ —Ç–æ—Ä–∫–µ
- –ö–ª–∞—Å–∏—á–Ω–µ –¶-–æ–≤—Å–∫–µ —Å—Ç—Ä—É–∫—Ç—É—Ä–µ
- –à–µ–¥–∏–Ω–∏—á–Ω–µ —Å—Ç—Ä—É–∫—Ç—É—Ä–µ (/unit structs/) - —Å—Ç—Ä—É–∫—Ç—É—Ä–µ –±–µ–∑ –∞—Ç—Ä–∏–±—É—Ç–∞

** –î–µ—Ñ–∏–Ω–∏—Ü–∏—ò–∞ —Å—Ç—Ä—É–∫—Ç—É—Ä–µ
#+begin_src rust
struct User {
    active: bool,
    username: String,
    email: String,
    sign_in_count: u64,
}
#+end_src

** –ö—Ä–µ–∏—Ä–∞—ö–µ –∏–Ω—Å—Ç–∞–Ω—Ü–µ —Å—Ç—Ä—É–∫—Ç—É—Ä–µ
#+begin_src rust
fn main() {
    let user1 = User {
        active: true,
        username: String::from("someusername123"),
        email: String::from("someone@example.com"),
        sign_in_count: 1,
    };
}
#+end_src

** –ü—Ä–æ–º–µ–Ω–∞ –≤—Ä–µ–¥–Ω–æ—Å—Ç–∏ –ø–æ—ô–∞
#+begin_src rust
fn main() {
    let mut user1 = User {
        active: true,
        username: String::from("someusername123"),
        email: String::from("someone@example.com"),
        sign_in_count: 1,
    };

    user1.email = String::from("anotheremail@example.com");
}
#+end_src

** –ö—Ä–µ–∏—Ä–∞—ö–µ —Å—Ç—Ä—É–∫—Ç—É—Ä–µ –ø—É—Ç–µ–º —Ñ—É–Ω–∫—Ü–∏—ò–µ
#+begin_src rust
fn build_user(email: String, username: String) -> User {
    User {
        active: true,
        username: username,
        email: email,
        sign_in_count: 1,
    }
}
#+end_src

** –£–ø–æ—Ç—Ä–µ–±–∞ —Å–∫—Ä–∞—õ–µ–Ω–æ–≥ –æ–±–ª–∏–∫–∞
#+begin_src rust
fn build_user(email: String, username: String) -> User {
    User {
        active: true,
        username,
        email,
        sign_in_count: 1,
    }
}
#+end_src

** –ö—Ä–µ–∏—Ä–∞—ö–µ –∏–Ω—Å—Ç–∞–Ω—Ü–µ –∏–∑ –¥—Ä—É–≥–µ –∏–Ω—Å—Ç–∞–Ω—Ü–µ —É–ø–æ—Ç—Ä–µ–±–æ–º —Å–∏–Ω—Ç–∞–∫—Å–µ –∑–∞ –∞–∂—É—Ä–∏—Ä–∞—ö–µ (/update syntax/)
–£–º–µ—Å—Ç–æ:
#+begin_src rust
fn main() {
    // --snip--
    let user2 = User {
        active: user1.active,
        username: user1.username,
        email: String::from("another@example.com"),
        sign_in_count: user1.sign_in_count,
    };
}
#+end_src

–ú–æ–∂–µ–º–æ –ø–∏—Å–∞—Ç–∏:
#+begin_src rust
fn main() {
    let user2 = User {
        email: String::from("another@example.com"),
        ..user1
    };
}
#+end_src

** –°—Ç—Ä—É–∫—Ç—É—Ä–µ —Ç–æ—Ä–∫–∏
–¢–∑–≤. /–∏–º–µ–Ω–æ–≤–∞–Ω–µ —Ç–æ—Ä–∫–µ/. –ü–æ—ô–∞ –Ω–µ–º–∞—ò—É –∏–º–µ–Ω–∞, –ø—Ä–∏—Å—Ç—É–ø–∞ –∏–º —Å–µ –∫–∞–æ –∫–æ–¥ –æ–±–∏—á–Ω–∏—Ö —Ç–æ—Ä–∫–∏
—É–ø–æ—Ç—Ä–µ–±–æ–º =x.n= —Å–∏–Ω—Ç–∞–∫—Å–µ –≥–¥–µ —ò–µ =n= —Ä–µ–¥–Ω–∏ –±—Ä–æ—ò –ø–æ—ô–∞.

#+begin_src rust
struct Color(i32, i32, i32);
struct Point(i32, i32, i32);

fn main() {
    let black = Color(0, 0, 0);
    let origin = Point(5, 8, 0);
    let y = origin.1;
    println!("{}", y);
}
#+end_src

#+RESULTS:
: 8

** –à–µ–¥–∏–Ω–∏—á–Ω–µ —Å—Ç—Ä—É–∫—Ç—É—Ä–µ - –±–µ–∑ –ø–æ—ô–∞
–ö–æ—Ä–∏—Å—Ç–µ —Å–µ –∑–∞ –∫—Ä–µ–∏—Ä–∞—ö–µ —Ç–∏–ø–æ–≤–∞ –∫–æ—ò–∏ –∏–º–∞—ò—É –ø–æ–Ω–∞—à–∞—ö–µ (–∏–º–ø–ª–µ–º–µ–Ω—Ç–∏—Ä–∞—ò—É –æ—Å–æ–±–∏–Ω–µ) –∞–ª–∏
–Ω–µ —á—É–≤–∞—ò—É –ø–æ–¥–∞—Ç–∫–µ (—Ç–∑–≤. [[https://doc.rust-lang.org/nomicon/exotic-sizes.html#zero-sized-types-zsts][Zero Sized Types (ZSTs)]])

#+begin_src rust
struct AlwaysEqual;

fn main() {
    let subject = AlwaysEqual;
}
#+end_src

** –†–∞–∑–Ω–∏ –ø—Ä–∏–º–µ—Ä–∏
#+begin_src rust
#[derive(Debug)]
struct Person {
    name: String,
    age: u8,
}

// A unit struct
struct Unit;

// A tuple struct
struct Pair(i32, f32);

// A struct with two fields
struct Point {
    x: f32,
    y: f32,
}
// Structs can be reused as fields of another struct
struct Rectangle {
    // A rectangle can be specified by where the top left and bottom right
    // corners are in space.
    top_left: Point,
    bottom_right: Point,
}
#+end_src

#+REVEAL: split

#+begin_src rust
// Create struct with field init shorthand
let name = String::from("Peter");
let age = 27;
let peter = Person { name, age };

// Print debug struct
println!("{:?}", peter);

// Instantiate a `Point`
let point: Point = Point { x: 10.3, y: 0.4 };

// Access the fields of the point
println!("point coordinates: ({}, {})", point.x, point.y);

// Make a new point by using struct update syntax to use the fields of our
// other one
let bottom_right = Point { x: 5.2, ..point };

// `bottom_right.y` will be the same as `point.y` because we used that field
// from `point`
println!("second point: ({}, {})", bottom_right.x, bottom_right.y);
#+end_src

#+REVEAL: split

#+begin_src rust
// Destructure the point using a `let` binding
let Point { x: left_edge, y: top_edge } = point;

let _rectangle = Rectangle {
    // struct instantiation is an expression too
    top_left: Point { x: left_edge, y: top_edge },
    bottom_right: bottom_right,
};

// Instantiate a unit struct
let _unit = Unit;

// Instantiate a tuple struct
let pair = Pair(1, 0.1);

// Access the fields of a tuple struct
println!("pair contains {:?} and {:?}", pair.0, pair.1);

// Destructure a tuple struct
let Pair(integer, decimal) = pair;

println!("pair contains {:?} and {:?}", integer, decimal);
#+end_src

* –ï–Ω—É–º–µ—Ä–∞—Ü–∏—ò–µ
** /Enum/ —Ç–∏–ø
*** /Enum/ —Ç–∏–ø
- –î–µ—Ñ–∏–Ω–∏—Å–∞—ö–µ —Ç–∏–ø–∞ –Ω–∞–≤–æ—í–µ—ö–µ–º —Å–≤–∏—Ö –º–æ–≥—É—õ–∏—Ö –≤–∞—Ä–∏—ò–∞–Ω—Ç–∏
- –í–∞—Ä–∏—ò–∞–Ω—Ç–∞ –º–æ–∂–µ –¥–∞ —Å–∞–¥—Ä–∂–∏ –¥–æ–¥–∞—Ç–Ω–µ –ø–æ–¥–∞—Ç–∫–µ
- –°–ª–∏—á–Ω–æ —Å–∞ –∞–ª–≥–µ–±–∞—Ä—Å–∫–∏–º —Ç–∏–ø–æ–≤–∏–º–∞ –ø–æ–¥–∞—Ç–∞–∫–∞ (/algebraic data types/) —É —Ñ—É–Ω–∫—Ü–∏–æ–Ω–∞–ª–Ω–∏–º
  —ò–µ–∑–∏—Ü–∏–º–∞, –Ω–ø—Ä. F#, OCaml –∏ Haskell-—É. –û–≤–∞ –≤—Ä—Å—Ç–∞ –∞–ª–≥–µ–±–∞—Ä—Å–∫–æ–≥ —Ç–∏–ø–∞ —ò–µ –ø–æ–∑–Ω–∞—Ç–∞ –∏
  –ø–æ–¥ –Ω–∞–∑–∏–≤–æ–º /sum type/.

*** –ü—Ä–∏–º–µ—Ä - IP –∞–¥—Ä–µ—Å–∞
- IP –∞–¥—Ä–µ—Å–∞ –ø—Ä–µ–¥—Å—Ç–∞–≤—ô–∞ –∏–¥–µ–Ω—Ç–∏—Ñ–∏–∫–∞—Ü–∏—ò—É –º—Ä–µ–∂–Ω–∏—Ö –∏–Ω—Ç–µ—Ä—Ñ–µ—ò—Å–∞ —É —É—Ä–µ—í–∞—ò–∏–º–∞ –∫–æ—ò–∏
  –∫–æ–º—É–Ω–∏—Ü–∏—Ä–∞—ò—É –ø–æ—Å—Ä–µ–¥—Å—Ç–≤–æ–º –ò–Ω—Ç–µ—Ä–Ω–µ—Ç –ø—Ä–æ—Ç–æ–∫–æ–ª–∞ (/Internet Protocol - IP/).
- –¢—Ä–µ–Ω—É—Ç–Ω–æ –∏–º–∞–º–æ —É —É–ø–æ—Ç—Ä–µ–±–∏ —Å—Ç–∞—Ä—É –≤–µ—Ä–∑–∏—ò—É 4 –∏ –Ω–æ–≤—É –≤–µ—Ä–∑–∏—ò—É 6 –∫–æ—ò–∞ —õ–µ –≤—Ä–µ–º–µ–Ω–æ–º
  –∑–∞–º–µ–Ω–∏—Ç–∏ –≤–µ—Ä–∑–∏—ò—É 4.
- –í–µ—Ä–∑–∏—ò–∞ 4 —ò–µ –¥—É–∂–∏–Ω–µ 32 –±–∏—Ç–∞ –∏ –Ω–∞–≤–æ–¥–∏ —Å–µ –∫–∞–æ —á–µ—Ç–∏—Ä–∏ –æ–∫—Ç–µ—Ç–∞ —É –æ–±–ª–∏–∫—É –Ω–ø—Ä.
  =192.0.2.1=
- –í–µ—Ä–∑–∏—ò–∞ 6 —ò–µ –¥—É–∂–∏–Ω–µ 128 –±–∏—Ç–∞ –∏ –Ω–∞–≤–æ–¥–∏ —Å–µ –∫–∞–æ 8 –≥—Ä—É–ø–∞ –æ–¥ –ø–æ 4 —Ö–µ–∫—Å–∞ —Ü–∏—Ñ—Ä–µ
  —Ä–∞–∑–¥–≤–æ—ò–µ–Ω–µ —Å–∞ =:=, –Ω–ø—Ä. =2001:db8:0:1234:0:567:8:1=

#+REVEAL: split

–£ –†–∞—Å—Ç—É –º–æ–∂–µ–º–æ –ø–∏—Å–∞—Ç–∏ —Å–ª–µ–¥–µ—õ–µ:

#+begin_src rust
enum IpAddrKind {
    V4,
    V6,
}
#+end_src

–î–æ–∫ –≤—Ä–µ–¥–Ω–æ—Å—Ç–∏ –º–æ–∂–µ–º–æ –∫—Ä–µ–∏—Ä–∞—Ç–∏ —Å–∞:
#+begin_src rust
let four = IpAddrKind::V4;
let six = IpAddrKind::V6;
#+end_src

*** –ü—Ä–∏–º–µ—Ä - IP –∞–¥—Ä–µ—Å–∞ - —Ñ—É–Ω–∫—Ü–∏—ò–∞

–°–∞–¥–∞ –º–æ–∂–µ–º–æ –ø–∏—Å–∞—Ç–∏ —Ñ—É–Ω–∫—Ü–∏—ò—É –∫–æ—ò–∞ –ø—Ä–∏–º–∞ –æ–≤–∞—ò —Ç–∏–ø —á–∏–º–µ —ò–µ –º–æ–≥—É—õ–µ –ø—Ä–æ—Å–ª–µ–¥–∏—Ç–∏ –±–∏–ª–æ
–∫–æ—ò—É –≤–∞—Ä–∏—ò–∞–Ω—Ç—É –∫–∞–æ –∞—Ä–≥—É–º–µ–Ω—Ç.

#+begin_src rust
fn route(ip_kind: IpAddrKind) {}

...

route(IpAddrKind::V4);
route(IpAddrKind::V6);
#+end_src

*** –ü—Ä–∏–º–µ—Ä - IP –∞–¥—Ä–µ—Å–∞ - –≤—Ä–µ–¥–Ω–æ—Å—Ç

- –ê–ª–∏ –∫–∞–∫–æ –¥–∞ –¥–µ—Ñ–∏–Ω–∏—à–µ–º–æ –∫–æ–Ω–∫—Ä–µ—Ç–Ω—É –≤—Ä–µ–¥–Ω–æ—Å—Ç IP –∞–¥—Ä–µ—Å–µ?
- –ü—Ä–≤–∞ –∏–¥–µ—ò–∞ –±–∏ –º–æ–≥–ª–∞ –±–∏—Ç–∏ –¥–∞ –∫–æ—Ä–∏—Å—Ç–∏–º–æ —Å—Ç—Ä—É–∫—Ç—É—Ä—É.

#+begin_src rust
enum IpAddrKind {
    V4,
    V6,
}

struct IpAddr {
    kind: IpAddrKind,
    address: String,
}

let home = IpAddr {
    kind: IpAddrKind::V4,
    address: String::from("127.0.0.1"),
};

let loopback = IpAddr {
    kind: IpAddrKind::V6,
    address: String::from("::1"),
};
#+end_src

#+REVEAL: split

–ê–ª–∏, —Å–∞ =enum= —Ç–∏–ø–æ–º –º–æ–∂–µ–º–æ —Ç–æ —É—Ä–∞–¥–∏—Ç–∏ –∏ –±–æ—ô–µ. =Enum= –≤–∞—Ä–∏—ò–∞–Ω—Ç–µ –º–æ–≥—É —Å–∞–¥—Ä–∂–∞—Ç–∏
–¥–æ–¥–∞—Ç–Ω–µ –ø–æ–¥–∞—Ç–∫–µ.

#+begin_src rust
enum IpAddr {
    V4(String),
    V6(String),
}

let home = IpAddr::V4(String::from("127.0.0.1"));

let loopback = IpAddr::V6(String::from("::1"));
#+end_src

#+REVEAL: split
–í—Ä–µ–¥–Ω–æ—Å—Ç —Å–∞–¥—Ä–∂–∞–Ω–∞ —É –≤–∞—Ä–∏—ò–∞–Ω—Ç–∏ –Ω–µ –º–æ—Ä–∞ –±–∏—Ç–∏ –∏—Å—Ç–∞ –∑–∞ —Å–≤–µ –≤–∞—Ä–∏—ò–∞–Ω—Ç–µ. –ù–∞ –ø—Ä–∏–º–µ—Ä,
IPv4 —Å–µ —Å–∞—Å—Ç–æ—ò–∏ –æ–¥ 4 –æ–∫—Ç–µ—Ç–∞ –∏ –º–æ–∂–¥–∞ –∂–µ–ª–∏–º–æ –¥–∞ –≤—Ä–µ–¥–Ω–æ—Å—Ç –Ω–∞–≤–æ–¥–∏–º–æ –∏ —á—É–≤–∞–º–æ —É —Ç–æ–º
–æ–±–ª–∏–∫—É.

#+begin_src rust
enum IpAddr {
    V4(u8, u8, u8, u8),
    V6(String),
}

let home = IpAddr::V4(127, 0, 0, 1);

let loopback = IpAddr::V6(String::from("::1"));
#+end_src

*** –ü—Ä–∏–º–µ—Ä - IP –∞–¥—Ä–µ—Å–∞ - std –±–∏–±–ª–∏–æ—Ç–µ–∫–∞

–£ —Å—Ç–∞–Ω–¥–∞—Ä–¥–Ω–æ—ò –±–∏–±–ª–∏–æ—Ç–µ—Ü–∏ –º–æ–∂–µ–º–æ –ø—Ä–æ–Ω–∞—õ–∏ —Ç–∏–ø =IpAddr=. –î–µ—Ñ–∏–Ω–∏—Å–∞–Ω —ò–µ –Ω–∞ —Å–ª–µ–¥–µ—õ–∏
–Ω–∞—á–∏–Ω.

#+begin_src rust
struct Ipv4Addr {
    // --snip--
}

struct Ipv6Addr {
    // --snip--
}

enum IpAddr {
    V4(Ipv4Addr),
    V6(Ipv6Addr),
}
#+end_src

*** –ü—Ä–∏–º–µ—Ä  - /Message/

#+begin_src rust
enum Message {
    Quit,
    Move { x: i32, y: i32 },
    Write(String),
    ChangeColor(i32, i32, i32),
}
#+end_src

#+REVEAL: split
–°–ª–µ–¥–µ—õ–µ —Å—Ç—Ä—É–∫—Ç—É—Ä–µ —Å–∞–¥—Ä–∂–µ –∏—Å—Ç–µ –ø–æ–¥–∞—Ç–∫–µ –∫–∞–æ –ø—Ä–µ—Ç—Ö–æ–¥–Ω–∏ =enum= —Ç–∏–ø.

#+begin_src rust
struct QuitMessage; // unit struct
struct MoveMessage {
    x: i32,
    y: i32,
}
struct WriteMessage(String); // tuple struct
struct ChangeColorMessage(i32, i32, i32); // tuple struct
#+end_src

–ê–ª–∏, –ø—Ä–µ–¥–Ω–æ—Å—Ç =enum= —Ç–∏–ø–∞ —ò–µ —à—Ç–æ —ò–µ —Ç–æ —ò–µ–¥–∏–Ω—Å—Ç–≤–µ–Ω —Ç–∏–ø –ø–∞ –º–æ–∂–µ–º–æ –Ω–ø—Ä. –Ω–∞–ø—Ä–∞–≤–∏—Ç–∏
—Ñ—É–Ω–∫—Ü–∏—ò—É –∫–æ—ò–∞ –ø—Ä–∏–º–∞ –±–∏–ª–æ –∫–æ—ò—É –≤—Ä–µ–¥–Ω–æ—Å—Ç/–≤–∞—Ä–∏—ò–∞–Ω—Ç—É –æ–≤–æ–≥ —Ç–∏–ø–∞.

#+REVEAL: split
–ù–∞–¥ =enum= —Ç–∏–ø–æ–º, –∫–∞–æ –∏ –¥—Ä—É–≥–∏–º —Ç–∏–ø–æ–≤–∏–º–∞, –º–æ–∂–µ–º–æ –∏–º–ø–ª–µ–º–µ–Ω—Ç–∏—Ä–∞—Ç–∏ –º–µ—Ç–æ–¥–µ —É–ø–æ—Ç—Ä–µ–±–æ–º
=imlp= –∫—ô—É—á–Ω–µ —Ä–µ—á–∏.

#+begin_src rust
impl Message {
    fn call(&self) {
        // —Ç–µ–ª–æ –º–µ—Ç–æ–¥–µ —Å–µ –æ–≤–¥–µ –¥–µ—Ñ–∏–Ω–∏—à–µ
    }
}

let m = Message::Write(String::from("hello"));
m.call();
#+end_src
*** –ü—Ä–∏–º–µ—Ä - /WebEvent/
#+begin_src rust
enum WebEvent {
    // An `enum` variant may either be `unit-like`,
    PageLoad,
    PageUnload,
    // like tuple structs,
    KeyPress(char),
    Paste(String),
    // or c-like structures.
    Click { x: i64, y: i64 },
}

fn inspect(event: WebEvent) {
    match event {
        WebEvent::PageLoad => println!("page loaded"),
        WebEvent::PageUnload => println!("page unloaded"),
        // Destructure `c` from inside the `enum` variant.
        WebEvent::KeyPress(c) => println!("pressed '{}'.", c),
        WebEvent::Paste(s) => println!("pasted \"{}\".", s),
        // Destructure `Click` into `x` and `y`.
        WebEvent::Click { x, y } => {
            println!("clicked at x={}, y={}.", x, y);
        },
    }
}
#+end_src

#+REVEAL: split

#+begin_src rust
fn main() {
    let pressed = WebEvent::KeyPress('x');
    // `to_owned()` creates an owned `String` from a string slice.
    let pasted  = WebEvent::Paste("my text".to_owned());
    let click   = WebEvent::Click { x: 20, y: 80 };
    let load    = WebEvent::PageLoad;
    let unload  = WebEvent::PageUnload;

    inspect(pressed);
    inspect(pasted);
    inspect(click);
    inspect(load);
    inspect(unload);
}
#+end_src

#+RESULTS:
: pressed 'x'.
: pasted "my text".
: clicked at x=20, y=80.
: page loaded
: page unloaded

*** –£–ø–æ—Ç—Ä–µ–±–∞ =use= –∫—ô—É—á–Ω–µ —Ä–µ—á–∏
–í–∞—Ä–∏—ò–∞–Ω—Ç–µ –º–æ–∂–µ–º–æ –∏–º–ø–æ—Ä—Ç–æ–≤–∞—Ç–∏ —É —Ç–µ–∫—É—õ–∏ –æ–ø—Å–µ–≥ —Ç–∞–∫–æ –¥–∞ —Å–µ –º–æ–∂–µ –∏–∑–±–µ—õ–∏ –ø—É–Ω–∞
–∫–≤–∞–ª–∏—Ñ–∏–∫–∞—Ü–∏—ò–∞ –≤–∞—Ä–∏—ò–∞–Ω—Ç–∏ –µ–Ω—É–º–µ—Ä–∏—Å–∞–Ω–æ–≥ —Ç–∏–ø–∞.

#+begin_src rust
enum Status {
    Rich,
    Poor,
}

enum Work {
    Civilian,
    Soldier,
}
#+end_src

#+REVEAL: split

#+begin_src rust
fn main() {
    // Explicitly `use` each name so they are available without
    // manual scoping.
    use crate::Status::{Poor, Rich};
    // Automatically `use` each name inside `Work`.
    use crate::Work::*;

    // Equivalent to `Status::Poor`.
    let status = Poor;
    // Equivalent to `Work::Civilian`.
    let work = Civilian;

    match status {
        // Note the lack of scoping because of the explicit `use` above.
        Rich => println!("The rich have lots of money!"),
        Poor => println!("The poor have no money..."),
    }

    match work {
        // Note again the lack of scoping.
        Civilian => println!("Civilians work!"),
        Soldier  => println!("Soldiers fight!"),
    }
}
#+end_src

*** –¶-–æ–≤—Å–∫–∏ –µ–Ω—É–º–µ—Ä–∏—Å–∞–Ω–∏ —Ç–∏–ø
–ï–Ω—É–º–µ—Ä–∏—Å–∞–Ω–∏ —Ç–∏–ø —É –†–∞—Å—Ç—É —Å–µ –º–æ–∂–µ –∫–æ—Ä–∏—Å—Ç–∏—Ç–∏ –∫–∞–æ —É –¶-—É.

#+begin_src rust
// enum with implicit discriminator (starts at 0)
enum Number {
    Zero,
    One,
    Two,
}

// enum with explicit discriminator
enum Color {
    Red = 0xff0000,
    Green = 0x00ff00,
    Blue = 0x0000ff,
}

fn main() {
    // `enums` can be cast as integers.
    println!("zero is {}", Number::Zero as i32);
    println!("one is {}", Number::One as i32);

    println!("roses are #{:06x}", Color::Red as i32);
    println!("violets are #{:06x}", Color::Blue as i32);
}
#+end_src

#+RESULTS:
: zero is 0
: one is 1
: roses are #ff0000
: violets are #0000ff

*** –¢–µ—Å—Ç —Å–ª—É—á–∞—ò - –ø–æ–≤–µ–∑–∞–Ω–∞ –ª–∏—Å—Ç–∞

#+begin_src rust
use crate::List::*;
enum List {
    Cons(u32, Box<List>),
    Nil,
}
impl List {
    fn new() -> List {
        Nil
    }
    fn prepend(self, elem: u32) -> List {
        Cons(elem, Box::new(self))
    }
    fn len(&self) -> u32 {
        match *self {
            Cons(_, ref tail) => 1 + tail.len(),
            Nil => 0
        }
    }
    fn stringify(&self) -> String {
        match *self {
            Cons(head, ref tail) => {
                format!("{}, {}", head, tail.stringify())
            },
            Nil => {
                format!("Nil")
            },
        }
    }
}
#+end_src

#+REVEAL: split

#+begin_src rust
fn main() {
    // Create an empty linked list
    let mut list = List::new();
    // Prepend some elements
    list = list.prepend(1);
    list = list.prepend(2);
    list = list.prepend(3);

    // Show the final state of the list
    println!("linked list has length: {}", list.len());
    println!("{}", list.stringify());
}
#+end_src

#+RESULTS:
: linked list has length: 3
: 3, 2, 1, Nil

** =Option= –µ–Ω—É–º–µ—Ä–∞—Ü–∏—ò–∞
*** =Option= –µ–Ω—É–º–µ—Ä–∞—Ü–∏—ò–∞
- –ß–µ—Å—Ç —Å–ª—É—á–∞—ò –¥–∞ –≤—Ä–µ–¥–Ω–æ—Å—Ç –º–æ–∂–µ –±–∏—Ç–∏ –Ω–µ—à—Ç–æ –∏–ª–∏ –Ω–∏—à—Ç–∞.
- –ù–ø—Ä. –∞–∫–æ —Ñ—É–Ω–∫—Ü–∏—ò–∞ –≤—Ä–∞—õ–∞ –ø—Ä–≤–∏ –µ–ª–µ–º–µ–Ω—Ç –∏–∑ –ª–∏—Å—Ç–µ –∫–æ—ò–∞ –Ω–∏—ò–µ –ø—Ä–∞–∑–Ω–∞ –¥–æ–±–∏—õ–µ–º–æ –ø—Ä–≤–∏
  –µ–ª–µ–º–µ–Ω—Ç, –º–µ—í—É—Ç–∏–º –∞–∫–æ —ò–µ –ª–∏—Å—Ç–∞ –ø—Ä–∞–∑–Ω–∞ –ø–æ–≤—Ä–∞—Ç–Ω–∞ –≤—Ä–µ–¥–Ω–æ—Å—Ç —ò–µ –Ω–∏—à—Ç–∞.
- –û–≤–∞—ò –∫–æ–Ω—Ü–µ–ø—Ç —Å–µ —É —Ä–∞–∑–ª–∏—á–∏—Ç–∏–º —ò–µ–∑–∏—Ü–∏–º–∞ —Ä–∞–∑–ª–∏—á–∏—Ç–æ –∏–º–ø–ª–µ–º–µ–Ω—Ç–∏—Ä–∞. –ß–µ—Å—Ç–æ —Å–µ –∫–æ—Ä–∏—Å—Ç–∏
  —Å–ø–µ—Ü–∏—ò–∞–ª–Ω–∞ –≤—Ä–µ–¥–Ω–æ—Å—Ç =null= (–∏–ª–∏ =nil=, =none= –∏ —Å–ª.) –∏ —Å–≤–µ –≤–∞—Ä–∏—ò–∞–±–ª–µ –º–æ–≥—É –±–∏—Ç–∏ =null=
  –∏–ª–∏ =non-null=. –ü—Ä–æ–±–ª–µ–º —ò–µ —à—Ç–æ –ø—Ä–æ–≥—Ä–∞–º–µ—Ä –Ω–µ –¥–µ—Ñ–∏–Ω–∏—à–µ –º–æ–≥—É—õ–Ω–æ—Å—Ç –æ–≤–µ –≤—Ä–µ–¥–Ω–æ—Å—Ç–∏
  –∫—Ä–æ–∑ —Ç–∏–ø –ø–∞ —Å–∞–º–∏–º —Ç–∏–º –∫–æ–º–ø–∞—ò–ª–µ—Ä –Ω–µ–º–∞ –º–æ–≥—É—õ–Ω–æ—Å—Ç –¥–∞ –ø—Ä–æ–≤–µ—Ä–∏ –¥–∞ –ª–∏ –∫–æ–¥ –∏—Å–ø—Ä–∞–≤–Ω–æ
  –æ–±—Ä–∞—í—É—ò–µ –æ–≤—É –º–æ–≥—É—õ–Ω–æ—Å—Ç.

#+REVEAL: split

–£ –ø—Ä–µ–∑–µ–Ω—Ç–∞—Ü–∏—ò–∏ –∏–∑ 2009 –≥–æ–¥–∏–Ω–µ –ø–æ–¥ –Ω–∞–∑–∏–≤–æ–º /Null References: The Billion Dollar
Mistake/ Tony Hoare, –∫–æ—ò–∏ —ò–µ –ø—Ä–≤–∏ —É–≤–µ–æ =null= –≤—Ä–µ–¥–Ω–æ—Å—Ç –∫–∞–æ –∫–æ–Ω—Ü–µ–ø—Ç —ò–µ –Ω–∞–ø–∏—Å–∞–æ
—Å–ª–µ–¥–µ—õ–µ:

#+begin_quote
I call it my billion-dollar mistake. At that time, I was designing the first
comprehensive type system for references in an object-oriented language. My goal
was to ensure that all use of references should be absolutely safe, with
checking performed automatically by the compiler. But I couldn‚Äôt resist the
temptation to put in a null reference, simply because it was so easy to
implement. This has led to innumerable errors, vulnerabilities, and system
crashes, which have probably caused a billion dollars of pain and damage in the
last forty years.
#+end_quote

#+REVEAL: split

=Option= —ò–µ –≥–µ–Ω–µ—Ä–∏—á–∫–∏ =enum= —Ç–∏–ø —É –†–∞—Å—Ç—É.
#+begin_src rust
enum Option<T> {
    None,
    Some(T),
}
#+end_src

–ü—Ä–∏–º–µ—Ä–∏ —É–ø–æ—Ç—Ä–µ–±–µ:
#+begin_src rust
let some_number = Some(5);           // —Ç–∏–ø —ò–µ Option<i32>
let some_string = Some("a string");  // —Ç–∏–ø —ò–µ Option<&str>

let absent_number: Option<i32> = None;    // –Ω–µ–º–æ–≥—É—õ–∞ –∏–Ω—Ñ–µ—Ä–µ–Ω—Ü–∞
#+end_src

*** –ó–∞—à—Ç–æ —ò–µ =Option<T>= –±–æ—ô–∏ –æ–¥ =null=?
#+begin_src rust
let x: i8 = 5;
let y: Option<i8> = Some(5);

let sum = x + y;
#+end_src

#+begin_example
$ cargo run
   Compiling enums v0.1.0 (file:///projects/enums)
error[E0277]: cannot add `Option<i8>` to `i8`
 --> src/main.rs:5:17
  |
5 |     let sum = x + y;
  |                 ^ no implementation for `i8 + Option<i8>`
  |
  = help: the trait `Add<Option<i8>>` is not implemented for `i8`

For more information about this error, try `rustc --explain E0277`.
error: could not compile `enums` due to previous error
#+end_example

*** –ö–∞–∫–æ –æ–±—Ä–∞—í–∏–≤–∞—Ç–∏ =Option<T>= –ø–æ–¥–∞—Ç–∫–µ?
- –ú–æ—Ä–∞–º–æ –µ–∫—Å–ø–ª–∏—Ü–∏—Ç–Ω–æ –æ–±—Ä–∞–¥–∏—Ç–∏ –≤—Ä–µ–¥–Ω–æ—Å—Ç =Option<T>= –∏ –º–æ–≥—É—õ–Ω–æ—Å—Ç –¥–∞ –≤—Ä–µ–¥–Ω–æ—Å—Ç –±—É–¥–µ
  =None=.
- =Option<T>= —Ç–∏–ø –∏–º–∞ [[https://doc.rust-lang.org/stable/std/option/enum.Option.html][–±–æ–≥–∞—Ç API]] –∫–æ—ò–∏ —ò–µ –ø–æ—Ç—Ä–µ–±–Ω–æ –∑–Ω–∞—Ç–∏ —ò–µ—Ä —ò–µ –æ–≤–∞—ò —Ç–∏–ø –≤—Ä–ª–æ —á–µ—Å—Ç–æ
  —É —É–ø–æ—Ç—Ä–µ–±–∏.

#+begin_src rust
let x = Some(2);
let y = None;
assert_eq!(x.or(y), Some(2));

let x = None;
let y = Some(100);
assert_eq!(x.or(y), Some(100));
#+end_src

- –ß–µ—Å—Ç–æ –∫–æ—Ä–∏—Å—Ç–∏–º–æ —ò–µ–∑–∏—á–∫–µ –∫–æ–Ω—Å—Ç—Ä—É–∫—Ü–∏—ò–µ –∫–æ—ò–µ –æ–º–æ–≥—É—õ–∞–≤–∞—ò—É –æ–±—Ä–∞–¥—É –æ–±–µ –≤–∞—Ä–∏—ò–∞–Ω—Ç–µ.

* –°–ª–æ–∂–µ–Ω–∞ –∫–æ–Ω—Ç—Ä–æ–ª–∞ —Ç–æ–∫–∞ –∏ –ø–æ–¥—É–¥–∞—Ä–∞—ö–µ –æ–±—Ä–∞–∑–∞—Ü–∞ (/Pattern Matching/)
** =match= –∏–∑—Ä–∞–∑
- –ú–æ—õ–∞–Ω –∏–∑—Ä–∞–∑ –∫–æ–Ω—Ç—Ä–æ–ª–µ —Ç–æ–∫–∞ –±–∞–∑–∏—Ä–∞–Ω –Ω–∞ –ø–æ–¥—É–¥–∞—Ä–∞—ö—É –æ–±—Ä–∞–∑–∞—Ü–∞ (/Pattern Matching/).
- –û–±—Ä–∞–∑–∞—Ü –º–æ–∂–µ –±–∏—Ç–∏ –ª–∏—Ç–µ—Ä–∞–ª, –Ω–∞–∑–∏–≤ –≤–∞—Ä–∏—ò–∞–±–ª–µ, —ü–æ–∫–µ—Ä (/wildcards/) –∏—Ç–¥.
- =match= –∏–∑—Ä–∞–∑ —õ–µ –∏–∑–≤—Ä—à–∏—Ç–∏ –ø–æ–¥—É–¥–∞—Ä–∞—ö–µ —É–∑ –∏—Å—Ü—Ä–ø—ô–∏–≤–∞—ö–µ —Å–≤–∏—Ö –º–æ–≥—É—õ–Ω–æ—Å—Ç. –£–∫–æ–ª–∏–∫–æ
  –Ω–µ–∫–∞ –º–æ–≥—É—õ–Ω–æ—Å—Ç –Ω–∏—ò–µ –æ–±—Ä–∞—í–µ–Ω–∞ –∫–æ–º–ø–∞—ò–ª–µ—Ä —õ–µ –ø—Ä–∏—ò–∞–≤–∏—Ç–∏ –≥—Ä–µ—à–∫—É.

** =match= –∫–∞–æ –º–∞—à–∏–Ω–∞ –∑–∞ —Å–æ—Ä—Ç–∏—Ä–∞—ö–µ –Ω–æ–≤—á–∏—õ–∞
–ó–∞ –ø–æ—á–µ—Ç–∞–∫ –º–æ–∂–µ–º–æ =match= –∏–∑—Ä–∞–∑ –ø–æ—Å–º–∞—Ç—Ä–∞—Ç–∏ –∫–∞–æ –∞—É—Ç–æ–º–∞—Ç –∑–∞ —Å–æ—Ä—Ç–∏—Ä–∞—ö–µ –Ω–æ–≤—á–∏—õ–∞.

#+begin_src rust
enum Coin {
    Penny,
    Nickel,
    Dime,
    Quarter,
}

fn value_in_cents(coin: Coin) -> u8 {
    match coin {
        Coin::Penny => 1,
        Coin::Nickel => 5,
        Coin::Dime => 10,
        Coin::Quarter => 25,
    }
}
#+end_src

- =match= –ø–æ—á–∏—ö–µ —Å–∞ –∏–∑—Ä–∞–∑–æ–º –ø—Ä–æ–∏–∑–≤–æ—ô–Ω–æ–≥ —Ç–∏–ø–∞.
- –£ —Ç–µ–ª—É —Å–µ –Ω–∞–ª–∞–∑–µ "—Ä—É–∫–µ" (/arms/) –≥–¥–µ —Å–≤–∞–∫–∞ —Ä—É–∫–∞ –∏–º–∞ –ª–µ–≤—É —Å—Ç—Ä–∞–Ω—É –∫–æ—ò–∞ –ø—Ä–µ–¥—Å—Ç–∞–≤—ô–∞
  –æ–±—Ä–∞–∑–∞—Ü –∑–∞ –ø–æ–¥—É–¥–∞—Ä–∞—ö–µ –∏ –¥–µ—Å–Ω—É —Å—Ç—Ä–∞–Ω—É (–ø–æ—Å–ª–µ ~=>~) –∫–æ—ò–∞ –ø—Ä–µ–¥—Å—Ç–∞–≤—ô–∞ –∫–æ–¥ –∫–æ—ò–∏ —Å–µ
  –µ–≤–∞–ª—É–∏—Ä–∞ —É —Å–ª—É—á–∞—ò—É –ø–æ–¥—É–¥–∞—Ä–∞—ö–∞. –†—É–∫–µ —Å—É —Ä–∞–∑–¥–≤–æ—ò–µ–Ω–µ –∑–∞—Ä–µ–∑–∏–º–∞.

#+REVEAL: split

- –†—É–∫–µ —Å–µ –ø–æ–¥—É–¥–∞—Ä–∞—ò—É —É —Ä–µ–¥–æ—Å–ª–µ–¥—É –Ω–∞–≤–æ—í–µ—ö–∞.
- –ü–æ–≤—Ä–∞—Ç–Ω–∞ –≤—Ä–µ–¥–Ω–æ—Å—Ç —Ü–µ–ª–æ–≥ =match= –∏–∑—Ä–∞–∑–∞ –±–∏—õ–µ –≤—Ä–µ–¥–Ω–æ—Å—Ç –µ–≤–∞–ª—É–∏—Ä–∞–Ω–æ–≥ –∫–æ–¥–∞ —Ä—É–∫–µ —á–∏—ò–µ
  —ò–µ –ø–æ–¥—É–¥–∞—Ä–∞—ö–µ —É—Å–ø–µ–ª–æ

#+REVEAL: split

–ú–æ–∂–µ–º–æ –Ω–∞ –¥–µ—Å–Ω–æ—ò —Å—Ç—Ä–∞–Ω–∏ –∫–æ—Ä–∏—Å—Ç–∏—Ç–∏ –ø—Ä–æ–∏–∑–≤–æ—ô–∞–Ω –∏–∑—Ä–∞–∑ –ø–∞ –∏ –±–ª–æ–∫ –∫–æ–¥–∞.
#+begin_src rust
fn value_in_cents(coin: Coin) -> u8 {
    match coin {
        Coin::Penny => {
            println!("Lucky penny!");
            1
        }
        Coin::Nickel => 5,
        Coin::Dime => 10,
        Coin::Quarter => 25,
    }
}
#+end_src

** –ü–æ–≤–µ–∑–∏–≤–∞—ö–µ –∏–º–µ–Ω–∞ –ø—Ä–∏ –ø–æ–¥—É–¥–∞—Ä–∞—ö—É (/binding/)
#+begin_src rust
#[derive(Debug)]
enum UsState {
    Alabama,
    Alaska,
    Arizona,
    // --snip--
}

enum Coin {
    Penny,
    Nickel,
    Dime,
    Quarter(UsState),
}

fn value_in_cents(coin: Coin) -> u8 {
    match coin {
        Coin::Penny => 1,
        Coin::Nickel => 5,
        Coin::Dime => 10,
        Coin::Quarter(state) => {
            println!("State quarter from {:?}!", state);
            25
        }
    }
}
#+end_src

** =match= —ò–µ –∏—Å—Ü—Ä–ø–∞–Ω
#+begin_src rust
fn value_in_cents(coin: Coin) -> u8 {
    match coin {
        Coin::Penny => 1,
        Coin::Nickel => 5,
        Coin::Dime => 10,
        Coin::Quarter(UsState::Alabama) | Coin::Quarter(UsState::Alaska) => 25
    }
}
#+end_src

#+begin_example
$ cargo run
   Compiling match_test v0.1.0 (/home/igor/NTP/match_test)
error[E0004]: non-exhaustive patterns: `Quarter(Arizona)` not covered
  --> src/main.rs:21:11
   |
13 | / enum Coin {
14 | |     Penny,
15 | |     Nickel,
16 | |     Dime,
17 | |     Quarter(UsState),
   | |     ------- not covered
18 | | }
   | |_- `Coin` defined here
...
21 |       match coin {
   |             ^^^^ pattern `Quarter(Arizona)` not covered
   |
   = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms
   = note: the matched value is of type `Coin`
#+end_example

** –ü–æ–¥—É–¥–∞—Ä–∞—ö–µ —Å–∞ =Option<T>= —Ç–∏–ø–æ–º
#+begin_src rust
fn plus_one(x: Option<i32>) -> Option<i32> {
    match x {
        None => None,
        Some(i) => Some(i + 1),
    }
}

let five = Some(5);
let six = plus_one(five);
let none = plus_one(None);
#+end_src

#+REVEAL: split

–ü–æ—à—Ç–æ —ò–µ =match= –∏—Å—Ü—Ä–ø–∞–Ω –Ω–µ –º–æ–∂–µ–º–æ –∑–∞–±–æ—Ä–∞–≤–∏—Ç–∏ –¥–∞ –æ–±—Ä–∞–¥–∏–º–æ =None= —Å–ª—É—á–∞—ò.

#+begin_src rust
fn plus_one(x: Option<i32>) -> Option<i32> {
    match x {
        Some(i) => Some(i + 1),
    }
}
#+end_src

#+begin_example
$ cargo run
   Compiling enums v0.1.0 (file:///projects/enums)
error[E0004]: non-exhaustive patterns: `None` not covered
   --> src/main.rs:3:15
    |
3   |         match x {
    |               ^ pattern `None` not covered
    |
    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms
    = note: the matched value is of type `Option<i32>`

For more information about this error, try `rustc --explain E0004`.
error: could not compile `enums` due to previous error
#+end_example

** –ü–æ–¥—Ä–∞–∑—É–º–µ–≤–∞–Ω–∞ –æ–±—Ä–∞–¥–∞ –ø—Ä–µ–æ—Å—Ç–∞–ª–∏—Ö —Å–ª—É—á–∞—ò–µ–≤–∞
- –ñ–µ–ª–∏–º–æ –Ω–∞ —Å–ø–µ—Ü–∏—Ñ–∏—á–∞–Ω –Ω–∞—á–∏–Ω –æ–±—Ä–∞–¥–∏–º–æ —Å–∞–º–æ –Ω–µ–∫–æ–ª–∏–∫–æ —Å–ª—É—á–∞—ò–µ–≤–∞ –¥–æ–∫ –∑–∞ —Å–≤–µ –æ—Å—Ç–∞–ª–µ
  —Ä–∞–¥–∏–º–æ –ø–æ–¥—Ä–∞–∑—É–º–µ–≤–∞–Ω—É –æ–±—Ä–∞–¥—É.

#+begin_src rust
let dice_roll = 9;
match dice_roll {
    3 => add_fancy_hat(),
    7 => remove_fancy_hat(),
    other => move_player(other),
}

fn add_fancy_hat() {}
fn remove_fancy_hat() {}
fn move_player(num_spaces: u8) {}
#+end_src

- –†–∞—Å—Ç —õ–µ –Ω–∞—Å —É–ø–æ–∑–æ—Ä–∏—Ç–∏ –∞–∫–æ –¥–æ–¥–∞–º–æ —Ä—É–∫—É –ø–æ—Å–ª–µ –æ–Ω–µ –∫–æ—ò–∞ –æ–±—Ä–∞—í—É—ò–µ —Å–≤–µ —Å–ª—É—á–∞—ò–µ–≤–µ
  —ò–µ—Ä —Ç–∞ —Å–µ —Ä—É–∫–∞ –Ω–∏–∫–∞–¥–∞ –Ω–µ—õ–µ —É–ø–æ—Ç—Ä–µ–±–∏—Ç–∏.

#+REVEAL: split

–ê–∫–æ –∂–µ–ª–∏–º–æ –¥–∞ –æ–±—Ä–∞–¥–∏–º–æ —Å–≤–µ —Å–ª—É—á–∞—ò–µ–≤–µ –∞–ª–∏ –Ω–∞—Å –≤—Ä–µ–¥–Ω–æ—Å—Ç –Ω–µ –∏–Ω—Ç–µ—Ä–µ—Å—É—ò–µ –º–æ–∂–µ–º–æ
–∫–æ—Ä–∏—Å—Ç–∏—Ç–∏ =_=.

#+begin_src rust
let dice_roll = 9;
match dice_roll {
    3 => add_fancy_hat(),
    7 => remove_fancy_hat(),
    _ => reroll(),
}

fn add_fancy_hat() {}
fn remove_fancy_hat() {}
fn reroll() {}
#+end_src
** –†–∞—Å–ø–∞–∫–∏–≤–∞—ö–µ (/Destructuring/)
*** –†–∞—Å–ø–∞–∫–∏–≤–∞—ö–µ —Ç–æ—Ä–∫–∏
#+begin_src rust
fn main() {
    let triple = (0, -2, 3);
    // TODO ^ Try different values for `triple`

    println!("Tell me about {:?}", triple);
    // Match can be used to destructure a tuple
    match triple {
        // Destructure the second and third elements
        (0, y, z) => println!("First is `0`, `y` is {:?}, and `z` is {:?}", y, z),
        (1, ..)  => println!("First is `1` and the rest doesn't matter"),
        (.., 2)  => println!("last is `2` and the rest doesn't matter"),
        (3, .., 4)  => println!("First is `3`, last is `4`, and the rest doesn't matter"),
        // `..` can be used to ignore the rest of the tuple
        _      => println!("It doesn't matter what they are"),
        // `_` means don't bind the value to a variable
    }
}
#+end_src

*** –†–∞—Å–ø–∞–∫–∏–≤–∞—ö–µ –∏—Å–µ—á–∞–∫–∞
#+begin_src rust
fn main() {
    let array = [4, -2, 6];

    match array {
        [0, second, third] =>
            println!("array[0] = 0, array[1] = {}, array[2] = {}", second, third),
        [1, _, third] => println!(
            "array[0] = 1, array[2] = {} and array[1] was ignored",
            third
        ),
        [-1, second, ..] => println!(
            "array[0] = -1, array[1] = {} and all the other ones were ignored",
            second
        ),
        [3, second, tail @ ..] => println!(
            "array[0] = 3, array[1] = {} and the other elements were {:?}",
            second, tail
        ),
        [first, middle @ .., last] => println!(
            "array[0] = {}, middle = {:?}, array[2] = {}",
            first, middle, last
        ),
    }
}
#+end_src

#+RESULTS:
: array[0] = 4, middle = [-2], array[2] = 6

*** –†–∞—Å–ø–∞–∫–∏–≤–∞—ö–µ –µ–Ω—É–º–µ—Ä–∞—Ü–∏—ò–∞
#+begin_src rust
#[allow(dead_code)]
enum Color {
    Red,
    Blue,
    Green,
    RGB(u32, u32, u32),
    HSV(u32, u32, u32),
    HSL(u32, u32, u32),
    CMY(u32, u32, u32),
    CMYK(u32, u32, u32, u32),
}
fn main() {
    let color = Color::RGB(122, 17, 40);
    println!("What color is it?");
    match color {
        Color::Red   => println!("The color is Red!"),
        Color::Blue  => println!("The color is Blue!"),
        Color::Green => println!("The color is Green!"),
        Color::RGB(r, g, b) =>
            println!("Red: {}, green: {}, and blue: {}!", r, g, b),
        Color::HSV(h, s, v) =>
            println!("Hue: {}, saturation: {}, value: {}!", h, s, v),
        Color::HSL(h, s, l) =>
            println!("Hue: {}, saturation: {}, lightness: {}!", h, s, l),
        Color::CMY(c, m, y) =>
            println!("Cyan: {}, magenta: {}, yellow: {}!", c, m, y),
        Color::CMYK(c, m, y, k) =>
            println!("Cyan: {}, magenta: {}, yellow: {}, key (black): {}!", c, m, y, k),
    }
}
#+end_src

*** –†–∞—Å–ø–∞–∫–∏–≤–∞—ö–µ —Ä–µ—Ñ–µ—Ä–µ–Ω—Ü–∏
#+begin_src rust
fn main() {
    let reference = &4;

    match reference {
        &val => println!("Got a value via destructuring: {:?}", val),
    }
    match *reference {
        val => println!("Got a value via dereferencing: {:?}", val),
    }
    let _not_a_reference = 3;

    let ref _is_a_reference = 3;

    let value = 5;
    let mut mut_value = 6;
    match value {
        ref r => println!("Got a reference to a value: {:?}", r),
    }
    match mut_value {
        ref mut m => {
            ,*m += 10;
            println!("We added 10. `mut_value`: {:?}", m);
        },
    }
}
#+end_src

#+RESULTS:
: Got a value via destructuring: 4
: Got a value via dereferencing: 4
: Got a reference to a value: 5
: We added 10. `mut_value`: 16

*** –†–∞—Å–ø–∞–∫–∏–≤–∞—ö–µ —Å—Ç—Ä—É–∫—Ç—É—Ä–∞
#+begin_src rust
fn main() {
    struct Foo {
        x: (u32, u32),
        y: u32,
    }

    let foo = Foo { x: (1, 2), y: 3 };
    match foo {
        Foo { x: (1, b), y } => println!("First of x is 1, b = {},  y = {} ", b, y),

        // you can destructure structs and rename the variables,
        // the order is not important
        Foo { y: 2, x: i } => println!("y is 2, i = {:?}", i),

        // and you can also ignore some variables:
        Foo { y, .. } => println!("y = {}, we don't care about x", y),
        // this will give an error: pattern does not mention field `x`
        //Foo { y } => println!("y = {}", y),
    }
}
#+end_src

** =if let= kontrola toka
=if let= –Ω–∞–º –æ–º–æ–≥—É—õ–∞–≤–∞ –∫–æ–º–±–∏–Ω–∞—Ü–∏—ò—É =if= –∏ =let= –∏—Å–∫–∞–∑–∞ —É –º–∞—ö–µ –æ–ø—à–∏—Ä–∞–Ω –∏—Å–∫–∞–∑ –∑–∞ –æ–±—Ä–∞–¥—É
—Å–∞–º–æ —ò–µ–¥–Ω–æ–≥ —Å–ª—É—á–∞—ò–∞ –ø–æ–∫–ª–∞–ø–∞—ö–∞ –∏ –∏–≥–Ω–æ—Ä–∏—Å–∞—ö–µ –æ—Å—Ç–∞–ª–∏—Ö.

#+begin_src rust
let config_max = Some(3u8);
match config_max {
    Some(max) => println!("The maximum is configured to be {}", max),
    _ => (),
}
#+end_src

–û–≤–æ –º–æ–∂–µ–º–æ –∫–æ–Ω—Ü–∏–∑–Ω–∏—ò–µ –∏—Å–∫–∞–∑–∞—Ç–∏ —Å–∞:

#+begin_src rust
let config_max = Some(3u8);
if let Some(max) = config_max {
    println!("The maximum is configured to be {}", max);
}
#+end_src

- –ì—É–±–∏–º–æ –∏—Å—Ü—Ä–ø–Ω–æ—Å—Ç =match= –∏–∑—Ä–∞–∑–∞.
- –°–∏–Ω—Ç–∞–∫—Å–Ω–∏ —à–µ—õ–µ—Ä —É —Å–∏—Ç—É–∞—Ü–∏—ò–∞–º–∞ –∫–∞–¥–∞ –∂–µ–ª–∏–º–æ –¥–∞ –∏–≥–Ω–æ—Ä–∏—à–µ–º–æ –æ—Å—Ç–∞–ª–µ –º–æ–≥—É—õ–Ω–æ—Å—Ç–∏.

#+REVEAL: split

** –ü–æ–Ω–∏—à—Ç–∏–≤–∏ –∏ –Ω–µ–ø–æ–Ω–∏—à—Ç–∏–≤–∏ –æ–±—Ä–∞—Å—Ü–∏
#+begin_note
–û–±—Ä–∞—Å—Ü–∏ –∑–∞ –ø–æ–¥—É–¥–∞—Ä–∞—ö–µ [[https://doc.rust-lang.org/book/ch18-02-refutability.html][–º–æ–≥—É –∏–º–∞—Ç–∏ –¥–≤–µ —Ñ–æ—Ä–º–µ]]: –ø–æ–Ω–∏—à—Ç–∏–≤ (/refutable/) –∏ –Ω–µ–ø–æ–Ω–∏—à—Ç–∏–≤
(/irrefutable/). –û–±—Ä–∞–∑–∞—Ü –∫–æ—ò–∏ —É–≤–µ–∫ –º–æ—Ä–∞ —É—Å–ø–µ—Ç–∏ (–Ω–ø—Ä. =let x = 5;=) —ò–µ –Ω–µ–ø–æ–Ω–∏—à—Ç–∏–≤.
–û–±—Ä–∞–∑–∞—Ü –∫–æ—ò–∏ –Ω–µ –º–æ—Ä–∞ –¥–∞ —É—Å–ø–µ —É–≤–µ–∫ —ò–µ –ø–æ–Ω–∏—à—Ç–∏–≤ (–Ω–ø—Ä. =if let Some(x) = a_value=
–Ω–µ—õ–µ —É—Å–ø–µ—Ç–∏ –∑–∞ ~a_value==None~).

–ü–∞—Ä–∞–º–µ—Ç—Ä–∏ —Ñ—É–Ω–∫—Ü–∏—ò–∞, =let= –∏—Å–∫–∞–∑–∏ –∏ =for= –ø–µ—Ç—ô–µ –ø—Ä–∏—Ö–≤–∞—Ç–∞—ò—É —Å–∞–º–æ –Ω–µ–ø–æ–Ω–∏—à—Ç–∏–≤–µ –æ–±—Ä–∞—Å—Ü–µ
—ò–µ—Ä –ø—Ä–æ–≥—Ä–∞–º –Ω–µ –º–æ–∂–µ —É—Ä–∞–¥–∏—Ç–∏ –Ω–∏—à—Ç–∞ —Å–º–∏—Å–ª–µ–Ω–æ —É–∫–æ–ª–∏–∫–æ –ø–æ–¥—É–¥–∞—Ä–∞—ö–µ –Ω–µ —É—Å–ø–µ.

=if let= –∏ =while let= –ø—Ä–∏—Ö–≤–∞—Ç–∞—ò—É –∏ –ø–æ–Ω–∏—à—Ç–∏–≤–µ –∏ –Ω–µ–ø–æ–Ω–∏—à—Ç–∏–≤–µ –æ–±—Ä–∞—Å—Ü–µ –∞–ª–∏ —õ–µ –Ω–∞—Å
–∫–æ–º–ø–∞—ò–ª–µ—Ä —É–ø–æ–∑–æ—Ä–∏—Ç–∏ —É–∫–æ–ª–∏–∫–æ –∫–æ—Ä–∏—Å—Ç–∏–º–æ –Ω–µ–ø–æ–Ω–∏—à—Ç–∏–≤–µ.
#+end_note

#+REVEAL: split

–ú–æ–∂–µ–º–æ –∫–æ—Ä–∏—Å—Ç–∏—Ç–∏ –∏ =else= –≥—Ä–∞–Ω—É. –°–ª–µ–¥–µ—õ–µ —ò–µ –µ–∫–≤–∏–≤–∞–ª–µ–Ω—Ç–Ω–æ.

#+begin_src rust
let mut count = 0;
match coin {
    Coin::Quarter(state) => println!("State quarter from {:?}!", state),
    _ => count += 1,
}
#+end_src

#+begin_src rust
let mut count = 0;
if let Coin::Quarter(state) = coin {
    println!("State quarter from {:?}!", state);
} else {
    count += 1;
}
#+end_src

** =let else=
–û–º–æ–≥—É—õ–∞–≤–∞ —É–ø–æ—Ç—Ä–µ–±—É –ø–æ–Ω–∏—à—Ç–∏–≤–∏—Ö –æ–±—Ä–∞–∑–∞—Ü–∞ —É –∏—Å–∫–∞–∑–∏–º–∞ –¥–æ–¥–µ–ª–µ. –£–∫–æ–ª–∏–∫–æ –¥–æ–¥–µ–ª–∞ –Ω–µ
—É—Å–ø–µ–≤–∞ –º–æ–∂–µ–º–æ –¥–∏–≤–µ—Ä–≥–∏—Ä–∞—Ç–∏ —Å–∞ =else= –≥—Ä–∞–Ω–æ–º (–Ω–ø—Ä. =break=, =return=, =panic!=).

#+begin_src rust
use std::str::FromStr;

fn get_count_item(s: &str) -> (u64, &str) {
    let mut it = s.split(' ');
    let (Some(count_str), Some(item)) = (it.next(), it.next()) else {
        panic!("Can't segment count item pair: '{s}'");
    };
    let Ok(count) = u64::from_str(count_str) else {
        panic!("Can't parse integer: '{count_str}'");
    };
    (count, item)
}

assert_eq!(get_count_item("3 chairs"), (3, "chairs"));
#+end_src

** =while let=
–°–ª–∏—á–Ω–æ –∫–∞–æ =if let= –∏ =while let= —á–∏–Ω–∏ –æ–¥—Ä–µ—í–µ–Ω–µ –∫–æ–Ω—Å—Ç—Ä—É–∫—Ü–∏—ò–µ —Å–∞ –ø–æ–¥—É–¥–∞—Ä–∞—ö–µ–º –æ–±—Ä–∞–∑–∞—Ü–∞
—ò–µ–∑–≥—Ä–æ–≤–∏—Ç–∏—ò–µ.

–ù–∞ –ø—Ä–∏–º–µ—Ä, –∞–∫–æ –∏–º–∞–º–æ –Ω–µ—à—Ç–æ –ø–æ–ø—É—Ç:
#+begin_src rust
// Make `optional` of type `Option<i32>`
let mut optional = Some(0);

// Repeatedly try this test.
loop {
    match optional {
        // If `optional` destructures, evaluate the block.
        Some(i) => {
            if i > 9 {
                println!("Greater than 9, quit!");
                optional = None;
            } else {
                println!("`i` is `{:?}`. Try again.", i);
                optional = Some(i + 1);
            }
        },
        // Quit the loop when the destructure fails:
        _ => { break; }
    }
}
#+end_src

#+REVEAL: split

–¢–æ –º–æ–∂–µ–º–æ –Ω–∞–ø–∏—Å–∞—Ç–∏ –∫–∞–æ:
#+begin_src rust
fn main() {
    // Make `optional` of type `Option<i32>`
    let mut optional = Some(0);

    // This reads: "while `let` destructures `optional` into
    // `Some(i)`, evaluate the block (`{}`). Else `break`.
    while let Some(i) = optional {
        if i > 9 {
            println!("Greater than 9, quit!");
            optional = None;
        } else {
            println!("`i` is `{:?}`. Try again.", i);
            optional = Some(i + 1);
        }
    }
}
#+end_src

* –ö–æ–ª–µ–∫—Ü–∏—ò–µ
** –í–µ–∫—Ç–æ—Ä (=Vec<T>=)
*** –®—Ç–∞ —ò–µ –≤–µ–∫—Ç–æ—Ä?
- –õ–∏–Ω–µ–∞—Ä–Ω–∞ —Å—Ç—Ä—É–∫—Ç—É—Ä–∞ –∫–æ—ò–∞ –æ–º–æ–≥—É—õ–∞–≤–∞ —Å–º–µ—à—Ç–∞—ö–µ –ø–æ–¥–∞—Ç–∞–∫–∞ —É —Å—É—Å–µ–¥–Ω–µ –ª–æ–∫–∞—Ü–∏—ò–µ —É –º–µ–º–æ—Ä–∏—ò–∏.
- –•–æ–º–æ–≥–µ–Ω–∞ —Å—Ç—Ä—É–∫—Ç—É—Ä–∞. –ï–ª–µ–º–µ–Ω—Ç–∏ –º–æ—Ä–∞—ò—É –±–∏—Ç–∏ –∏—Å—Ç–æ–≥ —Ç–∏–ø–∞.

*** –ö—Ä–µ–∏—Ä–∞—ö–µ –Ω–æ–≤–æ–≥ –≤–µ–∫—Ç–æ—Ä–∞
#+begin_src rust
let v: Vec<i32> = Vec::new();
#+end_src

- –ú–æ—Ä–∞–ª–∏ —Å–º–æ –¥–æ–¥–∞—Ç–∏ –∞–Ω–æ—Ç–∞—Ü–∏—ò—É —Ç–∏–ø–∞ —ò–µ—Ä —ò–µ –≤–µ–∫—Ç–æ—Ä –≥–µ–Ω–µ—Ä–∏—á–∫–∏ —Ç–∏–ø –∏ –∫–æ–º–ø–∞—ò–ª–µ—Ä –Ω–µ
  –∑–Ω–∞ —Ç–∏–ø –µ–ª–µ–º–µ–Ω—Ç–∞ –∫–æ—ò–µ —õ–µ–º–æ —Å–º–µ—à—Ç–∞—Ç–∏ —É –≤–µ–∫—Ç–æ—Ä.

- –ê–∫–æ –∫—Ä–µ–∏—Ä–∞–º–æ –≤–µ–∫—Ç–æ—Ä —Å–∞ –≤–µ—õ –ø–æ—Å—Ç–æ—ò–µ—õ–∏–º –µ–ª–µ–º–µ–Ω—Ç–∏–º–∞ —á–µ—à—õ–µ –∫–æ—Ä–∏—Å—Ç–∏–º–æ =vec!= –º–∞–∫—Ä–æ:

  #+begin_src rust
    let v = vec![1, 2, 3];
  #+end_src
*** –ê–∂—É—Ä–∏—Ä–∞—ö–µ –≤–µ–∫—Ç–æ—Ä–∞
#+begin_src rust
let mut v = Vec::new();
v.push(5);
v.push(6);
v.push(7);
v.push(8);
#+end_src

*** –ß–∏—Ç–∞—ö–µ –µ–ª–µ–º–µ–Ω–∞—Ç–∞ –≤–µ–∫—Ç–æ—Ä–∞
- –ò–Ω–¥–µ–∫—Å–Ω–∏ –ø—Ä–∏—Å—Ç—É–ø –∏–ª–∏ —É–ø–æ—Ç—Ä–µ–±–∞ =get= –º–µ—Ç–æ–¥–µ.

#+begin_src rust
let v = vec![1, 2, 3, 4, 5];

let third: &i32 = &v[2];
println!("The third element is {third}");

let third: Option<&i32> = v.get(2);
match third {
    Some(third) => println!("The third element is {third}"),
    None => println!("There is no third element."),
}
#+end_src

- –ò–Ω–¥–µ–∫—Å–Ω–∏ –ø—Ä–∏—Å—Ç—É–ø –º–æ–∂–µ –¥–∞ –¥–æ–≤–µ–¥–µ –¥–æ –ø—Ä–µ–∫–∏–¥–∞ –ø—Ä–æ–≥—Ä–∞–º–∞ —É–∫–æ–ª–∏–∫–æ –∏–Ω–¥–µ–∫—Å–∏—Ä–∞–º–æ –≤–∞–Ω
  –æ–ø—Å–µ–≥–∞ –≤–∞–ª–∏–¥–Ω–∏—Ö –∏–Ω–¥–µ–∫—Å–∞.
- =get= –º–µ—Ç–æ–¥–∞ —É–≤–µ–∫ —É—Å–ø–µ–≤–∞ –∏ –≤—Ä–∞—õ–∞ =Option<&T>=.

#+REVEAL: split

#+begin_src rust
let v = vec![1, 2, 3, 4, 5];

let does_not_exist = &v[100];
let does_not_exist = v.get(100);
#+end_src

- –ü—Ä–≤–∏ –∏–Ω–¥–µ–∫—Å–Ω–∏ –ø—Ä–∏—Å—Ç—É–ø —õ–µ –∏–∑–∞–∑–≤–∞—Ç–∏ –ø–∞–Ω–∏–∫—É.
- –ü—Ä–∏—Å—Ç—É–ø —Å–∞ =get= –±–∏ –≤—Ä–∞—Ç–∏–æ =None=.

*** –ü—Ä–æ–≤–µ—Ä–∞ –ø–æ–∑–∞—ò–º—ô–∏–≤–∞—ö–∞ —É –∫–æ–Ω—Ç–µ–∫—Å—Ç—É –≤–µ–∫—Ç–æ—Ä–∞
- [[*–†–µ—Ñ–µ—Ä–µ–Ω—Ü–µ –∏ –ø–æ–∑–∞—ò–º—ô–∏–≤–∞—ö–µ (/References and Borrowing/)][–ü—Ä–∞–≤–∏–ª–∞ –ø–æ–∑–∞—ò–º—ô–∏–≤–∞—ö–∞]] –≤–∞–∂–µ –∏ —É –∫–æ–Ω—Ç–µ–∫—Å—Ç—É –≤–µ–∫—Ç–æ—Ä–∞. –ù–µ –º–æ–∂–µ–º–æ –∏—Å—Ç–æ–≤—Ä–µ–º–µ–Ω–æ –∏–º–∞—Ç–∏
  –ø—Ä–æ–º–µ—ö–∏–≤—É –∏ –Ω–µ–ø—Ä–æ–º–µ—ö–∏–≤—É —Ä–µ—Ñ–µ—Ä–µ–Ω—Ü—É –Ω–∞ –µ–ª–µ–º–µ–Ω—Ç –≤–µ–∫—Ç–æ—Ä–∞.

#+begin_src rust
let mut v = vec![1, 2, 3, 4, 5];
let first = &v[0];
v.push(6);
println!("The first element is: {first}");
#+end_src

#+begin_src
$ cargo run
   Compiling collections v0.1.0 (file:///projects/collections)
error[E0502]: cannot borrow `v` as mutable because it is also borrowed as immutable
 --> src/main.rs:6:5
  |
4 |     let first = &v[0];
  |                  - immutable borrow occurs here
5 |
6 |     v.push(6);
  |     ^^^^^^^^^ mutable borrow occurs here
7 |
8 |     println!("The first element is: {first}");
  |                                      ----- immutable borrow later used here

For more information about this error, try `rustc --explain E0502`.
error: could not compile `collections` due to previous error
#+end_src

#+REVEAL: split

#+begin_note
–ò–º–∞–º–æ —Ä–µ—Ñ–µ—Ä–µ–Ω—Ü—É –Ω–∞ –ø—Ä–≤–∏ –µ–ª–µ–º–µ–Ω—Ç –≤–µ–∫—Ç–æ—Ä–∞ –∞ –ø–æ–∫—É—à–∞–≤–∞–º–æ –ø—Ä–æ–º–µ—ö–∏–≤–æ–º —Ä–µ—Ñ–µ—Ä–µ–Ω—Ü–æ–º –¥–∞
–¥–æ–¥–∞–º–æ –Ω–∞ –∫—Ä–∞—ò. –û–≤–æ –¥–µ–ª—É—ò–µ –∫–∞–æ –¥–∞ –±–∏ –±–∏–ª–æ –±–µ–∑–±–µ–¥–Ω–æ.

/–ó–∞—à—Ç–æ –†–∞—Å—Ç –Ω–µ –¥–æ–∑–≤–æ—ô–∞–≤–∞ –æ–≤–∞–∫–≤–µ –æ–ø–µ—Ä–∞—Ü–∏—ò–µ?/

–ü—Ä–∏–ª–∏–∫–æ–º –¥–æ–¥–∞–≤–∞—ö–∞ –Ω–æ–≤–æ–≥ –µ–ª–µ–º–µ–Ω—Ç–∞ –º–æ–∂–µ –¥–æ—õ–∏ –¥–æ –ø–æ–ø—É—ö–∞–≤–∞—ö–∞ —Ç–µ–∫—É—õ–µ –∞–ª–æ—Ü–∏—Ä–∞–Ω–µ –∑–æ–Ω–µ –∏
–∞–ª–æ—Ü–∏—Ä–∞—ö–∞ –Ω–æ–≤–µ –∑–æ–Ω–µ —É–∑ –ø—Ä–µ–º–µ—à—Ç–∞—ö–µ —Å–≤–∏—Ö –µ–ª–µ–º–µ–Ω–∞—Ç–∞ –Ω–∞ –Ω–æ–≤—É –ª–æ–∫–∞—Ü–∏—ò—É —á–∏–º–µ –±–∏ —Å–≤–µ
—Ç–µ–∫—É—õ–µ —Ä–µ—Ñ–µ—Ä–µ–Ω—Ü–µ –ø–æ—Å—Ç–∞–ª–µ –Ω–µ–≤–∞–ª–∏–¥–Ω–µ. –ü—Ä–∞–≤–∏–ª–æ –ø–æ–∑–∞—ò–º—ô–∏–≤–∞—ö–∞ —Å–ø—Ä–µ—á–∞–≤–∞ –æ–≤–∞–∫–≤–µ –≥—Ä–µ—à–∫–µ.
#+end_note

*** –ò—Ç–µ—Ä–∞—Ü–∏—ò–∞ –ø—Ä–µ–∫–æ –µ–ª–µ–º–µ–Ω–∞—Ç–∞ –≤–µ–∫—Ç–æ—Ä–∞

#+begin_src rust
let v = vec![100, 32, 57];
for i in &v {
    println!("{i}");
}
#+end_src

#+RESULTS:
: 100
: 32
: 57

#+begin_note
–ü–æ—à—Ç–æ –∏—Ç–µ—Ä–∏—Ä–∞–º–æ –ø—Ä–µ–∫–æ –ø–æ–∑–∞—ò–º—ô–µ–Ω–µ –≤—Ä–µ–¥–Ω–æ—Å—Ç–∏ =&v=, —Ç–∏–ø –æ–¥ =i= —õ–µ –±–∏—Ç–∏ –ø–æ–∑–∞—ò–º—ô–µ–Ω
(=&u32=). –£–∫–æ–ª–∏–∫–æ –±–∏ –∏—Ç–µ—Ä–∏—Ä–∞–ª–∏ –ø—Ä–µ–∫–æ –ø–æ—Å–µ–¥–æ–≤–∞–Ω–µ –≤—Ä–µ–¥–Ω–æ—Å—Ç–∏ =for i in v= —Ç–∞–¥–∞ –±–∏ —Å–≤–∏
–µ–ª–µ–º–µ–Ω—Ç–∏ –∏–∑ –≤–µ–∫—Ç–æ—Ä–∞ –±–∏–ª–∏ –ø—Ä–µ–º–µ—à—Ç–µ–Ω–∏ (—Ç—ò. –∫–æ–Ω–∑—É–º–∏—Ä–∞–Ω–∏) –æ–¥ —Å—Ç—Ä–∞–Ω–µ =for= –ø–µ—Ç—ô–µ –∏ –Ω–µ
–±–∏ –º–æ–≥–ª–∏ –≤–∏—à–µ –¥–∞ –∏–º –ø—Ä–∏—Å—Ç—É–ø–∏–º–æ.
#+end_note

#+REVEAL: split

#+begin_src rust
let mut v = vec![100, 32, 57];
for i in &mut v {
    ,*i += 50;
}
println!("{v:?}");
#+end_src

#+RESULTS:
: [150, 82, 107]

*** –°–º–µ—à—Ç–∞—ö–µ –µ–ª–µ–º–µ–Ω–∞—Ç–∞ —Ä–∞–∑–ª–∏—á–∏—Ç–æ–≥ —Ç–∏–ø–∞
- –í–µ–∫—Ç–æ—Ä –º–æ–∂–µ —Å–∞–¥—Ä–∂–∞—Ç–∏ —Å–∞–º–æ –µ–ª–µ–º–µ–Ω—Ç–µ –∏—Å—Ç–æ–≥ —Ç–∏–ø–∞.
- –£–∫–æ–ª–∏–∫–æ –∂–µ–ª–∏–º–æ –¥–∞ —Å–º–µ—Å—Ç–∏–º–æ –µ–ª–µ–º–µ–Ω—Ç–µ —Ä–∞–∑–ª–∏—á–∏—Ç–æ–≥ —Ç–∏–ø–∞ –∫–æ—Ä–∏—Å—Ç–∏–º–æ –µ–Ω—É–º–µ—Ä–∞—Ü–∏—ò–µ.

#+begin_src rust
#[derive(Debug)]
enum SpreadsheetCell {
    Int(i32),
    Float(f64),
    Text(String),
}
let row = vec![
    SpreadsheetCell::Int(3),
    SpreadsheetCell::Text(String::from("blue")),
    SpreadsheetCell::Float(10.12),
];
println!("{row:?}");
#+end_src

#+RESULTS:
: [Int(3), Text("blue"), Float(10.12)]

- –£–ø–æ—Ç—Ä–µ–±–∞ –µ–Ω—É–º–µ—Ä–∞—Ü–∏—ò–∞ –æ—Å–∏–≥—É—Ä–∞–≤–∞ –¥–∞ —õ–µ–º–æ –æ–±—Ä–∞–¥–∏—Ç–∏ —Å–≤–µ –º–æ–≥—É—õ–µ —Å–ª—É—á–∞—ò–µ–≤–µ –Ω–ø—Ä. =match= –∏–∑—Ä–∞–∑–æ–º.

*** –û—Å–ª–æ–±–∞—í–∞—ö–µ –µ–ª–µ–º–µ–Ω–∞—Ç–∞ –≤–µ–∫—Ç–æ—Ä–∞
- –í–µ–∫—Ç–æ—Ä —õ–µ –¥–µ–∞–ª–æ—Ü–∏—Ä–∞—Ç–∏ —Å–≤–æ—ò–µ –µ–ª–µ–º–µ–Ω—Ç–µ –∫–∞–¥–∞ –≤–ª–∞—Å–Ω–∏–∫ –Ω–∞–ø—É—Å—Ç–∏ –æ–ø—Å–µ–≥ –≤–∞–∂–µ—ö–∞.

#+begin_src rust
{
    let v = vec![1, 2, 3, 4];

    // do stuff with v
} // <- v goes out of scope and is freed here
#+end_src

** =String=
*** –®—Ç–∞ —ò–µ —Å—Ç—Ä–∏–Ω–≥?
- –†–∞—Å—Ç –∏–º–∞ —Å–∞–º–æ —ò–µ–¥–∞–Ω —Ç–∏–ø —Å—Ç—Ä–∏–Ω–≥–∞ –ø–æ–¥—Ä–∂–∞–Ω –¥–∏—Ä–µ–∫—Ç–Ω–æ –æ–¥ —Å—Ç—Ä–∞–Ω–µ —ò–µ–∑–∏–∫–∞ - =str= –∫–æ—ò–∏
  —Å–µ –æ–±–∏—á–Ω–æ –∫–æ—Ä–∏—Å—Ç–∏ —É –ø–æ–∑–∞—ò–º—ô–µ–Ω–æ—ò —Ñ–æ—Ä–º–∏ =&str= - —Å—Ç—Ä–∏–Ω–≥ –∏—Å–µ—á–∞–∫ –∫–æ—ò–∏ –ø—Ä–µ–¥—Å—Ç–∞–≤—ô–∞
  —Ä–µ—Ñ–µ—Ä–µ–Ω—Ü—É –Ω–∞ UTF-8 –µ–Ω–∫–æ–¥–æ–≤–∞–Ω —Å–∞–¥—Ä–∂–∞—ò.
- –¢–∏–ø =String=, –¥–µ—Ñ–∏–Ω–∏—Å–∞–Ω —É –†–∞—Å—Ç —Å—Ç–∞–Ω–¥–∞—Ä–¥–Ω–æ—ò –±–∏–±–ª–∏–æ—Ç–µ—Ü–∏, —ò–µ —Ä–∞—Å—Ç—É—õ–∏, –ø—Ä–æ–º–µ—ö–∏–≤–∏,
  –ø–æ—Å–µ–¥–æ–≤–∞–Ω–∏ UTF-8 –µ–Ω–∫–æ–¥–æ–≤–∞–Ω–∏ —Å—Ç—Ä–∏–Ω–≥ —Ç–∏–ø.

*** –ö—Ä–µ–∏—Ä–∞—ö–µ –Ω–æ–≤–æ–≥ —Å—Ç—Ä–∏–Ω–≥–∞
- –ù–æ–≤–∞ –ø—Ä–∞–∑–Ω–∞ =String= –≤—Ä–µ–¥–Ω–æ—Å—Ç —Å–µ –∫—Ä–µ–∏—Ä–∞ –Ω–∞ —Å–ª–µ–¥–µ—õ–∏ –Ω–∞—á–∏–Ω:
#+begin_src rust
let mut s = String::new();
#+end_src

–û–±–∏—á–Ω–æ –∫–æ—Ä–∏—Å—Ç–∏–º–æ =to_string= –º–µ—Ç–æ–¥—É —Ç–∏–ø–∞ –∫–æ—ò–∏ –∏–º–ø–ª–µ–º–µ–Ω—Ç–∏—Ä–∞ =Display= –æ—Å–æ–±–∏–Ω—É –¥–∞ –±–∏
–¥–æ–±–∏–ª–∏ –ø–æ—á–µ—Ç–Ω—É –≤—Ä–µ–Ω–æ—Å—Ç —Å—Ç—Ä–∏–Ω–≥–∞.

#+begin_src rust
let data = "initial contents";

let s = data.to_string();

// the method also works on a literal directly:
let s = "initial contents".to_string();
#+end_src

–¢–∞–∫–æ—í–µ, –º–æ–∂–µ–º–æ –∫–æ—Ä–∏—Å—Ç–∏—Ç–∏ =String::from=:
#+begin_src rust
let s = String::from("initial contents");
#+end_src

*** –°—Ç—Ä–∏–Ω–≥ –º–æ–∂–µ –¥–∞ —Å–∞–¥—Ä–∂–∏ –ø—Ä–æ–∏–∑–≤–æ—ô–Ω—É UTF-8 –≤—Ä–µ–¥–Ω–æ—Å—Ç
#+begin_src rust
let hello = String::from("ÿßŸÑÿ≥ŸÑÿßŸÖ ÿπŸÑŸäŸÉŸÖ");
let hello = String::from("Dobr√Ω den");
let hello = String::from("Hello");
let hello = String::from("◊©÷∏◊Å◊ú◊ï÷π◊ù");
let hello = String::from("‡§®‡§Æ‡§∏‡•ç‡§§‡•á");
let hello = String::from("„Åì„Çì„Å´„Å°„ÅØ");
let hello = String::from("ÏïàÎÖïÌïòÏÑ∏Ïöî");
let hello = String::from("‰Ω†Â•Ω");
let hello = String::from("Ol√°");
let hello = String::from("–ó–¥—Ä–∞–≤—Å—Ç–≤—É–π—Ç–µ");
let hello = String::from("Hola");
#+end_src

*** –ê–∂—É—Ä–∏—Ä–∞—ö–µ —Å—Ç—Ä–∏–Ω–≥–∞
#+begin_src rust
let mut s = String::from("foo");
s.push_str("bar");
#+end_src

#+begin_src rust
let mut s1 = String::from("foo");
let s2 = "bar";
s1.push_str(s2);
println!("s2 is {s2}");
#+end_src

=s2= —ò–µ –ø–æ–∑–∞—ò–º—ô–µ–Ω–æ –∏ –º–æ–∂–µ –¥–∞ —Å–µ –∫–æ—Ä–∏—Å—Ç–∏ –ø–æ—Å–ª–µ –¥–æ–¥–∞–≤–∞—ö–∞.

#+REVEAL: split

- –î–æ–¥–∞–≤–∞—ö–µ —ò–µ–¥–Ω–æ–≥ –∫–∞—Ä–∞–∫—Ç–µ—Ä–∞:
  #+begin_src rust
    let mut s = String::from("lo");
    s.push('l');
  #+end_src

*** –£–ø–æ—Ç—Ä–µ–±–∞ =+= –æ–ø–µ—Ä–∞—Ç–æ—Ä–∞
#+begin_src rust
let s1 = String::from("Hello, ");
let s2 = String::from("world!");
let s3 = s1 + &s2; // note s1 has been moved here and can no longer be used
#+end_src

=+= –æ–ø–µ—Ä–∞—Ç–æ—Ä –∫–æ–Ω–∑—É–º–∏—Ä–∞ –ø—Ä–≤–∏ –æ–ø–µ—Ä–∞–Ω–¥ —Ç–∞–∫–æ –¥–∞ —É –ø—Ä–µ—Ç—Ö–æ–¥–Ω–æ–º –ø—Ä–∏–º–µ—Ä—É =s1= –≤–∞—Ä–∏—ò–∞–±–ª–∞ –Ω–µ
–≤–∞–∂–∏ –ø–æ—Å–ª–µ –∑–∞–¥—ö–µ –ª–∏–Ω–∏—ò–µ.

=+= –æ–ø–µ—Ä–∞—Ç–æ—Ä –∏–Ω—Ç–µ—Ä–Ω–æ –∫–æ—Ä–∏—Å—Ç–∏ =add= –º–µ—Ç–æ–¥—É —á–∏—ò–∞ —Å–∏–≥–Ω–∞—Ç—É—Ä–∞ —ò–µ –Ω–µ—à—Ç–æ –ø–æ–ø—É—Ç:

#+begin_src rust
fn add(self, s: &str) -> String {
#+end_src

#+begin_note
–û–±—Ä–∞—Ç–∏—Ç–µ –ø–∞–∂—ö—É –¥–∞ —ò–µ –¥—Ä—É–≥–∏ –ø–∞—Ä–∞–º–µ—Ç–∞—Ä —Ç–∏–ø–∞ =&str= –¥–æ–∫ —ò–µ –ø—Ä–æ—Å–ª–µ—í–µ–Ω —Ç–∏–ø =&String=.
–ö–æ–º–ø–∞—ò–ª–µ—Ä –æ–≤–æ –ø—Ä–∏—Ö–≤–∞—Ç–∞. –ó–∞—à—Ç–æ?

–ö–æ—Ä–∏—Å—Ç–∏ —Å–µ —Ç–µ—Ö–Ω–∏–∫–∞ [[https://doc.rust-lang.org/std/ops/trait.Deref.html#more-on-deref-coercion][Deref coercion]], —ò–µ—Ä =String= –∏–º–ø–ª–µ–º–µ–Ω—Ç–∏—Ä–∞ –æ—Å–æ–±–∏–Ω—É =Deref<Target=str>=.
#+end_note

*** –£–ø–æ—Ç—Ä–µ–±–∞ =format!= –º–∞–∫—Ä–æ–∞
–£–º–µ—Å—Ç–æ:
#+begin_src rust
let s1 = String::from("tic");
let s2 = String::from("tac");
let s3 = String::from("toe");

let s = s1 + "-" + &s2 + "-" + &s3;
#+end_src

–ú–æ–∂–µ–º–æ –ø–∏—Å–∞—Ç–∏:
#+begin_src rust
let s1 = String::from("tic");
let s2 = String::from("tac");
let s3 = String::from("toe");

let s = format!("{s1}-{s2}-{s3}");
#+end_src

*** –ò–Ω–¥–µ–∫—Å–Ω–∏ –ø—Ä–∏—Å—Ç—É–ø —É–Ω—É—Ç–∞—Ä —Å—Ç—Ä–∏–Ω–≥–∞
#+begin_src rust
let s1 = String::from("hello");
let h = s1[0];
#+end_src

#+begin_src
$ cargo run
   Compiling collections v0.1.0 (file:///projects/collections)
error[E0277]: the type `String` cannot be indexed by `{integer}`
 --> src/main.rs:3:13
  |
3 |     let h = s1[0];
  |             ^^^^^ `String` cannot be indexed by `{integer}`
  |
  = help: the trait `Index<{integer}>` is not implemented for `String`
  = help: the following other types implement trait `Index<Idx>`:
            <String as Index<RangeFrom<usize>>>
            <String as Index<RangeFull>>
            <String as Index<RangeInclusive<usize>>>
            <String as Index<RangeTo<usize>>>
            <String as Index<RangeToInclusive<usize>>>
            <String as Index<std::ops::Range<usize>>>

For more information about this error, try `rustc --explain E0277`.
error: could not compile `collections` due to previous error
#+end_src

/–ó–∞—à—Ç–æ?/

*** –ß—É–≤–∞—ö–µ —Å—Ç—Ä–∏–Ω–≥–∞ —É –º–µ–º–æ—Ä–∏—ò–∏
#+begin_src rust
let hello = String::from("Hola");
println!("{}", hello.len());
#+end_src

#+RESULTS:
: 4

#+begin_src rust
let hello = String::from("–ó–¥—Ä–∞–≤–æ");
println!("{}", hello.len());   // –î—É–∂–∏–Ω–∞ –Ω–∏—ò–µ 6 –≤–µ—õ 12!
#+end_src

#+RESULTS:
: 12

–®—Ç–∞ –±–∏ —Ç—Ä–µ–±–∞–æ –¥–∞ –≤—Ä–∞—Ç–∏ –µ–ª–µ–º–µ–Ω—Ç –Ω–∞ –æ–¥—Ä–µ—í–µ–Ω–æ–º –∏–Ω–¥–µ–∫—Å—É?

*** –†–∞–∑–ª–∏—á–∏—Ç–∏ –ø–æ–≥–ª–µ–¥–∏ –Ω–∞ —Å—Ç—Ä–∏–Ω–≥
–¢—Ä–∏ –Ω–∞—á–∏–Ω–∞ –ø–æ—Å–º–∞—Ç—Ä–∞—ö–∞ —Å—Ç—Ä–∏–Ω–≥–∞: –Ω–∏–∑ –±–∞—ò—Ç–æ–≤–∞, –Ω–∏–∑ —Å–∫–∞–ª–∞—Ä–∞ –∏ –Ω–∏–∑ –≥—Ä–∞—Ñ–µ–º –∫–ª–∞—Å—Ç–µ—Ä–∞.

–ù–∞ –ø—Ä–∏–º–µ—Ä, —Ö–∏–Ω–¥–∏ —Ä–µ—á "‚Äú‡§®‡§ÆÔøΩ‡§§‡•á" —õ–µ —É –º–µ–º–æ—Ä–∏—ò–∏ –±–∏—Ç–∏ —Å–ª–µ–¥–µ—õ–∏ –Ω–∏–∑ –±–∞—ò—Ç–æ–≤–∞:
#+begin_src
[224, 164, 168, 224, 164, 174, 224, 164, 184, 224, 165, 141, 224, 164, 164,
224, 165, 135]
#+end_src

–ê–∫–æ –∏—Å—Ç—É —Ä–µ—á –ø–æ—Å–º–∞—Ç—Ä–∞–º–æ –∫–∞–æ –Ω–∏–∑ —Å–∫–∞–ª–∞—Ä–∞ –∏–ª–∏ –∫–∞—Ä–∞–∫—Ç–µ—Ä–∞ (–†–∞—Å—Ç =char= —Ç–∏–ø) –æ–Ω–¥–∞ –∏–º–∞–º–æ
—Å–ª–µ–¥–µ—õ–µ –≤—Ä–µ–¥–Ω–æ—Å—Ç–∏:

#+begin_src
['‡§®', '‡§Æ', '‡§∏', '‚óå‡•ç', '‡§§', '‚óå‡•á ']
#+end_src

–ß–µ—Ç–≤—Ä—Ç–∏ –∏ —à–µ—Å—Ç–∏ –∫–∞—Ä–∞–∫—Ç–µ—Ä —Å—É –¥–∏—ò–∞–∫—Ä–∏—Ç–∏—Ü–∏ —Ç—ò. –Ω–µ–º–∞—ò—É —Å–º–∏—Å–ª–∞ —Å–∞–º–∏ –∑–∞ —Å–µ–±–µ.

–ê–∫–æ –ø–æ—Å–º–∞—Ç—Ä–∞–º–æ –∏—Å—Ç–∏ —Å–∞–¥—Ä–∂–∞—ò –∫–∞–æ –≥—Ä–∞—Ñ–µ–º –∫–ª–∞—Å—Ç–µ—Ä–µ (–Ω–∞—ò–ø—Ä–∏–±–ª–∏–∂–Ω–∏—ò–µ –∫–æ–Ω—Ü–µ–ø—Ç—É —Å–ª–æ–≤–∞)
–æ–Ω–¥–∞ –≤–∏–¥–∏–º–æ —Å–ª–µ–¥–µ—õ–µ:

#+begin_src rust
["‡§®", "‡§Æ", "‡§∏‡•ç", "‡§§‡•á"]
#+end_src

*** –°–ª–æ–∂–µ–Ω–æ—Å—Ç –∏–Ω–¥–µ–∫—Å–Ω–æ–≥ –ø—Ä–∏—Å—Ç—É–ø–∞
–î–æ–¥–∞—Ç–Ω–∏ —Ä–∞–∑–ª–æ–≥ –∑–∞—à—Ç–æ –Ω–µ —Ç—Ä–µ–±–∞ –¥–æ–∑–≤–æ–ª–∏—Ç–∏ –∏–Ω–¥–µ–∫—Å–Ω–∏ –ø—Ä–∏—Å—Ç—É–ø –∫–æ–¥ —Å—Ç—Ä–∏–Ω–≥–æ–≤–∞ —ò–µ—Å—Ç–µ
—á–∏—ö–µ–Ω–∏—Ü–∞ –¥–∞ –∏–Ω–¥–µ–∫—Å–Ω–∏ –ø—Ä–∏—Å—Ç—É–ø —É–≤–∞–∫ –∏–º–∞ —Å–ª–æ–∂–µ–Ω–æ—Å—Ç =O(1)= —à—Ç–æ —Å–µ –∫–æ–¥ —Å—Ç—Ä–∏–Ω–≥–æ–≤–∞ –Ω–µ
–º–æ–∂–µ –≥–∞—Ä–∞–Ω—Ç–æ–≤–∞—Ç–∏.

*** –ö—Ä–µ–∏—Ä–∞—ö–µ –∏—Å–µ—á–∞–∫–∞
–ú–æ–≥—É—õ–µ —ò–µ –∫—Ä–µ–∏—Ä–∞—ö–µ –∏—Å–µ—á–∞–∫–∞ —Å—Ç—Ä–∏–Ω–≥–æ–≤–∞ —Å —Ç–∏–º –¥–∞ —ò–µ –Ω–∞ –ø—Ä–æ–≥—Ä–∞–º–µ—Ä—É –¥–∞ –æ–±–µ–∑–±–µ–¥–∏ –¥–∞ —Å–µ
–≥—Ä–∞–Ω–∏—Ü–µ –∏—Å–µ—á–∞–∫–∞ –Ω–∞–ª–∞–∑–µ –Ω–∞ –∫—Ä–∞—ò–µ–≤–∏–º–∞ =char= —Ç–∏–ø–∞ —Ç—ò. –Ω–∏—ò–µ –º–æ–≥—É—õ–µ –¥–∞ –∏–≥—Ä–∞–Ω–∏—Ü–∞ –∏—Å–µ—á–∫–∞
–±—É–¥–µ —É–Ω—É—Ç–∞—Ä –∫–∞—Ä–∞–∫—Ç–µ—Ä–∞.

–ù–∞ –ø—Ä–∏–º–µ—Ä, –æ–≤–æ —ò–µ –º–æ–≥—É—õ–µ:
#+begin_src rust
let hello = "–ó–¥—Ä–∞–≤–æ";
let s = &hello[0..4];
println!("{s}")
#+end_src

#+RESULTS:
: –ó–¥

–ê–ª–∏ –æ–≤–æ —ò–µ –≥—Ä–µ—à–∫–∞:
#+begin_src rust
let hello = "–ó–¥—Ä–∞–≤–æ";
let s = &hello[0..3];
println!("{s}")
#+end_src

#+begin_src
thread 'main' panicked at 'byte index 3 is not a char boundary; it is inside '–¥' (bytes 2..4)
of `–ó–¥—Ä–∞–≤–æ`', src/main.rs:4:10
#+end_src

*** –ò—Ç–µ—Ä–∞—Ü–∏—ò–∞ –ø—Ä–µ–∫–æ —Å—Ç—Ä–∏–Ω–≥–æ–≤–∞
–ù–∞—á–∏–Ω –¥–∞ –æ–±—Ä–∞–¥–∏–º–æ —Å–≤–µ –µ–ª–µ–º–µ–Ω—Ç–µ —Å—Ç—Ä–∏–Ω–≥–∞ —ò–µ –¥–∞ –∏—Ç–µ—Ä–∏—Ä–∞–º–æ, –ø—Ä–∏ —á–µ–º—É –∏–º–∞–º–æ –¥–≤–µ
–º–µ—Ç–æ–¥–µ:

- =chars= - –∞–∫–æ –∂–µ–ª–∏–º–æ –¥–∞ –æ–±—Ä–∞–¥–∏–º–æ —Å—Ç—Ä–∏–Ω–≥ –∫–∞–æ –Ω–∏–∑ –∫–∞—Ä–∞–∫—Ç–µ—Ä–∞
  #+begin_src rust
    for c in "–ó–¥".chars() {
        println!("{c}");
    }
  #+end_src

- =bytes= - –∞–∫–æ –∂–µ–ª–∏–º–æ –¥–∞ –æ–±—Ä–∞–¥–∏–º–æ —Å—Ç—Ä–∏–Ω–≥ –∫–∞–æ –Ω–∏–∑ –±–∞—ò—Ç–æ–≤–∞
  #+begin_src rust
    for b in "–ó–¥".bytes() {
        println!("{b}");
    }
  #+end_src

** –•–µ—à –º–∞–ø–∞ (=HashMap<K, V>=)
*** –®—Ç–∞ —ò–µ —Ö–µ—à –º–∞–ø–∞?
- –ì–µ–Ω–µ—Ä–∏—á–∫–∞, —Ö–æ–º–æ–≥–µ–Ω–∞ —Å—Ç—Ä—É–∫—Ç—É—Ä–∞ –∫–æ—ò–∞ —á—É–≤–∞ –ø–∞—Ä–æ–≤–µ –∫—ô—É—á-–≤—Ä–µ–Ω–æ—Å—Ç.
- –£ –¥—Ä—É–≥–∏–º —ò–µ–∑–∏—Ü–∏–º–∞ —Å–µ –∑–æ–≤–µ —ò–æ—à –∏: —Ö–µ—à —Ç–∞–±–µ–ª–∞, —Ä–µ—á–Ω–∏–∫ –∏–ª–∏ –∞—Å–æ—Ü–∏—ò–∞—Ç–∏–≤–Ω–∏ –Ω–∏–∑.
- –ö–æ—Ä–∏—Å–Ω–æ —É —Å–∏—Ç–∞—Ü–∏—ò–∞–º–∞ –∫–∞–¥–∞ —ò–µ –ø–æ—Ç—Ä–µ–±–Ω–æ –ø—Ä–æ–Ω–∞—õ–∏ –≤–µ–∑–∞–Ω–∏ –ø–æ–¥–∞—Ç–∞–∫ –Ω–µ –ø–æ –∏–Ω–¥–µ–∫—Å—É –≤–µ—õ
  –ø–æ –¥—Ä—É–≥–æ—ò –≤—Ä–µ–¥–Ω–æ—Å—Ç–∏.

*** –ö—Ä–µ–∏—Ä–∞—ö–µ —Ö–µ—à –º–∞–ø–µ
#+begin_src rust
use std::collections::HashMap;

let mut scores = HashMap::new();

scores.insert(String::from("Blue"), 10);
scores.insert(String::from("Yellow"), 50);
#+end_src

*** –ü—Ä–∏—Å—Ç—É–ø–∞—ö–µ –µ–ª–µ–º–µ–Ω—Ç–∏–º–∞ —Ö–µ—à –º–∞–ø–µ
#+begin_src rust
use std::collections::HashMap;

let mut scores = HashMap::new();

scores.insert(String::from("Blue"), 10);
scores.insert(String::from("Yellow"), 50);

let team_name = String::from("Blue");
let score = scores.get(&team_name).copied().unwrap_or(0);
#+end_src

- =get= –º–µ—Ç–æ–¥–∞ –≤—Ä–∞—õ–∞ —Ç–∏–ø =Option<&T>=, –¥–∞–∫–ª–µ =None= –≤—Ä–µ–¥–Ω–æ—Å—Ç –∞–∫–æ –∑–∞ –¥–∞—Ç–∏ –∫—ô—É—á –Ω–µ
  –ø–æ—Å—Ç–æ—ò–∏ –≤–µ–∑–∞–Ω–∞ –≤—Ä–µ–¥–Ω–æ—Å—Ç. –ü–æ–∑–∏–≤–∞–º–æ =copied= –¥–∞ –¥–æ–±–∏—ò–µ–º–æ =Option<T>= —Å–∞ –∫–æ–ø–∏—Ä–∞–Ω–æ–º
  –≤—Ä–µ–¥–Ω–æ—à—õ—É.

*** –ò—Ç–µ—Ä–∞—Ü–∏—ò–∞ –ø—Ä–µ–∫–æ –ø–∞—Ä–æ–≤–∞ –∫—ô—É—á-–≤—Ä–µ–¥–Ω–æ—Å—Ç
#+begin_src rust
use std::collections::HashMap;

let mut scores = HashMap::new();

scores.insert(String::from("Blue"), 10);
scores.insert(String::from("Yellow"), 50);

for (key, value) in &scores {
    println!("{key}: {value}");
}
#+end_src

#+RESULTS:
: Yellow: 50
: Blue: 10

*** –•–µ—à –º–∞–ø–∞ –∏ –≤–ª–∞—Å–Ω–∏—à—Ç–≤–æ
- –ê–∫–æ —Ç–∏–ø –∏–º–ø–ª–µ–º–µ–Ω—Ç–∏—Ä–∞ =Copy= –æ—Å–æ–±–∏–Ω—É –±–∏—õ–µ –∫–æ–ø–∏—Ä–∞–Ω —É –º–∞–ø—É, —É —Å—É–ø—Ä–æ—Ç–Ω–æ–º –±–∏—õ–µ
  –ø—Ä–µ–º–µ—à—Ç–µ–Ω –∏ —Ö–µ—à –º–∞–ø–∞ –ø–æ—Å—Ç–∞—ò–µ –≤–ª–∞—Å–Ω–∏–∫.

#+begin_src rust
use std::collections::HashMap;

let field_name = String::from("Favorite color");
let field_value = String::from("Blue");

let mut map = HashMap::new();
map.insert(field_name, field_value);
// field_name and field_value are invalid at this point, try using them and
// see what compiler error you get!
#+end_src

*** –ê–∂—É—Ä–∏—Ä–∞—ö–µ —Ö–µ—à –º–∞–ø–µ - –ø—Ä–µ–ø–∏—Å–∏–≤–∞—ö–µ –≤—Ä–µ–¥–Ω–æ—Å—Ç–∏
#+begin_src rust
use std::collections::HashMap;

let mut scores = HashMap::new();

scores.insert(String::from("Blue"), 10);
scores.insert(String::from("Blue"), 25);

println!("{:?}", scores);
#+end_src

#+RESULTS:
: {"Blue": 25}

*** –ê–∂—É—Ä–∏—Ä–∞—ö–µ —Ö–µ—à –º–∞–ø–µ - –¥–æ–¥–∞–≤–∞—ö–µ —É–∫–ª–æ–ª–∏–∫–æ –∫—ô—É—á –Ω–µ –ø–æ—Å—Ç–æ—ò–∏
#+begin_src rust
use std::collections::HashMap;

let mut scores = HashMap::new();
scores.insert(String::from("Blue"), 10);

scores.entry(String::from("Yellow")).or_insert(50);
scores.entry(String::from("Blue")).or_insert(50);

println!("{:?}", scores);
#+end_src

#+RESULTS:
: {"Yellow": 50, "Blue": 10}

–ö–æ—Ä–∏—Å—Ç–∏–º–æ =Entry API=.

*** –ê–∂—É—Ä–∏—Ä–∞—ö–µ —Ö–µ—à –º–∞–ø–µ - –Ω–∞ –æ—Å–Ω–æ–≤—É —Å—Ç–∞—Ä–µ –≤—Ä–µ–¥–Ω–æ—Å—Ç–∏
#+begin_src rust
use std::collections::HashMap;

let text = "hello world wonderful world";

let mut map = HashMap::new();

for word in text.split_whitespace() {
    let count = map.entry(word).or_insert(0);
    *count += 1;
}

println!("{:?}", map);
#+end_src

#+RESULTS:
: {"wonderful": 1, "hello": 1, "world": 2}

* –û–±—Ä–∞–¥–∞ –≥—Ä–µ—à–∞–∫–∞
** –ö–∞—Ç–µ–≥–æ—Ä–∏—ò–µ –≥—Ä–µ—à–∞–∫–∞ —É –†–∞—Å—Ç—É
- –≥—Ä–µ—à–∫–µ –∫–æ–¥ –∫–æ—ò–∏—Ö —ò–µ –º–æ–≥—É—õ –æ–ø–æ—Ä–∞–≤–∞–∫ (/recoverable/)
  - –ì—Ä–µ—à–∫–µ –∫–æ—ò–µ –æ—á–µ–∫–∏–≤–∞–Ω–æ –º–æ–≥—É –¥–∞ —Å–µ –¥–µ—Å–µ —É —Ç–æ–∫—É —Ä–∞–¥–∞ –∏ –∫–æ—ò–µ –º–æ–∂–µ–º–æ –¥–∞ –æ–±—Ä–∞–¥–∏–º–æ
    –∏ –Ω–∞—Å—Ç–∞–≤–∏–º–æ –∏–∑–≤—Ä—à–∞–≤–∞—ö–µ –±–µ–∑ –Ω–∞—Ä—É—à–∞–≤–∞—ö–∞ –∫–æ–Ω–∑–∏—Ç–µ–Ω—Ç–Ω–æ—Å—Ç–∏ —Å—Ç–∞—ö–∞ –ø—Ä–æ–≥—Ä–∞–º–∞.
- –≥—Ä–µ—à–∫–µ –∫–æ–¥ –∫–æ—ò–∏—Ö –æ–ø–æ—Ä–∞–≤–∞–∫ –Ω–∏—ò–µ –º–æ–≥—É—õ (/unrecoverable/)
  - –£–≤–µ–∫ —Å—É —Å–∏–º–ø—Ç–æ–º –±–∞–≥–æ–≤–∞ —É –ø—Ä–æ–≥—Ä–∞–º—É, –Ω–ø—Ä. —á–∏—Ç–∞—ö–µ –≤–∞–Ω –æ–ø—Å–µ–≥–∞ –Ω–∏–∑–∞.
  - –à–µ–¥–∏–Ω–∏ –ª–æ–≥–∏—á–∞–Ω –ø–æ—Å—Ç—É–ø–∞–∫ —ò–µ –ø—Ä–µ–∫–∏–¥ —Ä–∞–¥–∞ –ø—Ä–æ–≥—Ä–∞–º–∞.
- –í–µ—õ–∏–Ω–∞ —ò–µ–∑–∏–∫–∞ –Ω–µ –ø—Ä–∞–≤–∏ —Ä–∞–∑–ª–∏–∫—É –≤–µ—õ —Å–≤–µ –æ–±—Ä–∞—í—É—ò–µ –Ω–∞ –∏—Å—Ç–∏ –Ω–∞—á–∏–Ω, –Ω–∞—ò—á–µ—à—õ–µ
  —É–ø–æ—Ç—Ä–µ–±–æ–º –º–µ—Ö–∞–Ω–∏–∑–º–∞ –∏–∑—É–∑–µ—Ç–∞–∫–∞.

** =panic!=
- –ú–∞–∫—Ä–æ –∫–æ—ò–∏ –¥–æ–≤–æ–¥–∏ –¥–æ –ø—Ä–µ–∫–∏–¥–∞ –ø—Ä–æ–≥—Ä–∞–º–∞. –ü–æ–∑–∏–≤–∞–º–æ –≥–∞ –∫–∞–¥–∞ –ø—Ä–æ–≥—Ä–∞–º –∑–∞–≤—Ä—à–∏ —É —Å—Ç–∞—ö—É
  —É –∫–æ–º–µ –Ω–∏—ò–µ –º–æ–≥—É—õ –æ–ø–æ—Ä–∞–≤–∞–∫.

#+begin_src rust
fn main() {
    panic!("crash and burn");
}
#+end_src

#+begin_src sh
$ cargo run
   Compiling panic v0.1.0 (file:///projects/panic)
    Finished dev [unoptimized + debuginfo] target(s) in 0.25s
     Running `target/debug/panic`
thread 'main' panicked at 'crash and burn', src/main.rs:2:5
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace
#+end_src

** =panic!= –ø–æ–≤—Ä–∞—Ç–Ω–∏ —Ç—Ä–∞–≥ (/backtrace/)

#+begin_src rust
fn main() {
    let v = vec![1, 2, 3];

    v[99];
}
#+end_src

#+begin_src sh
$ cargo run
   Compiling panic v0.1.0 (file:///projects/panic)
    Finished dev [unoptimized + debuginfo] target(s) in 0.27s
     Running `target/debug/panic`
thread 'main' panicked at 'index out of bounds: the len is 3 but the index is 99', src/main.rs:4:5
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace
#+end_src

#+REVEAL: split

- –ß–∏—Ç–∞–º–æ –ª–∏–Ω–∏—ò–µ –ø–æ–≤—Ä–∞—Ç–Ω–æ–≥ —Ç—Ä–∞–≥–∞ –æ–¥ –≥–æ—Ä–µ –¥–æ –¥–æ–ª–µ –∏ –∏–Ω—Ç–µ—Ä–µ—Å—É—ò–µ –Ω–∞—Å –¥–∞ –ø—Ä–æ–Ω–∞—í–µ–º–æ
  –ø—Ä–≤–æ –º–µ—Å—Ç–æ –≥–¥–µ —Å–µ –ø–æ–º–∏—ö–µ –Ω–∞—à –∫–æ–¥. –¢–æ —ò–µ –ª–æ–∫–∞—Ü–∏—ò–∞ –∫–æ—ò–∞ —ò–µ –∏–∑–∞–∑–≤–∞–ª–∞ –ø—Ä–µ–∫–∏–¥.
#+begin_src sh
$ RUST_BACKTRACE=1 cargo run
thread 'main' panicked at 'index out of bounds: the len is 3 but the index is 99', src/main.rs:4:5
stack backtrace:
   0: rust_begin_unwind
             at /rustc/e092d0b6b43f2de967af0887873151bb1c0b18d3/library/std/src/panicking.rs:584:5
   1: core::panicking::panic_fmt
             at /rustc/e092d0b6b43f2de967af0887873151bb1c0b18d3/library/core/src/panicking.rs:142:14
   2: core::panicking::panic_bounds_check
             at /rustc/e092d0b6b43f2de967af0887873151bb1c0b18d3/library/core/src/panicking.rs:84:5
   3: <usize as core::slice::index::SliceIndex<[T]>>::index
             at /rustc/e092d0b6b43f2de967af0887873151bb1c0b18d3/library/core/src/slice/index.rs:242:10
   4: core::slice::index::<impl core::ops::index::Index<I> for [T]>::index
             at /rustc/e092d0b6b43f2de967af0887873151bb1c0b18d3/library/core/src/slice/index.rs:18:9
   5: <alloc::vec::Vec<T,A> as core::ops::index::Index<I>>::index
             at /rustc/e092d0b6b43f2de967af0887873151bb1c0b18d3/library/alloc/src/vec/mod.rs:2591:9
   6: panic::main
             at ./src/main.rs:4:5
   7: core::ops::function::FnOnce::call_once
             at /rustc/e092d0b6b43f2de967af0887873151bb1c0b18d3/library/core/src/ops/function.rs:248:5
note: Some details are omitted, run with `RUST_BACKTRACE=full` for a verbose backtrace.
#+end_src

#+REVEAL: split

#+begin_note
–£ –ø—Ä–æ–≥—Ä–∞–º—Å–∫–æ–º —ò–µ–∑–∏–∫—É –¶, —á–∏—Ç–∞—ö–µ –≤–∞–Ω –æ–ø—Å–µ–≥–∞ —ò–µ –Ω–µ–¥–µ—Ñ–∏–Ω–∏—Å–∞–Ω–æ –ø–æ–Ω–∞—à–∞—ö–µ –∏ –∫–æ–º–ø–∞—ò–ª–µ—Ä
–º–æ–∂–µ –¥–∞ –ø—Ä–æ–∏–∑–≤–µ–¥–µ –∫√¥–¥ –∫–æ—ò–∏ —Ä–∞–¥–∏ –ø—Ä–æ–∏–∑–≤–æ—ô–Ω—É —Å—Ç–≤–∞—Ä. –ù–∞—ò—á–µ—à—õ–µ —õ–µ –¥–∞ —á–∏—Ç–∞ —Å–∞
–ª–æ–∫–∞—Ü–∏—ò–µ –∫–æ—ò–∞ —Å–µ –Ω–∞–ª–∞–∑–∏ –∏–∑–∞ –∫—Ä–∞—ò–∞ –Ω–∏–∑–∞ —à—Ç–æ –ø—Ä–µ–¥—Å—Ç–∞–≤—ô–∞ –≥—Ä–µ—à–∫—É /buffer overread/
–∫–æ—ò–∞ –¥–æ–≤–æ–¥–∏ –¥–æ —Å–∏–≥—É—Ä–Ω–æ—Å–Ω–∏—Ö –ø—Ä–æ–ø—É—Å—Ç–∞.
#+end_note
** –û–ø–æ—Ä–∞–≤–∞–∫ –æ–¥ –≥—Ä–µ—à–∫–µ - =Result<T,E>=
- –ú–Ω–æ–≥–µ –≥—Ä–µ—à–∫–µ —Å—É –æ—á–µ–∫–∏–≤–∞–Ω–µ —Ç–æ–∫–æ–º –Ω–æ—Ä–º–∞–ª–Ω–æ–≥ –∏–∑–≤—Ä—à–∞–≤–∞—ö–∞ –ø—Ä–æ–≥—Ä–∞–º–∞.
- –ù–∞ –ø—Ä–∏–º–µ—Ä, –∞–∫–æ –ø–æ–∫—É—à–∞–º–æ –æ—Ç–≤–∞—Ä–∞—ö–µ —Ñ–∞—ò–ª–∞, –æ–Ω –º–æ–∂–¥–∞ –Ω–µ –ø–æ—Å—Ç–æ—ò–∏ —Ç–∞–∫–æ –¥–∞ –±–∏
  –æ–ø–æ—Ä–∞–≤–∞–∫ –æ–¥ –≥—Ä–µ—à–∫–µ –º–æ–≥–∞–æ –±–∏—Ç–∏ —ö–µ–≥–æ–≤–æ –∫—Ä–µ–∏—Ä–∞—ö–µ.
- –ö–æ–¥ –æ–≤–∞–∫–≤–∏—Ö –≥—Ä–µ—à–∞–∫–∞ –†–∞—Å—Ç –∫–æ—Ä–∏—Å—Ç–∏ –≥–µ–Ω–µ—Ä–∏—á–∫–∏ —Ç–∏–ø =Result<T,E>=:

#+begin_src rust
enum Result<T, E> {
    Ok(T),
    Err(E),
}
#+end_src

** –û—Ç–≤–∞—Ä–∞—ö–µ —Ñ–∞—ò–ª–∞

–§–∞—ò–ª: =src/main.rs=:
#+begin_src rust
use std::fs::File;

fn main() {
    let greeting_file_result = File::open("hello.txt");
}
#+end_src

- –í–∞—Ä–∏—ò–∞–±–ª–∞ =greeting_file_result= —õ–µ –±–∏—Ç–∏ —Ç–∏–ø–∞ =Result<std::fs::File,
  std::io::Error>=. –£–∫–æ–ª–∏–∫–æ —ò–µ –≤—Ä–∞—õ–µ–Ω–∞ –≤–∞—Ä–∏—ò–∞–Ω—Ç–∞ =Ok= –æ–Ω–∞ —õ–µ —É —Å–µ–±–∏ —Å–∞–¥—Ä–∂–∞—Ç–∏ —Ñ–∞—ò–ª,
  —É–∫–æ–ª–∏–∫–æ —Å–µ –≤—Ä–∞—Ç–∏ –≤–∞—Ä–∏—ò–∞–Ω—Ç–∞ =Err=, —É —ö–æ—ò —õ–µ –±–∏—Ç–∏ –≥—Ä–µ—à–∫–∞ —Ç–∏–ø–∞ =std::io::Error=.

#+REVEAL: split

- –£ —Å–≤–∞–∫–æ–º —Å–ª—É—á–∞—ò—É –º–æ—Ä–∞–º–æ –æ–±—Ä–∞–¥–∏—Ç–∏ –æ–±–µ –≤–∞—Ä–∏—ò–∞–Ω—Ç–µ.
–§–∞—ò–ª: =src/main.rs=:
#+begin_src rust
use std::fs::File;

fn main() {
    let greeting_file_result = File::open("hello.txt");

    let greeting_file = match greeting_file_result {
        Ok(file) => file,
        Err(error) => panic!("Problem opening the file: {:?}", error),
    };
}
#+end_src

** –ü—Ä–µ–ø–æ–∑–Ω–∞–≤–∞—ö–µ —Ä–∞–∑–ª–∏—á–∏—Ç–∏—Ö –≥—Ä–µ—à–∞–∫–∞
- –ñ–µ–ª–∏–º–æ –¥–∞ –∫—Ä–µ–∏—Ä–∞–º–æ —Ñ–∞—ò–ª —É–∫–æ–ª–∏–∫–æ –Ω–µ –ø–æ—Å—Ç–æ—ò–∏. –ú–æ—Ä–∞–º–æ –¥–∞ –ø—Ä–æ–≤–µ—Ä–∏–º–æ –∫–æ—ò—É –≥—Ä–µ—à–∫—É
  —Å–º–æ –¥–æ–±–∏–ª–∏.

#+begin_src rust
use std::fs::File;
use std::io::ErrorKind;

fn main() {
    let greeting_file_result = File::open("hello.txt");

    let greeting_file = match greeting_file_result {
        Ok(file) => file,
        Err(error) => match error.kind() {
            ErrorKind::NotFound => match File::create("hello.txt") {
                Ok(fc) => fc,
                Err(e) => panic!("Problem creating the file: {:?}", e),
            },
            other_error => {
                panic!("Problem opening the file: {:?}", other_error);
            }
        },
    };
}
#+end_src

#+REVEAL: split

- –ê–ª—Ç–µ—Ä–Ω–∞—Ç–∏–≤–Ω–æ –º–æ–∂–µ–º–æ –∫–æ—Ä–∏—Å—Ç–∏—Ç–∏ API =Result= —Ç–∏–ø–∞:

#+begin_src rust
use std::fs::File;
use std::io::ErrorKind;

fn main() {
    let greeting_file = File::open("hello.txt").unwrap_or_else(|error| {
        if error.kind() == ErrorKind::NotFound {
            File::create("hello.txt").unwrap_or_else(|error| {
                panic!("Problem creating the file: {:?}", error);
            })
        } else {
            panic!("Problem opening the file: {:?}", error);
        }
    });
}
#+end_src

** –ü—Ä–µ—á–∏—Ü–∞ =unwrap=

- –° –æ–±–∑–∏—Ä–æ–º –¥–∞ —ò–µ –æ–≤–∞–∫–≤–∞ –æ–±—Ä–∞–¥–∞ —á–µ—Å—Ç–∞, –ø–æ—Å—Ç–æ—ò–∏ –ø—Ä–µ—á–∏—Ü–∞ —Ç–∞–∫–æ –¥–∞ –º–æ–∂–µ–º–æ –ø–∏—Å–∞—Ç–∏
  –¥–æ—Å—Ç–∞ –∫—Ä–∞—õ–µ:

#+begin_src rust
use std::fs::File;

fn main() {
    let greeting_file = File::open("hello.txt").unwrap();
}
#+end_src

#+begin_src
thread 'main' panicked at 'called `Result::unwrap()` on an `Err` value: Os {
code: 2, kind: NotFound, message: "No such file or directory" }',
src/main.rs:4:49
#+end_src

** –ü—Ä–µ—á–∏—Ü–∞ =expect=
- –ò–ª–∏, —É–∫–æ–ª–∏–∫–æ –∂–µ–ª–∏–º–æ –¥–∞ –¥–∞–º–æ –≤–∏—à–µ –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—ò–∞ —É —Å–ª—É—á–∞—ò—É –ø—Ä–µ–∫–∏–¥–∞:

#+begin_src rust
use std::fs::File;

fn main() {
    let greeting_file = File::open("hello.txt")
        .expect("hello.txt should be included in this project");
}
#+end_src

#+begin_src
thread 'main' panicked at 'hello.txt should be included in this project: Os {
code: 2, kind: NotFound, message: "No such file or directory" }',
src/main.rs:5:10
#+end_src

** –ü—Ä–æ–ø–∞–≥–∞—Ü–∏—ò–∞ –≥—Ä–µ—à–∞–∫–∞

#+begin_src rust
use std::fs::File;
use std::io::{self, Read};

fn read_username_from_file() -> Result<String, io::Error> {
    let username_file_result = File::open("hello.txt");

    let mut username_file = match username_file_result {
        Ok(file) => file,
        Err(e) => return Err(e),
    };

    let mut username = String::new();

    match username_file.read_to_string(&mut username) {
        Ok(_) => Ok(username),
        Err(e) => Err(e),
    }
}
#+end_src

–°–∞–¥–∞ –ø–æ–∑–∏–≤–∞–æ—Ü –º–æ–∂–µ –¥–∞ –æ–¥–ª—É—á–∏ –∫–∞–∫–æ –¥–∞ –æ–±—Ä–∞–¥–∏ –≥—Ä–µ—à–∫—É. –ù–ø—Ä. –º–æ–∂–µ –¥–∞:
- –ø—Ä–µ–∫–∏–Ω–µ –ø—Ä–æ–≥—Ä–∞–º —Å–∞ =panic!=
- –∫–æ—Ä–∏—Å—Ç–∏ –ø–æ–¥—Ä–∞–∑—É–º–µ–≤–∞–Ω–æ –∫–æ—Ä–∏—Å–Ω–∏—á–∫–æ –∏–º–µ
- –ø—Ä–æ–Ω–∞—í–µ –∫–æ—Ä–∏—Å–Ω–∏—á–∫–æ –∏–º–µ –Ω–∞ –Ω–µ–∫–æ–º –¥—Ä—É–≥–æ–º –º–µ—Å—Ç—É (–Ω–ø—Ä. –∏–∑ –±–∞–∑–µ –ø–æ–¥–∞—Ç–∞–∫–∞)

** –ü—Ä–µ—á–∏—Ü–∞ –∑–∞ –ø—Ä–æ–ø–∞–≥–∞—Ü–∏—ò—É –≥—Ä–µ—à–∞–∫–∞ - –æ–ø–µ—Ä–∞—Ç–æ—Ä =?=

#+begin_src rust
use std::fs::File;
use std::io::{self, Read};

fn read_username_from_file() -> Result<String, io::Error> {
    let mut username_file = File::open("hello.txt")?;
    let mut username = String::new();
    username_file.read_to_string(&mut username)?;
    Ok(username)
}
#+end_src

- –û–ø–µ—Ä–∞—Ç–æ—Ä =?= –µ–ª–∏–º–∏–Ω–∏—à–µ —Ç–∑–≤. /boilerplate/ –∫–æ–¥.
- –§—É–Ω–∫—Ü–∏—ò–∞ –º–æ—Ä–∞ –¥–∞ –≤—Ä–∞—õ–∞ –∫–æ–º–ø–∞—Ç–∏–±–∏–ª–∞–Ω —Ç–∏–ø –¥–∞ –±–∏ –º–æ–≥–ª–∞ –¥–∞ —Å–µ –∫–æ—Ä–∏—Å—Ç–∏ –æ–≤–∞ –ø—Ä–µ—á–∏—Ü–∞.

#+REVEAL: split

#+begin_note
–ü–æ—Å—Ç–æ—ò–∏ –∑–Ω–∞—á–∞—ò–Ω–∞ —Ä–∞–∑–ª–∏–∫–∞ –∏–∑–º–µ—í—É =?= –æ–ø–µ—Ä–∞—Ç–æ—Ä–∞ –∏ =match= –∏–∑—Ä–∞–∑–∞. =?= –æ–ø–µ—Ä–∞—Ç–æ—Ä —õ–µ
–∞—É—Ç–æ–º–∞—Ç—Å–∫–∏ —Ä–∞–¥–∏—Ç–∏ –∫–æ–Ω–≤–µ—Ä–∑–∏—ò—É –≥—Ä–µ—à–∞–∫–∞ –∑–∞ —Å–≤–µ –≥—Ä–µ—à–∫–µ –∫–æ—ò–µ –∏–º–ø–ª–µ–º–µ–Ω—Ç–∏—Ä–∞—ò—É =From=
–æ—Å–æ–±–∏–Ω—É. –ù–∞ –ø—Ä–∏–º–µ—Ä, –∞–∫–æ –Ω–µ–∫–∞ –Ω–∞—à–∞ –≥—Ä–µ—à–∫–∞ =OurError= –∏–º–ø–ª–µ–º–µ–Ω—Ç–∏—Ä–∞ –∫–æ–Ω–≤–µ—Ä–∑–∏—ò—É –∏–∑
=std::io::Error= —Ç–∞–∫–æ —à—Ç–æ –∏–º–∞–º–æ =impl From<std::io::Error> for OurError= —Ç–∞–¥–∞ –º–æ–∂–µ–º–æ
–¥–µ–∫–ª–∞—Ä–∏—Å–∞—Ç–∏ –¥–∞ –Ω–∞—à–∞ —Ñ—É–Ω–∫—Ü–∏—ò–∞ –≤—Ä–∞—õ–∞ =OurError= –∏ –¥–∞—ô–µ –∫–æ—Ä–∏—Å—Ç–∏—Ç–∏ –ø—Ä–µ—á–∏—Ü—É =?= –Ω–∞
–º–µ—Å—Ç–∏–º–∞ –∫–æ—ò–∞ —Ä–µ–∑—É–ª—Ç—É—ò—É —Å–∞ =std::io::Error=.
#+end_note

** –î–æ–¥–∞—Ç–Ω–æ —Å–∫—Ä–∞—õ–µ—ö–µ –∫–æ–¥–∞
- –£–ø–æ—Ç—Ä–µ–±–æ–º –ø–æ–≤–µ–∑–∞–Ω–∏—Ö –ø–æ–∑–∏–≤–∞ /chain call/ –º–æ–∂–µ–º–æ –¥–æ–¥–∞—Ç–Ω–æ –ø–æ—ò–µ–¥–Ω–æ—Å—Ç–∞–≤–∏—Ç–∏ –∫–æ–¥:

#+begin_src rust
use std::fs::File;
use std::io::{self, Read};

fn read_username_from_file() -> Result<String, io::Error> {
    let mut username = String::new();

    File::open("hello.txt")?.read_to_string(&mut username)?;

    Ok(username)
}
#+end_src

** –£–ø–æ—Ç—Ä–µ–±–∞ =?= –æ–ø–µ—Ä–∞—Ç–æ—Ä–∞ –∫–æ–¥ =Option= —Ç–∏–ø–∞
#+begin_src rust
fn last_char_of_first_line(text: &str) -> Option<char> {
    text.lines().next()?.chars().last()
}
#+end_src

** –£–ø–æ—Ç—Ä–µ–±–∞ =?= –æ–ø–µ—Ä–∞—Ç–æ—Ä–∞ —É —Ñ—É–Ω–∫—Ü–∏—ò–∏ =main=

#+begin_src rust
use std::error::Error;
use std::fs::File;

fn main() -> Result<(), Box<dyn Error>> {
    let greeting_file = File::open("hello.txt")?;

    Ok(())
}
#+end_src

* –ü–∞–∫–µ—Ç–∏, —Å–∞–Ω–¥—É—Ü–∏ –∏ –º–æ–¥—É–ª–∏
** –û—Ä–≥–∞–Ω–∏–∑–∞—Ü–∏—ò–∞ –ø—Ä–æ–≥—Ä–∞–º—Å–∫–æ–≥ –∫–æ–¥–∞
- –°–∞ –ø–æ—Ä–∞—Å—Ç–æ–º –≤–µ–ª–∏—á–∏–Ω–µ –ø—Ä–æ—ò–µ–∫—Ç–∞ —Ä–∞—Å—Ç–µ –∑–Ω–∞—á–∞—ò –æ—Ä–≥–∞–Ω–∏–∑–∞—Ü–∏—ò–µ –∫–æ–¥–∞.
- –†–∞—Å—Ç –º–µ—Ö–∞–Ω–∏–∑–º–∏ –∑–∞ –æ—Ä–≥–∞–Ω–∏–∑–∞—Ü–∏—ò—É –∫–æ–¥–∞ —Å—É:
  - –ü–∞–∫–µ—Ç–∏
  - –°–∞–Ω–¥—É—Ü–∏ (/crates/)
  - –ú–æ–¥—É–ª–∏ –∏ –∫—ô—É—á–Ω–∞ —Ä–µ—á =use=
  - –ü—É—Ç–∞—ö–µ (/paths/)
** –°–∞–Ω–¥—É—Ü–∏ (/crates/)
- –°–∞–Ω–¥—É–∫ –ø—Ä–µ–¥—Å—Ç–∞–≤—ô–∞ –Ω–∞—ò–º–∞—ö—É –∫–æ–ª–∏—á–∏–Ω—É –∫–æ–¥–∞ –∫–æ—ò—É –†–∞—Å—Ç –∫–æ–º–ø–∞—ò–ª–µ—Ä –æ–±—Ä–∞—í—É—ò–µ —É —ò–µ–¥–Ω–æ–º —Ç—Ä–µ–Ω—É—Ç–∫—É.
- –°–∞–Ω–¥—É–∫ –º–æ–∂–µ –±–∏—Ç–∏ —É —Ñ–æ—Ä–º–∏ /–±–∏–Ω–∞—Ä–Ω–æ–≥ —Å–∞–Ω–¥—É–∫–∞/ –∏ /–±–∏–±–ª–∏–æ—Ç–µ—á–∫–æ–≥ —Å–∞–Ω–¥—É–∫–∞/.
- –ë–∏–Ω–∞—Ä–Ω–∏ —Å–∞–Ω–¥—É–∫ –ø—Ä–µ–¥—Å—Ç–∞–≤—ô–∞ –ø—Ä–æ–≥—Ä–∞–º–µ –∫–æ—ò–∏ –º–æ–≥—É –¥–∞ —Å–µ –∫–æ–º–ø–∞—ò–ª–∏—Ä–∞—ò—É –∏ –ø–æ–∫—Ä–µ–Ω—É. –û–≤–∏
  —Å–∞–Ω–¥—É—Ü–∏ –∏–º–∞—ò—É —Ñ—É–Ω–∫—Ü–∏—ò—É =main= –∫–æ—ò–∞ –ø—Ä–µ–¥—Å—Ç–∞–≤—ô–∞ —É–ª–∞–∑–Ω—É —Ç–∞—á–∫—É.
- –ë–∏–±–ª–∏–æ—Ç–µ—á–∫–∏ —Å–∞–Ω–¥—É—Ü–∏ –ø—Ä–µ–¥—Å—Ç–∞–≤—ô–∞—ò—É —Ñ—É–Ω–∫—Ü–∏–æ–Ω–∞–ª–Ω–æ—Å—Ç –Ω–∞–º–µ—ö–µ–Ω—É –∑–∞ –¥–µ—ô–µ—ö–µ —Å–∞ –¥—Ä—É–≥–∏–º –ø—Ä–æ—ò–µ–∫—Ç–∏–º–∞.
- –ö–æ—Ä–µ–Ω —Å–∞–Ω–¥—É–∫–∞ –ø—Ä–µ–¥—Å—Ç–∞–≤—ô–∞ –ø–æ—á–µ—Ç–Ω–∏ —Ñ–∞—ò–ª –æ–¥ –∫–æ–≥–∞ –†–∞—Å—Ç –∫–æ–º–ø–∞—ò–ª–µ—Ä –∫—Ä–µ—õ–µ, –æ–¥–Ω–æ—Å–Ω–æ
  –ø—Ä–µ–¥—Å—Ç–∞–≤—ô–∞ –∫–æ—Ä–µ–Ω—Å–∫–∏ –º–æ–¥—É–ª.

** –ü–∞–∫–µ—Ç–∏
- –ü–∞–∫–µ—Ç –ø—Ä–µ–¥—Å—Ç–∞–≤—ô–∞ —Å–∫—É–ø –ª–æ–≥–∏—á–∫–∏ –ø–æ–≤–µ–∑–∞–Ω–∏—Ö —Å–∞–Ω–¥—É–∫–∞ –∫–æ—ò–∏–º–∞ —Å–µ —É–ø—Ä–∞–≤—ô–∞ –Ω–∞
  —ò–µ–¥–∏–Ω—Å—Ç–≤–µ–Ω –Ω–∞—á–∏–Ω.
- –ü–∞–∫–µ—Ç –º–æ—Ä–∞ –∏–º–∞—Ç–∏ –±–∞—Ä —ò–µ–¥–∞–Ω —Å–∞–Ω–¥—É–∫.
- –ü–∞–∫–µ—Ç –º–æ–∂–µ –∏–º–∞—Ç–∏ –ø—Ä–æ–∏–∑–≤–æ—ô–Ω–æ –º–Ω–æ–≥–æ –±–∏–Ω–∞—Ä–Ω–∏—Ö —Å–∞–Ω–¥—É–∫–∞ –∞–ª–∏ –Ω–∞—ò–≤–∏—à–µ —ò–µ–¥–∞–Ω
  –±–∏–±–ª–∏–æ—Ç–µ—á–∫–∏ —Å–∞–Ω–¥—É–∫.

** –ö—Ä–µ–∏—Ä–∞—ö–µ –ø–∞–∫–µ—Ç–∞

#+begin_src sh
$ cargo new my-project
     Created binary (application) `my-project` package
$ ls my-project
Cargo.toml
src
$ ls my-project/src
main.rs
#+end_src

- –°–≤–∞–∫–∏ –ø–∞–∫–µ—Ç–∏ —É –∫–æ—Ä–µ–Ω—É –∏–º–∞ =Cargo.toml= –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏–æ–Ω–∏ —Ñ–∞—ò–ª.
- –ü—Ä–µ–º–∞ –∫–æ–Ω–≤–µ–Ω—Ü–∏—ò–∏ –∫–æ—Ä–µ–Ω –±–∏–Ω–∞—Ä–Ω–æ–≥ —Å–∞–Ω–¥—É–∫–∞ —ò–µ =src/main.rs=, –¥–æ–∫ —ò–µ –∫–æ—Ä–µ–Ω
  –±–∏–±–ª–∏–æ—Ç–µ—á–∫–æ–≥ —Å–∞–Ω–¥—É–∫–∞ =src/lib.rs=.
- –ê–∫–æ –ø–∞–∫–µ—Ç –∏–º–∞ –≤–∏—à–µ –±–∏–Ω–∞—Ä–Ω–∏—Ö —Å–∞–Ω–¥—É–∫–∞, –∫–æ—Ä–µ–Ω—Å–∫–∏ —Ñ–∞—ò–ª–æ–≤–∏ —Å–µ —Å–º–µ—à—Ç–∞—ò—É —É —Ñ–æ–ª–¥–µ—Ä =src/bin=.

** –°—Ç—Ä—É–∫—Ç—É—Ä–∞ –ø–∞–∫–µ—Ç–∞
#+begin_src text
backyard
‚îú‚îÄ‚îÄ Cargo.lock
‚îú‚îÄ‚îÄ Cargo.toml              <- –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—ò–∞ –ø–∞–∫–µ—Ç–∞
‚îî‚îÄ‚îÄ src
    ‚îú‚îÄ‚îÄ garden
    ‚îÇ   ‚îî‚îÄ‚îÄ vegetables.rs   <- –º–æ–¥—É–ª
    ‚îú‚îÄ‚îÄ garden.rs           <- –º–æ–¥—É–ª
    ‚îî‚îÄ‚îÄ main.rs             <- –∫–æ—Ä–µ–Ω –±–∏–Ω–∞—Ä–Ω–æ–≥ —Å–∞–Ω–¥—É–∫–∞
#+end_src

** –ì—Ä—É–ø–∏—Å–∞—ö–µ –ø–æ–≤–µ–∑–∞–Ω–æ–≥ –∫–æ–¥–∞ —É –º–æ–¥—É–ª–µ
- –£ —Ü–∏—ô—É —á–∏—Ç—ô–∏–≤–æ—Å—Ç–∏, –ª–∞–∫—à–µ–≥ –ø—Ä–æ–Ω–∞–ª–∞—Å–∫–∞ –∏ –ø–æ–Ω–æ–≤–Ω–µ –∏—Å–∫–æ—Ä–∏—Å—Ç—ô–∏–≤–æ—Å—Ç–∏, –º–æ–¥—É–ª–∏ –Ω–∞–º –æ–º–æ–≥—É—õ–∞–≤–∞—ò—É –æ—Ä–≥–∞–Ω–∏–∑–∞—Ü–∏—ò—É –∫–æ–¥–∞ —É–Ω—É—Ç–∞—Ä —Å–∞–Ω–¥—É–∫–∞ —É –≤–∏–¥—É —Å—Ç–∞–±–ª–∞.
- –ú–æ–¥—É–ª–∏, —Ç–∞–∫–æ—í–µ, –æ–º–æ–≥—É—õ–∞–≤–∞—ò—É –¥–µ—Ñ–∏–Ω–∏—Å–∞—ö–µ –ø—Ä–∞–≤–∏–ª–∞ –ø—Ä–∏—Å—Ç—É–ø–∞. –°–≤–∏ –µ–ª–µ–º–µ–Ω—Ç–∏ —É–Ω—É—Ç–∞—Ä
  –º–æ–¥—É–ª–∞ —Å—É –ø–æ–¥—Ä–∞–∑—É–º–µ–≤–∞–Ω–æ –ø—Ä–∏–≤–∞—Ç–Ω–∏.

** –ü—Ä–∏–º–µ—Ä —É–ø–æ—Ç—Ä–µ–±–µ –º–æ–¥—É–ª–∞
#+begin_src sh
cargo new restaurant --lib
#+end_src

–§–∞—ò–ª: src/lib.rs
#+begin_src rust
mod front_of_house {
    mod hosting {
        fn add_to_waitlist() {}

        fn seat_at_table() {}
    }

    mod serving {
        fn take_order() {}

        fn serve_order() {}

        fn take_payment() {}
    }
}
#+end_src

–ú–æ–¥—É–ª–∏ –º–æ–≥—É –∏–º–∞—Ç–∏ –¥—Ä—É–≥–µ –º–æ–¥—É–ª–µ, —Å—Ç—Ä—É–∫—Ç—É—Ä–µ, –µ–Ω—É–º–µ—Ä–∞—Ü–∏—ò–µ, –∫–æ–Ω—Å—Ç–∞–Ω—Ç–µ, –æ—Å–æ–±–∏–Ω–µ –∏—Ç–¥.

** –°—Ç–∞–±–ª–æ –º–æ–¥—É–ª–∞ (/module tree/)
–ú–æ–¥—É–ª–∏ —Å–µ –ø–æ–≤–µ–∑—É—ò—É –∏ —á–∏–Ω–µ —Å—Ç—Ä—É–∫—Ç—É—Ä—É —Ç–∏–ø–∞ —Å—Ç–∞–±–ª–∞ —á–∏—ò–∏ –∫–æ—Ä–µ–Ω —ò–µ –∫–æ—Ä–µ–Ω —Å–∞–Ω–¥—É–∫–∞
(=main.rs= ili =lib.rs=).

#+begin_src text
crate
 ‚îî‚îÄ‚îÄ front_of_house
     ‚îú‚îÄ‚îÄ hosting
     ‚îÇ   ‚îú‚îÄ‚îÄ add_to_waitlist
     ‚îÇ   ‚îî‚îÄ‚îÄ seat_at_table
     ‚îî‚îÄ‚îÄ serving
         ‚îú‚îÄ‚îÄ take_order
         ‚îú‚îÄ‚îÄ serve_order
         ‚îî‚îÄ‚îÄ take_payment
#+end_src

–ê–Ω–∞–ª–æ–≥–∏—ò–∞ —ò–µ —Å–∏—Å—Ç–µ–º —Ñ–∞—ò–ª–æ–≤–∞ –∏ —Ñ–æ–ª–¥–µ—Ä–∞.

** –ü—É—Ç–∞—ö–µ —É–Ω—É—Ç–∞—Ä —Å—Ç–∞–±–ª–∞ –º–æ–¥—É–ª–∞
–ï–ª–µ–º–µ–Ω—Ç–∏ –†–∞—Å—Ç –∫–æ–¥–∞ —Å–µ –º–æ–≥—É —Ä–µ—Ñ–µ—Ä–µ–Ω—Ü–∏—Ä–∞—Ç–∏ –ø—É—Ç–∞—ö–∞–º–∞ –∫–æ—ò–µ —Å–∏–Ω—Ç–∞–∫—Å–Ω–∏ –µ–ª–µ–º–µ–Ω—Ç –∑–∞
–Ω–∞–≤–∏–≥–∞—Ü–∏—ò—É –Ω–∞–¥ —Å—Ç–∞–±–ª–æ–º –º–æ–¥—É–ª–∞.

–ü–æ—Å—Ç–æ—ò–µ –¥–≤–µ –≤—Ä—Å—Ç–µ –ø—É—Ç–∞—ö–∞:
- /–∞–ø—Å–æ–ª—É—Ç–Ω–∞ –ø—É—Ç–∞—ö–∞/ - –ø—É–Ω–∞ –ø—É—Ç–∞—ö–∞ –∫–æ—ò–∞ –ø–æ—á–∏—ö–µ –æ–¥ –∫–æ—Ä–µ–Ω–∞ —Å–∞–Ω–¥—É–∫–∞. –ó–∞–ø–æ—á–∏—ö–µ —Å–∞
  —Ä–µ—á—ò—É =crate=.
- /—Ä–µ–ª–∞—Ç–∏–≤–Ω–∞ –ø—É—Ç–∞—ö–∞/ - –ø—É—Ç–∞—ö–∞ –∫–æ—ò–∞ —Å–µ –≥—Ä–∞–¥–∏ —Ä–µ–ª–∞—Ç–∏–≤–Ω–æ –æ–¥ –ø–æ–∑–∏—Ü–∏—ò–µ –≥–¥–µ —Å–µ –Ω–∞–≤–æ–¥–∏.
  –ú–æ–∂–µ –¥–∞ –∫–æ—Ä–∏—Å—Ç–∏ –∫—ô—É—á–Ω–µ —Ä–µ—á–∏ =self= i =super=.

** –ü—Ä–∏–º–µ—Ä –∞–ø—Å–æ–ª—É—Ç–Ω–µ –∏ —Ä–µ–ª–∞—Ç–∏–≤–Ω–µ –ø—É—Ç–∞—ö–µ
#+begin_src rust
mod front_of_house {
    mod hosting {
        fn add_to_waitlist() {}
    }
}

pub fn eat_at_restaurant() {
    // Absolute path
    crate::front_of_house::hosting::add_to_waitlist();

    // Relative path
    front_of_house::hosting::add_to_waitlist();
}
#+end_src

** –í–∏–¥—ô–∏–≤–æ—Å—Ç –µ–ª–µ–º–µ–Ω–∞—Ç–∞ —É–Ω—É—Ç–∞—Ä –º–æ–¥—É–ª–∞
- –ü—Ä–µ—Ç—Ö–æ–¥–Ω–∏ –ø—Ä–∏–º–µ—Ä —Å–µ –Ω–µ –∫–æ–º–ø–∞—ò–ª–∏—Ä–∞.

#+begin_src rust
$ cargo build
   Compiling restaurant v0.1.0 (file:///projects/restaurant)
error[E0603]: module `hosting` is private
 --> src/lib.rs:9:28
  |
9 |     crate::front_of_house::hosting::add_to_waitlist();
  |                            ^^^^^^^ private module
  |
note: the module `hosting` is defined here
 --> src/lib.rs:2:5
  |
2 |     mod hosting {
  |     ^^^^^^^^^^^

error[E0603]: module `hosting` is private
  --> src/lib.rs:12:21
   |
12 |     front_of_house::hosting::add_to_waitlist();
   |                     ^^^^^^^ private module
   |
note: the module `hosting` is defined here
  --> src/lib.rs:2:5
   |
2  |     mod hosting {
   |     ^^^^^^^^^^^

For more information about this error, try `rustc --explain E0603`.
error: could not compile `restaurant` due to 2 previous errors
#+end_src

#+REVEAL: split

–ê–∫–æ —É—á–∏–Ω–∏–º–æ –º–æ–¥—É–ª =hosting= —ò–∞–≤–Ω–∏–º:

#+begin_src rust
mod front_of_house {
    pub mod hosting {
        fn add_to_waitlist() {}
    }
}

pub fn eat_at_restaurant() {
    // Absolute path
    crate::front_of_house::hosting::add_to_waitlist();

    // Relative path
    front_of_house::hosting::add_to_waitlist();
}
#+end_src

#+REVEAL: split

–ò –¥–∞—ô–µ –∏–º–∞–º–æ –≥—Ä–µ—à–∫—É:
#+begin_src rust
$ cargo build
   Compiling restaurant v0.1.0 (file:///projects/restaurant)
error[E0603]: function `add_to_waitlist` is private
 --> src/lib.rs:9:37
  |
9 |     crate::front_of_house::hosting::add_to_waitlist();
  |                                     ^^^^^^^^^^^^^^^ private function
  |
note: the function `add_to_waitlist` is defined here
 --> src/lib.rs:3:9
  |
3 |         fn add_to_waitlist() {}
  |         ^^^^^^^^^^^^^^^^^^^^

error[E0603]: function `add_to_waitlist` is private
  --> src/lib.rs:12:30
   |
12 |     front_of_house::hosting::add_to_waitlist();
   |                              ^^^^^^^^^^^^^^^ private function
   |
note: the function `add_to_waitlist` is defined here
  --> src/lib.rs:3:9
   |
3  |         fn add_to_waitlist() {}
   |         ^^^^^^^^^^^^^^^^^^^^

For more information about this error, try `rustc --explain E0603`.
error: could not compile `restaurant` due to 2 previous errors
#+end_src

#+REVEAL: split

–ú–æ—Ä–∞–º–æ —É—á–∏–Ω–∏—Ç–∏ –∏ —Ñ—É–Ω–∫—Ü–∏—ò—É =add_to_waitlist= —ò–∞–≤–Ω–æ–º —ò–µ—Ä –∏–∞–∫–æ —ò–µ –º–æ–¥—É–ª —ò–∞–≤–∞–Ω —ö–µ–≥–æ–≤–∏
–µ–ª–µ–º–µ–Ω—Ç–∏ —Å—É –ø–æ–¥—Ä–∞–∑—É–º–µ–≤–∞–Ω–æ –ø—Ä–∏–≤–∞—Ç–Ω–∏.

#+begin_src rust
mod front_of_house {
    pub mod hosting {
        pub fn add_to_waitlist() {}
    }
}

pub fn eat_at_restaurant() {
    // Absolute path
    crate::front_of_house::hosting::add_to_waitlist();

    // Relative path
    front_of_house::hosting::add_to_waitlist();
}
#+end_src

** –à–∞–≤–Ω–∏ API

–ö–æ–¥ –∫–æ—ò–∏ —ò–µ —ò–∞–≤–Ω–æ –¥–æ—Å—Ç—É–ø–∞–Ω –≤–∞–Ω –±–∏–±–ª–∏–æ—Ç–µ—á–∫–æ–≥ —Å–∞–Ω–¥—É–∫–∞ —á–∏–Ω–∏ —ò–∞–≤–Ω–∏ API –±–∏–±–ª–∏–æ—Ç–µ–∫–µ –∏
–ø—Ä–µ–¥—Å—Ç–∞–≤—ô–∞ "—É–≥–æ–≤–æ—Ä" —Å–∞ –∫–æ—Ä–∏—Å–Ω–∏—Ü–∏–º–∞ –±–∏–±–ª–∏–æ—Ç–µ–∫–µ. –°—Ç–æ–≥–∞ —ò–µ –≤–∞–∂–Ω–æ –ø–æ—à—Ç–æ–≤–∞—Ç–∏ –æ–¥—Ä–µ—í–µ–Ω–∞
–ø—Ä–∞–≤–∏–ª–∞ –∏–∑–º–µ–Ω–µ –æ–≤–∏—Ö –µ–ª–µ–º–µ–Ω–∞—Ç–∞.

–î–µ–ª–æ–≤–∏ –∫–æ–¥–∞ –∫–æ—ò–∏ –Ω–∏—Å—É —Å–ø–æ—ô–∞ —ò–∞–≤–Ω–æ –¥–æ—Å—Ç—É–ø–Ω–∏ –º–æ–≥—É —Å–ª–æ–±–æ–¥–Ω–æ –¥–∞ —Å–µ –º–µ—ö–∞—ò—É —ò–µ—Ä –Ω–µ—õ–µ
—É—Ç–∏—Ü–∞—Ç–∏ –Ω–∞ –∫–æ—Ä–∏—Å–Ω–∏–∫–µ.

** –†–µ–ª–∞—Ç–∏–≤–Ω–µ –ø—É—Ç–∞—ö–µ –∏ —É–ø–æ—Ç—Ä–µ–±–∞ =super=
- =super= —Å–µ –∫–æ—Ä–∏—Å—Ç–∏ —É —Å–∏—Ç—É–∞—Ü–∏—ò–∏ –∫–∞–¥–∞ —Ä–µ–ª–∞—Ç–∏–≤–Ω—É –ø—É—Ç–∞—ö—É –∫—Ä–µ–∏—Ä–∞–º–æ —Å–∞ –ø–æ—á–µ—Ç–∫–æ–º —É
  —Ä–æ–¥–∏—Ç–µ—ô—Å–∫–æ–º –º–æ–¥—É–ª—É.

#+begin_src rust
fn deliver_order() {}

mod back_of_house {
    fn fix_incorrect_order() {
        cook_order();
        super::deliver_order();
    }

    fn cook_order() {}
}
#+end_src

** –à–∞–≤–Ω–∏ –ø—Ä–∏—Å—Ç—É–ø —Å—Ç—Ä—É–∫—Ç—É—Ä–∞–º–∞ –∏ –µ–Ω—É–º–µ—Ä–∞—Ü–∏—ò–∞–º–∞
- –ü–æ—Å—Ç–æ—ò–∏ –æ–¥—Ä–µ—í–µ–Ω–∞ —Ä–∞–∑–ª–∏–∫–∞ —É —Ç—Ä–µ—Ç–∏—Ä–∞—ö—É =pub= –∫—ô—É—á–Ω–µ —Ä–µ—á–∏ –∫–∞–¥–∞ —Å—É —É –ø–∏—Ç–∞—ö—É
  —Å—Ç—Ä—É–∫—Ç—É—Ä–µ –∏ –µ–Ω—É–º–µ—Ä–∞—Ü–∏—ò–µ.
- –°—Ç—Ä—É–∫—Ç—É—Ä–µ –∫–æ—ò–µ –∏–º–∞—ò—É —ò–∞–≤–Ω–∏ –ø—Ä–∏—Å—Ç—É–ø –∏ –¥–∞—ô–µ –ø–æ–¥—Ä–∞–∑—É–º–µ–≤–∞–Ω–æ –∏–º–∞—ò—É –ø—Ä–∏–≤–∞—Ç–∞–Ω –ø—Ä–∏—Å—Ç—É–ø –ø–æ—ô–∏–º–∞.
#+begin_src rust
mod back_of_house {
    pub struct Breakfast {
        pub toast: String,
        seasonal_fruit: String,
    }
    impl Breakfast {
        pub fn summer(toast: &str) -> Breakfast {
            Breakfast {
                toast: String::from(toast),
                seasonal_fruit: String::from("peaches"),
            }
        }
    }
}
pub fn eat_at_restaurant() {
    let mut meal = back_of_house::Breakfast::summer("Rye");

    meal.toast = String::from("Wheat");
    println!("I'd like {} toast please", meal.toast);

    // –°–ª–µ–¥–µ—õ–∞ –ª–∏–Ω–∏—ò–∞ —Å–µ –Ω–µ –∫–æ–º–ø–∞—ò–ª–∏—Ä–∞ —ò–µ—Ä —ò–µ –ø–æ—ô–µ –ø—Ä–∏–≤–∞—Ç–Ω–æ
    // meal.seasonal_fruit = String::from("blueberries");
}
#+end_src

#+REVEAL: split

–°–∞ –¥—Ä—É–≥–µ —Å—Ç—Ä–∞–Ω–µ, –≤–∞—Ä–∏—ò–∞–Ω—Ç–µ –µ–Ω—É–º–µ—Ä–∞—Ü–∏—ò–∞ —Å—É —É–≤–µ–∫ —ò–∞–≤–Ω–µ:

#+begin_src rust
mod back_of_house {
    pub enum Appetizer {
        Soup,
        Salad,
    }
}

pub fn eat_at_restaurant() {
    let order1 = back_of_house::Appetizer::Soup;
    let order2 = back_of_house::Appetizer::Salad;
}
#+end_src

** –£–≤–æ—í–µ—ö–µ –µ–ª–µ–º–µ–Ω–∞—Ç–∞ —É –æ–ø—Å–µ–≥ - –∫—ô—É—á–Ω–∞ —Ä–µ—á =use=
- –£–ø–æ—Ç—Ä–µ–±–∞ –ø—É–Ω–∏—Ö –ø—É—Ç–∞—ö–∞ –∑–∞ —Å–≤–∞–∫–æ –Ω–∞–≤–æ—í–µ—ö–µ —ò–µ–∑–∏—á–∫–æ–≥ –µ–ª–µ–º–µ–Ω—Ç–∞ —ò–µ –æ–ø—Ç–µ—Ä–µ—õ—É—ò—É—õ–µ –∏
  –ª–æ—à–µ —É—Ç–∏—á–µ –Ω–∞ —á–∏—Ç–∫–æ—Å—Ç –∫–æ–¥–∞.
- –£–ø–æ—Ç—Ä–µ–±–æ–º –∫—ô—É—á–Ω–µ —Ä–µ—á–∏ =use= –º–æ–∂–µ–º–æ —É–≤–µ—Å—Ç–∏ –µ–ª–µ–º–µ–Ω—Ç —É —Ç–µ–∫—É—õ–∏ –æ–ø—Å–µ–≥.

#+begin_src rust
mod front_of_house {
    pub mod hosting {
        pub fn add_to_waitlist() {}
    }
}

use crate::front_of_house::hosting;

pub fn eat_at_restaurant() {
    hosting::add_to_waitlist();
}
#+end_src

–ê–Ω–∞–ª–æ–≥–Ω–æ –∫—Ä–µ–∏—Ä–∞—ö—É –ø—Ä–µ—á–∏—Ü–∞ (/shortcuts/) —É —Ñ–∞—ò–ª —Å–∏—Å—Ç–µ–º—É.

** =use= —Å–∞–º–æ –∫—Ä–µ–∏—Ä–∞ –ø—Ä–µ—á–∏—Ü—É
–°–ª–µ–¥–µ—õ–∏ –ø—Ä–∏–º–µ—Ä —Å–µ –Ω–µ –∫–æ–º–ø–∞—ò–ª–∏—Ä–∞ —ò–µ—Ä —Å–º–æ –ø–æ–º–æ—Ä–∏–ª–∏ —Ñ—É–Ω–∫—Ü–∏—ò—É =eat_at_restaurant= —É
–º–æ–¥—É–ª =customer= –∏ —Ä–µ–ª–∞—Ç–∏–≤–Ω–∞ –ø—Ä–µ—á–∏—Ü–∞ –≤–∏—à–µ –Ω–∏—ò–µ –≤–∞–ª–∏–¥–Ω–∞.

#+begin_src rust
mod front_of_house {
    pub mod hosting {
        pub fn add_to_waitlist() {}
    }
}

use crate::front_of_house::hosting;

mod customer {
    pub fn eat_at_restaurant() {
        hosting::add_to_waitlist();
    }
}
#+end_src

** –ö—Ä–µ–∏—Ä–∞—ö–µ –∏–¥–∏–æ–º–∞—Ç—Å–∫–∏—Ö –ø—É—Ç–∞—ö–∞
- –ö–∞–¥–∞ —É–≤–æ–¥–∏–º–æ —Ñ—É–Ω–∫—Ü–∏—ò—É —É –æ–ø—Å–µ–≥ –æ–±–∏—á–Ω–æ —Ç–æ —Ä–∞–¥–∏–º–æ —É–≤–æ—í–µ—ö–µ–º —Ä–æ–¥–∏—Ç–µ—ô—Å–∫–æ–≥ –º–æ–¥—É–ª–∞
  –∫–∞–∫–æ —Å–º–æ –≤–∏–¥–µ–ª–∏ –Ω–∞ –ø—Ä–µ—Ç—Ö–æ–¥–Ω–æ–º –ø—Ä–∏–º–µ—Ä—É.
- –ê–∫–æ —É–≤–æ–¥–∏–º–æ —Ç–∏–ø–æ–≤–µ (—Å—Ç—Ä—É–∫—Ç—É—Ä–µ, –µ–Ω—É–º–µ—Ä–∞—Ü–∏—ò–µ) –Ω–∞–≤–æ–¥–∏–º–æ –∏—Ö –¥–∏—Ä–µ–∫—Ç–Ω–æ.
- –ù–∞ –ø—Ä–∏–º–µ—Ä, —É–≤–æ—í–µ—ö–µ —Å—Ç—Ä—É–∫—Ç—É—Ä–µ =HashMap= –∏–∑ —Å—Ç–∞–Ω–¥–∞—Ä–¥–Ω–µ –±–∏–±–ª–∏–æ—Ç–µ–∫–µ:

#+begin_src rust
use std::collections::HashMap;

fn main() {
    let mut map = HashMap::new();
    map.insert(1, 2);
}
#+end_src

** –£–ø–æ—Ç—Ä–µ–±–∞ –∫—ô—É—á–Ω–µ —Ä–µ—á–∏ =as= –∑–∞ –ø—Ä–æ–º–µ–Ω—É –∏–º–µ–Ω–∞
–†–∞—Å—Ç –Ω–µ –¥–æ–∑–≤–æ—ô–∞–≤–∞ –¥–∞ –ø–æ—Å—Ç–æ—ò–µ —Ä–∞–∑–ª–∏—á–∏—Ç–∏ –µ–ª–µ–º–µ–Ω—Ç–∏ —É –æ–ø—Å–µ–≥—É —Å–∞ –∏—Å—Ç–∏–º –∏–º–µ–Ω–æ–º.
–£–∫–æ–ª–∏–∫–æ –∂–µ–ª–∏–º–æ –¥–∞ —É–≤–µ–¥–µ–º–æ –µ–ª–µ–º–µ–Ω—Ç–µ —Å–∞ –∏—Å—Ç–∏–º –Ω–∞–∑–∏–≤–æ–º –º–æ–∂–µ–º–æ:
- –£–≤–µ—Å—Ç–∏ —Ä–æ–¥–∏—Ç–µ—ô—Å–∫–∏ –º–æ–¥—É–ª, –∫–∞–æ —É —Å–ª–µ–¥–µ—õ–µ–º –ø—Ä–∏–º–µ—Ä—É:
  #+begin_src rust
    use std::fmt;
    use std::io;
    fn function1() -> fmt::Result {
        // --snip--
    }

    fn function2() -> io::Result<()> {
        // --snip--
    }
  #+end_src

- –ü—Ä–æ–º–µ–Ω–∏—Ç–∏ –∏–º–µ —É —Ç–µ–∫—É—õ–µ–º –æ–ø—Å–µ–≥—É —É–ø–æ—Ç—Ä–µ–±–æ–º –∫—ô—É—á–Ω–µ —Ä–µ—á–∏ =as=.
  #+begin_src rust
    use std::fmt::Result;
    use std::io::Result as IoResult;
    fn function1() -> Result {
        // --snip--
    }

    fn function2() -> IoResult<()> {
        // --snip--
    }
  #+end_src

** –†–µ–µ–∫—Å–ø–æ—Ä—Ç –∏–º–µ–Ω–∞ —Å–∞ =pub use=
- –ö–∞–¥–∞ —É–≤–µ–¥–µ–º–æ –∏–º–µ —É –æ–ø—Å–µ–≥ —Å–∞ =use= –æ–Ω —ò–µ –ø—Ä–∏–≤–∞—Ç–∞–Ω –∑–∞ –ø—Ä–∏—Å—Ç—É–ø —Å–ø–æ—ô–∞.
- –£–∫–æ–ª–∏–∫–æ –∂–µ–ª–∏–º–æ –¥–∞ –±—É–¥–µ —ò–∞–≤–∞–Ω —Å–ø–æ—ô–∞ –º–æ–∂–µ–º–æ –∫–æ—Ä–∏—Å—Ç–∏—Ç–∏ =pub use=.

#+begin_src rust
mod front_of_house {
    pub mod hosting {
        pub fn add_to_waitlist() {}
    }
}

pub use crate::front_of_house::hosting;

pub fn eat_at_restaurant() {
    hosting::add_to_waitlist();
}
#+end_src

- –û–≤–æ —Å–µ —á–µ—Å—Ç–æ –∫–æ—Ä–∏—Å—Ç–∏ –∫–∞–¥–∞ —ò–∞–≤–Ω–∏ API –±–∏–±–ª–∏–æ—Ç–µ–∫–µ —Ç—Ä–µ–±–∞ –¥–∞ –±—É–¥–µ —Ä–∞–∑–ª–∏—á–∏—Ç –æ–¥
  –∏–Ω—Ç–µ—Ä–Ω–µ –æ—Ä–≥–∞–Ω–∏–∑–∞—Ü–∏—ò–µ –∫–æ–¥–∞.

** –£–ø–æ—Ç—Ä–µ–±–∞ –µ–∫—Å—Ç–µ—Ä–Ω–∏—Ö –ø–∞–∫–µ—Ç–∞

–§–∞—ò–ª =Cargo.toml=:
#+begin_src rust
...
[dependencies]
rand = "0.8.5"
...
#+end_src

–ò –∑–∞—Ç–∏–º –º–æ–∂–µ–º–æ —É–≤–µ—Å—Ç–∏ –µ–ª–µ–º–µ–Ω—Ç–µ –∏–∑ =rand= —Å–∞–Ω–¥—É–∫–∞ —Å–∞:
#+begin_src rust
use rand::Rng;

fn main() {
    let secret_number = rand::thread_rng().gen_range(1..=100);
}
#+end_src

#+REVEAL: split

–ü–∞–∫–µ—Ç–∏ —Å–µ –ø–æ–¥—Ä–∞–∑—É–º–µ–≤–∞–Ω–æ –ø—Ä–µ—É–∑–∏–º–∞—ò—É —Å–∞ =crates.io=. =std= –±–∏–±–ª–∏–æ—Ç–µ–∫–∞ —ò–µ —Å–∞–Ω–¥—É–∫, —É–≤–µ–∫
—ò–µ –ª–æ–∫–∞–ª–Ω–æ –ø—Ä–∏—Å—É—Ç–∞–Ω, –Ω–∏—ò–µ –ø–æ—Ç—Ä–µ–±–Ω–æ –ø–æ—Å–µ–±–Ω–æ –≥–∞ –Ω–∞–≤–æ–¥–∏—Ç–∏ —É –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—ò–∏ –∞–ª–∏ —ò–µ
–µ–ª–µ–º–µ–Ω—Ç–µ –∫–æ—ò–µ –∫–æ—Ä–∏—Å—Ç–∏–º–æ –ø–æ—Ç—Ä–µ–±–Ω–æ —É–≤–µ—Å—Ç–∏.

#+begin_src rust
use std::collections::HashMap;
#+end_src

** –£–≥—ö–µ–∂–¥–µ–Ω–µ –ø—É—Ç–∞—ö–µ –ø—Ä–∏ —É–≤–æ—í–µ—ö—É
- –ê–∫–æ —É–≤–æ–¥–∏–º–æ –≤–∏—à–µ –µ–ª–µ–º–µ–Ω–∞—Ç–∞ –∏–∑ –∏—Å—Ç–æ–≥ –º–æ–¥—É–ª–∞ –º–æ–∂–µ–º–æ –∫–æ—Ä–∏—Å—Ç–∏—Ç–∏ —Å–∫—Ä–∞—õ–µ–Ω–∏ —É–≥—ö–µ–∂–¥–µ–Ω–∏
  –∑–∞–ø–∏—Å.

- –ù–∞ –ø—Ä–∏–º–µ—Ä:
  #+begin_src rust
    // --snip--
    use std::cmp::Ordering;
    use std::io;
    // --snip--
  #+end_src

- –ú–æ–∂–µ–º–æ –ø–∏—Å–∞—Ç–∏ –∫–∞–æ:
  #+begin_src rust
    // --snip--
    use std::{cmp::Ordering, io};
    // --snip--
  #+end_src

#+REVEAL: split

- Mo–∂–µ–º–æ –∏—Å—Ç–æ–≤—Ä–µ–º–µ–Ω–æ —É–≤–µ—Å—Ç–∏ –∏ –º–æ–¥—É–ª –∏ –Ω–µ–∫–µ –æ–¥ —ö–µ–≥–æ–≤–∏—Ö –µ–ª–µ–º–µ–Ω–∞—Ç–∞. –ù–∞ –ø—Ä–∏–º–µ—Ä,
  —É–º–µ—Å—Ç–æ:
  #+begin_src rust
    use std::io;
    use std::io::Write;
  #+end_src
- –ú–æ–∂–µ–º–æ –ø–∏—Å–∞—Ç–∏:
  #+begin_src rust
    use std::io::{self, Write};
  #+end_src

** /Glob/ –æ–ø–µ—Ä–∞—Ç–æ—Ä

- –ê–∫–æ –∂–µ–ª–∏–º–æ –¥–∞ —É–≤–µ–¥–µ–º–æ —Å–≤–µ –µ–ª–µ–º–µ–Ω—Ç–µ –Ω–µ–∫–æ–≥ –º–æ–¥—É–ª–∞ –º–æ–∂–µ–º–æ –ø–∏—Å–∞—Ç–∏:
  #+begin_src rust
    use std::collections::*;
  #+end_src

** –ü–æ–¥–µ–ª–∞ –º–æ–¥—É–ª–∞ —É –ø–æ—Å–µ–±–Ω–µ —Ñ–∞—ò–ª–æ–≤–µ
–ú–æ–¥—É–ª–µ —á–µ—Å—Ç–æ –ø–∏—à–µ–º–æ —É –ø–æ—Å–µ–±–Ω–∏–º —Ñ–∞—ò–ª–æ–≤–∏–º–∞ –∑–±–æ–≥ –ª–∞–∫—à–µ–≥ –ø—Ä–∏—Å—Ç—É–ø–∞ –∏ –æ—Ä–≥–∞–Ω–∏–∑–∞—Ü–∏—ò–µ.

–§–∞—ò–ª =src/lib.rs=:
#+begin_src rust
pub mod front_of_house;    // <- –Ω–∞–≤–æ–¥–∏–º–æ –∏–º–µ —Ñ–∞—ò–ª–∞ –º–æ–¥—É–ª–∞

pub use crate::front_of_house::hosting;

pub fn eat_at_restaurant() {
    hosting::add_to_waitlist();
}
#+end_src

–ê –∑–∞—Ç–∏–º —É —Ñ–∞—ò–ª—É =src/front_of_house.rs=
#+begin_src rust
pub mod hosting {
    pub fn add_to_waitlist() {}
}
#+end_src

#+REVEAL: split

–ê –º–æ–∂–µ–º–æ –¥–∞—ô–µ –¥–µ–∫–æ–º–ø–æ–Ω–æ–≤–∞—Ç–∏ –∏ –∏–∑–≤—É—õ–∏ –º–æ–¥—É–ª =hosting= –∏–∑ —Ñ–∞—ò–ª–∞ =front_of_house.rs=:

–§–∞—ò–ª =src/front_of_house.rs=:
#+begin_src rust
pub mod hosting;
#+end_src

–§–∞—ò–ª =src/front_of_house/hosting.rs=:
#+begin_src rust
pub fn add_to_waitlist() {}
#+end_src

#+begin_note
=mod= —ò–µ –ø–æ—Ç—Ä–µ–±–Ω–æ –Ω–∞–≤–µ—Å—Ç–∏ —Å–∞–º–æ —ò–µ–¥–Ω–æ–º. –¢–∏–º–µ —Å–µ –º–æ–¥—É–ª —É–≤–µ–∑—É—ò–µ —É —Å—Ç–∞–±–ª–æ –º–æ–¥—É–ª–∞ –∏
–º–æ–≥—É—õ–µ –≥–∞ —ò–µ —Ä–µ—Ñ–µ—Ä–µ–Ω—Ü–∏—Ä–∞—Ç–∏ –ø—É—Ç–∞—ö–∞–º–∞ –∏–∑ –æ—Å—Ç–∞—Ç–∫–∞ –∫–æ–¥–∞. –û–¥–Ω–æ—Å–Ω–æ, =mod= –Ω–∏—ò–µ –∏—Å—Ç–æ —à—Ç–æ
–∏ =include= –∏–∑ –¥—Ä—É–≥–∏—Ö –ø—Ä–æ–≥—Ä–∞–º—Å–∫–∏—Ö —ò–µ–∑–∏–∫–∞.
#+end_note

* –¢–µ—Å—Ç–∏—Ä–∞—ö–µ
** –¢–µ—Å—Ç–∏—Ä–∞—ö–µ
#+begin_quote
Program testing can be a very effective way to show the presence of bugs, but it
is hopelessly inadequate for showing their absence.

                            -- Edsger W. Dijkstra, ‚ÄúThe Humble Programmer‚Äù, 1972
#+end_quote

#+REVEAL: split

- –†–∞—Å—Ç —Å–∏—Å—Ç–µ–º —Ç–∏–ø–æ–≤–∞ –∏ –ø—Ä–æ–≤–µ—Ä–∞ –ø–æ–∑–∞—ò–º–∏—Ü–∞ —Å–ø—Ä–µ—á–∞–≤–∞ –ø–æ—ò–∞–≤—É —à–∏—Ä–µ –∫–ª–∞—Å–µ –ª–æ–≥–∏—á–∫–∏—Ö
  –≥—Ä–µ—à–∞–∫–∞ –∞–ª–∏ –Ω–µ –º–æ–∂–µ –¥–∞ –ø—Ä–µ–¥—É–ø—Ä–µ–¥–∏ –ø–æ—ò–∞–≤—É —Å–≤–∏—Ö –≥—Ä–µ—à–∞–∫–∞. –ù–∞ –ø—Ä–∏–º–µ—Ä, –†–∞—Å—Ç –Ω–µ –º–æ–∂–µ
  –¥–∞ –ø—Ä–æ–≤–µ—Ä–∏ –¥–∞ —õ–µ –æ–¥—Ä–µ—í–∞–Ω —Ñ—É–Ω–∫—Ü–∏—ò–∞ –¥–∞ —Ä–∞–¥–∏ —Ç–∞—á–Ω–æ –æ–Ω–æ —à—Ç–æ —ò–µ –ø—Ä–æ–≥—Ä–∞–º–µ—Ä –∑–∞–º–∏—Å–ª–∏–æ.
- –û–¥—Ä–µ—í–µ–Ω–∞ –∫–ª–∞—Å–∞ –ª–æ–≥–∏—á–∫–∏—Ö –≥—Ä–µ—à–∞–∫–∞ –∑–∞—Ö—Ç–µ–≤–∞ –∫—Ä–µ–∏—Ä–∞—ö–µ —Ç–µ—Å—Ç–æ–≤–∞.

** –ö–∞–∫–æ –ø–∏—Å–∞—Ç–∏ —Ç–µ—Å—Ç–æ–≤–µ?

1. –ü–æ—Å—Ç–∞–≤–∏—Ç–∏ –ø–æ—Ç—Ä–µ–±–Ω–æ —Å—Ç–∞—ö–µ –∏ –ø–æ–¥–∞—Ç–∫–µ.
2. –ò–∑–≤—Ä—à–∏—Ç–∏ –∫–æ–¥ –∫–æ—ò–∏ —Å–µ —Ç–µ—Å—Ç–∏—Ä–∞ —Å–∞ –¥–∞—Ç–∏–º —É–ª–∞–∑–∏–º–∞.
3. –ü–æ—Ç–≤—Ä–¥–∏—Ç–∏ –¥–∞ —ò–µ —Ä–µ–∑—É–ª—Ç–∞—Ç –∏–∑–≤—Ä—à–∞–≤–∞—ö–∞ –æ—á–µ–∫–∏–≤–∞–Ω.

** –ê–Ω–∞—Ç–æ–º–∏—ò–∞ —Ç–µ—Å—Ç —Ñ—É–Ω–∫—Ü–∏—ò–µ
#+begin_src rust
$ cargo new adder --lib
     Created library `adder` project
$ cd adder
#+end_src

–ì–µ–Ω–µ—Ä–∏—Å–∞–Ω —Ç–µ—Å—Ç —õ–µ –±–∏—Ç–∏:

–§–∞—ò–ª =src/lib.rs=:
#+begin_src rust
#[cfg(test)]
mod tests {
    #[test]
    fn it_works() {
        let result = 2 + 2;
        assert_eq!(result, 4);
    }
}
#+end_src

** –ü–æ–∫—Ä–µ—Ç–∞—ö–µ —Ç–µ—Å—Ç–∞
#+begin_src sh
$ cargo test
   Compiling adder v0.1.0 (file:///projects/adder)
    Finished test [unoptimized + debuginfo] target(s) in 0.57s
     Running unittests src/lib.rs (target/debug/deps/adder-92948b65e88960b4)

running 1 test
test tests::it_works ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

   Doc-tests adder

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s
#+end_src

** –ü—Ä–∏–º–µ—Ä —Ç–µ—Å—Ç–∞ 1

#+begin_src rust
#[derive(Debug)]
struct Rectangle {
    width: u32,
    height: u32,
}

impl Rectangle {
    fn can_hold(&self, other: &Rectangle) -> bool {
        self.width > other.width && self.height > other.height
    }
}
#+end_src

#+REVEAL: split

#+begin_src rust
#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn larger_can_hold_smaller() {
        let larger = Rectangle {
            width: 8,
            height: 7,
        };
        let smaller = Rectangle {
            width: 5,
            height: 1,
        };

        assert!(larger.can_hold(&smaller));
    }
}
#+end_src

#+REVEAL: split

#+begin_src sh
$ cargo test
   Compiling rectangle v0.1.0 (file:///projects/rectangle)
    Finished test [unoptimized + debuginfo] target(s) in 0.66s
     Running unittests src/lib.rs (target/debug/deps/rectangle-6584c4561e48942e)

running 1 test
test tests::larger_can_hold_smaller ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

   Doc-tests rectangle

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s
#+end_src

** –ü—Ä–∏–º–µ—Ä —Ç–µ—Å—Ç–∞ 2
#+begin_src rust
#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn larger_can_hold_smaller() {
        // --snip--
    }

    #[test]
    fn smaller_cannot_hold_larger() {
        let larger = Rectangle {
            width: 8,
            height: 7,
        };
        let smaller = Rectangle {
            width: 5,
            height: 1,
        };

        assert!(!smaller.can_hold(&larger));
    }
}
#+end_src

#+REVEAL: split

#+begin_src sh
$ cargo test
   Compiling rectangle v0.1.0 (file:///projects/rectangle)
    Finished test [unoptimized + debuginfo] target(s) in 0.66s
     Running unittests src/lib.rs (target/debug/deps/rectangle-6584c4561e48942e)

running 2 tests
test tests::larger_can_hold_smaller ... ok
test tests::smaller_cannot_hold_larger ... ok

test result: ok. 2 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

   Doc-tests rectangle

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s
#+end_src

** –ù–µ—É—Å–ø–µ—à–∞–Ω —Ç–µ—Å—Ç

- –ù–∞–º–µ—Ä–Ω–æ —É–≤–æ–¥–∏–º–æ –≥—Ä–µ—à–∫—É —É –∫–æ–¥ –¥–∞ –≤–∏–¥–∏–º–æ –∫–∞–∫–æ –∏–∑–ª–≥–µ–¥–∞ –∫–∞–¥–∞ —Ç–µ—Å—Ç –Ω–µ —É—Å–ø–µ–≤–∞:
#+begin_src rust
// --snip--
impl Rectangle {
    fn can_hold(&self, other: &Rectangle) -> bool {
        self.width < other.width && self.height > other.height
    }
}
#+end_src

#+REVEAL: split

#+begin_src sh
$ cargo test
   Compiling rectangle v0.1.0 (file:///projects/rectangle)
    Finished test [unoptimized + debuginfo] target(s) in 0.66s
     Running unittests src/lib.rs (target/debug/deps/rectangle-6584c4561e48942e)

running 2 tests
test tests::larger_can_hold_smaller ... FAILED
test tests::smaller_cannot_hold_larger ... ok

failures:

---- tests::larger_can_hold_smaller stdout ----
thread 'tests::larger_can_hold_smaller' panicked at 'assertion failed: larger.can_hold(&smaller)', src/lib.rs:28:9
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

failures:
    tests::larger_can_hold_smaller

test result: FAILED. 1 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

error: test failed, to rerun pass `--lib`
#+end_src

** –¢–µ—Å—Ç–∏—Ä–∞—ö–µ —ò–µ–¥–Ω–∞–∫–æ—Å—Ç–∏ –∏ –Ω–µ—ò–µ–¥–Ω–∞–∫–æ—Å—Ç–∏ - =assert_eq!= –∏ =assert_ne!=

#+begin_src rust
pub fn add_two(a: i32) -> i32 {
    a + 2
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn it_adds_two() {
        assert_eq!(4, add_two(2));
    }
}
#+end_src

#+REVEAL: split

#+begin_src sh
$ cargo test
   Compiling adder v0.1.0 (file:///projects/adder)
    Finished test [unoptimized + debuginfo] target(s) in 0.58s
     Running unittests src/lib.rs (target/debug/deps/adder-92948b65e88960b4)

running 1 test
test tests::it_adds_two ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

   Doc-tests adder

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s
#+end_src

#+REVEAL: split

–£–∫–æ–ª–∏–∫–æ —Ç–µ—Å—Ç –Ω–µ —É—Å–ø–µ:

#+begin_src rust
pub fn add_two(a: i32) -> i32 {
    a + 3
}
#+end_src

#+REVEAL: split

#+begin_src sh
$ cargo test
   Compiling adder v0.1.0 (file:///projects/adder)
    Finished test [unoptimized + debuginfo] target(s) in 0.61s
     Running unittests src/lib.rs (target/debug/deps/adder-92948b65e88960b4)

running 1 test
test tests::it_adds_two ... FAILED

failures:

---- tests::it_adds_two stdout ----
thread 'tests::it_adds_two' panicked at 'assertion failed: `(left == right)`
  left: `4`,
 right: `5`', src/lib.rs:11:9
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace


failures:
    tests::it_adds_two

test result: FAILED. 0 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

error: test failed, to rerun pass `--lib`
#+end_src

** –ü—Ä–æ–∏–∑–≤–æ—ô–Ω–∞ –∫–æ—Ä–∏—Å–Ω–∏—á–∫–∞ –ø–æ—Ä—É–∫–∞
#+begin_src rust
#[test]
    fn greeting_contains_name() {
        let result = greeting("Carol");
        assert!(
            result.contains("Carol"),
            "Greeting did not contain name, value was `{}`",
            result
        );
    }

#+end_src

#+REVEAL: split

#+begin_src sh
$ cargo test
   Compiling greeter v0.1.0 (file:///projects/greeter)
    Finished test [unoptimized + debuginfo] target(s) in 0.93s
     Running unittests src/lib.rs (target/debug/deps/greeter-170b942eb5bf5e3a)

running 1 test
test tests::greeting_contains_name ... FAILED

failures:

---- tests::greeting_contains_name stdout ----
thread 'tests::greeting_contains_name'
panicked at 'Greeting did not contain name, value was `Hello!`', src/lib.rs:12:9
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace


failures:
    tests::greeting_contains_name

test result: FAILED. 0 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out;
finished in 0.00s

error: test failed, to rerun pass `--lib`
#+end_src

** –ü—Ä–æ–≤–µ—Ä–∞ =should_panic=

#+begin_src rust
pub struct Guess {
    value: i32,
}

impl Guess {
    pub fn new(value: i32) -> Guess {
        if value < 1 || value > 100 {
            panic!("Guess value must be between 1 and 100, got {}.", value);
        }

        Guess { value }
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    #[should_panic]
    fn greater_than_100() {
        Guess::new(200);
    }
}
#+end_src

#+REVEAL: split

#+begin_src rust
impl Guess {
    pub fn new(value: i32) -> Guess {
        if value < 1 {
            panic!(
                "Guess value must be greater than or equal to 1, got {}.",
                value
            );
        } else if value > 100 {
            panic!(
                "Guess value must be less than or equal to 100, got {}.",
                value
            );
        }
        Guess { value }
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    #[test]
    #[should_panic(expected = "less than or equal to 100")]
    fn greater_than_100() {
        Guess::new(200);
    }
}
#+end_src
** –§–∏–ª—Ç—Ä–∏—Ä–∞—ö–µ —Ç–µ—Å—Ç–æ–≤–∞ –ø—Ä–∏ –ø–æ–∫—Ä–µ—Ç–∞—ö—É
#+begin_src rust
pub fn add_two(a: i32) -> i32 {
    a + 2
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn add_two_and_two() {
        assert_eq!(4, add_two(2));
    }

    #[test]
    fn add_three_and_two() {
        assert_eq!(5, add_two(3));
    }

    #[test]
    fn one_hundred() {
        assert_eq!(102, add_two(100));
    }
}
#+end_src

#+REVEAL: split

#+begin_src sh
$ cargo test one_hundred
   Compiling adder v0.1.0 (file:///projects/adder)
    Finished test [unoptimized + debuginfo] target(s) in 0.69s
     Running unittests src/lib.rs (target/debug/deps/adder-92948b65e88960b4)

running 1 test
test tests::one_hundred ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 2 filtered out; finished in 0.00s
#+end_src

#+REVEAL: split

#+begin_src sh
$ cargo test add
   Compiling adder v0.1.0 (file:///projects/adder)
    Finished test [unoptimized + debuginfo] target(s) in 0.61s
     Running unittests src/lib.rs (target/debug/deps/adder-92948b65e88960b4)

running 2 tests
test tests::add_three_and_two ... ok
test tests::add_two_and_two ... ok

test result: ok. 2 passed; 0 failed; 0 ignored; 0 measured; 1 filtered out; finished in 0.00s
#+end_src

* –ì–µ–Ω–µ—Ä–∏—á–∫–∏ —Ç–∏–ø–æ–≤–∏, –æ—Å–æ–±–∏–Ω–µ (/Traits/) –∏ –∂–∏–≤–æ—Ç–Ω–∏ –≤–µ–∫ (/Lifetimes/)
** –ì–µ–Ω–µ—Ä–∏—á–∫–∏ —Ç–∏–ø–æ–≤–∏ (/generics/)
*** –ì–µ–Ω–µ—Ä–∏—á–∫–∏ —Ç–∏–ø–æ–≤–∏ (/generics/)
- –ú–µ—Ö–∞–Ω–∏–∑–∞–º –∑–∞ –µ–ª–∏–º–∏–Ω–∞—Ü–∏—ò—É –¥—É–ø–ª–∏—Ä–∞—ö–∞ –∫–æ–¥–∞.
- –ì–µ–Ω–µ—Ä–∏—á–∫–∏ —Ç–∏–ø–æ–≤–∏ —Å—É –∞–ø—Å—Ç—Ä–∞–∫—Ç–Ω–µ –∑–∞–º–µ–Ω–µ –∑–∞ –∫–æ–Ω–∫—Ä–µ—Ç–Ω–µ —Ç–∏–ø–æ–≤–µ —É –¥—Ä—É–≥–µ –æ—Å–æ–±–∏–Ω–µ —É
  –≤—Ä–µ–º–µ –∏–∑–≤—Ä—à–∞–≤–∞—ö–∞.
- –û–º–æ–≥—É—õ–∞–≤–∞—ò—É –Ω–∞–º –¥–∞ –Ω–∞ –∞–ø—Å—Ç—Ä–∞–∫—Ç–∞–Ω –Ω–∞—á–∏–Ω –∏—Å–∫–∞–∂–µ–º–æ –æ—Å–æ–±–∏–Ω–µ —Ç–∏–ø–æ–≤–∞ –∏ —ö–∏—Ö–æ–≤–µ –≤–µ–∑–µ
  —Å–∞ –¥—Ä—É–≥–∏–º —Ç–∏–ø–æ–≤–∏–º–∞ –±–µ–∑ –∑–Ω–∞—ö–∞ –æ —Ç–æ–º–µ –∫–æ—ò–∏ —õ–µ —Å–µ –∫–æ–Ω–∫—Ä–µ—Ç–Ω–∏ —Ç–∏–ø–æ–≤–∏ –Ω–∞—õ–∏ –Ω–∞
  —ö–∏—Ö–æ–≤–æ–º –º–µ—Å—Ç—É —É –≤—Ä–µ–º–µ –∫–æ–º–ø–∞—ò–ª–∏—Ä–∞—ö–∞ –∏ –∏–∑–≤—Ä—à–∞–≤–∞—ö–∞ –∫–æ–¥–∞.
- –ù–∞ –ø—Ä–∏–º–µ—Ä —Ñ—É–Ω–∫—Ü–∏—ò–µ –º–æ–≥—É –ø—Ä–∏–º–∏—Ç–∏ –≥–µ–Ω–µ—Ä–∏—á–∫–µ –ø–∞—Ä–∞–º–µ—Ç—Ä–µ. –¢–∞–∫–æ—í–µ, —Å–ª–æ–∂–µ–Ω–∏ —Ç–∏–ø–æ–≤–∏
  –º–æ–≥—É –±–∏—Ç–∏ –ø–∞—Ä–∞–º–µ—Ç—Ä–∏–∑–æ–≤–∞–Ω–∏ –≥–µ–Ω–µ—Ä–∏—á–∫–∏–º —Ç–∏–ø–æ–≤–∏–º–∞ (–ø—Ä–∏–º–µ—Ä —ò–µ =Option<T>=).

*** –£–∫–ª–∞—ö–∞—ö–µ –¥—É–ø–ª–æ–≥ –∫–æ–¥–∞ —É–ø–æ—Ç—Ä–µ–±–æ–º —Ñ—É–Ω–∫—Ü–∏—ò–∞
#+begin_src rust
fn main() {
    let number_list = vec![34, 50, 25, 100, 65];

    let mut largest = number_list[0];

    for number in number_list {
        if number > largest {
            largest = number;
        }
    }

    println!("The largest number is {}", largest);
}
#+end_src

#+REVEAL: split

#+begin_src rust
fn main() {
    let number_list = vec![34, 50, 25, 100, 65];

    let mut largest = number_list[0];

    for number in number_list {
        if number > largest {
            largest = number;
        }
    }

    println!("The largest number is {}", largest);

    let number_list = vec![102, 34, 6000, 89, 54, 2, 43, 8];

    let mut largest = number_list[0];

    for number in number_list {
        if number > largest {
            largest = number;
        }
    }

    println!("The largest number is {}", largest);
}
#+end_src

–î—É–ø–ª–∏—Ä–∞—ö–µ –∫–æ–¥–∞!

#+REVEAL: split

–ï–ª–∏–º–∏–Ω–∏—à–µ–º–æ –¥—É–ø–ª–∏—Ä–∞—ö–µ —É–≤–æ—í–µ—ö–µ–º —Ñ—É–Ω–∫—Ü–∏—ò–µ.

#+begin_src rust
fn largest(list: &[i32]) -> i32 {
    let mut largest = list[0];

    for &item in list {
        if item > largest {
            largest = item;
        }
    }

    largest
}

fn main() {
    let number_list = vec![34, 50, 25, 100, 65];

    let result = largest(&number_list);
    println!("The largest number is {}", result);

    let number_list = vec![102, 34, 6000, 89, 54, 2, 43, 8];

    let result = largest(&number_list);
    println!("The largest number is {}", result);
}
#+end_src


#+REVEAL: split

–ü–æ—Å—Ç—É–ø–∞–∫ –µ–ª–∏–º–∏–Ω–∞—Ü–∏—ò–µ –¥—É–ø–ª–æ–≥ –∫–æ–¥–∞ —ò–µ –ø–æ–¥—Ä–∞–∑—É–º–µ–≤–∞–æ —Å–ª–µ–¥–µ—õ–µ:

1. –ò–¥–µ–Ω—Ç–∏—Ñ–∏–∫–∞—Ü–∏—ò–∞ –¥—É–ø–ª–æ–≥ –∫–æ–¥–∞.
2. –ï–∫—Å—Ç—Ä–∞–∫—Ü–∏—ò–∞ –∫–æ–¥–∞ —É —Ñ—É–Ω–∫—Ü–∏—ò—É, –¥–µ—Ñ–∏–Ω–∏—Å–∞—ö–µ –ø–∞—Ä–∞–º–µ—Ç–∞—Ä–∞ –∏ –ø–æ–≤—Ä–∞—Ç–Ω–µ –≤—Ä–µ–¥–Ω–æ—Å—Ç–∏.
3. –ó–∞–º–µ–Ω–∞ –∏–Ω—Å—Ç–∞–Ω—Ü–∏ –¥—É–ø–ª–æ–≥ –∫–æ–¥–∞ —Å–∞ –ø–æ–∑–∏–≤–æ–º —Ñ—É–Ω–∫—Ü–∏—ò–µ.

*** –£–∫–ª–∞—ö–∞—ö–µ –¥—É–ø–ª–æ–≥ –∫–æ–¥–∞ —É–ø–æ—Ç—Ä–µ–±–æ–º –≥–µ–Ω–µ—Ä–∏—á–∫–∏—Ö —Ñ—É–Ω–∫—Ü–∏—ò–∞
–ò–º–∞–º–æ —Ñ—É–Ω–∫—Ü–∏—ò—É –∑–∞ –ø—Ä–æ–Ω–∞–ª–∞–∂–µ—ö–µ –Ω–∞—ò–≤–µ—õ–µ–≥ –µ–ª–µ–º–µ–Ω—Ç–∞ —É –ª–∏—Å—Ç–∏ —Å–∞ —Ä–∞–∑–ª–∏—á–∏—Ç–∏–º —Ç–∏–ø–æ–≤–∏–º–∞.
#+begin_src rust
fn largest_i32(list: &[i32]) -> i32 {
    let mut largest = list[0];
    for &item in list {
        if item > largest {
            largest = item;
        }
    }
    largest
}
fn largest_char(list: &[char]) -> char {
    let mut largest = list[0];
    for &item in list {
        if item > largest {
            largest = item;
        }
    }
    largest
}
fn main() {
    let number_list = vec![34, 50, 25, 100, 65];
    let result = largest_i32(&number_list);
    println!("The largest number is {}", result);
    let char_list = vec!['y', 'm', 'a', 'q'];
    let result = largest_char(&char_list);
    println!("The largest char is {}", result);
}
#+end_src

#+REVEAL: split

–§—É–Ω–∫—Ü–∏—ò–µ —Å—É –≥–æ—Ç–æ–≤–æ –∏–¥–µ–Ω—Ç–∏—á–Ω–µ. –†–∞–∑–ª–∏–∫–∞ —ò–µ —Å–∞–º–æ —É —Ç–∏–ø—É. –ü–∏—à–µ–º–æ –≥–µ–Ω–µ—Ä–∏—á–∫—É —Ñ—É–Ω–∫—Ü–∏—ò—É
—Ç–∞–∫–æ —à—Ç–æ –¥–µ—Ñ–∏–Ω–∏—à–µ–º–æ –≥–µ–Ω–µ—Ä–∏—á–∫–∏ —Ç–∏–ø —É–Ω—É—Ç–∞—Ä =<>= –ø–æ—Å–ª–µ –Ω–∞–∑–∏–≤–∞ —Ñ—É–Ω–∫—Ü–∏—ò–µ:

#+begin_src rust
fn largest<T>(list: &[T]) -> T {
#+end_src

=T= —ò–µ –≥–µ–Ω–µ—Ä–∏—á–∫–∏ —Ç–∏–ø –∏ —É –≤—Ä–µ–º–µ –∫–æ–º–ø–∞—ò–ª–∏—Ä–∞—ö–∞ –±–∏—õ–µ –∑–∞–º–µ—ö–µ–Ω —Å–∞ –∫–æ–Ω–∫—Ä–µ—Ç–Ω–∏–º —Ç–∏–ø–æ–º.

#+REVEAL: split

–°–∞–¥–∞ —ò–µ –Ω–∞—à –∫–æ–¥ —Å–ª–µ–¥–µ—õ–∏:

#+begin_src rust
fn largest<T>(list: &[T]) -> T {
    let mut largest = list[0];

    for &item in list {
        if item > largest {
            largest = item;
        }
    }

    largest
}

fn main() {
    let number_list = vec![34, 50, 25, 100, 65];

    let result = largest(&number_list);
    println!("The largest number is {}", result);

    let char_list = vec!['y', 'm', 'a', 'q'];

    let result = largest(&char_list);
    println!("The largest char is {}", result);
}
#+end_src

#+REVEAL: split

–ê–ª–∏ —Å–µ –Ω–µ –∫–æ–º–ø–∞—ò–ª–∏—Ä–∞.

#+begin_src rust
$ cargo run
   Compiling chapter10 v0.1.0 (file:///projects/chapter10)
error[E0369]: binary operation `>` cannot be applied to type `T`
 --> src/main.rs:5:17
  |
5 |         if item > largest {
  |            ---- ^ ------- T
  |            |
  |            T
  |
help: consider restricting type parameter `T`
  |
1 | fn largest<T: std::cmp::PartialOrd>(list: &[T]) -> T {
  |             ++++++++++++++++++++++

For more information about this error, try `rustc --explain E0369`.
error: could not compile `chapter10` due to previous error
#+end_src

–¢–∏–ø =T= –º–æ–∂–µ –±–∏—Ç–∏ –±–∏–ª–æ –∫–æ—ò–∏ —Ç–∏–ø –ø–∞ –∏ —Ç–∏–ø –∫–æ—ò–∏ –Ω–µ –¥–µ—Ñ–∏–Ω–∏—à–µ –æ–ø–µ—Ä–∞—Ü–∏—ò—É =>= –∫–æ—ò–∞ —Å–µ
–∫–æ—Ä–∏—Å—Ç–∏ —É –∫–æ–¥—É. –î–∞–∫–ª–µ, –º–æ—Ä–∞–º–æ –æ–≥—Ä–∞–Ω–∏—á–∏—Ç–∏ –∫–æ—ò–∏ —Ç–∏–ø–æ–≤–∏ —Å—É –º–æ–≥—É—õ–∏.

–í–∏–¥–µ—õ–µ–º–æ –∫–∞–∫–æ —Å–µ –æ–≤–æ —Ä–∞–¥–∏ —É –Ω–∞—Å—Ç–∞–≤–∫—É —É –ø—Ä–∏—á–∏ –æ –æ—Å–æ–±–∏–Ω–∞–º–∞ (/Traits/).

*** –ì–µ–Ω–µ—Ä–∏—á–∫–∏ —Ç–∏–ø–æ–≤–∏ —É —Å—Ç—Ä—É–∫—Ç—É—Ä–∞–º–∞
#+begin_src rust
struct Point<T> {
    x: T,
    y: T,
}

fn main() {
    let integer = Point { x: 5, y: 10 };
    let float = Point { x: 1.0, y: 4.0 };
}
#+end_src

#+REVEAL: split

–¢–∏–ø–æ–≤–∏ –æ–±–∞ –ø–æ—ô–∞ –º–æ—Ä–∞—ò—É –±–∏—Ç–∏ –∏—Å—Ç–∏.

#+begin_src rust
struct Point<T> {
    x: T,
    y: T,
}

fn main() {
    let wont_work = Point { x: 5, y: 4.0 };
}
#+end_src

#+begin_example
$ cargo run
   Compiling chapter10 v0.1.0 (file:///projects/chapter10)
error[E0308]: mismatched types
 --> src/main.rs:7:38
  |
7 |     let wont_work = Point { x: 5, y: 4.0 };
  |                                      ^^^ expected integer, found floating-point number

For more information about this error, try `rustc --explain E0308`.
error: could not compile `chapter10` due to previous error
#+end_example

#+REVEAL: split

–ê–∫–æ –∂–µ–ª–∏–º–æ –¥–∞ –ø–æ—ô–∞ –∏–º–∞—ò—É —Ä–∞–∑–ª–∏—á–∏—Ç–µ —Ç–∏–ø–æ–≤–µ –æ–Ω–¥–∞ –º–æ—Ä–∞–º–æ –∏–º–∞—Ç–∏ —Ä–∞–∑–ª–∏—á–∏—Ç–µ –≥–µ–Ω–µ—Ä–∏—á–∫–µ —Ç–∏–ø–æ–≤–µ.

#+begin_src rust
struct Point<T, U> {
    x: T,
    y: U,
}

fn main() {
    let both_integer = Point { x: 5, y: 10 };
    let both_float = Point { x: 1.0, y: 4.0 };
    let integer_and_float = Point { x: 5, y: 4.0 };
}
#+end_src

*** –ì–µ–Ω–µ—Ä–∏—á–∫–∏ —Ç–∏–ø–æ–≤–∏ —É –µ–Ω—É–º–µ—Ä–∞—Ü–∏—ò–∞–º–∞
#+begin_src rust
enum Option<T> {
    Some(T),
    None,
}
#+end_src

#+REVEAL: split

#+begin_src rust
enum Result<T, E> {
    Ok(T),
    Err(E),
}
#+end_src

*** –î–µ—Ñ–∏–Ω–∏—Ü–∏—ò–µ –º–µ—Ç–æ–¥–∞
#+begin_src rust
struct Point<T> {
    x: T,
    y: T,
}

impl<T> Point<T> {
    fn x(&self) -> &T {
        &self.x
    }
}

fn main() {
    let p = Point { x: 5, y: 10 };

    println!("p.x = {}", p.x());
}
#+end_src

–ü–æ—à—Ç–æ —Å–º–æ –Ω–∞–≤–µ–ª–∏ =<T>= –∏–∑–∞ –∫—ô—É—á–Ω–µ —Ä–µ—á–∏ =impl= –†–∞—Å—Ç –¥–∞—ô–µ –∑–Ω–∞ –¥–∞ —ò–µ —Ç–∏–ø =T= –≥–µ–Ω–µ—Ä–∏—á–∫–∏
–∞ –Ω–µ –∫–æ–Ω–∫—Ä–µ—Ç–Ω–∏ —Ç–∏–ø —Ç–∞–∫–æ –¥–∞ —ò–µ –º–µ—Ç–æ–¥–∞ =x= –∑–∞ =Point<T>= –¥–µ—Ñ–∏–Ω–∏—Å–∞–Ω–∞ –Ω–∞–¥ —Å–≤–∏–º —Ç–∏–ø–æ–≤–∏–º–∞
=T=.

#+REVEAL: split

–ú–æ–≥–ª–∏ —Å–º–æ –Ω–ø—Ä. –º–µ—Ç–æ–¥—É –¥–µ—Ñ–∏–Ω–∏—Å–∞—Ç–∏ —Å–∞–º–æ –∑–∞ –æ–¥—Ä–µ—í–µ–Ω–∏ =Point= —Ç–∏–ø.

#+begin_src rust
impl Point<f32> {
    fn distance_from_origin(&self) -> f32 {
        (self.x.powi(2) + self.y.powi(2)).sqrt()
    }
}
#+end_src

–û–≤–∞—ò =impl= –±–ª–æ–∫ –¥–µ—Ñ–∏–Ω–∏—à–µ –º–µ—Ç–æ–¥—É =distance_from_origin= –∞–ª–∏ —Å–∞–º–æ –∑–∞ =Point<f32>= –¥–æ–∫
–æ—Å—Ç–∞–ª–∏ =Point= —Ç–∏–ø–æ–≤–∏ –Ω–µ—õ–µ –∏–º–∞—Ç–∏ –æ–≤—É –º–µ—Ç–æ–¥—É.

*** –ì–µ–Ω–µ—Ä–∏—á–∫–∏ —Ç–∏–ø–æ–≤–∏ —É –º–µ—Ç–æ–¥–∞–º–∞ –∏ =impl= –±–ª–æ–∫–æ–≤–∏–º–∞
–ì–µ–Ω–µ—Ä–∏—á–∫–∏ —Ç–∏–ø–æ–≤–∏ —É —Å—Ç—Ä—É–∫—Ç—É—Ä–∞–º–∞ –∏ –º–µ—Ç–æ–¥–∞–º–∞ –Ω–µ –º–æ—Ä–∞—ò—É –±–∏—Ç–∏ –∏—Å—Ç–∏. –ù–∞ –ø—Ä–∏–º–µ—Ä, –º–æ–∂–µ–º–æ
–∫—Ä–µ–∏—Ä–∞—Ç–∏ –º–µ—Ç–æ–¥—É =mixup= –∫–æ—ò–∞ —É–∑–∏–º–∞ –¥–≤–µ –∏–Ω—Å—Ç–∞–Ω—Ü–µ =Point= –∏ –≤—Ä–∞—õ–∞ –Ω–æ–≤–∏ =Point= —Ç–∏–ø –≥–¥–µ
—õ–µ –ø—Ä–≤–æ –ø–æ—ô–µ –∏–º–∞—Ç–∏ –∏—Å—Ç–∏ —Ç–∏–ø –∫–∞–æ –ø—Ä–≤–∞ —Ç–∞—á–∫–∞ –∞ –¥—Ä—É–≥–æ –ø–æ—ô–µ –∫–∞–æ –¥—Ä—É–≥–∞ —Ç–∞—á–∫–∞.

#+begin_src rust
struct Point<X1, Y1> {
    x: X1,
    y: Y1,
}

impl<X1, Y1> Point<X1, Y1> {
    fn mixup<X2, Y2>(self, other: Point<X2, Y2>) -> Point<X1, Y2> {
        Point {
            x: self.x,
            y: other.y,
        }
    }
}

fn main() {
    let p1 = Point { x: 5, y: 10.4 };
    let p2 = Point { x: "Hello", y: 'c' };
    let p3 = p1.mixup(p2);
    println!("p3.x = {}, p3.y = {}", p3.x, p3.y);
}
#+end_src

- –ì–µ–Ω–µ—Ä–∏—á–∫–∏ —Ç–∏–ø–æ–≤–∏ =X2= –∏ =Y2= —Å—É –Ω–∞–≤–µ–¥–µ–Ω–∏ —Å–∞–º–æ —É –º–µ—Ç–æ–¥–∏ —ò–µ—Ä —Å—É —Ä–µ–ª–µ–≤–∞–Ω—Ç–Ω–∏ —Å–∞–º–æ —É
  —ö–µ–Ω–æ–º –∫–æ–Ω—Ç–µ–∫—Å—Ç—É.

*** –ü–µ—Ä—Ñ–æ—Ä–º–∞–Ω—Å–µ
–£–ø–æ—Ç—Ä–µ–±–∞ –≥–µ–Ω–µ—Ä–∏—á–∫–æ–≥ –∫–æ–¥–∞ –Ω–µ –¥–æ–≤–æ–¥–∏ –¥–æ –¥–µ–≥—Ä–∞–¥–∞—Ü–∏—ò–µ –ø–µ—Ä—Ñ–æ—Ä–º–∞–Ω—Å–∏. –†–∞—Å—Ç –∫–æ—Ä–∏—Å—Ç–∏
—Ç–µ—Ö–Ω–∏–∫—É –º–æ–Ω–æ–º–æ—Ä—Ñ–∏–∑–∞—Ü–∏—ò–µ (/Monomorphization/) –∫–æ–¥ –∫–æ—ò–µ —õ–µ –∫–æ–º–ø–∞—ò–ª–µ—Ä –∏–Ω—Å—Ç–∞–Ω—Ü–∏—Ä–∞—Ç–∏
–∫–æ–Ω–∫—Ä–µ—Ç–∞–Ω –∫–æ–¥ –∑–∞ —Å–≤–∞–∫–∏ —Ç–∏–ø –ø–æ—Å–µ–±–Ω–æ.

–¢–æ –±–∏ –∑–Ω–∞—á–∏–ª–æ —Å–ª–µ–¥–µ—õ–µ. –ê–∫–æ –∏–º–∞–º–æ –∫–æ–¥:

#+begin_src rust
let integer = Some(5);
let float = Some(5.0)
#+end_src

–ö–æ–º–ø–∞—ò–ª–µ—Ä —õ–µ –ø—Ä–æ–∏–∑–≤–µ—Å—Ç–∏ –∫–æ–¥ –µ–∫–≤–∏–≤–∞–ª–µ–Ω—Ç–∞–Ω —Å–ª–µ–¥–µ—õ–µ–º:
#+begin_src rust
enum Option_i32 {
    Some(i32),
    None,
}

enum Option_f64 {
    Some(f64),
    None,
}

fn main() {
    let integer = Option_i32::Some(5);
    let float = Option_f64::Some(5.0);
}
#+end_src
** –û—Å–æ–±–∏–Ω–µ (/Traits/) - –¥–µ—Ñ–∏–Ω–∏—Å–∞—ö–µ –∑–∞—ò–µ–¥–Ω–∏—á–∫–æ–≥ –ø–æ–Ω–∞—à–∞—ö–∞
*** –û—Å–æ–±–∏–Ω–µ (/Traits/)
- –û—Å–æ–±–∏–Ω–∞ –¥–µ—Ñ–∏–Ω–∏—à–µ —Ñ—É–Ω–∫—Ü–∏–æ–Ω–∞–ª–Ω–æ—Å—Ç –∫–æ—ò—É —Ç–∏–ø –º–æ–∂–µ –¥–µ–ª–∏—Ç–∏ —Å–∞ –¥—Ä—É–≥–∏–º —Ç–∏–ø–æ–≤–∏–º–∞.
- –£ –¥—Ä—É–≥–∏–º —ò–µ–∑–∏—Ü–∏–º–∞ —Å–ª–∏—á–∞–Ω –∫–æ–Ω—Ü–µ–ø—Ç –Ω–∞–∑–∏–≤–∞ —Å–µ –∏–Ω—Ç–µ—Ä—Ñ–µ—ò—Å.
- –ú–æ–∂–µ–º–æ –∫–æ—Ä–∏—Å—Ç–∏—Ç–∏ /–æ–≥—Ä–∞–Ω–∏—á–µ—ö–∞ –∫—Ä–æ–∑ –æ—Å–æ–±–∏–Ω–µ/ (/Trait bounds/) –¥–∞ –¥–µ—Ñ–∏–Ω–∏—à–µ–º–æ –¥–∞
  –≥–µ–Ω–µ—Ä–∏—á–∫–∏ —Ç–∏–ø –º–æ—Ä–∞ –∑–∞–¥–æ–≤–æ—ô–∏—Ç–∏ –æ–¥—Ä–µ—í–µ–Ω–∞ –æ–≥—Ä–∞–Ω–∏—á–µ—ö–∞.

*** –î–µ—Ñ–∏–Ω–∏—Å–∞—ö–µ –æ—Å–æ–±–∏–Ω–∞
- –ü—Ä–∏–º–µ—Ä –¥–µ—Ñ–∏–Ω–∏—Å–∞—ö–∞ /media aggregator/ –±–∏–±–ª–∏–æ—Ç–µ–∫–µ –∫–æ—ò–∞ –º–æ–∂–µ –¥–∞ –ø—Ä–∏–∫–∞–∑–µ —Å–∞–∂–µ—Ç–∞–∫
  –ø–æ–¥–∞—Ç–∞–∫–∞ –∫–æ—ò–∏ —Å–µ –º–æ–∂–µ —á—É–≤–∞—Ç–∏ —É =NewsArticle= –∏–ª–∏ =Tweet= –∏–Ω—Å—Ç–∞–Ω—Ü–∏.
- –î–µ—Ñ–∏–Ω–∏—à–µ–º–æ =Summary= –æ—Å–æ–±–∏–Ω—É –¥–∞ –æ–ø–∏—à–µ–º–æ –æ–≤—É —Ñ—É–Ω–∫—Ü–∏–æ–Ω–∞–ª–Ω–æ—Å—Ç.

#+begin_src rust
pub trait Summary {
    fn summarize(&self) -> String;
}
#+end_src

*** –ò–º–ø–ª–µ–º–µ–Ω—Ç–∞—Ü–∏—ò–∞ –æ—Å–æ–±–∏–Ω–∞
#+begin_src rust
pub struct NewsArticle {
    pub headline: String,
    pub location: String,
    pub author: String,
    pub content: String,
}

impl Summary for NewsArticle {
    fn summarize(&self) -> String {
        format!("{}, by {} ({})", self.headline, self.author, self.location)
    }
}

pub struct Tweet {
    pub username: String,
    pub content: String,
    pub reply: bool,
    pub retweet: bool,
}

impl Summary for Tweet {
    fn summarize(&self) -> String {
        format!("{}: {}", self.username, self.content)
    }
}
#+end_src

#+REVEAL: split

–ú–µ—Ç–æ–¥–µ –æ—Å–æ–±–∏–Ω–∞ —Å–µ –ø–æ–∑–∏–≤–∞—ò—É –∫–∞–æ –∏ –æ–±–∏—á–Ω–µ –º–µ—Ç–æ–¥–µ. –à–µ–¥–∏–Ω–∞ —Ä–∞–∑–ª–∏–∫–∞ —ò–µ —É —Ç–æ–º–µ —à—Ç–æ
–º–µ—Ç–æ–¥–µ –æ—Å–æ–±–∏–Ω–∞ –º–æ—Ä–∞—ò—É –±–∏—Ç–∏ –¥–æ—Å—Ç—É–ø–Ω–µ —É –æ–ø—Å–µ–≥—É (—É–∫—ô—É—á–∏—Ç–∏ –∏—Ö —Å–∞ =use=).

#+begin_src rust
use aggregator::{Summary, Tweet};

fn main() {
    let tweet = Tweet {
        username: String::from("horse_ebooks"),
        content: String::from(
            "of course, as you probably already know, people",
        ),
        reply: false,
        retweet: false,
    };

    println!("1 new tweet: {}", tweet.summarize());
}
#+end_src

#+REVEAL: split

#+begin_note
–û–≥—Ä–∞–Ω–∏—á–µ—ö–µ —É —É–ø–æ—Ç—Ä–µ–±–∏ –æ—Å–æ–±–∏–Ω–∞ —ò–µ –¥–∞ –º–æ–∂–µ–º–æ –∏–º–ø–ª–µ–º–µ–Ω—Ç–∏—Ä–∞—Ç–∏ –æ—Å–æ–±–∏–Ω—É –Ω–∞–¥ —Ç–∏–ø–æ–º
—ò–µ–¥–∏–Ω–æ –∞–∫–æ —ò–µ –±–∞—Ä —ò–µ–¥–Ω–æ –æ–¥ —ö–∏—Ö –ª–æ–∫–∞–ª–Ω–æ –∑–∞ –Ω–∞—à —Å–∞–Ω–¥—É–∫. –û–≤–æ –ø—Ä–∞–≤–∏–ª–æ —ò–µ –¥–µ–æ —Å–∫—É–ø–∞
–ø—Ä–∞–≤–∏–ª–∞ –∫–æ—ò–∏ —Å–µ –Ω–∞–∑–∏–≤–∞—ò—É /coherence/. –ö–æ–Ω–∫—Ä–µ—Ç–Ω–æ –æ–≤–æ –ø—Ä–∞–≤–∏–ª–æ –∑–æ–≤–µ —Å–µ /orphan rule/ –∏
—Å–ø—Ä–µ—á–∞–≤–∞ –Ω–µ–∫–æ–º–ø–∞—Ç–∏–±–∏–ª–Ω–µ –∏–º–ø–ª–µ–º–µ–Ω—Ç–∞—Ü–∏—ò–µ –æ—Å–æ–±–∏–Ω–∞ –Ω–∞–¥ —Ç–∏–ø–æ–≤–∏–º–∞ –æ–¥ —Å—Ç—Ä–∞–Ω–µ –≤–∏—à–µ
—Å–∞–Ω–¥—É–∫–∞.

–ë–µ–∑ –æ–≤–æ–≥ –ø—Ä–∞–≤–∏–ª–∞ –º–æ–≥–ª–æ –±–∏ —Å–µ –¥–µ—Å–∏—Ç–∏ –¥–∞ –¥–≤–∞ —Ä–∞–∑–ª–∏—á–∏—Ç–∞ —Å–∞–Ω–¥—É–∫–∞ –∏–º–ø–ª–µ–º–µ–Ω—Ç–∏—Ä–∞—ò—É –∏—Å—Ç—É
–æ—Å–æ–±–∏–Ω—É –Ω–∞–¥ –∏—Å—Ç–∏–º —Ç–∏–ø–æ–º –Ω–∞ —Ä–∞–∑–ª–∏—á–∏—Ç–µ –Ω–∞—á–∏–Ω–µ –∏ –∫–æ–º–ø–∞—ò–ª–µ—Ä –Ω–µ –±–∏ –∑–Ω–∞–æ –∫–æ—ò—É –≤–µ—Ä–∑–∏—ò—É
–¥–∞ –∫–æ—Ä–∏—Å—Ç–∏.
#+end_note
*** –ü–æ–¥—Ä–∞–∑—É–º–µ–≤–∞–Ω–∞ –∏–º–ø–ª–µ–º–µ–Ω—Ç–∞—Ü–∏—ò–∞
–û—Å–æ–±–∏–Ω–∞ –º–æ–∂–µ –∏–º–∞—Ç–∏ –ø–æ–¥—Ä–∞–∑—É–º–µ–≤–∞–Ω—É –∏–º–ø–ª–µ–º–µ–Ω—Ç–∞—Ü–∏—ò—É –º–µ—Ç–æ–¥–∞.

#+begin_src rust
pub trait Summary {
    fn summarize(&self) -> String {
        String::from("(Read more...)")
    }
}
#+end_src

–î–∞ –±–∏ –∫–æ—Ä–∏—Å—Ç–∏–ª–∏ –ø–æ–¥—Ä–∞–∑—É–º–µ–≤–∞–Ω—É –∏–º–ø–ª–µ–º–µ–Ω—Ç–∞—Ü–∏—ò—É –º–æ–∂–µ–º–æ –Ω–∞–≤–µ—Å—Ç–∏ –ø—Ä–∞–∑–Ω–æ —Ç–µ–ª–æ —É =impl=
–±–ª–æ–∫—É:

#+begin_src rust
impl Summary for NewsArticle {}
#+end_src

#+REVEAL: split

–ò –∑–∞—Ç–∏–º –º–æ–∂–µ–º–æ –ø–æ–∑–≤–∞—Ç–∏ =summarize= –º–µ—Ç–æ–¥—É:

#+begin_src rust
let article = NewsArticle {
        headline: String::from("Penguins win the Stanley Cup Championship!"),
        location: String::from("Pittsburgh, PA, USA"),
        author: String::from("Iceburgh"),
        content: String::from(
            "The Pittsburgh Penguins once again are the best \
             hockey team in the NHL.",
        ),
    };

    println!("New article available! {}", article.summarize());
#+end_src

#+REVEAL: split

- –ü–æ–¥—Ä–∞–∑—É–º–µ–≤–∞–Ω–∞ –∏–º–ø–ª–µ–º–µ–Ω—Ç–∞—Ü–∏—ò–∞ –º–æ–∂–µ –±–∏—Ç–∏ —Ä–µ–¥–µ—Ñ–∏–Ω–∏—Å–∞–Ω–∞ –ø—Ä–∏–ª–∏–∫–æ–º –∏–º–ø–ª–µ–º–µ–Ω—Ç–∞—Ü–∏—ò–µ.
- –¢–∞–∫–æ—í–µ, –ø–æ–¥—Ä–∞–∑—É–º–µ–≤–∞–Ω–µ –º–µ—Ç–æ–¥–µ –º–æ–≥—É –ø–æ–∑–∏–≤–∞—Ç–∏ –¥—Ä—É–≥–µ –º–µ—Ç–æ–¥–µ.

#+begin_src rust
pub trait Summary {
    fn summarize_author(&self) -> String;

    fn summarize(&self) -> String {
        format!("(Read more from {}...)", self.summarize_author())
    }
}
#+end_src

–°–∞–¥–∞ —ò–µ –ø–æ—Ç—Ä–µ–±–Ω–æ –∏ –¥–æ–≤–æ—ô–Ω–æ –¥–∞ –ø—Ä–∏–ª–∏–∫–æ–º –∏–º–ø–ª–µ–º–µ–Ω—Ç–∞—Ü–∏—ò–µ –¥–µ—Ñ–∏–Ω–∏—à–µ–º–æ
=summarize_author= –º–µ—Ç–æ–¥—É:

#+begin_src rust
impl Summary for Tweet {
    fn summarize_author(&self) -> String {
        format!("@{}", self.username)
    }
}
#+end_src
*** –û—Å–æ–±–∏–Ω–µ –∫–∞–æ –ø–∞—Ä–∞–º–µ—Ç—Ä–∏
- –°–∞–¥–∞ –º–æ–∂–µ–º–æ –∫–æ—Ä–∏—Å—Ç–∏—Ç–∏ –æ—Å–æ–±–∏–Ω–µ –¥–∞ –¥–µ—Ñ–∏–Ω–∏—à–µ–º–æ —Ñ—É–Ω–∫—Ü–∏—ò–µ –∫–æ—ò–µ —Ä–∞–¥–µ –Ω–∞–¥ –ø–∞—Ä–∞–º–µ—Ç—Ä–∏–º–∞
  —Ä–∞–∑–ª–∏—á–∏—Ç–æ–≥ —Ç–∏–ø–∞.

#+begin_src rust
pub fn notify(item: &impl Summary) {
    println!("Breaking news! {}", item.summarize());
}
#+end_src

–§—É–Ω–∫—Ü–∏—ò–∞ =notify= —Ä–∞–¥–∏ –Ω–∞–¥ —Å–≤–∏–º —Ç–∏–ø–æ–≤–∏–º–∞ –∫–æ—ò–∏ –∏–º–ø–ª–µ–º–µ–Ω—Ç–∏—Ä–∞—ò—É =Summary=.

#+REVEAL: split

–ü—Ä–µ—Ç—Ö–æ–¥–Ω–∞ —É–ø–æ—Ç—Ä–µ–±–∞ =impl= –∫–æ–¥ –ø–∞—Ä–∞–º–µ—Ç—Ä–∞ —ò–µ —Å–∏–Ω—Ç–∞–∫—Å–Ω–∏ —à–µ—õ–µ—Ä –∑–∞ –æ–ø—à—Ç–∏ –æ–±–ª–∏–∫
–Ω–∞–≤–æ—í–µ—ö–∞ –æ–≥—Ä–∞–Ω–∏—á–µ—ö–∞ –∫—Ä–æ–∑ –æ—Å–æ–±–∏–Ω–µ.

#+begin_src rust
pub fn notify<T: Summary>(item: &T) {
    println!("Breaking news! {}", item.summarize());
}
#+end_src

–û–≥—Ä–∞–Ω–∏—á–µ—ö–∞ –∫—Ä–æ–∑ –æ—Å–æ–±–∏–Ω–µ (/Trait bounds/) —Å—Ç–∞–≤—ô–∞–º–æ –ø–æ—Å–ª–µ –¥–≤–æ—Ç–∞—á–∫–µ –∫–æ–¥ –Ω–∞–≤–æ—í–µ—ö–∞
–≥–µ–Ω–µ—Ä–∏—á–∫–æ–≥ —Ç–∏–ø–∞. –ö–æ–º–ø–∞—ò–ª–µ—Ä —õ–µ –≤–µ—Ä–∏—Ñ–∏–∫–æ–≤–∞—Ç–∏ –¥–∞ —Å–≤–µ —à—Ç–æ –∫–æ—Ä–∏—Å—Ç–∏–º–æ –Ω–∞–¥ –≤—Ä–µ–¥–Ω–æ—Å—Ç–∏–º–∞
–æ–≤–æ–≥ —Ç–∏–ø–∞ —É–Ω—É—Ç–∞—Ä —Ñ—É–Ω–∫—Ü–∏—ò–µ —ò–µ –∑–∞–∏—Å—Ç–∞ –¥–µ—Ñ–∏–Ω–∏—Å–∞–Ω–æ –æ—Å–æ–±–∏–Ω–∞–º–∞ –Ω–∞–≤–µ–¥–µ–Ω–∏–º —É –∑–∞–≥–ª–∞–≤—ô—É.

#+REVEAL: split

=impl Trait= —Å–∏–Ω—Ç–∞–∫—Å–µ —ò–µ –∫–æ–Ω—Ü–∏–∑–Ω–∏—ò–∞ –∫–æ–¥ —ò–µ–¥–Ω–æ—Å—Ç–∞–≤–Ω–∏—Ö –ø—Ä–∏–º–µ—Ä–∞ –∞–ª–∏ —ò–µ –ø—É–Ω–∞ —Å–∏–Ω—Ç–∞–∫—Å–∞
–±–æ—ô–∞ –∫–æ–¥ —Å–ª–æ–∂–µ–Ω–∏—ò–∏—Ö –ø—Ä–∏–º–µ—Ä–∞.

–ù–∞ –ø—Ä–∏–º–µ—Ä:

#+begin_src rust
pub fn notify(item1: &impl Summary, item2: &impl Summary) {
#+end_src

–±–∏ —É –ø—É–Ω–æ—ò —Å–∏–Ω—Ç–∞–∫—Å–∏ –±–∏–ª–æ:

#+begin_src rust
pub fn notify<T: Summary>(item1: &T, item2: &T) {
#+end_src

*** –í–∏—à–µ—Å—Ç—Ä—É–∫–µ –æ—Å–æ–±–∏–Ω–µ –∫–æ–¥ –æ–≥—Ä–∞–Ω–∏—á–µ—ö–∞
–ú–æ–∂–µ–º–æ –¥–µ—Ñ–∏–Ω–∏—Å–∞—Ç–∏ –∏ –≤–∏—à–µ –æ–≥—Ä–∞–Ω–∏—á–µ—ö–∞ —É–ø–æ—Ç—Ä–µ–±–æ–º =+= —Å–∏–Ω—Ç–∞–∫—Å–µ. –ù–∞ –ø—Ä–∏–º–µ—Ä, –∞–∫–æ
–ø–∞—Ä–∞–º–µ—Ç–∞—Ä –º–æ—Ä–∞ –¥–∞ –∏–º–ø–ª–µ–º–µ–Ω—Ç–∏—Ä–∞ =Summary= –∏ =Display=:
#+begin_src rust
pub fn notify(item: &(impl Summary + Display)) {
#+end_src

–∏–ª–∏ —É –ø—É–Ω–æ—ò —Å–∏–Ω—Ç–∞–∫—Å–∏:

#+begin_src rust
pub fn notify<T: Summary + Display>(item: &T) {
#+end_src

*** =where= –∫–ª–∞—É–∑—É–ª–∞ —É –æ–≥—Ä–∞–Ω–∏—á–µ—ö–∏–º–∞
- –£–∫–æ–ª–∏–∫–æ –∏–º–∞–º–æ –≤–∏—à–µ –æ–≥—Ä–∞–Ω–∏—á–µ—ö–∞ –æ—Å–Ω–æ–≤–Ω–∞ —Å–∏–Ω—Ç–∞–∫—Å–∞ –º–æ–∂–µ –¥–∞ —Å–º–∞—ö–∏ —á–∏—Ç–∫–æ—Å—Ç.

#+begin_src rust
fn some_function<T: Display + Clone, U: Clone + Debug>(t: &T, u: &U) -> i32 {
#+end_src

- =where= –∫–ª–∞—É–∑—É–ª–∞ –∏–∑–º–µ—à—Ç–∞ –¥–µ—Ñ–∏–Ω–∏—Å–∞—ö–µ –æ–≥—Ä–∞–Ω–∏—á–µ—ö–∞ –ø–æ—Å–ª–µ –∑–∞–≥–ª–∞–≤—ô–∞ —Ñ—É–Ω–∫—Ü–∏—ò–µ —á–∏–º–µ
  —Å–µ –ø–æ—Å—Ç–∏–∂–µ –±–æ—ô–∞ —á–∏—Ç–∫–æ—Å—Ç:

#+begin_src rust
fn some_function<T, U>(t: &T, u: &U) -> i32
    where T: Display + Clone,
          U: Clone + Debug
{
#+end_src

*** =impl Trait= –∫–∞–æ –ø–æ–≤—Ä–∞—Ç–Ω–∞ –≤—Ä–µ–¥–Ω–æ—Å—Ç —Ñ—É–Ω–∫—Ü–∏—ò–µ
#+begin_src rust
fn returns_summarizable() -> impl Summary {
    Tweet {
        username: String::from("horse_ebooks"),
        content: String::from(
            "of course, as you probably already know, people",
        ),
        reply: false,
        retweet: false,
    }
}
#+end_src

–ü–æ—Å–µ–±–Ω–æ –∑–Ω–∞—á–∞—ò–Ω–æ —É –∫–æ–Ω—Ç–µ–∫—Å—Ç—É –∑–∞—Ç–≤–æ—Ä–µ—ö–∞ (/closures/) –∏ –∏—Ç–µ—Ä–∞—Ç–æ—Ä–∞ –≥–¥–µ —ò–µ –∫–æ–Ω–∫—Ä–µ—Ç–∞–Ω
—Ç–∏–ø –ø—Ä–µ–≤–∏—à–µ —Å–ª–æ–∂–µ–Ω –∑–∞ –ø–∏—Å–∞—ö–µ –∏–ª–∏ —ò–µ –ø–æ–∑–Ω–∞—Ç —Å–∞–º–æ –∫–æ–º–ø–∞—ò–ª–µ—Ä—É.

#+begin_note
=impl Trait= —Å–∏–Ω—Ç–∞–∫—Å–∞ –∑–∞ –ø–æ–≤—Ä–∞—Ç–Ω–µ –≤—Ä–µ–¥–Ω–æ—Å—Ç–∏ —ò–µ –º–æ–≥—É—õ–∞ —Å–∞–º–æ –∞–∫–æ —Ñ—É–Ω–∫—Ü–∏—ò–∞ –≤—Ä–∞—õ–∞
—ò–µ–¥–∞–Ω —Ç–∏–ø –∫–æ—ò–∏ –∏–º–ø–ª–µ–º–µ–Ω—Ç–∏—Ä–∞ –¥–∞—Ç—É –æ—Å–æ–±–∏–Ω—É. –ù–∞ –ø—Ä–∏–º–µ—Ä, –æ–≤–∞ —Ñ—É–Ω–∫—Ü–∏—ò–∞ –Ω–µ—õ–µ —Ä–∞–¥–∏—Ç–∏
–∞–∫–æ —Ñ—É–Ω–∫—Ü–∏—ò–∞ –º–æ–∂–µ –≤—Ä–∞—Ç–∏—Ç–∏ =NewsArticle= –∏–ª–∏ =Tweet=.
#+end_note

*** –ü–æ–ø—Ä–∞–≤–∫–∞ =largest= –≥–µ–Ω–µ—Ä–∏—á–∫–µ —Ñ—É–Ω–∫—Ü–∏—ò–µ
–ù–∞ –ø—Ä–µ—Ç—Ö–æ–¥–Ω–∏–º —Å–ª–∞–¥–æ–≤–∏–º–∞ –∏–º–∞–ª–∏ —Å–º–æ —Ñ—É–Ω–∫—Ü–∏—ò—É =largest=. –°–∞–¥–∞ –º–æ–∂–µ–º–æ –¥–∞ –∑–∞–≤—Ä—à–∏–º–æ
—ö–µ–Ω—É –¥–µ—Ñ–∏–Ω–∏—Ü–∏—ò—É.

–ì—Ä–µ—à–∫–∞ —ò–µ –±–∏–ª–∞ —Å–ª–µ–¥–µ—õ–∞:
#+begin_example
$ cargo run
   Compiling chapter10 v0.1.0 (file:///projects/chapter10)
error[E0369]: binary operation `>` cannot be applied to type `T`
 --> src/main.rs:5:17
  |
5 |         if item > largest {
  |            ---- ^ ------- T
  |            |
  |            T
  |
help: consider restricting type parameter `T`
  |
1 | fn largest<T: std::cmp::PartialOrd>(list: &[T]) -> T {
  |             ++++++++++++++++++++++

For more information about this error, try `rustc --explain E0369`.
error: could not compile `chapter10` due to previous error
#+end_example

#+REVEAL: split

–î–∞–∫–ª–µ, –º–æ—Ä–∞–º–æ –æ–≥—Ä–∞–Ω–∏—á–∏—Ç–∏ —Ç–∏–ø–æ–≤–µ –Ω–∞ –æ–Ω–µ –∫–æ—ò–∏ –ø–æ–¥—Ä–∂–∞–≤–∞—ò—É –ø–æ—Ä–µ—í–µ—ö–µ. –û–≤–∞ –æ—Å–æ–±–∏–Ω–∞ —Å–µ
—É —Å—Ç–∞–Ω–¥–∞—Ä–¥–Ω–æ—ò –±–∏–±–ª–∏–æ—Ç–µ—Ü–∏ –∑–æ–≤–µ =std::cmp::PartialOrd=, –ø–∞ —õ–µ–º–æ –ø—Ä–µ–ø—Ä–∞–≤–∏—Ç–∏ –∑–∞–≥–ª–∞–≤—ô–µ
—Ñ—É–Ω–∫—Ü–∏—ò–µ –Ω–∞ —Å–ª–µ–¥–µ—õ–∏ –Ω–∞—á–∏–Ω:

#+begin_src rust
fn largest<T: PartialOrd>(list: &[T]) -> T {
#+end_src

#+REVEAL: split

–ú–µ—í—É—Ç–∏–º, —Å–∞–¥–∞ –∏–º–∞–º–æ —ò–æ—à —ò–µ–¥–Ω—É –≥—Ä–µ—à–∫—É:
#+begin_example
$ cargo run
   Compiling chapter10 v0.1.0 (file:///projects/chapter10)
error[E0508]: cannot move out of type `[T]`, a non-copy slice
 --> src/main.rs:2:23
  |
2 |     let mut largest = list[0];
  |                       ^^^^^^^
  |                       |
  |                       cannot move out of here
  |                       move occurs because `list[_]` has type `T`, which does not implement the `Copy` trait
  |                       help: consider borrowing here: `&list[0]`

error[E0507]: cannot move out of a shared reference
 --> src/main.rs:4:18
  |
4 |     for &item in list {
  |         -----    ^^^^
  |         ||
  |         |data moved here
  |         |move occurs because `item` has type `T`, which does not implement the `Copy` trait
  |         help: consider removing the `&`: `item`

Some errors have detailed explanations: E0507, E0508.
For more information about an error, try `rustc --explain E0507`.
error: could not compile `chapter10` due to 2 previous errors
#+end_example

#+REVEAL: split

–£–≤–æ–¥–∏–º–æ –¥–æ–¥–∞—Ç–Ω–æ –æ–≥—Ä–∞–Ω–∏—á–µ—ö–µ –¥–∞ –≥–µ–Ω–µ—Ä–∏—á–∫–∏ —Ç–∏–ø –º–æ—Ä–∞ –±–∏—Ç–∏ –∏ =Copy=. –¢–∞–∫–æ –¥–∞ —ò–µ –ø—É–Ω–æ
—Ä–µ—à–µ—ö–µ —Å–ª–µ–¥–µ—õ–µ:

#+begin_src rust
fn largest<T: PartialOrd + Copy>(list: &[T]) -> T {
    let mut largest = list[0];

    for &item in list {
        if item > largest {
            largest = item;
        }
    }

    largest
}

fn main() {
    let number_list = vec![34, 50, 25, 100, 65];

    let result = largest(&number_list);
    println!("The largest number is {}", result);

    let char_list = vec!['y', 'm', 'a', 'q'];

    let result = largest(&char_list);
    println!("The largest char is {}", result);
}
#+end_src

*** –£–ø–æ—Ç—Ä–µ–±–∞ –æ—Å–æ–±–∏–Ω–∞ –æ–≥—Ä–∞–Ω–∏—á–µ—ö–∞ –∑–∞ —É—Å–ª–æ–≤–Ω—É –∏–º–ø–ª–µ–º–µ–Ω—Ç–∞—Ü–∏—ò—É –º–µ—Ç–æ–¥–∞
–ê–∫–æ –∂–µ–ª–∏–º–æ –¥–∞ –∏–º–ø–ª–µ–º–µ–Ω—Ç–∏—Ä–∞–º–æ –º–µ—Ç–æ–¥—É —Å–∞–º–æ –Ω–∞–¥ —Ç–∏–ø–æ–≤–∏–º–∞ –∫–æ—ò–∏ –∏–º–ø–ª–µ–º–µ–Ω—Ç–∏—Ä–∞—ò—É
–æ–¥—Ä–µ—í–µ–Ω–µ –æ—Å–æ–±–∏–Ω–µ.
#+begin_src rust
use std::fmt::Display;

struct Pair<T> {
    x: T,
    y: T,
}

impl<T> Pair<T> {
    fn new(x: T, y: T) -> Self {
        Self { x, y }
    }
}

impl<T: Display + PartialOrd> Pair<T> {
    fn cmp_display(&self) {
        if self.x >= self.y {
            println!("The largest member is x = {}", self.x);
        } else {
            println!("The largest member is y = {}", self.y);
        }
    }
}
#+end_src

** –í–∞–ª–∏–¥–∞—Ü–∏—ò–∞ —Ä–µ—Ñ–µ—Ä–µ–Ω—Ü–∏ –∫—Ä–æ–∑ –∂–∏–≤–æ—Ç–Ω–∏ –≤–µ–∫ (/Lifetimes/)
*** –ñ–∏–≤–æ—Ç–Ω–∏ –≤–µ–∫ (/Lifetime/)
- –°–≤–∞–∫–∞ —Ä–µ—Ñ–µ—Ä–µ–Ω—Ü–∞ –∏–º–∞ –∂–∏–≤–æ—Ç–Ω–∏ –≤–µ–∫, –æ–ø—Å–µ–≥ —É –∫–æ–º–µ —ò–µ —Ä–µ—Ñ–µ—Ä–µ–Ω—Ü–∞ –≤–∞–ª–∏–¥–Ω–∞.
- –£ –¥–æ—Å—Ç–∞ —Å–∏—Ç—É–∞—Ü–∏—ò–∞ –∫–æ–º–ø–∞—ò–ª–µ—Ä –∞—É—Ç–æ–º–∞—Ç—Å–∫–∏ –º–æ–∂–µ –¥–∞ –∑–∞–∫—ô—É—á–∏ –∫–æ—ò–∏ —ò–µ –∂–∏–≤–æ—Ç–Ω–∏ –≤–µ–∫
  —Ä–µ—Ñ–µ—Ä–µ–Ω—Ü–µ. –ö–∞–¥–∞ —Ç–æ –Ω–∏—ò–µ —É —Å—Ç–∞—ö—É –º–æ—Ä–∞–º–æ –¥–∞ —É—Ä–∞–¥–∏–º–æ —Ä—É—á–Ω—É –∞–Ω–æ—Ç–∞—Ü–∏—ò—É.
- –ê–Ω–æ—Ç–∞—Ü–∏—ò–∞–º–∞ –∂–∏–≤–æ—Ç–Ω–æ–≥ –≤–µ–∫–∞ –¥–æ–≤–æ–¥–∏–º–æ —É –≤–µ–∑—É –∂–∏–≤–æ—Ç–Ω–∏ –≤–µ–∫ —Ä–∞–∑–ª–∏—á–∏—Ç–∏—Ö —Ä–µ—Ñ–µ—Ä–µ–Ω—Ü–∏.

*** –°–ø—Ä–µ—á–∞–≤–∞—ö–µ "–≤–∏—Å–µ—õ–∏—Ö" —Ä–µ—Ñ–µ—Ä–µ–Ω—Ü–∏
#+begin_src rust
{
    let r;

    {
        let x = 5;
        r = &x;
    }

    println!("r: {}", r);
}

#+end_src

#+begin_example
 cargo run
   Compiling chapter10 v0.1.0 (file:///projects/chapter10)
error[E0597]: `x` does not live long enough
  --> src/main.rs:7:17
   |
7  |             r = &x;
   |                 ^^ borrowed value does not live long enough
8  |         }
   |         - `x` dropped here while still borrowed
9  |
10 |         println!("r: {}", r);
   |                           - borrow later used here

For more information about this error, try `rustc --explain E0597`.
error: could not compile `chapter10` due to previous error
#+end_example

*** /Borrow Checker/
- –†–∞—Å—Ç –∫–æ–º–ø–∞—ò–ª–µ—Ä –∏–º–∞ –∫–æ–º–ø–æ–Ω–µ–Ω—Ç—É /borrow checker/ –∫–æ—ò–∞ –ø—Ä–æ–≤–µ—Ä–∞–≤–∞ –¥–∞ –ª–∏ —Å—É —Å–≤–µ
  –ø–æ–∑–∞—ò–º–∏—Ü–µ –≤–∞–ª–∏–¥–Ω–µ.

#+begin_src rust
{
    let r;                // ---------+-- 'a
                          //          |
    {                     //          |
        let x = 5;        // -+-- 'b  |
        r = &x;           //  |       |
    }                     // -+       |
                          //          |
    println!("r: {}", r); //          |
}                         // ---------+
#+end_src

- –ü—Ä–æ–≥—Ä–∞–º —ò–µ –æ–¥–±–∞—á–µ–Ω —ò–µ—Ä =r= —Ä–µ—Ñ–µ—Ä–µ–Ω—Ü–∏—Ä–∞ –≤—Ä–µ–¥–Ω–æ—Å—Ç —á–∏—ò–∏ –∂–∏–≤–æ—Ç–Ω–∏ –≤–µ–∫ (='b=) —ò–µ –∫—Ä–∞—õ–∏
  –æ–¥ –∂–∏–≤–æ—Ç–Ω–æ–≥ –≤–µ–∫–∞ –≤–∞—Ä–∏—ò–∞–±–ª–µ =r= (='a=). –£–∫–æ–ª–∏–∫–æ –±–∏ —Å–µ –æ–≤–æ –¥–æ–∑–≤–æ–ª–∏–ª–æ, =r= –±–∏ —É —ò–µ–¥–Ω–æ–º
  –¥–µ–ª—É —Ä–µ—Ñ–µ—Ä–µ–Ω—Ü–∏—Ä–∞–ª–∞ –Ω–µ–≤–∞–ª–∏–¥–Ω—É –≤—Ä–µ–¥–Ω–æ—Å—Ç.

#+REVEAL: split

–í–∞—Ä–∏—ò–∞–±–ª–µ –∏–º–∞—ò—É –∂–∏–≤–æ—Ç–Ω–∏ –≤–µ–∫ –∫–æ—ò–∏ —ò–µ —ò–µ–¥–Ω–∞–∫ —Å–∏–Ω—Ç–∞–∫—Å–Ω–æ–º –æ–ø—Å–µ–≥—É —É –∫–æ–º–µ —ò–µ
–≤–∞—Ä–∏—ò–∞–±–ª–∞ –¥–µ—Ñ–∏–Ω–∏—Å–∞–Ω–∞. –ñ–∏–≤–æ—Ç–Ω–∏ –≤–µ–∫ –∏–º–∞—ò—É –∏ —Ä–µ—Ñ–µ—Ä–µ–Ω—Ü–µ –∫–æ—ò–µ –ø–æ–∑–∞—ò–º—ô—É—ò—É –≤—Ä–µ–¥–Ω–æ—Å—Ç –∏
—Å–º–µ—à—Ç–∞—ò—É —Å–µ —É –≤–∞—Ä–∏—ò–∞–±–ª–µ (–Ω–ø—Ä. =r=&x= –∏–∑ –ø—Ä–µ—Ç—Ö–æ–¥–Ω–æ–≥ –ø—Ä–∏–º–µ—Ä–∞).

#+begin_note
–à–µ–¥–Ω–æ –æ–¥ –ø—Ä–∞–≤–∏–ª–∞ —ò–µ –¥–∞ —Ä–µ—Ñ–µ—Ä–µ–Ω—Ü–∞ –Ω–∞ –≤–∞—Ä–∏—ò–∞–±–ª—É (—Ç—ò. –≤—Ä–µ–¥–Ω–æ—Å—Ç) –Ω–µ –º–æ–∂–µ –¥–∞ –∂–∏–≤–∏
–¥—É–∂–µ –æ–¥ —Å–∞–º–µ –≤–∞—Ä–∏—ò–∞–±–ª–µ. –û–¥–Ω–æ—Å–Ω–æ /–∂–∏–≤–æ—Ç–Ω–∏ –≤–µ–∫ –≤–∞—Ä–∏—ò–∞–±–ª–µ –º–æ—Ä–∞ –¥–∞ —Å–∞–¥—Ä–∂–∏ –∂–∏–≤–æ—Ç–Ω–∏
–≤–µ–∫ —Ä–µ—Ñ–µ—Ä–µ–Ω—Ü–µ –ø–æ–∑–∞—ò–º—ô–µ–Ω–µ –æ–¥ —Ç–µ –≤–∞—Ä–∏—ò–∞–±–ª–µ/.
#+end_note

#+begin_src rust
{
    let r;
    {
        let x = 5;
        r = &x;           // -+- &x –Ω–µ –º–æ–∂–µ –¥–∞ –∂–∏–≤–∏ –¥—É–∂–µ –æ–¥
    }                     // -+  –æ–≤–æ–≥ –∂–∏–≤–æ—Ç–Ω–æ–≥ –≤–µ–∫–∞
    println!("r: {}", r);
}
#+end_src

#+REVEAL: split

–ê–∫–æ —Å–º–µ—Å—Ç–∏–º–æ —Ä–µ—Ñ–µ—Ä–µ–Ω—Ü—É —É –≤–∞—Ä–∏—ò–∞–±–ª—É, —Ä–µ—Ñ–µ—Ä–µ–Ω—Ü–∞ –º–æ—Ä–∞ –±–∏—Ç–∏ –∏—Å–ø—Ä–∞–≤–Ω–∞ –∑–∞ —Ü–µ–æ –∂–∏–≤–æ—Ç–Ω–∏
–≤–µ–∫ –≤–∞—Ä–∏—ò–∞–±–ª–µ —É –∫–æ—ò—É —ò–µ —Å–º–µ—à—Ç–µ–Ω–∞.

#+begin_note
–ö–∞–∂–µ–º–æ –¥–∞ /–∂–∏–≤–æ—Ç–Ω–∏ –≤–µ–∫ —Ä–µ—Ñ–µ—Ä–µ–Ω—Ü–µ –º–æ—Ä–∞ –¥–∞ —Å–∞–¥—Ä–∂–∏ –∂–∏–≤–æ—Ç–Ω–∏ –≤–µ–∫ –≤–∞—Ä–∏—ò–∞–±–ª–µ —É –∫–æ—ò—É —ò–µ
—Å–º–µ—à—Ç–µ–Ω–∞/.
#+end_note

#+begin_src rust
{
    let r;
    {
        let x = 5;
        r = &x;           // -+- –∂–∏–≤–æ—Ç–Ω–∏ –≤–µ–∫ –±–∏–ª–æ —á–µ–≥–∞ —à—Ç–æ
    }                     //  |  —Å–µ —Å–º–µ—Å—Ç–∏ —É r –º–æ—Ä–∞ –¥–∞ –∂–∏–≤–∏
    println!("r: {}", r); // -+  –±–∞—Ä –æ–≤–æ–ª–∏–∫–æ
}
#+end_src

–í–∏–¥–∏–º–æ –¥–∞ –æ–≤–æ –ø—Ä–∞–≤–∏–ª–æ –Ω–∏—ò–µ –∑–∞–¥–æ–≤–æ—ô–µ–Ω–æ. =&x= –Ω–µ –∂–∏–≤–∏ –¥–æ–≤–æ—ô–Ω–æ –¥—É–≥–æ —ò–µ—Ä =x= –Ω–µ –∂–∏–≤–∏
–¥–æ–≤–æ—ô–Ω–æ –¥—É–≥–æ.

#+REVEAL: split

–ê–∫–æ –ø—Ä–µ—Ç—Ö–æ–¥–Ω–∞ –¥–≤–∞ –ø—Ä–∞–≤–∏–ª–∞ –æ–±—ò–µ–¥–∏–Ω–∏–º–æ –º–æ–∂–µ–º–æ —Ä–µ—õ–∏ –¥–∞:

#+begin_note
/–ñ–∏–≤–æ—Ç–Ω–∏ –≤–µ–∫ –≤–∞—Ä–∏—ò–∞–±–ª–µ –º–æ—Ä–∞ –¥–∞ —Å–∞–¥—Ä–∂–∏ –∂–∏–≤–æ—Ç–Ω–∏ –≤–µ–∫ —Å–≤–∏—Ö –≤–∞—Ä–∏—ò–∞–±–ª–∏ –∫–æ—ò–µ –ø–æ–∑–∞—ò–º—ô—É—ò—É
–≤—Ä–µ–¥–Ω–æ—Å—Ç –æ–¥ –ø–æ—Å–º–∞—Ç—Ä–∞–Ω–µ –≤–∞—Ä–∏—ò–∞–±–ª–µ/.
#+end_note

–û–¥–Ω–æ—Å–Ω–æ, –≤–∞—Ä–∏—ò–∞–±–ª–∞ –º–æ–∂–µ –æ—Ç–∏—õ–∏ –∏–∑ –æ–ø—Å–µ–≥–∞ —Ç–µ–∫ –∫–∞–¥–∞ –Ω–µ –ø–æ—Å—Ç–æ—ò–∏ –≤–∏—à–µ –Ω–∏ —ò–µ–¥–Ω–∞
–≤–∞—Ä–∏—ò–∞–±–ª–∞ –∫–æ—ò–∞ —á—É–≤–∞ –ø–æ–∑–∞—ò–º—ô–µ–Ω—É –≤—Ä–µ–¥–Ω–æ—Å—Ç.

#+REVEAL: split

–°–ª–µ–¥–µ—õ–∏ –∫–æ–¥ —ò–µ –ø—Ä–∏—Ö–≤–∞—õ–µ–Ω. –†–µ—Ñ–µ—Ä–µ–Ω—Ü–∞ =r= –Ω–µ –∂–∏–≤–∏ –¥—É–∂–µ –æ–¥ –ø–æ–¥–∞—Ç–∫–∞ –∫–æ—ò–∏ —Ä–µ—Ñ–µ—Ä–µ–Ω—Ü–∏—Ä–∞
(=x=).

#+begin_src rust
{
    let x = 5;            // ----------+-- 'b
                          //           |
    let r = &x;           // --+-- 'a  |
                          //   |       |
    println!("r: {}", r); //   |       |
                          // --+       |
}                         // ----------+
#+end_src

*** –ì–µ–Ω–µ—Ä–∏—á–∫–∏ –∂–∏–≤–æ—Ç–Ω–∏ –≤–µ–∫–æ–≤–∏ —É —Ñ—É–Ω–∫—Ü–∏—ò–∞–º–∞
- –ö—Ä–µ–∏—Ä–∞–º–æ —Ñ—É–Ω–∫—Ü–∏—ò—É =longest= –∫–æ—ò–∞ –≤—Ä–∞—õ–∞ –¥—É–∂–∏ –æ–¥ –¥–≤–∞ –ø—Ä–æ—Å–ª–µ—í–µ–Ω–∞ —Å—Ç—Ä–∏–Ω–≥–∞.
  –ü—Ä–æ—Å–ª–µ—í—É—ò–µ–º–æ —Ä–µ—Ñ–µ—Ä–µ–Ω—Ü—É –Ω–∞ —Å—Ç—Ä–∏–Ω–≥ –∏—Å–µ—á–∞–∫ =&str=.

#+begin_src rust
fn main() {
    let string1 = String::from("abcd");
    let string2 = "xyz";

    let result = longest(string1.as_str(), string2);
    println!("The longest string is {}", result);
}
#+end_src

#+REVEAL: split

–û–≤–∞—ò –ø—Ä–æ–≥—Ä–∞–º –Ω–∏—ò–µ –ø—Ä–∏—Ö–≤–∞—õ–µ–Ω.
#+begin_src rust
fn longest(x: &str, y: &str) -> &str {
    if x.len() > y.len() {
        x
    } else {
        y
    }
}
#+end_src

#+begin_example
$ cargo run
   Compiling chapter10 v0.1.0 (file:///projects/chapter10)
error[E0106]: missing lifetime specifier
 --> src/main.rs:9:33
  |
9 | fn longest(x: &str, y: &str) -> &str {
  |               ----     ----     ^ expected named lifetime parameter
  |
  = help: this function's return type contains a borrowed value, but the signature does not say
  whether it is borrowed from `x` or `y`
help: consider introducing a named lifetime parameter
  |
9 | fn longest<'a>(x: &'a str, y: &'a str) -> &'a str {
  |           ++++     ++          ++          ++

For more information about this error, try `rustc --explain E0106`.
error: could not compile `chapter10` due to previous error
#+end_example

#+REVEAL: split

- –ó–∞—à—Ç–æ –ø—Ä–æ–≥—Ä–∞–º –Ω–∏—ò–µ –ø—Ä–∏—Ö–≤–∞—õ–µ–Ω?
- /Borrow checker/ –Ω–∏—ò–µ —É —Å—Ç–∞—ö—É –¥–∞ –æ–¥—Ä–µ–¥–∏ —É –∫–æ—ò–æ—ò —Ä–µ–ª–∞—Ü–∏—ò–∏ —Å—É —Ä–µ—Ñ–µ—Ä–µ–Ω—Ü–µ =x= –∏ =y= —Å–∞
  –ø–æ–≤—Ä–∞—Ç–Ω–æ–º –≤—Ä–µ–¥–Ω–æ—à—õ—É –∫–æ—ò–∞ —ò–µ —Ç–∞–∫–æ—í–µ —Ä–µ—Ñ–µ—Ä–µ–Ω—Ü–∞.
- –¢—ò. –ø–æ–≤—Ä–∞—Ç–Ω–∞ –≤—Ä–µ–¥–Ω–æ—Å—Ç –º–æ—Ä–∞ –±–∏—Ç–∏ –ø–æ–∑–∞—ò–º—ô–µ–Ω–∞ –æ–¥–Ω–µ–∫—É–¥, –∞–ª–∏ –∫–æ–º–ø–∞—ò–ª–µ—Ä –Ω–µ –º–æ–∂–µ –¥–∞
  –æ–¥—Ä–µ–¥–∏ –¥–∞ –ª–∏ —ò–µ –ø–æ–∑–∞—ò–º—ô–µ–Ω–∞ –æ–¥ =x= –∏–ª–∏ =y= –∏–ª–∏ –æ–¥ –Ω–µ–∫–µ –≥–ª–æ–±–∞–ª–Ω–µ –≤—Ä–µ–¥–Ω–æ—Å—Ç–∏.
- –û–≤–∞ –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—ò–∞ —ò–µ –ø–æ—Ç—Ä–µ–±–Ω–∞ –¥–∞ –±–∏ —Å–µ –æ–±–∞–≤–∏–ª–∞ –∫–∞–ª–∫—É–ª–∞—Ü–∏—ò–∞ –∏ –ø—Ä–æ–≤–µ—Ä–∞ –∂–∏–≤–æ—Ç–Ω–æ–≥ –≤–µ–∫–∞.

*** –°–∏–Ω—Ç–∞–∫—Å–∞ –∑–∞ –∞–Ω–æ—Ç–∞—Ü–∏—ò—É –∂–∏–≤–æ—Ç–Ω–æ–≥ –≤–µ–∫–∞
- –î–∞ –±–∏ –ø–æ–º–æ–≥–ª–∏ –∫–æ–º–ø–∞—ò–ª–µ—Ä—É —Ä–µ—Ñ–µ—Ä–µ–Ω—Ü–µ –æ–∑–Ω–∞—á–∞–≤–∞–º–æ —Å–∞ –∂–∏–≤–æ—Ç–Ω–∏–º –≤–µ–∫–æ–º –∏ —Ç–∏–º–µ
  –¥–æ–≤–æ–¥–∏–º–æ —É –≤–µ–∑—É —Ä–∞–∑–ª–∏—á–∏—Ç–µ —Ä–µ—Ñ–µ—Ä–µ–Ω—Ü–µ (–Ω–ø—Ä. –ø–∞—Ä–∞–º–µ—Ç—Ä–µ –∏ –ø–æ–≤—Ä–∞—Ç–Ω–µ –≤—Ä–µ–¥–Ω–æ—Å—Ç–∏
  —Ñ—É–Ω–∫—Ü–∏—ò–µ).
- –ê–Ω–æ—Ç–∞—Ü–∏—ò–∞ —ò–µ –æ–±–ª–∏–∫–∞ ='a=. –ò–∑–∞ –∞–ø–æ—Å—Ç—Ä–æ—Ñ–∞ —Å–µ –ø–∏—à–µ –∏–º–µ –∞–Ω–æ—Ç–∞—Ü–∏—ò–µ –∫–æ—ò–µ —ò–µ –Ω–∞—ò—á–µ—à—õ–µ
  —ò–µ–¥–Ω–æ –º–∞–ª–æ —Å–ª–æ–≤–æ —Å–∞ –ø–æ—á–µ—Ç–∫–∞ –∞–ª—Ñ–∞–±–µ—Ç–∞ (='a, 'b,...=).
- *–í–∞–∂–Ω–æ:* –∞–Ω–æ—Ç–∞—Ü–∏—ò–µ –∂–∏–≤–æ—Ç–Ω–æ–≥ –≤–µ–∫–∞ –Ω–µ –º–µ—ö–∞—ò—É –∂–∏–≤–æ—Ç–Ω–∏ –≤–µ–∫ —Ä–µ—Ñ–µ—Ä–µ–Ω—Ü–µ –≤–µ—õ —Å–∞–º–æ
  –ø–æ–º–∞–∂—É –∫–æ–º–ø–∞—ò–ª–µ—Ä—É —É –ø—Ä–æ–≤–µ—Ä–∏.

#+begin_src rust
&i32        // —Ä–µ—Ñ–µ—Ä–µ–Ω—Ü–∞
&'a i32     // —Ä–µ—Ñ–µ—Ä–µ–Ω—Ü–∞ —Å–∞ –µ–∫—Å–ø–ª–∏—Ü–∏—Ç–Ω–∏–º –∂–∏–≤–æ—Ç–Ω–∏–º –≤–µ–∫–æ–º
&'a mut i32 // –ø—Ä–æ–º–µ—ö–∏–≤–∞ —Ä–µ—Ñ–µ—Ä–µ–Ω—Ü–∞ —Å–∞ –µ–∫—Å–ø–ª–∏—Ü–∏—Ç–Ω–∏–º –∂–∏–≤–æ—Ç–Ω–∏–º –≤–µ–∫–æ–º
#+end_src

- –à–µ–¥–Ω–∞ –∞–Ω–æ—Ç–∞—Ü–∏—ò–∞ –Ω–µ–º–∞ –ø—É–Ω–æ —Å–º–∏—Å–ª–∞. –§—É–Ω–∫—Ü–∏—ò—É –∏–º–∞—ò—É —Ç–µ–∫ –∫–∞–¥–∞ –∞–Ω–æ—Ç–∏—Ä–∞–º–æ –≤–∏—à–µ
  —Ä–µ—Ñ–µ—Ä–µ–Ω—Ü–∏ —ò–µ—Ä —Å–µ –¥–æ–≤–æ–¥–µ —É –≤–µ–∑—É –∞–∫–æ –∏–º–∞—ò—É –∏—Å—Ç–æ –∏–º–µ.
- –£–≤–µ–¥–∏–º–æ —Ñ—É–Ω–∫—Ü–∏—ò—É =lt= –∫–æ—ò–∞ –≤—Ä–∞—õ–∞ –∂–∏–≤–æ—Ç–Ω–∏ –≤–µ–∫ –≤–∞—Ä–∏—ò–∞–±–ª–µ/–≤—Ä–µ–¥–Ω–æ—Å—Ç–∏ –∏ —Ä–µ–ª–∞—Ü–∏—ò—É
  –∏–∑–º–µ—í—É –∂–∏–≤–æ—Ç–Ω–∏—Ö –≤–µ–∫–æ–≤–∞ ='a‚â•'b= –æ–¥–Ω–æ—Å–Ω–æ ='b‚â§'a= –∫–æ—ò–∞ –∑–Ω–∞—á–∏ –¥–∞ ='a= –æ–±—É—Ö–≤–∞—Ç–∞ ='b=
  –æ–¥–Ω–æ—Å–Ω–æ ='b= —ò–µ —Å–∞–¥—Ä–∂–∞–Ω–æ —É ='a=.

*** –ê–Ω–æ—Ç–∞—Ü–∏—ò–∞ –∂–∏–≤–æ—Ç–Ω–æ–≥ –≤–µ–∫–∞ —É —Å–∏–≥–Ω–∞—Ç—É—Ä–∞–º–∞ —Ñ—É–Ω–∫—Ü–∏—ò–∞
- –°–ª–µ–¥–µ—õ–∞ –∞–Ω–æ—Ç–∞—Ü–∏—ò–∞ –∑–∞ —Ñ—É–Ω–∫—Ü–∏—ò—É =longest= —ò–µ –∏—Å–ø—Ä–∞–≤–Ω–∞ —ò–µ—Ä —Ä–µ—Ñ–µ—Ä–µ–Ω—Ü–∞ –∫–æ—ò–∞ —Å–µ –≤—Ä–∞—õ–∞
  –º–æ–∂–µ –±–∏—Ç–∏ =x= –∏–ª–∏ =y= —É –∑–∞–≤–∏—Å–Ω–æ—Å—Ç–∏ –æ–¥ –¥—É–∂–∏–Ω–µ —Å—Ç—Ä–∏–Ω–≥–∞. –°—Ç–æ–≥–∞ —ò–µ –ø–æ—Ç—Ä–µ–±–Ω–æ –¥–∞ –∏–º–∞–º–æ
  —Å—Ç—Ä–æ–∂–∏—ò–∏ —É—Å–ª–æ–≤ –¥–∞ —ò–µ –∂–∏–≤–æ—Ç–Ω–∏ –≤–µ–∫ –ø–æ–≤—Ä–∞—Ç–Ω–µ –≤—Ä–µ–¥–Ω–æ—Å—Ç–∏ —É –≤–µ–∑–∏ —Å–∞ –∂–∏–≤–æ—Ç–Ω–∏–º –≤–µ–∫–æ–º
  –æ–±–∞ –ø–∞—Ä–∞–º–µ—Ç—Ä–∞.

#+begin_src rust
fn longest<'a>(x: &'a str, y: &'a str) -> &'a str {
    if x.len() > y.len() {
        x
    } else {
        y
    }
}
#+end_src

- –û–≤–∏–º –∫–∞–∂–µ–º–æ –∫–æ–º–ø–∞—ò–ª–µ—Ä—É –¥–∞ –∑–∞ –Ω–µ–∫–∏ –≥–µ–Ω–µ—Ä–∏—á–∫–∏ –∂–∏–≤–æ—Ç–Ω–∏ –≤–µ–∫ ='a=, —Ñ—É–Ω–∫—Ü–∏—ò–∞ –ø—Ä–∏–º–∞ –¥–≤–µ
  —Ä–µ—Ñ–µ—Ä–µ–Ω—Ü–µ —á–∏—ò–∏ –∂–∏–≤–æ—Ç–Ω–∏ –≤–µ–∫ –≤—Ä–µ–¥–Ω–æ—Å—Ç–∏ –æ–±—É—Ö–≤–∞—Ç–∞ ='a= –∏ –≤—Ä–∞—õ–∞ —Ä–µ—Ñ–µ—Ä–µ–Ω—Ü—É –∫–æ—ò–∞ –º–æ—Ä–∞
  –±–∏—Ç–∏ –≤–∞–ª–∏–¥–Ω–∞ –±–∞—Ä –∫–æ–ª–∏–∫–æ –∏ –∂–∏–≤–æ—Ç–Ω–∏ –≤–µ–∫ ='a= —Ç—ò. –∂–∏–≤–æ—Ç–Ω–∏ –≤–µ–∫ –ø–æ–≤—Ä–∞—Ç–Ω–µ —Ä–µ—Ñ–µ—Ä–µ–Ω—Ü–µ
  –º–æ—Ä–∞ –¥–∞ –æ–±—É—Ö–≤–∞—Ç–∏ ='a=. –£–∫–æ–ª–∏–∫–æ —Ç–∞–∫–∞–≤ –∂–∏–≤–æ—Ç–Ω–∏ –≤–µ–∫ –ø–æ—Å—Ç–æ—ò–∏ –∫–æ–¥ —Å–µ –ø—Ä–∏—Ö–≤–∞—Ç–∞.
- –°–∏–≥–Ω–∞—Ç—É—Ä–∞ –¥–æ–≤–æ–¥–∏ —É –≤–µ–∑—É –æ–±–µ —É–ª–∞–∑–Ω–µ —Ä–µ—Ñ–µ—Ä–µ–Ω—Ü–µ —Å–∞ –∏–∑–ª–∞–∑–Ω–æ–º.

#+REVEAL: split

–ü–æ—Å–º–∞—Ç—Ä–∞—ò–º–æ –∫–æ–¥ –∫–æ—ò–∏ –ø–æ–∑–∏–≤–∞ —Ñ—É–Ω–∫—Ü–∏—ò—É =longest=:

#+begin_src rust
fn main() {
    let string1 = String::from("abcd");
    {
        let string2 = "xyz";
        let result = longest(string1.as_str(), string2);
    }
    println!("The longest string is {}", result);
}
#+end_src

–ó–∞ –∫–æ–¥ –º–æ—Ä–∞ –¥–∞ –ø–æ—Å—Ç–æ—ò–∏ ='a= —Ç–∞–∫–æ –¥–∞ –≤–∞–∂–∏:

#+begin_example
lt(string1) ‚â• 'a     # –∂–∏–≤–æ—Ç–Ω–∏ –≤–µ–∫ –≤—Ä–µ–¥–Ω–æ—Å—Ç–∏ –ø—Ä–≤–æ–≥ –ø–∞—Ä–∞–º–µ—Ç–∞—Ä–∞ —Å–∞–¥—Ä–∂–∏ 'a
lt(string2) ‚â• 'a     # –∂–∏–≤–æ—Ç–Ω–∏ –≤–µ–∫ –≤—Ä–µ–¥–Ω–æ—Å—Ç–∏ –¥—Ä—É–≥–æ–≥ –ø–∞—Ä–∞–º–µ—Ç–∞—Ä–∞ —Å–∞–¥—Ä–∂–∏ 'a
'a ‚â• lt(result)       # 'a –º–æ—Ä–∞ –¥–∞ —Å–∞–¥—Ä–∂–∏ –∂–∏–≤–æ—Ç–Ω–∏ –≤–µ–∫—É result –≤–∞—Ä–∏—ò–∞–±–ª–µ
#+end_example

–®—Ç–æ –Ω–µ –º–æ–∂–µ –±–∏—Ç–∏ –∏—Å–ø—É—ö–µ–Ω–æ –∏—Å—Ç–æ–≤—Ä–µ–º–µ–Ω–æ, —Ç—ò. –Ω–µ –ø–æ—Å—Ç–æ—ò–∏ ='a= –∫–æ—ò–µ –∏—Å–ø—É—ö–∞–≤–∞ –æ–≤–∞
–æ–≥—Ä–∞–Ω–∏—á–µ—ö–∞.

#+REVEAL: split

–î—Ä—É–≥–∏ –Ω–∞—á–∏–Ω —Ä–∞–∑–º–∏—à—ô–∞—ö–∞ —ò–µ –¥–∞ –ø–æ–≤—Ä–∞—Ç–Ω–∞ –≤—Ä–µ–¥–Ω–æ—Å—Ç —Ñ—É–Ω–∫—Ü–∏—ò–µ –ø–æ–∑–∞—ò–º—ô—É—ò–µ –æ–¥
–≤—Ä–µ–¥–Ω–æ—Å—Ç–∏ —É–ª–∞–∑–Ω–∏—Ö –ø–∞—Ä–∞–º–µ—Ç–∞—Ä–∞ –æ–∑–Ω–∞—á–µ–Ω–∏—Ö –∏—Å—Ç–∏–º –∏–º–µ–Ω–æ–º –∂–∏–≤–æ—Ç–Ω–æ–≥ –≤–µ–∫–∞.

#+begin_src rust
fn main() {
    let string1 = String::from("abcd");
    {
        let string2 = "xyz";
        let result = longest(string1.as_str(), string2);
    }
    println!("The longest string is {}", result);
}
#+end_src

–®—Ç–æ –∑–Ω–∞—á–∏ –¥–∞ =result= –ø–æ–∑–∞—ò–º—ô—É—ò–µ –æ–¥ =string1= –∏ =string2= –∏ —Ç–∞ –ø–æ–∑–∞—ò–º–∏—Ü–∞ —Ç—Ä–∞—ò–µ —Å–≤–µ
–≤—Ä–µ–º–µ –∂–∏–≤–æ—Ç–∞ –≤–∞—Ä–∏—ò–∞–±–ª–µ =result= —à—Ç–æ –Ω–µ –º–æ–∂–µ –±–∏—Ç–∏ –≤–∞–ª–∏–¥–Ω–æ —ò–µ—Ä –≤–∞—Ä–∏—ò–∞–±–ª–∞ –∂–∏–≤–∏ –¥—É–∂–µ
–æ–¥ –≤—Ä–µ–¥–Ω–æ—Å—Ç–∏ =string2=.

–ò–∞–∫–æ, –º–æ–∂–µ–º–æ –≤–∏–¥–µ—Ç–∏ –¥–∞ —õ–µ, –∑–±–æ–≥ –¥—É–∂–∏–Ω–µ —Å—Ç—Ä–∏–Ω–≥–∞, –≤—Ä–∞—õ–µ–Ω–∞ –≤—Ä–µ–¥–Ω–æ—Å—Ç –±–∏—Ç–∏ =string1= –∏
–ø—Ä–æ–≥—Ä–∞–º —ò–µ –≤–∞–ª–∏–¥–∞–Ω, –∫–æ–º–ø–∞—ò–ª–µ—Ä –æ–≤–æ –Ω–µ –º–æ–∂–µ –¥–∞ –∑–∞–∫—ô—É—á–∏.
*** –ú–µ–Ω—Ç–∞–ª–Ω–∏ –º–æ–¥–µ–ª —É –∫–æ–Ω—Ç–µ–∫—Å—Ç—É –∂–∏–≤–æ—Ç–Ω–æ–≥ –≤–µ–∫–∞
- –ù–∞–≤–æ—í–µ—ö–µ –∞–Ω–æ—Ç–∞—Ü–∏—ò–µ –∂–∏–≤–æ—Ç–Ω–æ–≥ –≤–µ–∫–∞ –∑–∞–≤–∏—Å–∏ –æ–¥ —Ç–æ–≥–∞ —à—Ç–∞ —Ñ—É–Ω–∫—Ü–∏—ò–∞ —Ä–∞–¥–∏.
- –ù–∞ –ø—Ä–∏–º–µ—Ä:

#+begin_src rust
fn longest<'a>(x: &'a str, y: &str) -> &'a str {
    x
}
#+end_src

- –£ –æ–≤–æ–º —Å–ª—É—á–∞—ò—É –≤—Ä–∞—õ–∞–º–æ –∂–∏–≤–æ—Ç–Ω–∏ –≤–µ–∫ –ø—Ä–≤–æ–≥ –ø–∞—Ä–∞–º–µ—Ç—Ä–∞ —á–∏–º–µ —Å–∞–æ–ø—à—Ç–∞–≤–∞–º–æ –∫–æ–º–ø–∞—ò–ª–µ—Ä—É
  –¥–∞ —Å–µ –ø–æ–∑–∞—ò–º–∏—Ü–∞ –≤—Ä—à–∏ –∏—Å–∫—ô—É—á–∏–≤–æ –æ–¥ –ø—Ä–≤–æ–≥ –ø–∞—Ä–∞–º–µ—Ç—Ä–∞.

#+REVEAL: split

- –ê–∫–æ –Ω–µ –ø–æ–∑–∞—ò–º–∏–º–æ –æ–¥ —É–ª–∞–∑–Ω–∏—Ö –ø–∞—Ä–∞–º–µ—Ç–∞—Ä–∞ –º–æ—Ä–∞–º–æ –≤—Ä–∞—Ç–∏—Ç–∏ —Ä–µ—Ñ–µ—Ä–µ–Ω—Ü—É –Ω–∞ –≤—Ä–µ–¥–Ω–æ—Å—Ç
  –∫—Ä–µ–∏—Ä–∞–Ω—É —É–Ω—É—Ç–∞—Ä —Ñ—É–Ω–∫—Ü–∏—ò–µ, —à—Ç–æ –Ω–∏—ò–µ –¥–æ–∑–≤–æ—ô–µ–Ω–æ.

#+begin_src rust
fn longest<'a>(x: &str, y: &str) -> &'a str {
    let result = String::from("really long string");
    result.as_str()
}
#+end_src

#+begin_src
$ cargo run
   Compiling chapter10 v0.1.0 (file:///projects/chapter10)
error[E0515]: cannot return reference to local variable `result`
  --> src/main.rs:11:5
   |
11 |     result.as_str()
   |     ^^^^^^^^^^^^^^^ returns a reference to data owned by the current function

For more information about this error, try `rustc --explain E0515`.
error: could not compile `chapter10` due to previous error
#+end_src

–ù–µ–º–æ–≥—É—õ–µ —ò–µ –≤—Ä–∞—Ç–∏—Ç–∏ —Ä–µ—Ñ–µ—Ä–µ–Ω—Ü—É –Ω–∞ –ª–æ–∫–∞–ª–Ω—É –ø—Ä–æ–º–µ—ö–∏–≤—É —ò–µ—Ä –±–∏ —Ç–æ –±–∏–ª–∞ –≤–∏—Å–µ—õ–∞
—Ä–µ—Ñ–µ—Ä–µ–Ω—Ü–∞. –†–µ—à–µ—ö–µ —É –æ–≤–æ–º —Å–ª—É—á–∞—ò—É —ò–µ –¥–∞ –≤—Ä–∞—Ç–∏–º–æ –ø–æ—Å–µ–¥–æ–≤–∞–Ω—É –≤—Ä–µ–¥–Ω–æ—Å—Ç.

#+REVEAL: split

#+begin_note
–î–∞–∫–ª–µ, —Å–∏–Ω—Ç–∞–∫—Å–∞ –∑–∞ –∞–Ω–æ—Ç–∞—Ü–∏—ò—É –∂–∏–≤–æ—Ç–Ω–∏—Ö –≤–µ–∫–æ–≤–∞ –¥–æ–≤–æ–¥–∏ —É –≤–µ–∑—É –∂–∏–≤–æ—Ç–Ω–µ –≤–µ–∫–æ–≤–µ
—É–ª–∞–∑–Ω–∏—Ö –ø–∞—Ä–∞–º–µ—Ç–∞—Ä–∞ –∏ –ø–æ–≤—Ä–∞—Ç–Ω–∏—Ö –≤—Ä–µ–¥–Ω–æ—Å—Ç–∏. –ù–∞–≤–æ–¥–∏ —Å–µ —Å–∞–º–æ –∫–æ–¥ —Ä–µ—Ñ–µ—Ä–µ–Ω—Ü–∏.

–ù–∞ –æ—Å–Ω–æ–≤—É –∞–Ω–æ—Ç–∞—Ü–∏—ò–µ, –†–∞—Å—Ç —ò–µ —É —Å—Ç–∞—ö—É –¥–∞ –æ–±–∞–≤–∏ –ø—Ä–æ–≤–µ—Ä–µ –∏ –æ–±–µ–∑–±–µ–¥–∏ –æ–ø–µ—Ä–∞—Ü–∏—ò–µ –∫–æ—ò–µ
—Å—É –º–µ–º–æ—Ä–∏—ò—Å–∫–∏ —Å–∏–≥—É—Ä–Ω–µ –∏ –∑–∞–±—Ä–∞–Ω–∏ –æ–ø–µ—Ä–∞—Ü–∏—ò–µ –∫–æ—ò–µ –±–∏ –º–æ–≥–ª–µ –¥–∞ –¥–æ–≤–µ–¥—É –¥–æ –Ω–∞—Ä—É—à–∞–≤–∞—ö–∞
–º–µ–º–æ—Ä–∏—ò—Å–∫–µ —Å–∏–≥—É—Ä–Ω–æ—Å—Ç–∏.

–ê–Ω–æ—Ç–∞—Ü–∏—ò–µ –∂–∏–≤–æ—Ç–Ω–æ–≥ –≤–µ–∫–∞ –∏—Å—Ç–æ–≤—Ä–µ–º–µ–Ω–æ –ø—Ä–µ–¥—Å—Ç–∞–≤—ô–∞—ò—É –∏ –∫–æ—Ä–∏—Å–Ω–µ –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—ò–µ
–ø—Ä–æ–≥—Ä–∞–º–µ—Ä–∏–º–∞ —ò–µ—Ä —ò–µ –ª–∞–∫–æ –≤–∏–¥–µ—Ç–∏ —É –∫–∞–∫–≤–æ—ò —Å—É –≤–µ–∑–∏ —É–ª–∞–∑–Ω–∏ –ø–∞—Ä–∞–º–µ—Ç—Ä–∏ –∏ –∏–∑–ª–∞–∑–Ω–µ
–≤—Ä–µ–¥–Ω–æ—Å—Ç–∏.
#+end_note

*** –ê–Ω–æ—Ç–∞—Ü–∏—ò–µ –∂–∏–≤–æ—Ç–Ω–æ–≥ –≤–µ–∫–∞ —É –¥–µ–∫–ª–∞—Ä–∞—Ü–∏—ò–∞–º–∞ —Å—Ç—Ä—É–∫—Ç—É—Ä–∞
- –°–ª–æ–∂–µ–Ω–∏ —Ç–∏–ø–æ–≤–∏ –∫–æ—ò–∏ —É —Å–µ–±–∏ —Å–∞–¥—Ä–∂–µ —Ä–µ—Ñ–µ—Ä–µ–Ω—Ü–µ –º–æ—Ä–∞—ò—É —É–≤–µ—Å—Ç–∏ –∞–Ω–æ—Ç–∞—Ü–∏—ò–µ –∫–∞–æ –≤—Ä—Å—Ç—É
  –≥–µ–Ω–µ—Ä–∏—á–∫–æ–≥ —Ç–∏–ø–∞.

#+begin_src rust
struct ImportantExcerpt<'a> {
    part: &'a str,
}

fn main() {
    let novel = String::from("Call me Ishmael. Some years ago...");
    let first_sentence = novel.split('.').next().expect("Could not find a '.'");
    let i = ImportantExcerpt {
        part: first_sentence,
    };
}
#+end_src

*** –ï–ª–∏–∑–∏—ò–∞ –∂–∏–≤–æ—Ç–Ω–æ–≥ –≤–µ–∫–∞
- –ò–º–∞–ª–∏ —Å–º–æ –ø—Ä–µ—Ç—Ö–æ–¥–Ω–æ –ø—Ä–∏–º–µ—Ä —É –∫–æ–º–µ –Ω–∏—Å–º–æ –¥–µ—Ñ–∏–Ω–∏—Å–∞–ª–∏ –∞–Ω–æ—Ç–∞—Ü–∏—ò–µ –∂–∏–≤–æ—Ç–Ω–æ–≥ –≤–µ–∫–∞.

#+begin_src rust
fn first_word(s: &str) -> &str {
    let bytes = s.as_bytes();

    for (i, &item) in bytes.iter().enumerate() {
        if item == b' ' {
            return &s[0..i];
        }
    }

    &s[..]
}
#+end_src

- –ü–æ—Å—Ç–æ—ò–µ –æ–¥—Ä–µ—í–µ–Ω–∞ –ø—Ä–∞–≤–∏–ª–∞ –∫–æ—ò–µ –Ω–∞–∑–∏–≤–∞–º–æ /–ø—Ä–∞–≤–∏–ª–∏–º–∞ –µ–ª–∏–∑–∏—ò–µ –∂–∏–≤–æ—Ç–Ω–æ–≥ –≤–µ–∫–∞/
  (/lifetime elision rules/) –∏ –∫–æ—ò–∞ –æ–º–æ–≥—É—õ–∞–≤–∞—ò—É –¥–∞ —Å–µ –∏–∑–±–µ–≥–Ω–µ –∞–Ω–æ—Ç–∏—Ä–∞—ö–µ –∂–∏–≤–æ—Ç–Ω–æ–≥
  –≤–µ–∫–∞ –∫–∞–¥–∞ —ò–µ –∞–Ω–æ—Ç–∞—Ü–∏—ò–∞ –æ—á–∏–≥–ª–µ–¥–Ω–∞.

*** –ü—Ä–∞–≤–∏–ª–∞ –µ–ª–∏–∑–∏—ò–µ –∂–∏–≤–æ—Ç–Ω–æ–≥ –≤–µ–∫–∞
1. –ö–æ–º–ø–∞—ò–ª–µ—Ä –∫—Ä–µ–∏—Ä–∞ –∂–∏–≤–æ—Ç–Ω–∏ –≤–µ–∫ –∑–∞ —Å–≤–∞–∫—É —Ä–µ—Ñ–µ—Ä–µ–Ω—Ü—É —É –ø–∞—Ä–∞–º–µ—Ç—Ä–∏–º–∞ —Ñ—É–Ω–∫—Ü–∏—ò–µ:

#+begin_src rust
fn foo<'a>(x: &'a i32)
fn foo<'a, 'b>(x: &'a i32, y: &'b i32)
–∏—Ç–¥.
#+end_src

#+REVEAL: split

2. –ö–∞–¥–∞ –∏–º–∞–º–æ —Ç–∞—á–Ω–æ —ò–µ–¥–∞–Ω —É–ª–∞–∑–Ω–∏ –∂–∏–≤–æ—Ç–Ω–∏ –≤–µ–∫, –æ–Ω —ò–µ –¥–æ–¥–µ—ô–µ–Ω —Å–≤–∏–º —Ä–µ—Ñ–µ—Ä–µ–Ω—Ü–∞–º–∞ —É
   –ø–æ–≤—Ä–∞—Ç–Ω–æ—ò –≤—Ä–µ–¥–Ω–æ—Å—Ç–∏:

#+begin_src rust
fn foo<'a>(x: &'a i32) -> &'a i32
#+end_src

#+REVEAL: split

3. –ê–∫–æ –∏–º–∞ –≤–∏—à–µ —É–ª–∞–∑–Ω–∏—Ö –∂–∏–≤–æ—Ç–Ω–∏—Ö –≤–µ–∫–æ–≤–∞ –∞–ª–∏ —ò–µ —ò–µ–¥–∞–Ω —É–ª–∞–∑–Ω–∏ –ø–∞—Ä–∞–º–µ—Ç–∞—Ä =&self= ili
   =&mut self= —Ç–∞–¥–∞ —Å–µ –æ–≤–∞—ò –∂–∏–≤–æ—Ç–Ω–∏ –≤–µ–∫ –¥–æ–¥–µ—ô—É—ò–µ —Å–≤–∏–º –∏–∑–ª–∞–∑–Ω–∏–º —Ä–µ—Ñ–µ—Ä–µ–Ω—Ü–µ–º–∞.

*** –ü—Ä–∏–º–µ—Ä –µ–ª–∏–∑–∏—ò–µ 1

#+begin_src rust
fn first_word(s: &str) -> &str {
#+end_src

#+REVEAL: split

–ü—Ä–∞–≤–∏–ª–æ 1.

#+begin_src rust
fn first_word<'a>(s: &'a str) -> &str {
#+end_src

#+REVEAL: split

–ü—Ä–∞–≤–∏–ª–æ 2.

#+begin_src rust
fn first_word<'a>(s: &'a str) -> &'a str {
#+end_src

*** –ü—Ä–∏–º–µ—Ä –µ–ª–∏–∑–∏—ò–µ 2

#+begin_src rust
fn longest(x: &str, y: &str) -> &str {
#+end_src

#+REVEAL: split

–ü—Ä–∞–≤–∏–ª–æ 1.

#+begin_src rust
fn longest<'a, 'b>(x: &'a str, y: &'b str) -> &str {
#+end_src

- –ù–µ –º–æ–∂–µ–º–æ –¥–∞ –ø—Ä–∏–º–µ–Ω–∏–º–æ –Ω–∏ –ø—Ä–∞–≤–∏–ª–æ 2 –Ω–∏ –ø—Ä–∞–≤–∏–ª–æ 3. –ò –¥–∞—ô–µ –Ω–∞–º –∏–∑–ª–∞–∑–Ω–∏ –ø–∞—Ä–∞–º–µ—Ç–∞—Ä
  –Ω–µ–º–∞ –∞–Ω–æ—Ç–∞—Ü–∏—ò—É -> –∞–Ω–æ—Ç–∞—Ü–∏—ò–∞ –º–æ—Ä–∞ —Ä—É—á–Ω–æ –¥–∞ —Å–µ –æ–±–∞–≤–∏.
*** –ê–Ω–æ—Ç–∞—Ü–∏—ò–∞ –∂–∏–≤–æ—Ç–Ω–æ–≥ –≤–µ–∫–∞ —É –º–µ—Ç–æ–¥–∞–º–∞
#+begin_src rust
impl<'a> ImportantExcerpt<'a> {
    fn level(&self) -> i32 {
        3
    }
}
#+end_src

- –ù–∞ –æ—Å–Ω–æ–≤—É –ø—Ä–∞–≤–∏–ª–∞ 1. –Ω–µ –º–æ—Ä–∞–º–æ –¥–∞ –∞–Ω–æ—Ç–∏—Ä–∞–º–æ —É–ª–∞–∑–Ω—É —Ä–µ—Ñ–µ—Ä–µ–Ω—Ü—É.

#+REVEAL: split

#+begin_src rust
impl<'a> ImportantExcerpt<'a> {
    fn announce_and_return_part(&self, announcement: &str) -> &str {
        println!("Attention please: {}", announcement);
        self.part
    }
}
#+end_src

- –ù–∞ –æ—Å–Ω–æ–≤—É –ø—Ä–∞–≤–∏–ª–∞ 1 –Ω–µ –º–æ—Ä–∞–º–æ –¥–∞ –∞–Ω–æ—Ç–∏—Ä–∞–º–æ —É–ª–∞–∑–Ω–µ —Ä–µ—Ñ–µ—Ä–µ–Ω—Ü–µ –∞ –Ω–∞ –æ—Å–Ω–æ–≤—É
  –ø—Ä–∞–≤–∏–ª–∞ 3 –Ω–µ –º–æ—Ä–∞–º–æ –¥–∞ –∞–Ω–æ—Ç–∏—Ä–∞–º–æ –Ω–∏ –ø–æ–≤—Ä–∞—Ç–Ω—É –≤—Ä–µ–¥–Ω–æ—Å—Ç.

*** –ñ–∏–≤–æ—Ç–Ω–∏ –≤–µ–∫ =static=
- –°–ø–µ—Ü–∏—ò–∞–ª–∞–Ω –∂–∏–≤–æ—Ç–Ω–∏ –≤–µ–∫ –∫–æ—ò–∏ –æ–∑–Ω–∞—á–∞–≤–∞–º–æ —Å–∞ ='static= –æ–∑–Ω–∞—á–∞–≤–∞ –∂–∏–≤–æ—Ç–Ω–∏ –≤–µ–∫
  —Ü–µ–ª–æ–∫—É–ø–Ω–æ–≥ —Ç—Ä–∞—ò–∞—ö–∞ –∏–∑–≤—Ä—à–∞–≤–∞—ö–∞ –ø—Ä–æ–≥—Ä–∞–º–∞.
- –û–≤–∞—ò –∂–∏–≤–æ—Ç–Ω–∏ –≤–µ–∫ –∏–º–∞—ò—É —Å—Ç–∞—Ç–∏—á–∫–µ –≤—Ä–µ–¥–Ω–æ—Å—Ç–∏ —ò–µ—Ä —Å—É —Ç–∞–∫–≤–µ –≤—Ä–µ–¥–Ω–æ—Å—Ç–∏ —Å–º–µ—à—Ç–µ–Ω–µ
  –¥–∏—Ä–µ–∫—Ç–Ω–æ —É –∏–∑–≤—Ä—à–Ω—É –¥–∞—Ç–æ—Ç–µ–∫—É —Ç—ò. –Ω–∏—Å—É –∞–ª–æ—Ü–∏—Ä–∞–Ω–µ —É —Ç–æ–∫—É –∏–∑–≤—Ä—à–∞–≤–∞—ö–∞ –ø—Ä–æ–≥—Ä–∞–º–∞.

#+begin_src rust
let s: &'static str = "I have a static lifetime.";
#+end_src

*** –ì–µ–Ω–µ—Ä–∏—á–∫–∏ —Ç–∏–ø–æ–≤–∏, –æ–≥—Ä–∞–Ω–∏—á–µ—ö–µ –∫—Ä–æ–∑ –æ—Å–æ–±–∏–Ω–µ –∏ –∂–∏–≤–æ—Ç–Ω–∏ –≤–µ–∫
#+begin_src rust
use std::fmt::Display;

fn longest_with_an_announcement<'a, T>(
    x: &'a str,
    y: &'a str,
    ann: T,
) -> &'a str
where
    T: Display,
{
    println!("Announcement! {}", ann);
    if x.len() > y.len() {
        x
    } else {
        y
    }
}
#+end_src

* TODO –§—É–Ω–∫—Ü–∏–æ–Ω–∞–ª–Ω–æ –ø—Ä–æ–≥—Ä–∞–º–∏—Ä–∞—ö–µ, –∑–∞—Ç–≤–æ—Ä–µ—ö–∞ –∏ –∏—Ç–µ—Ä–∞—Ç–æ—Ä–∏
* TODO –ú–∞–∫—Ä–æ–∏
* TODO –û–û–ü, –ø–∞–º–µ—Ç–Ω–∏ –ø–æ–∏–Ω—Ç–µ—Ä–∏, –∫–æ–Ω–∫—É—Ä–µ–Ω—Ç–Ω–æ –ø—Ä–æ–≥—Ä–∞–º–∏—Ä–∞—ö–µ
* –õ–∏—Ç–µ—Ä–∞—Ç—É—Ä–∞
- Steve Klabnik and Carol Nichols: [[https://doc.rust-lang.org/book/][The Rust Programming Language]], no starch press.
- Rust by Example, https://doc.rust-lang.org/stable/rust-by-example/index.html
- Slice is NOT reference, https://github.com/rust-lang/book/issues/3070
- Google: Comprehensive Rust, https://google.github.io/comprehensive-rust/
- [[https://rust-lang.github.io/rfcs/0505-api-comment-conventions.html][RFC 505: API documentation conventions]]
