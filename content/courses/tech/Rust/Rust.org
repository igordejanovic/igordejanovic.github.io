# -*- ispell-dictionary: "sr"; -*-
#+TITLE: Програмски језик Раст
#+SUBTITLE: Базирано на верзији 1.65.0. У изради.
#+EXPORT_FILE_NAME: index.html
#+EXPORT_REVEAL_HLEVEL: 10
#+SETUPFILE: ../../courses-startup-cyr.org

* Увод
- Језик опште намене, компајлиран и статички типизиран са инференцом типова
- Системско програмирање али са особинама вишег нивоа апстракције као што су
  функционално програмирање
- 2010, Graydon Hoare, Mozilla Research
- Перформансе и сигурност
- Не користи /garbage collector/ али обезбеђује меморијску сигурност кроз /borrow
  checker/
- Синтаксно сличан C++. Утицај и OCaml-а, Haskell-а и Erlang-а.
- Користи се у великим фирмама: Amazon, Facebook, Google, Microsoft...
- Више година за редом на SO упитнику први у категорији /"most loved programming
  languages"/

* Инсталација и подешавање
** Инсталација
- Раст стиже са алатом за управљање ланцем алата (енг. /toolchain/) -- =rustup=

#+begin_src sh
$ curl --proto '=https' --tlsv1.2 https://sh.rustup.rs -sSf | sh
#+end_src

- Провера инсталације:

#+begin_src sh
~> rustc --version
rustc 1.65.0 (897e37553 2022-11-02)
#+end_src

** Преглед инсталације
#+begin_src sh
~> rustup show
Default host: x86_64-unknown-linux-gnu
rustup home:  /home/igor/.rustup

installed toolchains
--------------------

stable-x86_64-unknown-linux-gnu (default)
nightly-x86_64-unknown-linux-gnu

active toolchain
----------------

stable-x86_64-unknown-linux-gnu (default)
rustc 1.58.1 (db9d1b20b 2022-01-20)
#+end_src

** Ажурирање
За ажурирање инсталације на најновију верзију:

#+begin_src sh
rustup update
#+end_src

** Документација
Раст стиже са веома добром документацијом и књигама које су доступне директно из
инсталације:

#+begin_src sh
rustup doc
#+end_src

* Почетак
** Hello, World!
#+begin_src sh
$ mkdir hello_world
$ cd hello_world
#+end_src

File =main.rs=:
#+begin_src rust
fn main() {
    println!("Hello, world!");
}
#+end_src

** Компајлирање и покретање
#+begin_src sh
$ rustc main.rs
$ ./main
Hello, world!
#+end_src

** Hello, Cargo!
- Алат за разрешавање зависности и управљање пројектом.

#+begin_src sh
~> cargo --version
cargo 1.65.0 (4bc8f24d3 2022-10-20)
#+end_src

- Креирање пројекта са =cargo= алатом:

#+begin_src sh
$ cargo new hello_cargo
$ cd hello_cargo
#+end_src

** Садржај креираног пројекта
Фајл =cargo.toml= чува конфигурацију пројекта. Формат је [[https://toml.io/en/][TOML]] (/Tom’s Obvious,
Minimal Language/):

#+begin_src toml
[package]
name = "hello_cargo"
version = "0.1.0"
edition = "2021"

[dependencies]
#+end_src

Fajl =src/main.rs=:
#+begin_src rust
fn main() {
    println!("Hello, world!");
}
#+end_src

** Покретање
#+begin_src rust
$ cargo build
   Compiling hello_cargo v0.1.0 (file:///projects/hello_cargo)
    Finished dev [unoptimized + debuginfo] target(s) in 2.85 secs
#+end_src

Извршни фајл се може наћи на локацији =target/debug/hello_cargo=:

#+begin_src sh
$ ./target/debug/hello_cargo
Hello, world!
#+end_src

Али =cargo= омогућава и једноставнији начин покретања:
#+begin_src sh
$ cargo run
    Finished dev [unoptimized + debuginfo] target(s) in 0.0 secs
     Running `target/debug/hello_cargo`
Hello, world!
#+end_src

** Провера
Такође је могуће брзо проверити да ли се код компајлира:

#+begin_src sh
$ cargo check
   Checking hello_cargo v0.1.0 (file:///projects/hello_cargo)
    Finished dev [unoptimized + debuginfo] target(s) in 0.32 secs
#+end_src

** Изградња финалне верзије
- У току развоја користимо изградњу за дебаговање која се брже заврши али
  генерисани извршни код није оптималан.

- За финалну верзију је потребно изградњу обавити на следећи начин:

    #+begin_src rust
    cargo build --release
    #+end_src

- Ово ће обавити додатне оптимизације које ће дуже трајати али ће крајњи код
  бити оптимизован.

** =cargo= као конвенција
Практично сви Раст пројекти користе =cargo= тако да је унификован начин изградње
пројеката. Углавном се своди на:

#+begin_src sh
$ git clone example.org/someproject
$ cd someproject
$ cargo build
#+end_src
* Игра погађања бројева
** Подешавање пројекта
#+begin_src rust
$ cargo new guessing_game
$ cd guessing_game
#+end_src

Фајл =Cargo.toml=:
#+begin_src toml
[package]
name = "guessing_game"
version = "0.1.0"
edition = "2021"

[dependencies]
#+end_src

Фајл =src/main.rs=:
#+begin_src rust
fn main() {
    println!("Hello, world!");
}
#+end_src

#+REVEAL: split

#+begin_src sh
$ cargo run
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
    Finished dev [unoptimized + debuginfo] target(s) in 1.50s
     Running `target/debug/guessing_game`
Hello, world!
#+end_src

** Преузимање броја са стандардног улаза
#+begin_src rust
use std::io;

fn main() {
    println!("Guess the number!");

    println!("Please input your guess.");

    let mut guess = String::new();

    io::stdin()
        .read_line(&mut guess)
        .expect("Failed to read line");

    println!("You guessed: {}", guess);
}
#+end_src

** Променљивост (/mutability/)
- Варијабле су подразумевано непромењиве (/immutable/).
- Уколико желимо варијаблу чија вредност може да се мења користимо кључну реч
  =mut=.

  #+begin_src rust
  let apples = 5; // immutable
  let mut bananas = 5; // mutable
  #+end_src

- Исто важи и за параметре и аргументе функција:

  #+begin_src rust
  io::stdin()
      .read_line(&mut guess)
  #+end_src

** Обрада могућих грешака употребом =Result= типа
=read_line= може да заврши неуспешно. Зато враћа =io::Result= тип који представља
тип енумерације (/enum/) и има две могуће вредности: =Ok= и =Err=.

#+begin_src rust
io::stdin()
    .read_line(&mut guess)
    .expect("Failed to read line");
#+end_src

=expect= je имплементиран тако да ће у случају =Ok= варијанте вратити вредност која
је садржана унутар варијанте док ће у случају =Err= варијанте прекинути извршавање
програма.

#+begin_src rust
pub fn expect(self, msg: &str) -> T
    where
        E: fmt::Debug,
    {
        match self {
            Ok(t) => t,
            Err(e) => unwrap_failed(msg, &e),
        }
    }
#+end_src

** Покретање
#+begin_src rust
$ cargo run
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
    Finished dev [unoptimized + debuginfo] target(s) in 6.44s
     Running `target/debug/guessing_game`
Guess the number!
Please input your guess.
6
You guessed: 6
#+end_src

** Генерисање случајног броја
Користимо =rand= пакет (сандук - /crate/ у терминологији /Cargo/-a).

Секција =[dependencies]= у фајлу =Cargo.toml=:
#+begin_src toml
[dependencies]
rand = "0.8.3"
#+end_src

#+begin_src sh
$ cargo build
    Updating crates.io index
  Downloaded rand v0.8.3
  Downloaded libc v0.2.86
  ...
   Compiling rand_chacha v0.3.0
   Compiling rand v0.8.3
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
    Finished dev [unoptimized + debuginfo] target(s) in 2.53s
#+end_src

/Cargo/ користи [[https://semver.org/][Semantic Versioning]]. Раст пакети се преузимају са сајта [[https://crates.io/][crates.io]]
и кеширају локално.

** Поновљивост изградње - /Cargo.lock/
- Свако следеће покретање изградње користи исте верзије.
- Први пут када се покрене =cargo build= креира се фајл =Cargo.lock= са
  информацијама о верзијама свих сандука који су инсталирани.
- =Cargo.lock= је потребно чувати у систему контроле верзија (нпр. =git=) да би се
  осигурала поновљивост.

** Ажурирање сандука
- Ажурирање на нове верзије сандука се обавља са:

  #+begin_src sh
  $ cargo update
    Updating crates.io index
    Updating rand v0.8.3 -> v0.8.4
  #+end_src
- Поштује се семантичко верзионирање тј. аутоматски се ажурира на следећу
  верзију која је мања од наредне главне (/major/) верзије.
- Ако прелазимо на нову главну верзију то морамо урадити изменом верзије у
  =Cargo.toml= фајлу.

** Генерисање случајног броја
Фајл =src/main.rs=:
#+begin_src rust
use std::io;
use rand::Rng;

fn main() {
    println!("Guess the number!");

    let secret_number = rand::thread_rng().gen_range(1..101);

    println!("The secret number is: {}", secret_number);

    println!("Please input your guess.");

    let mut guess = String::new();

    io::stdin()
        .read_line(&mut guess)
        .expect("Failed to read line");

    println!("You guessed: {}", guess);
}
#+end_src

У =gen_range= користимо израз опсега (/range expression/). Интервал је затворен на
доњој граници и отворен на горњој. За интервал затворен и од горе можемо
писати ~1..=100~.

** Документација за локалне сандуке
Да би знали које методе и функције су нам доступне можемо користити уграђену
документацију за сандуке пројекта. Документацију добијамо са:

#+begin_src sh
cargo doc --open
#+end_src

** Покретање програма
#+begin_src sh
$ cargo run
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
    Finished dev [unoptimized + debuginfo] target(s) in 2.53s
     Running `target/debug/guessing_game`
Guess the number!
The secret number is: 7
Please input your guess.
4
You guessed: 4
#+end_src

** Поређење тајног броја са задатим
Фајл =src/main.rs=
#+begin_src rust
use rand::Rng;
use std::cmp::Ordering;
use std::io;

fn main() {
    // --snip--

    println!("You guessed: {}", guess);

    match guess.cmp(&secret_number) {
        Ordering::Less => println!("Too small!"),
        Ordering::Greater => println!("Too big!"),
        Ordering::Equal => println!("You win!"),
    }
}
#+end_src
- Користимо =std::cmp::Ordering= енумерисани тип који има варијанте =Less=, =Greater=
  и =Equal=
- =match= израз пореди задату вредност са вредностима задатим у телу и извршава
  грану која се подудара. Гране =match= израза се у Раст терминологији зову "руке"
  (/arms/).

** Поправка типова
Код са претходног слајда није исправан:
#+begin_src sh
$ cargo build
   Compiling libc v0.2.86
   ...
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
error[E0308]: mismatched types
  --> src/main.rs:22:21
   |
22 |     match guess.cmp(&secret_number) {
   |                     ^^^^^^^^^^^^^^ expected struct `String`, found integer
   |
   = note: expected reference `&String`
              found reference `&{integer}`

error[E0283]: type annotations needed for `{integer}`
   --> src/main.rs:8:44
    |
8   |     let secret_number = rand::thread_rng().gen_range(1..101);
    |         -------------                      ^^^^^^^^^ cannot infer type for type `{integer}`
    |         |
    |         consider giving `secret_number` a type
    |
    = note: multiple `impl`s satisfying `{integer}: SampleUniform` found in the `rand` crate:
            - impl SampleUniform for i128;
            - impl SampleUniform for i16;
            - impl SampleUniform for i32;
            - impl SampleUniform for i64;
            and 8 more
...
#+end_src

#+REVEAL: split

Основа грешке је неслагање типова. Са улаза прихватамо =String= док нам је тајни
број =integer=.

** Конверзија стринга у број
Проблем решавамо конверзијом стринга са улаза у бројни тип.

#+begin_src rust
// --snip--

    let mut guess = String::new();

    io::stdin()
        .read_line(&mut guess)
        .expect("Failed to read line");

    let guess: u32 = guess.trim().parse().expect("Please type a number!");

    println!("You guessed: {}", guess);

    match guess.cmp(&secret_number) {
        Ordering::Less => println!("Too small!"),
        Ordering::Greater => println!("Too big!"),
        Ordering::Equal => println!("You win!"),
    }
#+end_src

#+REVEAL: split

Сада се програм компајлира.

#+begin_src sh
$ cargo run
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
    Finished dev [unoptimized + debuginfo] target(s) in 0.43s
     Running `target/debug/guessing_game`
Guess the number!
The secret number is: 58
Please input your guess.
  76
You guessed: 76
Too big!
#+end_src

** Омогућавање вишеструког погађања - употреба петље
Фајл =src/main.rs=:
#+begin_src rust
// --snip--

    println!("The secret number is: {}", secret_number);

    loop {
        println!("Please input your guess.");

        // --snip--

        match guess.cmp(&secret_number) {
            Ordering::Less => println!("Too small!"),
            Ordering::Greater => println!("Too big!"),
            Ordering::Equal => println!("You win!"),
        }
    }
}
#+end_src

** Прекид рада
Проблем је како прекинути програм када корисник погоди број?

#+begin_src rust
// --snip--

        match guess.cmp(&secret_number) {
            Ordering::Less => println!("Too small!"),
            Ordering::Greater => println!("Too big!"),
            Ordering::Equal => {
                println!("You win!");
                break;
            }
        }
    }
}
#+end_src

** Руковање неисправним улазом
#+begin_src rust
// --snip--

        io::stdin()
            .read_line(&mut guess)
            .expect("Failed to read line");

        let guess: u32 = match guess.trim().parse() {
            Ok(num) => num,
            Err(_) => continue,
        };

        println!("You guessed: {}", guess);

        // --snip--
#+end_src

Потребно је још обрисати линију која приказује генерисани број.

** Финални код
#+begin_src rust
use rand::Rng;
use std::cmp::Ordering;
use std::io;

fn main() {
    println!("Guess the number!");
    let secret_number = rand::thread_rng().gen_range(1..101);

    loop {
        println!("Please input your guess.");
        let mut guess = String::new();
        io::stdin()
            .read_line(&mut guess)
            .expect("Failed to read line");
        let guess: u32 = match guess.trim().parse() {
            Ok(num) => num,
            Err(_) => continue,
        };
        println!("You guessed: {}", guess);
        match guess.cmp(&secret_number) {
            Ordering::Less => println!("Too small!"),
            Ordering::Greater => println!("Too big!"),
            Ordering::Equal => {
                println!("You win!");
                break;
            }
        }
    }
}
#+end_src

* Основни програмски концепти
** Варијабле и променљивост (/mutability/)
*** Варијабле и променљивост (/mutability/)
- Варијабле су подразумевано непромењиве.
- Једном када добију вредност (/binding/) та вредност се не може променити

  #+begin_src rust
    fn main() {
        let x = 5;
        println!("The value of x is: {}", x);
        x = 6;     // greška
        println!("The value of x is: {}", x);
    }
  #+end_src

  #+REVEAL: split

  #+begin_src sh
    $ cargo run
    Compiling variables v0.1.0 (file:///projects/variables)
    error[E0384]: cannot assign twice to immutable variable `x`
    --> src/main.rs:4:5
    |
    2 |     let x = 5;
    |         -
    |         |
    |         first assignment to `x`
    |         help: consider making this binding mutable: `mut x`
    3 |     println!("The value of x is: {}", x);
    4 |     x = 6;
    |     ^^^^^ cannot assign twice to immutable variable

    For more information about this error, try `rustc --explain E0384`.
    error: could not compile `variables` due to previous error
  #+end_src
*** =mut= кључна реч

#+begin_src rust
fn main() {
    let mut x = 5;
    println!("The value of x is: {}", x);
    x = 6;
    println!("The value of x is: {}", x);
}
#+end_src
** Константе - =const=
- Слично као непромењиве варијабле са следећим разликама:
  - Увек су непромењиве
  - Могу се иницијализовати само константним изразом (познатим у време
    компајлирања)
  - Валидне за целокупно време извршавања програма у опсегу важења где су
    дефинисане (/scope/)
  - Мора се експлицитно дефинисати тип
- Компајлер ће константе "убацити" на месту употребе
- По конвенцији имена константи се пишу великим словима

  #+begin_src rust
    const THREE_HOURS_IN_SECONDS: u32 = 60 * 60 * 3;
  #+end_src

** Типови података
*** Типови података
- Свака вредност у Расту има тип. Типови морају бити познати у време
  компајлирања (/статички типизиран језик/).
- Компајлер ће пробати да одреди типове (/type inference/). Ако није могуће
  захтева се да дефинишемо тип експлицитно.

  Нпр:
  #+begin_src rust
    let guess: u32 = "42".parse().expect("Not a number!");
  #+end_src
  Овде није могуће одредити тип јер =str::parse= функција може вратити различите
  бројне типове (функција је генеричка) а не постоји начин да се тип аутоматски
  одреди.

  Сигнатура је:
  #+begin_src rust
    pub fn parse<F>(&self) -> Result<F, <F as FromStr>::Err>
    where
        F: FromStr
  #+end_src
*** /Integer/ типови

| Дужина  | Signed | Unsigned |
|---------+--------+----------|
| 8-bit   | i8     | u8       |
| 16-bit  | i16    | u16      |
| 32-bit  | i32    | u32      |
| 64-bit  | i64    | u64      |
| 128-bit | i128   | u128     |
| arch    | isize  | usize    |

*** Литерали бројева

| Литерали       | Примери     |
|----------------+-------------|
| Decimal        | 98_222      |
| Hex            | 0xff        |
| Octal          | 0o77        |
| Binary         | 0b1111_0000 |
| Byte (u8 only) | b'A'        |

*** /Floating-Point/ типови

#+begin_src rust
fn main() {
    let x = 2.0; // f64

    let y: f32 = 3.0; // f32
}
#+end_src

IEEE-754 стандард

*** Операције над бројевима

#+begin_src rust
fn main() {
    // addition
    let sum = 5 + 10;

    // subtraction
    let difference = 95.5 - 4.3;

    // multiplication
    let product = 4 * 30;

    // division
    let quotient = 56.7 / 32.2;
    let floored = 2 / 3; // Results in 0

    // remainder
    let remainder = 43 % 5;
}
#+end_src

*** /Boolean/ тип
#+begin_src rust
fn main() {
    let t = true;

    let f: bool = false; // with explicit type annotation
}
#+end_src

*** Тип карактера

#+begin_src rust
fn main() {
    let c = 'z';
    let z = 'ℤ';
    let heart_eyed_cat = '😻';
}
#+end_src

*** Торке (/tuples/)
#+begin_src rust
fn main() {
    let tup: (i32, f64, u8) = (500, 6.4, 1);
}
#+end_src

- Распакивање торки (/destructuring/):
#+begin_src rust
fn main() {
    let tup = (500, 6.4, 1);

    let (x, y, z) = tup;

    println!("The value of y is: {}", y);
}
#+end_src

#+REVEAL: split

Приступ елементима торке:
#+begin_src rust
fn main() {
    let x: (i32, f64, u8) = (500, 6.4, 1);

    let five_hundred = x.0;

    let six_point_four = x.1;

    let one = x.2;
}
#+end_src

*** Низовни тип
- Сваки елемент низовног типа мора имати исти тип
- Димензија низа је непромењива (алоциран је на стеку)
    #+begin_src rust
    fn main() {
        let a = [1, 2, 3, 4, 5];
    }
    #+end_src

- Тип се може експлицитно дефинисати на следећи начин (низ дужине =5= типа =i32=):
    #+begin_src rust
    let a: [i32; 5] = [1, 2, 3, 4, 5];
    #+end_src

- Иницијализација свих елемената на исту вредност се обавља на следећи начин:
  #+begin_src rust
  let a = [3; 5];
  #+end_src
  Где је вредност сваког елемента =3= а дужина низа =5=.

#+REVEAL: split

Индексни приступ:

#+begin_src rust
fn main() {
    let a = [1, 2, 3, 4, 5];

    let first = a[0];
    let second = a[1];
}
#+end_src

** Функције
*** Функције
#+begin_src rust
fn main() {
    println!("Hello, world!");

    another_function();
}

fn another_function() {
    println!("Another function.");
}
#+end_src
- За именовање функција као и варијабли користи се /snake_case/.
*** Funkcije - parametri
#+begin_src rust
fn main() {
    print_labeled_measurement(5, 'h');
}

fn print_labeled_measurement(value: i32, unit_label: char) {
    println!("The measurement is: {}{}", value, unit_label);
}
#+end_src

*** Искази и изрази
- Рaст је језик базиран на изразима (/expression-based/)
- Искази (/statements/) су језичке конструкције које немају повратну вредност.
  Изрази (/expressions/) се евалуирају у одређени резултат, тј. имају вредност.
- Пример: =let= је исказ тј. нема повратну вредност. Ово можете писати:
  #+begin_src rust
  let y = 6;
  #+end_src
  Ali ovo ne:
  #+begin_src rust
  let x = (let y = 6);
  #+end_src

#+REVEAL: split

Блок кода је такође израз. Шта је вредност у коју се евалуира?

#+begin_src rust
{
    let x = 3;
    x + 1
}
#+end_src

Вредност блока је вредност последњег израза, тј. =x+1=. Приметите да ту не
користимо =;= јер терминација овим карактером претвара израз у исказ.

#+REVEAL: split

Због овога је сасвим легално да пишемо:

#+begin_src rust
fn main() {
    let y = {
        let x = 3;
        x + 1
    };

    println!("The value of y is: {}", y);
}
#+end_src

#+RESULTS:
: The value of y is: 4
*** Повратне вредности функција
Вредност функције је вредност блока који представља тело функције, дакле
последњег израза унутар тела функције.

#+begin_src rust
fn five() -> i32 {
    5
}

fn main() {
    let x = five();

    println!("The value of x is: {}", x);
}
#+end_src

#+RESULTS:
: The value of x is: 5

#+REVEAL: split

Или на пример:
#+begin_src rust
fn main() {
    let x = plus_one(5);

    println!("The value of x is: {}", x);
}

fn plus_one(x: i32) -> i32 {
    x + 1
}
#+end_src

#+RESULTS:
: The value of x is: 6

#+REVEAL: split

Уколико израз =x+1= терминирамо са =;= код се неће компајлирати јер функција
декларише да враћа тип =i32= док сада враћа =()= (тзв. /unit type/) односно нема
повратну вредност јер је последња инструкција исказ.

#+begin_src rust
fn main() {
    let x = plus_one(5);

    println!("The value of x is: {}", x);
}

fn plus_one(x: i32) -> i32 {
    x + 1;
}
#+end_src

#+begin_example
error[E0308]: mismatched types
 --> src/main.rs:8:24
  |
8 | fn plus_one(x: i32) -> i32 {
  |    --------            ^^^ expected `i32`, found `()`
  |    |
  |    implicitly returns `()` as its body has no tail or `return` expression
9 |     x + 1;
  |          - help: consider removing this semicolon

For more information about this error, try `rustc --explain E0308`.
error: could not compile `cargo4UyKF0` due to previous error
#+end_example

** Коментари
Коментари се пишу после =//= или у форми блок коментара =/*.... */= као и у C++-у.
Ово би били валидни коментари:
#+begin_src rust
// So we’re doing something complicated here, long enough that we need
// multiple lines of comments to do it! Whew! Hopefully, this comment will
// explain what’s going on.

fn main() {
    let lucky_number = 7; // I’m feeling lucky today
}
...
fn main() {
    // I’m feeling lucky today
    let lucky_number = 7;
    /* this is block comment
       which can span multiple lines.
       Nesting is allowed.
     */
}
#+end_src

#+REVEAL: split

Постоје и коментари за документацију који представљају посебну синтаксу за
коментаре који су део API документације. Они се пишу после =///=. На пример:
#+begin_src rust
/// Adds one to the number given.
///
/// # Examples
///
/// ```
/// let arg = 5;
/// let answer = my_crate::add_one(arg);
///
/// assert_eq!(6, answer);
/// ```
pub fn add_one(x: i32) -> i32 {
    x + 1
}
#+end_src
** Контрола тока
*** =if= изрази
#+begin_src rust
fn main() {
    let number = 3;

    if number < 5 {
        println!("condition was true");
    } else {
        println!("condition was false");
    }
}
#+end_src

*** =if-else=
#+begin_src rust
fn main() {
    let number = 6;

    if number % 4 == 0 {
        println!("number is divisible by 4");
    } else if number % 3 == 0 {
        println!("number is divisible by 3");
    } else if number % 2 == 0 {
        println!("number is divisible by 2");
    } else {
        println!("number is not divisible by 4, 3, or 2");
    }
}
#+end_src
*** =if= у =let= исказима
=if= је израз па се може користити где год можемо писати и било који други израз.

#+begin_src rust
fn main() {
    let condition = true;
    let number = if condition { 5 } else { 6 };

    println!("The value of number is: {}", number);
}
#+end_src

#+RESULTS:
: The value of number is: 5

#+REVEAL: split

Али се гране морају слагати по типу. Ово је погрешно јер је прва грана типа
=i32= док је =else= грана типа =str=.

#+begin_src rust
fn main() {
    let condition = true;

    let number = if condition { 5 } else { "six" };

    println!("The value of number is: {}", number);
}
#+end_src
*** Петље
Рaст има три типа петље:
- =loop= - за бесконачне петље
- =while= - условна петља
- =for= - петља за итерацију кроз елементе итерабилних типова

*** =loop=
#+begin_src rust
fn main() {
    loop {
        println!("again!");
    }
}
#+end_src

*** =loop= лабеле
Уколико имамо угњеждене =loop= исказе можемо користити лабеле приликом изласка са
=break= инструкцијом.

#+begin_src rust
fn main() {
    let mut count = 0;
    'counting_up: loop {
        println!("count = {}", count);
        let mut remaining = 10;

        loop {
            println!("remaining = {}", remaining);
            if remaining == 9 {
                break;
            }
            if count == 2 {
                break 'counting_up;
            }
            remaining -= 1;
        }

        count += 1;
    }
    println!("End count = {}", count);
}
#+end_src

*** =loop= као израз
=loop= може имати повратну вредност. Повратна вредност се дефинише као параметар
=break= инструкције.

#+begin_src rust
fn main() {
    let mut counter = 0;

    let result = loop {
        counter += 1;

        if counter == 10 {
            break counter * 2;
        }
    };

    println!("The result is {}", result);
}
#+end_src
*** =while=
#+begin_src rust
fn main() {
    let mut number = 3;

    while number != 0 {
        println!("{}!", number);

        number -= 1;
    }

    println!("LIFTOFF!!!");
}
#+end_src
*** =for=
Итерацију кроз уређену колекцију, као што је низ, можемо обавити са =while= петљом.
#+begin_src rust
fn main() {
    let a = [10, 20, 30, 40, 50];
    let mut index = 0;

    while index < 5 {
        println!("the value is: {}", a[index]);

        index += 1;
    }
}
#+end_src

#+REVEAL: split
Али је за ту намену природније и сигурније користити =for= петљу. Такође ће се
програм брже извршавати.

#+begin_src rust
fn main() {
    let a = [10, 20, 30, 40, 50];

    for element in a {
        println!("the value is: {}", element);
    }
}
#+end_src

#+REVEAL: split
=for= петље су најчешћи облик петљи у употреби у Расту. Користе се нпр. и у
ситуацији када је потребно извршити петљу одређени број пута.

#+begin_src rust
fn main() {
    for number in (1..4).rev() {
        println!("{}!", number);
    }
    println!("LIFTOFF!!!");
}
#+end_src

#+RESULTS:
: 3!
: 2!
: 1!
: LIFTOFF!!!

* Власништво и позајмљивање (/Ownership and borrowing/)
** Власништво
*** Власништво
- Један од најважнијих концепата језика.
- Скуп правила који омогућавају управљање меморијом.
- Гаранције за меморијску сигурност без употребе /garbage collector/-а
- Све провере се обављају у време компајлирања - резултује одличним
  перформансама у време извршавања.

*** Стек и хип (/Stack and Heap/)
- Стек - алокација простора за податке чија је величина позната у време
  компајлирања.
  - Бржа алокација и деалокација - једноставан механизам, LIFO структура.
  - Бржи приступ - локалне варијабле, кеширање приступа.
- Хип - слободна алокација у време извршавања.
  - Спорија алокација и деалокација.
  - Спорији приступ - произвољна локација.

*** Правила власништва
1. Свака вредност у Расту има варијаблу која се назива /власником/ (/owner/).
2. У сваком тренутку постоји само један власник.
3. Када власник изађе из опсега важења (/scope/) вредност се деалоцира (/drop/).

*** Опсег важења варијабле (/Variable Scope/)

#+begin_src rust
{                      // s није валидно овде јер још није декларисано
    let s = "hello";   // s је валидно од ове позиције

    // користимо s
}   // овде опсег престаје да важи и s више није валидно
#+end_src

*** =String= тип

- Демонстрација власништва над типом који се алоцира на хипу.

  #+begin_src rust
  let mut s = String::from("hello");
  s.push_str(", world!"); // push_str() додаје литерал на стринг
  println!("{}", s); // hello, world!`
  #+end_src

- Меморија се алоцира са хипа у време извршавања.
- Морамо вратити меморију алокатору када нам више није потребна.

#+REVEAL: split

- Алокација стринга се обавља на линији:

  #+begin_src rust
  let mut s = String::from("hello");
  #+end_src

- Али деалокација је тежа:
  - /Garbage collector/
  - /Memory waste/
  - /Double-free/

#+REVEAL: split

- Раст компајлер ће додати код који ради деалокацију када власник напусти опсег важења.
- Позива се функција =drop= над типом и ова функција је задужена да обави деалокацију.

  #+begin_src rust
  {
        let s = String::from("hello"); // s постаје валидно

        // користимо s
  }  // <- s излази из опсега и позива се "drop"
  #+end_src

*** Додела вредности
- Копирање вредности =x= у =y=. Обе варијабле сада имају вредност =5=.

  #+begin_src rust
  let x = 5;
  let y = x;
  #+end_src

- Али са =String= типом дешава се нешто друго.

  #+begin_src rust
  let s1 = String::from("hello");
  #+end_src

#+attr_html: :style height: 400px;
#+ATTR_ORG: :width 300px
[[./images/string-type.png]]

#+REVEAL: split

- Ако би се копирао само садржај са стека без имали бисмо следећу ситуацију
  (тзв. /shallow copy/).

  #+begin_src rust
  let s1 = String::from("hello");
  let s2 = s1;
  #+end_src

#+attr_html: :style height: 400px;
#+ATTR_ORG: :width 300px
[[./images/string-type-2.png]]

Што је проблематично јер када и =s1= и =s2= напусте опсег покушаће се двострука
деалокација исте меморије на хипу (/double free/).

#+REVEAL: split

Ако би се и хип меморија копирала (tzv. /deep copy/) имали бисмо валидну ситуацију
али би таква операција била веома "скупа".

#+attr_html: :style height: 500px;
#+ATTR_ORG: :width 300px
[[./images/string-type-3.png]]

*** Премештање (/Move/)
Ако пробамо да компајлирамо следећи код:

#+begin_src rust
let s1 = String::from("hello");
let s2 = s1;

println!("{}, world!", s1);
#+end_src

Добићемо грешку:

#+begin_example
$ cargo run
   Compiling ownership v0.1.0 (file:///projects/ownership)
error[E0382]: borrow of moved value: `s1`
 --> src/main.rs:5:28
  |
2 |     let s1 = String::from("hello");
  |         -- move occurs because `s1` has type `String`, which does not implement the `Copy` trait
3 |     let s2 = s1;
  |              -- value moved here
4 |
5 |     println!("{}, world!", s1);
  |                            ^^ value borrowed here after move

For more information about this error, try `rustc --explain E0382`.
error: could not compile `ownership` due to previous error
#+end_example

#+REVEAL: split

Оно што нам компајлер каже је да се у исказу:

#+begin_src rust
let s2 = s1;
#+end_src

променио власник овог стринга. Нови власник је сада =s2= док је варијабла =s1=
постала невалидна и није је више могуће користити.

Кажемо да се обавило "премештање" (/move/) вредности из =s1= у =s2=.

#+attr_html: :style height: 400px;
#+ATTR_ORG: :width 300px
[[./images/string-type-4.png]]

Чиме се испуњава прво правило власништва и спречава /double free/ грешка.

*** Клонирање
Последица претходног је да Раст никада неће аутоматски обавити дубоко копирање
варијабле јер би то могло да изазове лоше перформансе.

Дубоко копирање (стек+хип) радимо са =clone= методом:

#+begin_src rust
let s1 = String::from("hello");
let s2 = s1.clone();

println!("s1 = {}, s2 = {}", s1, s2);
#+end_src

Сада је лако пронаћи у коду сва места где се обавља потенцијално "скупа"
операција дубоког копирања.

*** /Copy/ типови
Како онда ради пример који смо видели претходно? Зашто не долази до премештања
и инвалидације =y= варијабле?

#+begin_src rust
let x = 5;
let y = x;

println!("x = {}, y = {}", x, y);
#+end_src

- Код простих типова чија је величина позната у време компајлирања и који могу
  у целости стати на стек нема разлике између дубоког и плитког копирања.
- Овакви типови су анотирани са /Copy/ трејтом (/Trait/). Типови који су на овај
  начин анотирани не обављају премештање већ увек копирање.
- Импликација је да се варијабла са десне стране доделе може користити и након
  доделе.
- Раст ће спречити /Copy/ анотацију ако тип имплементира и /Drop/ јер то значи да
  ради неку специјалну алокацију па му је потребна и посебна деалокација што
  значи да мора да се ради премештање.

*** Власништво и функције
- Семантика преноса параметара код позива функција је слична семантици доделе.

#+begin_src rust
fn main() {
    let s = String::from("hello");  // s постаје валидно

    takes_ownership(s);             // s вредност се премешта у функцију...
                                    // ... тако да s није валидно од ове позиције

    let x = 5;                      // x постаје валидно

    makes_copy(x);                  // x би се преместило у функцију,
                                    // али i32 је Copy, тако да је ok
                                    // да се x користи и после

} // x излази из опсега, затим s. Али пошто је s премештено ништа посебно се
  // не дешава.

fn takes_ownership(some_string: String) { // some_string улази у опсег
    println!("{}", some_string);
} // some_string излази из опсега и позива се `drop`. Меморија са хипа се
  // ослобађа.

fn makes_copy(some_integer: i32) { // some_integer улази у опсег
    println!("{}", some_integer);
} // some_integer излази из опсега. Пошто није 'Drop', ништа посебно се не
  // догађа (осим "скидања" са стека наравно)
#+end_src

*** Повратне вредности и опсези
Приликом враћања вредности из функције такође може доћи до премештања власништва.

#+begin_src rust
fn main() {
    let s1 = gives_ownership();         // gives_ownership премешта повратну
                                        // вредност у s1

    let s2 = String::from("hello");     // s2 постаје валидно

    let s3 = takes_and_gives_back(s2);  // s2 се премешта у функцију
                                        // takes_and_gives_back, која премешта
                                        // повратну вредност у s3
} // s3 излази из опсега и позива се `drop`. s2 је премештена па се ништа
  // не дешава. s1 такође излази из опсега и деалоцира се.

fn gives_ownership() -> String {             // gives_ownership ће преместити
                                             // своју повратну вредност у функцију
                                             // која је позива

    let some_string = String::from("yours"); // some_string постаје валидно

    some_string                              // some_string се премешта
                                             // у функцију позиваоца
}

// Ова функција узима власништво над стрингом и враћа га назад
fn takes_and_gives_back(a_string: String) -> String { // a_string постаје валидно

    a_string  // a_string се премешта у функцију позиваоца
}
#+end_src

#+REVEAL: split

- Често нам је потребно да варијаблу користимо и после слања у функцију.
- Могли би је стало враћати заједно са резултатом функције на пример употребом торки.

#+begin_src rust
fn main() {
    let s1 = String::from("hello");

    let (s2, len) = calculate_length(s1);

    println!("The length of '{}' is {}.", s2, len);
}

fn calculate_length(s: String) -> (String, usize) {
    let length = s.len();

    (s, length)
}
#+end_src

Али је то напорно. Постоји концепт у Раст који је намењен оваквим
ситуацијама и базиран је на референцама и позајмљивању вредности.
** Референце и позајмљивање (/References and Borrowing/)
*** Референце и позајмљивање (/References and Borrowing/)
- Референца је попут поинтера, садржи адресу вредности коју поседује нека друга
  варијабла.
- За разлику од поинтера, референце у Расту су гарантовано валидне.

#+begin_src rust
fn main() {
    let s1 = String::from("hello");

    let len = calculate_length(&s1);

    println!("The length of '{}' is {}.", s1, len);
}

fn calculate_length(s: &String) -> usize {
    s.len()
}
#+end_src

#+attr_html: :style height: 400px;
#+ATTR_ORG: :width 300px
[[./images/reference.png]]

*** Референцирање
- Примена оператора =&= над варијаблом називамо /референцирање/.

  #+begin_src rust
  let s1 = String::from("hello");
  let len = calculate_length(&s1);
  #+end_src

- Синтакса =&s1= нам омогућава да креирамо референцу на вредност чији власник је
  =s1= без узимања власништва.
- Пошто референца није власник не долази до деалокације приликом изласка из
  опсега.
- Операција обрнута референцирању назива се /дереференцирање/ и врши се =*=
  оператором над референцом (нпр. =*s2= је вредност на коју референцира =s2=).
- Операцију референцирања називамо позајмљивањем (/borrowing/).

#+REVEAL: split

- Такође, параметар функције може бити референца.
#+begin_src rust
fn calculate_length(s: &String) -> usize { // s је референца на String
    s.len()
} // s излази из опсега али пошто нема власништво над вредношћу
  // ништа се не дешава.
#+end_src

*** Промена позајмљене вредности
Шта се дешава уколико покушамо да модификујемо позајмљену вредност?

#+begin_src rust
fn main() {
    let s = String::from("hello");
    change(&s);
}

fn change(some_string: &String) {
    some_string.push_str(", world");
}
#+end_src

#+begin_example
$ cargo run
   Compiling ownership v0.1.0 (file:///projects/ownership)
error[E0596]: cannot borrow `*some_string` as mutable, as it is behind a `&` reference
 --> src/main.rs:8:5
  |
7 | fn change(some_string: &String) {
  |                        ------- help: consider changing this to be a mutable reference: `&mut String`
8 |     some_string.push_str(", world");
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ `some_string` is a `&` reference, so the data it refers
  to cannot be borrowed as mutable

For more information about this error, try `rustc --explain E0596`.
error: could not compile `ownership` due to previous error
#+end_example

*** Промењиве референце
Као и варијабле, и референце су подразумевано непромењива (/immutable/). Морамо
бити експлицитни уколико нам треба промењива референца.

#+begin_src rust
fn main() {
    let mut s = String::from("hello");
    change(&mut s);
}

fn change(some_string: &mut String) {
    some_string.push_str(", world");
}
#+end_src

*** Више промењивих референци над истом вредношћу
Раст не дозвољава да исти податак у једном тренутку има више промењивих
референци.

#+begin_src rust
let mut s = String::from("hello");

let r1 = &mut s;
let r2 = &mut s;

println!("{}, {}", r1, r2);
#+end_src

#+begin_example
$ cargo run
   Compiling ownership v0.1.0 (file:///projects/ownership)
error[E0499]: cannot borrow `s` as mutable more than once at a time
 --> src/main.rs:5:14
  |
4 |     let r1 = &mut s;
  |              ------ first mutable borrow occurs here
5 |     let r2 = &mut s;
  |              ^^^^^^ second mutable borrow occurs here
6 |
7 |     println!("{}, {}", r1, r2);
  |                        -- first borrow later used here

For more information about this error, try `rustc --explain E0499`.
error: could not compile `ownership` due to previous error
#+end_example

#+REVEAL: split

Овим ограничењем Раст, у време компајлирања, спречава класу грешака које
доводе до недефинисаног понашања и које зовемо /data races/. Ове грешке се веома
тешко откривају и отклањају и могу настати уколико су задовољени следећи
услови:

- Два или више поинтера приступају истим подацима у исто време,
- Бар један поинтер се користи за измену податка,
- Не постоји механизам за синхронизацију приступа.

#+REVEAL: split

Више промењивих референци можемо имати али не у истом опсегу:

#+begin_src rust
let mut s = String::from("hello");

{
    let r1 = &mut s;
} // r1 овде излази из опсега тако да можемо краирати нове референце

let r2 = &mut s;
#+end_src

*** Комбинација промењивих и непромењивих референци
Слично правило постоји и уколико имамо комбинацију промењивих и непромењивих
референци:

#+begin_src rust
let mut s = String::from("hello");

let r1 = &s; // ovo je OK
let r2 = &s; // ovo je OK
let r3 = &mut s; // GREŠKA!

println!("{}, {}, and {}", r1, r2, r3);
#+end_src

#+begin_example
$ cargo run
   Compiling ownership v0.1.0 (file:///projects/ownership)
error[E0502]: cannot borrow `s` as mutable because it is also borrowed as immutable
 --> src/main.rs:6:14
  |
4 |     let r1 = &s; // no problem
  |              -- immutable borrow occurs here
5 |     let r2 = &s; // no problem
6 |     let r3 = &mut s; // BIG PROBLEM
  |              ^^^^^^ mutable borrow occurs here
7 |
8 |     println!("{}, {}, and {}", r1, r2, r3);
  |                                -- immutable borrow later used here

For more information about this error, try `rustc --explain E0502`.
error: could not compile `ownership` due to previous error
#+end_example

#+REVEAL: split

- Не можемо истовремено имати непромењиве и промењиве референце јер корисници
  непромењивих референци не очекују да се подаци мењају.
- Можемо имати више непромењивих референци јер нико не може да мења податке и
  тиме утиче на друге.

*** Опсег важења референце
Опсег важења референце почиње од места где је уведена па до њене последње
употребе. На пример, ово је валидно:

#+begin_src rust
let mut s = String::from("hello");

let r1 = &s; // OK
let r2 = &s; // OK
println!("{} and {}", r1, r2);
// варијабле r1 и r2 се не користе у наставку па њихов опсег
// престаје да важи.

let r3 = &mut s; // зато је ово OK
println!("{}", r3);
#+end_src

Ова особина референци се назива /Non-Lexical Lifetimes (NLL)/.

*** "Висеће" референце
- У језицима са поинтерима лако је креирати поинтер на део меморије који је деалоциран.
- Раст гарантовано спречава овакве грешке. Референце су увек валидне у Расту.

#+begin_src rust
fn main() {
    let reference_to_nothing = dangle();
}

fn dangle() -> &String {
    let s = String::from("hello");

    &s
}
#+end_src

#+REVEAL: split

#+begin_example
$ cargo run
   Compiling ownership v0.1.0 (file:///projects/ownership)
error[E0106]: missing lifetime specifier
 --> src/main.rs:5:16
  |
5 | fn dangle() -> &String {
  |                ^ expected named lifetime parameter
  |
  = help: this function's return type contains a borrowed value, but there is no value
  for it to be borrowed from
help: consider using the `'static` lifetime
  |
5 | fn dangle() -> &'static String {
  |                ~~~~~~~~

For more information about this error, try `rustc --explain E0106`.
error: could not compile `ownership` due to previous error
#+end_example

- Механизам који ово спречава назива се "време живота" (/lifetime/) и биће
  детаљније обрађено у наставку.
- У преводу Раст нам поручује:

  #+begin_quote
  Тип повратне вредности ове функције је позајмљена вредност, али вредност која
  је позајмљена после повратка више не постоји.
  #+end_quote

*** Шта се тачно десило?
#+begin_src rust
fn dangle() -> &String { // dangle враћа референцу на String

    let s = String::from("hello"); // s је нови String

    &s // Враћамо референцу на String s
} // s излази из опсега и позива се `drop`. Меморија се ослобађа.
  // ОПАСНОСТ! Враћена референца ће бити "висећа".
#+end_src

Како се може решити. Вратићемо поседовану (/owned/) вредност, тј урадићемо
премештање вредности у функцију позиваоца.

#+begin_src rust
fn no_dangle() -> String {
    let s = String::from("hello");

    s
}
#+end_src

*** Правила референцирања
1. У сваком тренутку можемо имати или једну промењиву или произвољан број
   непромењивих референци.
2. Референце увек морају бити валидне.

** Исечци (/Slice/ тип)
*** /Slice/
- Исечци (/slices/) омогућавају референцирање континуалне секвенце унутар
  колекције уместо целе колекције

*** Пример
Функција која за задати стринг враћа прву реч.

#+begin_src rust
fn first_word(s: &String) -> usize {
    let bytes = s.as_bytes();

    for (i, &item) in bytes.iter().enumerate() {
        if item == b' ' {
            return i;
        }
    }

    s.len()
}
#+end_src

- Дакле, враћамо индекс краја речи. Позиваоц сада има потребне информације да дође до тражене речи.
- Проблем: два податка која су у вези али морамо ту везу ручно да одржавамо јер
  немамо гаранцију да ће број који је враћен бити валидан и у будућности (нпр.
  стринг може да се промени или да изађе из опсега).

#+REVEAL: split

#+begin_src rust
fn main() {
    let mut s = String::from("hello world");

    let word = first_word(&s); // word ће добити вредност 5

    s.clear(); // стринг s постаје ""

    // word је и даље 5 иако то више није исправно
}
#+end_src

#+REVEAL: split

Проблем постаје још озбиљнији ако нпр. напишемо функцију =second_word= која враћа
другу реч задатог стринга. По аналогији са претходним, требали би да вратимо
почетак и крај друге речи.

#+begin_src rust
fn second_word(s: &String) -> (usize, usize) {
#+end_src

Сада имамо три податка о којима морамо да водимо рачуна.

*** Стринг исечак
Проблем решавамо употребом исечака.

#+begin_src rust
let s = String::from("hello world");

let hello = &s[0..5];
let world = &s[6..11];
#+end_src

#+REVEAL_HTML: <div class="column" style="float:left; width: 50%">
Синтакса =s[x..y]= креира исечак над секвенцом =s=. С обзиром да овај тип (=[T]=) нема
познату величину у време компајлирања, не можемо га алоцирати на стеку, односно
не можемо га доделити локалним варијаблама или прослеђивати као параметар
функције. Зато се у пракси користи референца на исечак (=&[T]=) (често се зове и
/fat pointer/).

Дакле, у пракси много чешће срећемо синтаксу =&s[x..y]=.
#+REVEAL_HTML: </div>

#+REVEAL_HTML: <div class="column" style="float:right; width: 50%">
#+attr_html: :style height: 600px;
#+ATTR_ORG: :width 300px
[[./images/slice.png]]
#+REVEAL_HTML: </div>

#+REVEAL_HTML: <div style="clear: both;">

*** Исечци и синтакса опсега (/range/)
#+begin_src rust
let s = String::from("hello");

let slice = &s[0..2];
let slice = &s[..2];
#+end_src

#+begin_src rust
let s = String::from("hello");

let len = s.len();

let slice = &s[3..len];
let slice = &s[3..];
#+end_src

#+begin_src rust
let s = String::from("hello");

let len = s.len();

let slice = &s[0..len];
let slice = &s[..];
#+end_src

*** Модификација примера да користи стринг исечке
#+begin_src rust
fn first_word(s: &String) -> &str {
    let bytes = s.as_bytes();

    for (i, &item) in bytes.iter().enumerate() {
        if item == b' ' {
            return &s[0..i];
        }
    }

    &s[..]
}
#+end_src

Исти API и за =second_word=.

#+begin_src rust
fn second_word(s: &String) -> &str {
#+end_src

#+REVEAL: split

Сада нам компајлер осигурава да увек имамо валидну референцу на реч.
#+begin_src rust
fn main() {
    let mut s = String::from("hello world");

    let word = first_word(&s);

    s.clear(); // ГРЕШКА!

    println!("the first word is: {}", word);
}
#+end_src

#+begin_example
$ cargo run
   Compiling ownership v0.1.0 (file:///projects/ownership)
error[E0502]: cannot borrow `s` as mutable because it is also borrowed as immutable
  --> src/main.rs:18:5
   |
16 |     let word = first_word(&s);
   |                           -- immutable borrow occurs here
17 |
18 |     s.clear(); // error!
   |     ^^^^^^^^^ mutable borrow occurs here
19 |
20 |     println!("the first word is: {}", word);
   |                                       ---- immutable borrow later used here

For more information about this error, try `rustc --explain E0502`.
error: could not compile `ownership` due to previous error
#+end_example

Не само да је API лакши за употребу већ је читава класа грешака које се тешко
откривају елиминисана у време компајлирања.

*** Стринг литерали су референце на исечке
#+begin_src rust
let s = "Hello, world!";
#+end_src

Тип од =s= је =&str=. =str= је стринг исечак.

*** Стринг исечци као параметри функција
#+begin_src rust
fn first_word(s: &String) -> &str {
#+end_src

Али ће искусни Раст програмери писати:

#+begin_src rust
fn first_word(s: &str) -> &str {
#+end_src

Јер ће ова функција моћи да се користи и за =&str= и за =&String=. Овде се
употребљава тзв. /Deref Coercion/ односно могућности типова да се дереференцирају
у други тип. Нпр. =&String= ће се аутоматски дереференцирати у =&str= уколико је то
потребно. Операција је ефикасна.

#+REVEAL: split

#+begin_src rust
fn main() {
    let my_string = String::from("hello world");

    // `first_word` works on slices of `String`s, whether partial or whole
    let word = first_word(&my_string[0..6]);
    let word = first_word(&my_string[..]);
    // `first_word` also works on references to `String`s, which are equivalent
    // to whole slices of `String`s
    let word = first_word(&my_string);

    let my_string_literal = "hello world";

    // `first_word` works on slices of string literals, whether partial or whole
    let word = first_word(&my_string_literal[0..6]);
    let word = first_word(&my_string_literal[..]);

    // Because string literals *are* string slices already,
    // this works too, without the slice syntax!
    let word = first_word(my_string_literal);
}
#+end_src

*** Употреба исечака над другим структурама
#+begin_src rust
let a = [1, 2, 3, 4, 5];

let slice = &a[1..3]; // референца на исечак типа &[i32]

assert_eq!(slice, &[2, 3]);
#+end_src

* Структуре
* Енумерације и подударање образаца (/Pattern Matching/)
** /Enum/ тип
*** /Enum/ тип
- Дефинисање типа навођењем свих могућих варијанти
- Варијанта може да садржи додатне податке
- Слично са алгебарским типовима података (/algebraic data types/) у функционалним
  језицима, нпр. F#, OCaml и Haskell-у. Ова врста алгебарског типа је позната и
  под називом /sum type/.

*** Пример - IP адреса
- IP адреса представља идентификацију мрежних интерфејса у уређајима који
  комуницирају посредством Интернет протокола (/Internet Protocol - IP/).
- Тренутно имамо у употреби стару верзију 4 и нову верзију 6 која ће временом
  заменити верзију 4.
- Верзија 4 је дужине 32 бита и наводи се као четири октета у облику нпр.
  =192.0.2.1=
- Верзија 6 је дужине 128 бита и наводи се као 8 група од по 4 хекса цифре
  раздвојене са =:=, нпр. =2001:db8:0:1234:0:567:8:1=

#+REVEAL: split

У Расту можемо писати следеће:

#+begin_src rust
enum IpAddrKind {
    V4,
    V6,
}
#+end_src

Док вредности можемо креирати са:
#+begin_src rust
let four = IpAddrKind::V4;
let six = IpAddrKind::V6;
#+end_src

*** Пример - IP адреса - функција

Сада можемо писати функцију која прима овај тип чиме је могуће проследити било
коју варијанту као аргумент.

#+begin_src rust
fn route(ip_kind: IpAddrKind) {}

...

route(IpAddrKind::V4);
route(IpAddrKind::V6);
#+end_src

*** Пример - IP адреса - вредност

- Али како да дефинишемо конкретну вредност IP адресе?
- Прва идеја би могла бити да користимо структуру.

#+begin_src rust
enum IpAddrKind {
    V4,
    V6,
}

struct IpAddr {
    kind: IpAddrKind,
    address: String,
}

let home = IpAddr {
    kind: IpAddrKind::V4,
    address: String::from("127.0.0.1"),
};

let loopback = IpAddr {
    kind: IpAddrKind::V6,
    address: String::from("::1"),
};
#+end_src

#+REVEAL: split

Али, са =enum= типом можемо то урадити и боље. =Enum= варијанте могу садржати
додатне податке.

#+begin_src rust
enum IpAddr {
    V4(String),
    V6(String),
}

let home = IpAddr::V4(String::from("127.0.0.1"));

let loopback = IpAddr::V6(String::from("::1"));
#+end_src

#+REVEAL: split
Вредност садржана у варијанти не мора бити иста за све варијанте. На пример,
IPv4 се састоји од 4 октета и можда желимо да вредност наводимо и чувамо у том
облику.

#+begin_src rust
enum IpAddr {
    V4(u8, u8, u8, u8),
    V6(String),
}

let home = IpAddr::V4(127, 0, 0, 1);

let loopback = IpAddr::V6(String::from("::1"));
#+end_src

*** Пример - IP адреса - std библиотека

У стандардној библиотеци можемо пронаћи тип =IpAddr=. Дефинисан је на следећи
начин.

#+begin_src rust
struct Ipv4Addr {
    // --snip--
}

struct Ipv6Addr {
    // --snip--
}

enum IpAddr {
    V4(Ipv4Addr),
    V6(Ipv6Addr),
}
#+end_src

*** Пример  - /Message/

#+begin_src rust
enum Message {
    Quit,
    Move { x: i32, y: i32 },
    Write(String),
    ChangeColor(i32, i32, i32),
}
#+end_src

#+REVEAL: split
Следеће структуре садрже исте податке као претходни =enum= тип.

#+begin_src rust
struct QuitMessage; // unit struct
struct MoveMessage {
    x: i32,
    y: i32,
}
struct WriteMessage(String); // tuple struct
struct ChangeColorMessage(i32, i32, i32); // tuple struct
#+end_src

Али, предност =enum= типа је што је то јединствен тип па можемо нпр. направити
функцију која прима било коју вредност/варијанту овог типа.

#+REVEAL: split
Над =enum= типом, као и другим типовима, можемо имплементирати методе употребом
=imlp= кључне речи.

#+begin_src rust
impl Message {
    fn call(&self) {
        // тело методе се овде дефинише
    }
}

let m = Message::Write(String::from("hello"));
m.call();
#+end_src

** =Option= енумерација
*** =Option= енумерација
- Чест случај да вредност може бити нешто или ништа.
- Нпр. ако функција враћа први елемент из листе која није празна добићемо први
  елемент, међутим ако је листа празна повратна вредност је ништа.
- Овај концепт се у различитим језицима различито имплементира. Често се користи
  специјална вредност =null= (или =nil=, =none= и сл.) и све варијабле могу бити =null=
  или =non-null=. Проблем је што програмер не дефинише могућност ове вредности
  кроз тип па самим тим компајлер нема могућност да провери да ли код исправно
  обрађује ову могућност.

#+REVEAL: split

У презентацији из 2009 године под називом /Null References: The Billion Dollar
Mistake/ Tony Hoare, који је први увео =null= вредност као концепт је написао
следеће:

#+begin_quote
I call it my billion-dollar mistake. At that time, I was designing the first
comprehensive type system for references in an object-oriented language. My goal
was to ensure that all use of references should be absolutely safe, with
checking performed automatically by the compiler. But I couldn’t resist the
temptation to put in a null reference, simply because it was so easy to
implement. This has led to innumerable errors, vulnerabilities, and system
crashes, which have probably caused a billion dollars of pain and damage in the
last forty years.
#+end_quote

#+REVEAL: split

=Option= је генерички =enum= тип у Расту.
#+begin_src rust
enum Option<T> {
    None,
    Some(T),
}
#+end_src

Примери употребе:
#+begin_src rust
let some_number = Some(5);           // тип је Option<i32>
let some_string = Some("a string");  // тип је Option<&str>

let absent_number: Option<i32> = None;    // немогућа инференца
#+end_src

*** Зашто је =Option<T>= бољи од =null=?
#+begin_src rust
let x: i8 = 5;
let y: Option<i8> = Some(5);

let sum = x + y;
#+end_src

#+begin_example
$ cargo run
   Compiling enums v0.1.0 (file:///projects/enums)
error[E0277]: cannot add `Option<i8>` to `i8`
 --> src/main.rs:5:17
  |
5 |     let sum = x + y;
  |                 ^ no implementation for `i8 + Option<i8>`
  |
  = help: the trait `Add<Option<i8>>` is not implemented for `i8`

For more information about this error, try `rustc --explain E0277`.
error: could not compile `enums` due to previous error
#+end_example

*** Како обрађивати =Option<T>= податке?
- Морамо експлицитно обрадити вредност =Option<T>= и могућност да вредност буде
  =None=.
- =Option<T>= тип има [[https://doc.rust-lang.org/stable/std/option/enum.Option.html][богат API]] који је потребно знати јер је овај тип врло често
  у употреби.

#+begin_src rust
let x = Some(2);
let y = None;
assert_eq!(x.or(y), Some(2));

let x = None;
let y = Some(100);
assert_eq!(x.or(y), Some(100));
#+end_src

- Често користимо језичке конструкције које омогућавају обраду обе варијанте.

** =match= конструкција за контролу тока
*** =match= израз
- Моћан израз контроле тока базиран на подударању образаца (/Pattern Matching/).
- Образац може бити литерал, назив варијабле, џокер (/wildcards/) итд.
- =match= израз ће извршити подударање уз исцрпљивање свих могућност. Уколико
  нека могућност није обрађена компајлер ће пријавити грешку.

*** =match= као машина за сортирање новчића
За почетак можемо =match= израз посматрати као аутомат за сортирање новчића.

#+begin_src rust
enum Coin {
    Penny,
    Nickel,
    Dime,
    Quarter,
}

fn value_in_cents(coin: Coin) -> u8 {
    match coin {
        Coin::Penny => 1,
        Coin::Nickel => 5,
        Coin::Dime => 10,
        Coin::Quarter => 25,
    }
}
#+end_src

- =match= почиње са изразом произвољног типа.
- У телу се налазе "руке" (/arms/) где свака рука има леву страну која представља
  образац за подударање и десну страну (после ~=>~) која представља код који се
  евалуира у случају подударања. Руке су раздвојене зарезима.

#+REVEAL: split

- Руке се подударају у редоследу навођења.
- Повратна вредност целог =match= израза биће вредност евалуираног кода руке чије
  је подударање успело

#+REVEAL: split

Можемо на десној страни користити произвољан израз па и блок кода.
#+begin_src rust
fn value_in_cents(coin: Coin) -> u8 {
    match coin {
        Coin::Penny => {
            println!("Lucky penny!");
            1
        }
        Coin::Nickel => 5,
        Coin::Dime => 10,
        Coin::Quarter => 25,
    }
}
#+end_src

*** Повезивање имена при подударању (/binding/)
#+begin_src rust
#[derive(Debug)]
enum UsState {
    Alabama,
    Alaska,
    Arizona,
    // --snip--
}

enum Coin {
    Penny,
    Nickel,
    Dime,
    Quarter(UsState),
}

fn value_in_cents(coin: Coin) -> u8 {
    match coin {
        Coin::Penny => 1,
        Coin::Nickel => 5,
        Coin::Dime => 10,
        Coin::Quarter(state) => {
            println!("State quarter from {:?}!", state);
            25
        }
    }
}
#+end_src

*** =match= је исцрпан
#+begin_src rust
fn value_in_cents(coin: Coin) -> u8 {
    match coin {
        Coin::Penny => 1,
        Coin::Nickel => 5,
        Coin::Dime => 10,
        Coin::Quarter(UsState::Alabama) | Coin::Quarter(UsState::Alaska) => 25
    }
}
#+end_src

#+begin_example
$ cargo run
   Compiling match_test v0.1.0 (/home/igor/NTP/match_test)
error[E0004]: non-exhaustive patterns: `Quarter(Arizona)` not covered
  --> src/main.rs:21:11
   |
13 | / enum Coin {
14 | |     Penny,
15 | |     Nickel,
16 | |     Dime,
17 | |     Quarter(UsState),
   | |     ------- not covered
18 | | }
   | |_- `Coin` defined here
...
21 |       match coin {
   |             ^^^^ pattern `Quarter(Arizona)` not covered
   |
   = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms
   = note: the matched value is of type `Coin`
#+end_example

*** Подударање са =Option<T>= типом
#+begin_src rust
fn plus_one(x: Option<i32>) -> Option<i32> {
    match x {
        None => None,
        Some(i) => Some(i + 1),
    }
}

let five = Some(5);
let six = plus_one(five);
let none = plus_one(None);
#+end_src

#+REVEAL: split

Пошто је =match= исцрпан не можемо заборавити да обрадимо =None= случај.

#+begin_src rust
fn plus_one(x: Option<i32>) -> Option<i32> {
    match x {
        Some(i) => Some(i + 1),
    }
}
#+end_src

#+begin_example
$ cargo run
   Compiling enums v0.1.0 (file:///projects/enums)
error[E0004]: non-exhaustive patterns: `None` not covered
   --> src/main.rs:3:15
    |
3   |         match x {
    |               ^ pattern `None` not covered
    |
    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms
    = note: the matched value is of type `Option<i32>`

For more information about this error, try `rustc --explain E0004`.
error: could not compile `enums` due to previous error
#+end_example

*** Подразумевана обрада преосталих случајева
- Желимо на специфичан начин обрадимо само неколико случајева док за све остале
  радимо подразумевану обраду.

#+begin_src rust
let dice_roll = 9;
match dice_roll {
    3 => add_fancy_hat(),
    7 => remove_fancy_hat(),
    other => move_player(other),
}

fn add_fancy_hat() {}
fn remove_fancy_hat() {}
fn move_player(num_spaces: u8) {}
#+end_src

- Раст ће нас упозорити ако додамо руку после оне која обрађује све случајеве
  јер та се рука никада неће употребити.

#+REVEAL: split

Ако желимо да обрадимо све случајеве али нас вредност не интересује можемо
користити =_=.

#+begin_src rust
let dice_roll = 9;
match dice_roll {
    3 => add_fancy_hat(),
    7 => remove_fancy_hat(),
    _ => reroll(),
}

fn add_fancy_hat() {}
fn remove_fancy_hat() {}
fn reroll() {}
#+end_src
** =if let= kontrola toka
=if let= нам омогућава комбинацију =if= и =let= исказе у мање опширан исказ за обраду
само једног случаја поклапања и игнорисање осталих.

#+begin_src rust
let config_max = Some(3u8);
match config_max {
    Some(max) => println!("The maximum is configured to be {}", max),
    _ => (),
}
#+end_src

Ово можемо концизније исказати са:

#+begin_src rust
let config_max = Some(3u8);
if let Some(max) = config_max {
    println!("The maximum is configured to be {}", max);
}
#+end_src

- Губимо исцрпност =match= израза.
- Синтаксни шећер у ситуацијама када желимо да игноришемо остале могућности.

#+REVEAL: split

#+begin_note
Обрасци за подударање [[https://doc.rust-lang.org/book/ch18-02-refutability.html][могу имати две форме]]: поништив (/refutable/) и непоништив
(/irrefutable/). Образац који увек мора успети (нпр. =let x = 5;=) је непоништив.
Образац који не мора да успе увек је поништив (нпр. =if let Some(x) = a_value=
неће успети за ~a_value==None~).

Параметри функција, =let= искази и =for= петље прихватају само непоништиве обрасце
јер програм не може урадити ништа смислено уколико подударање не успе.

=if let= и =while let= прихватају и поништиве и непоништиве обрасце али ће нас
компајлер упозорити уколико користимо непоништиве.
#+end_note

#+REVEAL: split
Можемо користити и =else= грану. Следеће је еквивалентно.

#+begin_src rust
let mut count = 0;
match coin {
    Coin::Quarter(state) => println!("State quarter from {:?}!", state),
    _ => count += 1,
}
#+end_src

#+begin_src rust
let mut count = 0;
if let Coin::Quarter(state) = coin {
    println!("State quarter from {:?}!", state);
} else {
    count += 1;
}
#+end_src

* Модули
* Колекције
* Обрада грешака
* Тестирање
* Генерички типови, особине (/Traits/) и животни век (/Lifetimes/)
** Генерички типови (/generics/)
*** Генерички типови (/generics/)
- Механизам за елиминацију дуплирања кода.
- Генерички типови су апстрактне замене за конкретне типове у друге особине у
  време извршавања.
- Омогућавају нам да на апстрактан начин искажемо особине типова и њихове везе
  са другим типовима без знања о томе који ће се конкретни типови наћи на
  њиховом месту у време компајлирања и извршавања кода.
- На пример функције могу примити генеричке параметре. Такође, сложени типови
  могу бити параметризовани генеричким типовима (пример је =Option<T>=).

*** Уклањање дуплог кода употребом функција

#+begin_src rust
fn main() {
    let number_list = vec![34, 50, 25, 100, 65];

    let mut largest = number_list[0];

    for number in number_list {
        if number > largest {
            largest = number;
        }
    }

    println!("The largest number is {}", largest);
}
#+end_src

#+REVEAL: split

#+begin_src rust
fn main() {
    let number_list = vec![34, 50, 25, 100, 65];

    let mut largest = number_list[0];

    for number in number_list {
        if number > largest {
            largest = number;
        }
    }

    println!("The largest number is {}", largest);

    let number_list = vec![102, 34, 6000, 89, 54, 2, 43, 8];

    let mut largest = number_list[0];

    for number in number_list {
        if number > largest {
            largest = number;
        }
    }

    println!("The largest number is {}", largest);
}
#+end_src

#+REVEAL: split

#+begin_src rust
fn largest(list: &[i32]) -> i32 {
    let mut largest = list[0];

    for &item in list {
        if item > largest {
            largest = item;
        }
    }

    largest
}

fn main() {
    let number_list = vec![34, 50, 25, 100, 65];

    let result = largest(&number_list);
    println!("The largest number is {}", result);

    let number_list = vec![102, 34, 6000, 89, 54, 2, 43, 8];

    let result = largest(&number_list);
    println!("The largest number is {}", result);
}
#+end_src


#+REVEAL: split

Поступак елиминације дуплог кода је подразумевао следеће:

1. Идентификација дуплог кода.
2. Екстракција кода у функцију, дефинисање параметара и повратне вредности.
3. Замена инстанци дуплог кода са позивом функције.

*** Уклањање дуплог кода употребом генеричких функција

Имамо функцију за проналажење највећег елемента у листи са различитим типовима.
#+begin_src rust
fn largest_i32(list: &[i32]) -> i32 {
    let mut largest = list[0];
    for &item in list {
        if item > largest {
            largest = item;
        }
    }
    largest
}
fn largest_char(list: &[char]) -> char {
    let mut largest = list[0];
    for &item in list {
        if item > largest {
            largest = item;
        }
    }
    largest
}
fn main() {
    let number_list = vec![34, 50, 25, 100, 65];
    let result = largest_i32(&number_list);
    println!("The largest number is {}", result);
    let char_list = vec!['y', 'm', 'a', 'q'];
    let result = largest_char(&char_list);
    println!("The largest char is {}", result);
}
#+end_src

#+REVEAL: split

Функције су готово идентичне. Разлика је само у типу. Пишемо генеричку функцију
тако што дефинишемо генерички тип унутар =<>= после назива функције:

#+begin_src rust
fn largest<T>(list: &[T]) -> T {
#+end_src

=T= је генерички тип и у време компајлирања биће замењен са конкретним типом.

#+REVEAL: split

Сада је наш код следећи:

#+begin_src rust
fn largest<T>(list: &[T]) -> T {
    let mut largest = list[0];

    for &item in list {
        if item > largest {
            largest = item;
        }
    }

    largest
}

fn main() {
    let number_list = vec![34, 50, 25, 100, 65];

    let result = largest(&number_list);
    println!("The largest number is {}", result);

    let char_list = vec!['y', 'm', 'a', 'q'];

    let result = largest(&char_list);
    println!("The largest char is {}", result);
}
#+end_src

#+REVEAL: split

Али се не компајлира.

#+begin_src rust
$ cargo run
   Compiling chapter10 v0.1.0 (file:///projects/chapter10)
error[E0369]: binary operation `>` cannot be applied to type `T`
 --> src/main.rs:5:17
  |
5 |         if item > largest {
  |            ---- ^ ------- T
  |            |
  |            T
  |
help: consider restricting type parameter `T`
  |
1 | fn largest<T: std::cmp::PartialOrd>(list: &[T]) -> T {
  |             ++++++++++++++++++++++

For more information about this error, try `rustc --explain E0369`.
error: could not compile `chapter10` due to previous error
#+end_src

Тип =T= може бити било који тип па и тип који не дефинише операцију =>= која се
користи у коду. Дакле, морамо ограничити који типови су могући.

Видећемо како се ово ради у наставку у причи о особинама (/Traits/).

*** Генерички типови у структурама

#+begin_src rust
struct Point<T> {
    x: T,
    y: T,
}

fn main() {
    let integer = Point { x: 5, y: 10 };
    let float = Point { x: 1.0, y: 4.0 };
}
#+end_src

#+REVEAL: split

Типови оба поља морају бити исти.

#+begin_src rust
struct Point<T> {
    x: T,
    y: T,
}

fn main() {
    let wont_work = Point { x: 5, y: 4.0 };
}
#+end_src

#+begin_example
$ cargo run
   Compiling chapter10 v0.1.0 (file:///projects/chapter10)
error[E0308]: mismatched types
 --> src/main.rs:7:38
  |
7 |     let wont_work = Point { x: 5, y: 4.0 };
  |                                      ^^^ expected integer, found floating-point number

For more information about this error, try `rustc --explain E0308`.
error: could not compile `chapter10` due to previous error
#+end_example

#+REVEAL: split

Ако желимо да поља имају различите типове онда морамо имати различите генеричке типове.

#+begin_src rust
struct Point<T, U> {
    x: T,
    y: U,
}

fn main() {
    let both_integer = Point { x: 5, y: 10 };
    let both_float = Point { x: 1.0, y: 4.0 };
    let integer_and_float = Point { x: 5, y: 4.0 };
}
#+end_src

*** Генерички типови у енумерацијама

#+begin_src rust
enum Option<T> {
    Some(T),
    None,
}
#+end_src

#+REVEAL: split

#+begin_src rust
enum Result<T, E> {
    Ok(T),
    Err(E),
}
#+end_src

*** Дефиниције метода

#+begin_src rust
struct Point<T> {
    x: T,
    y: T,
}

impl<T> Point<T> {
    fn x(&self) -> &T {
        &self.x
    }
}

fn main() {
    let p = Point { x: 5, y: 10 };

    println!("p.x = {}", p.x());
}
#+end_src

Пошто смо навели =<T>= иза кључне речи =impl= Раст даље зна да је тип =T= генерички
а не конкретни тип тако да је метода =x= за =Point<T>= дефинисана над свим типовима
=T=.

#+REVEAL: split

Могли смо нпр. методу дефинисати само за одређени =Point= тип.

#+begin_src rust
impl Point<f32> {
    fn distance_from_origin(&self) -> f32 {
        (self.x.powi(2) + self.y.powi(2)).sqrt()
    }
}
#+end_src

Овај =impl= блок дефинише методу =distance_from_origin= али само за =Point<f32>= док
остали =Point= типови неће имати ову методу.

*** Генерички типови у методама и =impl= блоковима

Генерички типови у структурама и методама не морају бити исти. На пример, можемо
креирати методу =mixup= која узима две инстанце =Point= и враћа нови =Point= тип где
ће прво поље имати исти тип као прва тачка а друго поље као друга тачка.

#+begin_src rust
struct Point<X1, Y1> {
    x: X1,
    y: Y1,
}

impl<X1, Y1> Point<X1, Y1> {
    fn mixup<X2, Y2>(self, other: Point<X2, Y2>) -> Point<X1, Y2> {
        Point {
            x: self.x,
            y: other.y,
        }
    }
}

fn main() {
    let p1 = Point { x: 5, y: 10.4 };
    let p2 = Point { x: "Hello", y: 'c' };
    let p3 = p1.mixup(p2);
    println!("p3.x = {}, p3.y = {}", p3.x, p3.y);
}
#+end_src

- Генерички типови =X2= и =Y2= су наведени само у методи јер су релевантни само у
  њеном контексту.

*** Перформансе

Употреба генеричког кода не доводи до деградације перформанси. Раст користи
технику мономорфизације (/Monomorphization/) код које ће компајлер инстанцирати
конкретан код за сваки тип посебно.

То би значило следеће. Ако имамо код:

#+begin_src rust
let integer = Some(5);
let float = Some(5.0)
#+end_src

Компајлер ће произвести код еквивалентан следећем:
#+begin_src rust
enum Option_i32 {
    Some(i32),
    None,
}

enum Option_f64 {
    Some(f64),
    None,
}

fn main() {
    let integer = Option_i32::Some(5);
    let float = Option_f64::Some(5.0);
}
#+end_src
** Особине (/Traits/) - дефинисање заједничког понашања
*** /Traits/
- /Trait/ дефинише функционалност коју тип може делити са другим типовима.
- У другим језицима сличан концепт назива се интерфејс.
- Можемо користити /ограничења кроз особине/ (/Trait bounds/) да дефинишемо да
  генерички тип мора задовољити одређена ограничења.

*** Дефинисање особина

- Пример дефинисања медиа агрегатор библиотеке која може да приказе сажетак
  података који се може чувати у =NewsArticle= или =Tweet= инстанци.
- Дефинишемо =Summary= особину да опишемо ову функционалност.

#+begin_src rust
pub trait Summary {
    fn summarize(&self) -> String;
}
#+end_src

*** Имплементација особина

#+begin_src rust
pub struct NewsArticle {
    pub headline: String,
    pub location: String,
    pub author: String,
    pub content: String,
}

impl Summary for NewsArticle {
    fn summarize(&self) -> String {
        format!("{}, by {} ({})", self.headline, self.author, self.location)
    }
}

pub struct Tweet {
    pub username: String,
    pub content: String,
    pub reply: bool,
    pub retweet: bool,
}

impl Summary for Tweet {
    fn summarize(&self) -> String {
        format!("{}: {}", self.username, self.content)
    }
}
#+end_src

#+REVEAL: split

Методе особина се позивају као и обичне методе. Једина разлика је у томе што
методе особина морају бити доступне у опсегу (укључити их са =use=).

#+begin_src rust
use aggregator::{Summary, Tweet};

fn main() {
    let tweet = Tweet {
        username: String::from("horse_ebooks"),
        content: String::from(
            "of course, as you probably already know, people",
        ),
        reply: false,
        retweet: false,
    };

    println!("1 new tweet: {}", tweet.summarize());
}
#+end_src

#+REVEAL: split

#+begin_note
Ограничење у употреби особина је да можемо имплементирати особину над типом
једино ако је бар једно од њих локално за наш сандук. Ово правило је део скупа
правила који се називају /coherence/. Конкретно ово правило зове се /orphan rule/ и
спречава некомпатибилне имплементације особина над типовима од стране више
сандука.

Без овог правила могло би се десити да два различита сандука имплементирају исту
особину над истим типом на различите начине и компајлер не би знао коју верзију
да користи.
#+end_note
*** Подразумевана имплементација

Особина може имати подразумевану имплементацију метода.

#+begin_src rust
pub trait Summary {
    fn summarize(&self) -> String {
        String::from("(Read more...)")
    }
}
#+end_src

Да би користили подразумевану имплементацију можемо навести празно тело у =impl=
блоку:

#+begin_src rust
impl Summary for NewsArticle {}
#+end_src

#+REVEAL: split

И затим можемо позвати =summarize= методу:

#+begin_src rust
let article = NewsArticle {
        headline: String::from("Penguins win the Stanley Cup Championship!"),
        location: String::from("Pittsburgh, PA, USA"),
        author: String::from("Iceburgh"),
        content: String::from(
            "The Pittsburgh Penguins once again are the best \
             hockey team in the NHL.",
        ),
    };

    println!("New article available! {}", article.summarize());
#+end_src

#+REVEAL: split

- Подразумевана имплементација може бити редефинисана приликом имплементације.
- Такође, подразумеване методе могу позивати друге методе.

#+begin_src rust
pub trait Summary {
    fn summarize_author(&self) -> String;

    fn summarize(&self) -> String {
        format!("(Read more from {}...)", self.summarize_author())
    }
}
#+end_src

Сада је потребно и довољно да приликом имплементације дефинишемо
=summarize_author= методу:

#+begin_src rust
impl Summary for Tweet {
    fn summarize_author(&self) -> String {
        format!("@{}", self.username)
    }
}
#+end_src
*** Osobine kao parametri

- Сада можемо користити особине да дефинишемо функције које раде над параметрима
  различитог типа.

#+begin_src rust
pub fn notify(item: &impl Summary) {
    println!("Breaking news! {}", item.summarize());
}
#+end_src

Сада функција =notify= ради над свим типовима који имплементирају =Summary=

#+REVEAL: split

Претходна употреба =impl= код параметра је синтаксни шећер за општи облик
навођења ограничења кроз особине.

#+begin_src rust
pub fn notify<T: Summary>(item: &T) {
    println!("Breaking news! {}", item.summarize());
}
#+end_src

Ограничења кроз особине (/Trait bounds/) стављамо после двотачке код навођења
генеричког типа. Компајлер ће верификовати да све што користимо над вредностима
овог типа унутар функције је заиста дефинисано особинама наведеним у заглављу.

#+REVEAL: split

=impl Trait= синтаксе је концизнија код једноставних примера али је пуна синтакса
боља код сложенијих примера.

На пример:

#+begin_src rust
pub fn notify(item1: &impl Summary, item2: &impl Summary) {
#+end_src

би у пуној синтакси било:

#+begin_src rust
pub fn notify<T: Summary>(item1: &T, item2: &T) {
#+end_src

*** Вишеструке особине код ограничења

Можемо дефинисати и више ограничења употребом =+= синтаксе. На пример, ако
параметар мора да имплементира =Summary= и =Display=:
#+begin_src rust
pub fn notify(item: &(impl Summary + Display)) {
#+end_src

или у пуној синтакси:

#+begin_src rust
pub fn notify<T: Summary + Display>(item: &T) {
#+end_src

*** =where= клаузула у ограничењима

- Уколико имамо више ограничења основна синтакса може да смањи читкост.

#+begin_src rust
fn some_function<T: Display + Clone, U: Clone + Debug>(t: &T, u: &U) -> i32 {
#+end_src

- =where= клаузула измешта дефинисање ограничења после заглавља функције чиме
  се постиже боља читкост:

#+begin_src rust
fn some_function<T, U>(t: &T, u: &U) -> i32
    where T: Display + Clone,
          U: Clone + Debug
{
#+end_src

*** =impl Trait= као повратна вредност функције
#+begin_src rust
fn returns_summarizable() -> impl Summary {
    Tweet {
        username: String::from("horse_ebooks"),
        content: String::from(
            "of course, as you probably already know, people",
        ),
        reply: false,
        retweet: false,
    }
}
#+end_src

Посебно значајно у контексту затворења (/closures/) и итератора где је конкретан
тип превише сложен за писање или је познат само компајлеру.

#+begin_note
=impl Trait= синтакса за повратне вредности је могућа само ако функција враћа
један тип који имплементира дату особину. На пример, ова функција неће радити
ако функција може вратити =NewsArticle= или =Tweet=.
#+end_note

*** Поправка =largest= генеричке функције

На претходним сладовима имали смо функцију =largest=. Сада можемо да завршимо
њену дефиницију.

Грешка је била следећа:
#+begin_example
$ cargo run
   Compiling chapter10 v0.1.0 (file:///projects/chapter10)
error[E0369]: binary operation `>` cannot be applied to type `T`
 --> src/main.rs:5:17
  |
5 |         if item > largest {
  |            ---- ^ ------- T
  |            |
  |            T
  |
help: consider restricting type parameter `T`
  |
1 | fn largest<T: std::cmp::PartialOrd>(list: &[T]) -> T {
  |             ++++++++++++++++++++++

For more information about this error, try `rustc --explain E0369`.
error: could not compile `chapter10` due to previous error
#+end_example

#+REVEAL: split

Дакле, морамо ограничити типове на оне који подржавају поређње. Ова особина се
у стандардној библиотеци зове =std::cmp::PartialOrd=, па ћемо преправити заглавље
функције на следећи начин:

#+begin_src rust
fn largest<T: PartialOrd>(list: &[T]) -> T {
#+end_src

#+REVEAL: split

Међутим, сада имамо још једну грешку:
#+begin_example
$ cargo run
   Compiling chapter10 v0.1.0 (file:///projects/chapter10)
error[E0508]: cannot move out of type `[T]`, a non-copy slice
 --> src/main.rs:2:23
  |
2 |     let mut largest = list[0];
  |                       ^^^^^^^
  |                       |
  |                       cannot move out of here
  |                       move occurs because `list[_]` has type `T`, which does not implement the `Copy` trait
  |                       help: consider borrowing here: `&list[0]`

error[E0507]: cannot move out of a shared reference
 --> src/main.rs:4:18
  |
4 |     for &item in list {
  |         -----    ^^^^
  |         ||
  |         |data moved here
  |         |move occurs because `item` has type `T`, which does not implement the `Copy` trait
  |         help: consider removing the `&`: `item`

Some errors have detailed explanations: E0507, E0508.
For more information about an error, try `rustc --explain E0507`.
error: could not compile `chapter10` due to 2 previous errors
#+end_example

#+REVEAL: split

Уводимо додатно ограничење да генерички тип мора бити и =Copy=. Тако да је пуно
решење следеће:

#+begin_src rust
fn largest<T: PartialOrd + Copy>(list: &[T]) -> T {
    let mut largest = list[0];

    for &item in list {
        if item > largest {
            largest = item;
        }
    }

    largest
}

fn main() {
    let number_list = vec![34, 50, 25, 100, 65];

    let result = largest(&number_list);
    println!("The largest number is {}", result);

    let char_list = vec!['y', 'm', 'a', 'q'];

    let result = largest(&char_list);
    println!("The largest char is {}", result);
}
#+end_src

*** Употреба особина ограничења за условну имплементацију метода

Ако желимо да имплементирамо методу само над типовима који имплементирају
одређене особине.
#+begin_src rust
use std::fmt::Display;

struct Pair<T> {
    x: T,
    y: T,
}

impl<T> Pair<T> {
    fn new(x: T, y: T) -> Self {
        Self { x, y }
    }
}

impl<T: Display + PartialOrd> Pair<T> {
    fn cmp_display(&self) {
        if self.x >= self.y {
            println!("The largest member is x = {}", self.x);
        } else {
            println!("The largest member is y = {}", self.y);
        }
    }
}
#+end_src

** Валидација референци кроз животни век (/Lifetimes/)
*** Животни век (/Lifetime/)
- Свака референца има животни век, опсег у коме је референца валидна.
- У доста ситуација компајлер аутоматски може да закључи који је животни век
  референце. Када то није у стању морамо да урадимо ручну анотацију.
- Анотацијама животног века доводимо у везу животни век различитих референци.

*** Спречавање "висећих" референци

#+begin_src rust
{
        let r;

        {
            let x = 5;
            r = &x;
        }

        println!("r: {}", r);
    }

#+end_src

#+begin_example
 cargo run
   Compiling chapter10 v0.1.0 (file:///projects/chapter10)
error[E0597]: `x` does not live long enough
  --> src/main.rs:7:17
   |
7  |             r = &x;
   |                 ^^ borrowed value does not live long enough
8  |         }
   |         - `x` dropped here while still borrowed
9  |
10 |         println!("r: {}", r);
   |                           - borrow later used here

For more information about this error, try `rustc --explain E0597`.
error: could not compile `chapter10` due to previous error
#+end_example

*** /Borrow Checker/
- Раст компајлер има компоненту /borrow checker/ која проверава да ли су све
  позајмице валидне.

#+begin_src rust
{
    let r;                // ---------+-- 'a
                          //          |
    {                     //          |
        let x = 5;        // -+-- 'b  |
        r = &x;           //  |       |
    }                     // -+       |
                          //          |
    println!("r: {}", r); //          |
}                         // ---------+
#+end_src

- Програм је одбачен јер =r= референцира вредност чији животни век (='b=) је краћи
  од животног века варијабле =r= (='a=). Уколико би се ово дозволило, =r= би у једном
  делу референцирала невалидну вредност.

#+REVEAL: split

Варијабле имају животни век који је једнак синстаксном опсегу у коме је
варијабла дефинисана. Животни век имају и референце које позајмљују вредност и
смештају се у варијабле (нпр. =r=&x= из претходног примера).

#+begin_note
Једно од правила је да референца на варијаблу (тј. вредност) не може да живи
дуже од саме варијабле. Односно /животни век варијабле мора да садржи животни
век референце позајмљене од те варијабле/.
#+end_note

#+begin_src rust
{
    let r;
    {
        let x = 5;
        r = &x;           // -+- &x не може да живи дуже од
    }                     // -+  овог животног века
    println!("r: {}", r);
}
#+end_src

#+REVEAL: split

Ако сместимо референцу у варијаблу, референца мора бити исправна за цео животни
век варијабле у коју је смештена.

#+begin_note
Кажемо да /животни век референце мора да садржи животни век варијабле у коју је
смештена/.
#+end_note

#+begin_src rust
{
    let r;
    {
        let x = 5;
        r = &x;           // -+- животни век било чега што
    }                     //  |  се смести у r мора да живи
    println!("r: {}", r); // -+  бар оволико
}
#+end_src

Видимо да ово правило није задовољено. =&x= не живи довољно дуго јер =x= не живи
довољно дуго.

#+REVEAL: split

Ако претходна два правила објединимо можемо рећи да:

#+begin_note
/Животни век варијабле мора да садржи животни век свих варијабли које позајмљују
вредност од посматране варијабле/.
#+end_note

Односно, варијабла може отићи из опсега тек када не постоји више ни једна
варијабла која чува позајмљену вредност.

#+REVEAL: split

Следећи код је прихваћен. Референца =r= не живи дуже од податка који референцира
(=x=).

#+begin_src rust
{
    let x = 5;            // ----------+-- 'b
                          //           |
    let r = &x;           // --+-- 'a  |
                          //   |       |
    println!("r: {}", r); //   |       |
                          // --+       |
}                         // ----------+
#+end_src

*** Генерички животни векови у функцијама

- Креирамо функцију =longest= која враћа дужи од два прослеђена стринга.
  Прослеђујемо референцу на стринг исечак =&str=.

#+begin_src rust
fn main() {
    let string1 = String::from("abcd");
    let string2 = "xyz";

    let result = longest(string1.as_str(), string2);
    println!("The longest string is {}", result);
}
#+end_src

#+REVEAL: split

Овај програм није прихваћен.
#+begin_src rust
fn longest(x: &str, y: &str) -> &str {
    if x.len() > y.len() {
        x
    } else {
        y
    }
}
#+end_src

#+begin_example
$ cargo run
   Compiling chapter10 v0.1.0 (file:///projects/chapter10)
error[E0106]: missing lifetime specifier
 --> src/main.rs:9:33
  |
9 | fn longest(x: &str, y: &str) -> &str {
  |               ----     ----     ^ expected named lifetime parameter
  |
  = help: this function's return type contains a borrowed value, but the signature does not say
  whether it is borrowed from `x` or `y`
help: consider introducing a named lifetime parameter
  |
9 | fn longest<'a>(x: &'a str, y: &'a str) -> &'a str {
  |           ++++     ++          ++          ++

For more information about this error, try `rustc --explain E0106`.
error: could not compile `chapter10` due to previous error
#+end_example

#+REVEAL: split

- Зашто програм није прихваћен?
- /Borrow checker/ није у стању да одреди у којој релацији су референце =x= и =y= са
  повратном вредношћу која је такође референца.
- Тј. повратна вредност мора бити позајмљена од некуд, али компајлер не може да
  одреди да ли је позамљена од =x= или =y= или од неке глобалне вредности.
- Ова информација је потребна да би се обавила калкулација и провера животног века.

*** Синтакса за анотацију животног века

- Да би помогли компајлеру референце означавамо са животним веком и тиме
  доводимо у везу различите референце (нпр. параметре и повратне вредности
  функције).
- Анотација је облика ='a=. Иза апострофа се пише име анотације које је најчешће
  једно мало слово са почетка алфабета (='a, 'b,...=).
- *Важно:* анотације животног века не мењају животни век референце већ само
  помажу компајлеру у провери.

#+begin_src rust
&i32        // референца
&'a i32     // референца са експлицитним животним веком
&'a mut i32 // промењива референца са експлицитним животним веком
#+end_src

- Једна анотација нема пуно смисла. Функцију имају тек када анотирамо више
  референци јер се доводе у везу ако имају исто име.
- Уведимо функцију =lt= која враћа животни век варијабле/вредности и релацију
  између животних векова ='a≥'b= односно ='b≤'a= која значи да ='a= обухвата ='b=
  односно ='b= је садржано у ='a=.

*** Анотација животног века у сигнатурама функција

- Следећа анотација за функцију =longest= је исправна јер референца која се враћа
  може бити =x= или =y= у зависности од дужине стринга. Стога је потребно да имамо
  строжији услов да је животни век повратне вредности у вези са животним веком
  оба параметра.

#+begin_src rust
fn longest<'a>(x: &'a str, y: &'a str) -> &'a str {
    if x.len() > y.len() {
        x
    } else {
        y
    }
}
#+end_src

- Овим кажемо компајлеру да за неки генерички животни век ='a=, функција прима две
  референце чији животни век вредности обухвата ='a= и враћа референцу која мора
  бити валидна бар колико и животни век ='a= тј. животни век повратне референце
  мора да обувати ='a=. Уколико такав животни век постоји код се прихвата.
- Сигнатура доводи у везу обе улазне референце са излазном.

#+REVEAL: split

Посматрајмо код који позива функцију =longest=:

#+begin_src rust
fn main() {
    let string1 = String::from("abcd");
    {
        let string2 = "xyz";
        let result = longest(string1.as_str(), string2);
    }
    println!("The longest string is {}", result);
}
#+end_src

За код мора да постоји ='a= тако да важи:

#+begin_example
lt(string1) ≥ 'a     # животни век вредности првог параметара садржи 'a
lt(string2) ≥ 'a     # животни век вредности другог параметара садржи 'a
'a ≥ lt(result)       # 'a мора да садржи животни веку ресулт варијабле
#+end_example

Што не може бити испуњено истовремено, тј. не постоји ='a= које испуњава ова
ограничења.

#+REVEAL: split

Други начин размишљања је да повратна вредност функције позајмљује од
вредности улазних параметара означених истим именом животног века.

#+begin_src rust
fn main() {
    let string1 = String::from("abcd");
    {
        let string2 = "xyz";
        let result = longest(string1.as_str(), string2);
    }
    println!("The longest string is {}", result);
}
#+end_src

Што значи да =result= позајмљује од =string1= и =string2= и та позајмица траје све
време живота варијабле =result= што не може бити валидно јер варијабла живи дуже
од вредности =string2=.

Иако, можемо видети да ће, због дужине стринга, враћена вредност бити =string1= и
програм је валидан, компајлер ово не може да закључи.
* Макрои
* Функционално програмирање, затворења и итератори
* ООП, паметни поинтери, конкурентно програмирање
* Литература
- Steve Klabnik and Carol Nichols: [[https://doc.rust-lang.org/book/][The Rust Programming Language]], no starch press.
- Slice is NOT reference, https://github.com/rust-lang/book/issues/3070
- Google: Comprehensive Rust, https://google.github.io/comprehensive-rust/
- [[https://rust-lang.github.io/rfcs/0505-api-comment-conventions.html][RFC 505: API documentation conventions]]
