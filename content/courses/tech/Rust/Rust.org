#+TITLE: Programski jezik Rust
#+SUBTITLE: Bazirano na verziji 1.58.1. U izradi.
#+EXPORT_FILE_NAME: index.html
#+EXPORT_REVEAL_HLEVEL: 10
#+SETUPFILE: ../../courses-startup.org

* Uvod
- Jezik opÅ¡te namene, kompajliran i statiÄki tipiziran sa inferencom tipova
- Sistemsko programiranje ali sa osobinama viÅ¡eg nivoa apstrakcije kao Å¡to su
  funkcionalno programiranje
- 2010, Graydon Hoare, Mozilla Research
- Performanse i sigurnost
- Ne koristi /garbage collector/ ali obezbeÄ‘uje memorijsku sigurnost kroz /borrow
  checker/
- Sintaksno sliÄan C++. Uticaj i OCaml-a, Haskell-a i Erlang-a.
- Koristi se u velikim firmama: Amazon, Facebook, Google, Microsoft...
- Od 2016 godine na SO upitniku konstantno prvi u kategoriji /"most loved
  programming languages"/
* Instalacija i podeÅ¡avanje
** Instalacija
- Rust stiÅ¾e sa alatom za upravljanje lanca alata =rustup=

#+begin_src sh
$ curl --proto '=https' --tlsv1.2 https://sh.rustup.rs -sSf | sh
#+end_src

- Provera instalacije

#+begin_src sh
~> rustc --version
rustc 1.58.1 (db9d1b20b 2022-01-20)
#+end_src

** Pregled instalacije
#+begin_src sh
~> rustup show
Default host: x86_64-unknown-linux-gnu
rustup home:  /home/igor/.rustup

installed toolchains
--------------------

stable-x86_64-unknown-linux-gnu (default)
nightly-x86_64-unknown-linux-gnu

active toolchain
----------------

stable-x86_64-unknown-linux-gnu (default)
rustc 1.58.1 (db9d1b20b 2022-01-20)
#+end_src

** AÅ¾uriranje
Za aÅ¾uriranje instalacije na najnoviju verziju

#+begin_src sh
rustup update
#+end_src

** Dokumentacija

Rust stiÅ¾e sa veoma dobrom dokumentacijom i knjigama koje su dostupne direktno
iz instalacije.

#+begin_src sh
rustup doc
#+end_src

* PoÄetak
** Hello, World!

#+begin_src sh
$ mkdir hello_world
$ cd hello_world
#+end_src

File =main.rs=:
#+begin_src rust
fn main() {
    println!("Hello, world!");
}
#+end_src

** Kompajliranje i pokretanje

#+begin_src sh
$ rustc main.rs
$ ./main
Hello, world!
#+end_src
** Hello, Cargo!
- Alat za razreÅ¡avanje zavisnosti i upravljanje projektom.

#+begin_src sh
~> cargo --version
cargo 1.58.0 (f01b232bc 2022-01-19)
#+end_src

- Kreiranje projekta sa =cargo= alatom:

#+begin_src sh
$ cargo new hello_cargo
$ cd hello_cargo
#+end_src

** SadrÅ¾aj kreiranog projekta
Fajl =cargo.toml= Äuva konfiguraciju projekta. Format je [[https://toml.io/en/][TOML]] (/Tomâ€™s Obvious,
Minimal Language/):

#+begin_src toml
[package]
name = "hello_cargo"
version = "0.1.0"
edition = "2021"

[dependencies]
#+end_src

Fajl =src/main.rs=:
#+begin_src rust
fn main() {
    println!("Hello, world!");
}
#+end_src
** Pokretanje

#+begin_src rust
$ cargo build
   Compiling hello_cargo v0.1.0 (file:///projects/hello_cargo)
    Finished dev [unoptimized + debuginfo] target(s) in 2.85 secs
#+end_src

IzvrÅ¡ni fajl se moÅ¾e naÄ‡i na lokaciji =target/debug/hello_cargo=:

#+begin_src sh
$ ./target/debug/hello_cargo
Hello, world!
#+end_src

Ali =cargo= omguÄ‡ava i jednostavniji naÄin pokretanja:
#+begin_src sh
$ cargo run
    Finished dev [unoptimized + debuginfo] target(s) in 0.0 secs
     Running `target/debug/hello_cargo`
Hello, world!
#+end_src

** Provera
TakoÄ‘e je moguÄ‡e brzo proveriti da li se kod kompajlira:

#+begin_src sh
$ cargo check
   Checking hello_cargo v0.1.0 (file:///projects/hello_cargo)
    Finished dev [unoptimized + debuginfo] target(s) in 0.32 secs
#+end_src

** Izgradnja finalne verzije
- U toku razvoja koristimo izgradnju za debagovanje koja se brÅ¾e zavrÅ¡i ali
  generisani izvrÅ¡ni kod nije optimalan.

- Za finalnu verziju je potrebno izgradnju obaviti na sledeÄ‡i naÄin:

    #+begin_src rust
    cargo build --release
    #+end_src

- Ovo Ä‡e obaviti dodatne optimizacije koje Ä‡e duÅ¾e trajati ali Ä‡e krajnji kod
  biti optimizovan.

** Cargo kao konvencija
PraktiÄno svi Rust projekti koriste Cargo tako da je unifikovan naÄin izgradnje
projekata. Uglavnom se svodi na:

#+begin_src sh
$ git clone example.org/someproject
$ cd someproject
$ cargo build
#+end_src

* Igra pogaÄ‘anja brojeva
** PodeÅ¡avanje projekta
#+begin_src rust
$ cargo new guessing_game
$ cd guessing_game
#+end_src

Fajl =Cargo.toml=:
#+begin_src toml
[package]
name = "guessing_game"
version = "0.1.0"
edition = "2021"

[dependencies]
#+end_src

Fajl =src/main.rs=:
#+begin_src rust
fn main() {
    println!("Hello, world!");
}
#+end_src

#+REVEAL: split

#+begin_src sh
$ cargo run
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
    Finished dev [unoptimized + debuginfo] target(s) in 1.50s
     Running `target/debug/guessing_game`
Hello, world!
#+end_src

** Preuzimanje broja sa standardnog ulaza

#+begin_src rust
use std::io;

fn main() {
    println!("Guess the number!");

    println!("Please input your guess.");

    let mut guess = String::new();

    io::stdin()
        .read_line(&mut guess)
        .expect("Failed to read line");

    println!("You guessed: {}", guess);
}
#+end_src

** Promenjivost (/mutability/)
- Varijable su podrazumevano nepromenjive (/immutable/).
- Ukoliko Å¾elimo varijablu Äija vrednost moÅ¾e da se menja koristimo kljuÄnu reÄ
  =mut=.

  #+begin_src rust
  let apples = 5; // immutable
  let mut bananas = 5; // mutable
  #+end_src

- Isto vaÅ¾i i za parametre funkcija:

  #+begin_src rust
  io::stdin()
      .read_line(&mut guess)
  #+end_src

** Obrada moguÄ‡ih greÅ¡aka upotrebom =Result= tipa
=read_line= moÅ¾e da zavrÅ¡i neuspeÅ¡no. Zato vraÄ‡a =io::Result= tip koji predstavlja
enumeraciju (/enum/) tip i ima dve vrednosti: =Ok= i =Err=.

#+begin_src rust
io::stdin()
    .read_line(&mut guess)
    .expect("Failed to read line");
#+end_src

=expect= implementiran na =Ok= varijanti Ä‡e vratiti vrednost koja je sadrÅ¾ana unutar
varijante dok implementacija nad =Err= varijanti prekida izvrÅ¡avanje programa.

** Pokretanje
#+begin_src rust
$ cargo run
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
    Finished dev [unoptimized + debuginfo] target(s) in 6.44s
     Running `target/debug/guessing_game`
Guess the number!
Please input your guess.
6
You guessed: 6
#+end_src

** Generisanje sluÄajnog broja
Koristimo =rand= paket (sanduk - /crate/ u terminologiji Cargo-a).

Sekcija =[dependencies]= u fajlu =Cargo.toml=:
#+begin_src toml
[dependencies]
rand = "0.8.3"
#+end_src

#+begin_src sh
$ cargo build
    Updating crates.io index
  Downloaded rand v0.8.3
  Downloaded libc v0.2.86
  ...
   Compiling rand_chacha v0.3.0
   Compiling rand v0.8.3
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
    Finished dev [unoptimized + debuginfo] target(s) in 2.53s
#+end_src

Cargo koristi [[https://semver.org/][Semantic Versioning]]. Rust paketi se preuzimaju sa sajta [[https://crates.io/][crates.io]]
i keÅ¡iraju lokalno.

** Ponovljivost izgradnje - /Cargo.lock/
- Prvi put kada se pokrene =cargo build= kreira se fajl =Cargo.lock= sa
  informacijama o verzijama svih sanduka koji su instalirani.
- Svako sledeÄ‡e pokretanje izgradnje koristi iste verzije.
- =Cargo.lock= je potrebno Äuvati u sistemu kontrole verzija (npr. =git=) da bi se
  osigurala ponovljivost.

** AÅ¾uriranje sanduka
- AÅ¾uriranje na nove verzije sanduka se obavlja sa:

  #+begin_src sh
  $ cargo update
    Updating crates.io index
    Updating rand v0.8.3 -> v0.8.4
  #+end_src
- PoÅ¡tuje se semantiÄko verzioniranje tj. automatski se aÅ¾urira na sledeÄ‡u
  verziju koja je manja od naredne glavne (/major/) verzije.
- Ako prelazimo na novu glavnu verziju to moramo uraditi izmenom verzije u
  =Cargo.toml= fajlu.

** Generisanje sluÄajnog broja
Fajl =src/main.rs=:
#+begin_src rust
use std::io;
use rand::Rng;

fn main() {
    println!("Guess the number!");

    let secret_number = rand::thread_rng().gen_range(1..101);

    println!("The secret number is: {}", secret_number);

    println!("Please input your guess.");

    let mut guess = String::new();

    io::stdin()
        .read_line(&mut guess)
        .expect("Failed to read line");

    println!("You guessed: {}", guess);
}
#+end_src

U =gen_range= koristimo izraz opsega (/range expression/). Interval je zatvoren na
donjoj granici i otvoren na gornjoj. Za interval zatvoren i od gore moÅ¾emo
pisati ~1..=100~.

** Dokumentacija za lokalne sanduke
Da bi znali koje metode i funkcije su nam dostupne moÅ¾emo koristiti ugraÄ‘enu
dokumentaciju za sanduke projekta. Dokumentaciju dobijamo sa:

#+begin_src sh
cargo doc --open
#+end_src

** Pokretanje programa
#+begin_src sh
$ cargo run
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
    Finished dev [unoptimized + debuginfo] target(s) in 2.53s
     Running `target/debug/guessing_game`
Guess the number!
The secret number is: 7
Please input your guess.
4
You guessed: 4
#+end_src

** PoreÄ‘enje tajnog broja sa zadatim
Fajl =src/main.rs=
#+begin_src rust
use rand::Rng;
use std::cmp::Ordering;
use std::io;

fn main() {
    // --snip--

    println!("You guessed: {}", guess);

    match guess.cmp(&secret_number) {
        Ordering::Less => println!("Too small!"),
        Ordering::Greater => println!("Too big!"),
        Ordering::Equal => println!("You win!"),
    }
}
#+end_src
- Koristimo =std::cmp::Ordering= enum koji ima varijante =Less=, =Greater= i =Equal=
- =match= izraz poredi zadatu vrednost sa vrednostima zadatim u telu i izvrÅ¡ava
  granu koja se podudara. Grane =match= izraza se u Rust terminologiji zovu "ruke" (/arms/).

** Popravka tipova
Kod sa prethodnog slajda nije ispravan:
#+begin_src sh
$ cargo build
   Compiling libc v0.2.86
   ...
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
error[E0308]: mismatched types
  --> src/main.rs:22:21
   |
22 |     match guess.cmp(&secret_number) {
   |                     ^^^^^^^^^^^^^^ expected struct `String`, found integer
   |
   = note: expected reference `&String`
              found reference `&{integer}`

error[E0283]: type annotations needed for `{integer}`
   --> src/main.rs:8:44
    |
8   |     let secret_number = rand::thread_rng().gen_range(1..101);
    |         -------------                      ^^^^^^^^^ cannot infer type for type `{integer}`
    |         |
    |         consider giving `secret_number` a type
    |
    = note: multiple `impl`s satisfying `{integer}: SampleUniform` found in the `rand` crate:
            - impl SampleUniform for i128;
            - impl SampleUniform for i16;
            - impl SampleUniform for i32;
            - impl SampleUniform for i64;
            and 8 more
...
#+end_src

#+REVEAL: split

Osnova greÅ¡ke je neslaganje tipova. Sa ulaza prihvatamo =String= dok nam je tajni
broj =integer=.

** Konverzija stringa u broj
Problem reÅ¡avamo konverzijom stringa sa ulaza u brojni tip.

#+begin_src rust
// --snip--

    let mut guess = String::new();

    io::stdin()
        .read_line(&mut guess)
        .expect("Failed to read line");

    let guess: u32 = guess.trim().parse().expect("Please type a number!");

    println!("You guessed: {}", guess);

    match guess.cmp(&secret_number) {
        Ordering::Less => println!("Too small!"),
        Ordering::Greater => println!("Too big!"),
        Ordering::Equal => println!("You win!"),
    }
#+end_src

#+REVEAL: split

Sada se program komapajlira.

#+begin_src sh
$ cargo run
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
    Finished dev [unoptimized + debuginfo] target(s) in 0.43s
     Running `target/debug/guessing_game`
Guess the number!
The secret number is: 58
Please input your guess.
  76
You guessed: 76
Too big!
#+end_src

** OmoguÄ‡avanje viÅ¡estrukog pogaÄ‘anja - upotreba petlje
Fajl =src/main.rs=:
#+begin_src rust
// --snip--

    println!("The secret number is: {}", secret_number);

    loop {
        println!("Please input your guess.");

        // --snip--

        match guess.cmp(&secret_number) {
            Ordering::Less => println!("Too small!"),
            Ordering::Greater => println!("Too big!"),
            Ordering::Equal => println!("You win!"),
        }
    }
}
#+end_src

** Prekid rada
Problem je kako prekinuti program kada korisnik pogodi broj?

#+begin_src rust
// --snip--

        match guess.cmp(&secret_number) {
            Ordering::Less => println!("Too small!"),
            Ordering::Greater => println!("Too big!"),
            Ordering::Equal => {
                println!("You win!");
                break;
            }
        }
    }
}
#+end_src

** Rukovanje neispravnim ulazom
#+begin_src rust
// --snip--

        io::stdin()
            .read_line(&mut guess)
            .expect("Failed to read line");

        let guess: u32 = match guess.trim().parse() {
            Ok(num) => num,
            Err(_) => continue,
        };

        println!("You guessed: {}", guess);

        // --snip--
#+end_src

Potrebno je joÅ¡ obrisati liniju koja prikazuje generisani broj.

** Finalni kod
#+begin_src rust
use rand::Rng;
use std::cmp::Ordering;
use std::io;

fn main() {
    println!("Guess the number!");
    let secret_number = rand::thread_rng().gen_range(1..101);

    loop {
        println!("Please input your guess.");
        let mut guess = String::new();
        io::stdin()
            .read_line(&mut guess)
            .expect("Failed to read line");
        let guess: u32 = match guess.trim().parse() {
            Ok(num) => num,
            Err(_) => continue,
        };
        println!("You guessed: {}", guess);
        match guess.cmp(&secret_number) {
            Ordering::Less => println!("Too small!"),
            Ordering::Greater => println!("Too big!"),
            Ordering::Equal => {
                println!("You win!");
                break;
            }
        }
    }
}
#+end_src

* Osnovni programski koncepti
** Varijable i promenjivost (/mutability/)
*** Varijable i promenjivost (/mutability/)
- Varijable su podrazumevano nepromenjive.
- Jednom kada dobiju vrednost (/binding/) ta vrednost se ne moÅ¾e promeniti

  #+begin_src rust
    fn main() {
        let x = 5;
        println!("The value of x is: {}", x);
        x = 6;     // greÅ¡ka
        println!("The value of x is: {}", x);
    }
  #+end_src

  #+REVEAL: split

  #+begin_src sh
    $ cargo run
    Compiling variables v0.1.0 (file:///projects/variables)
    error[E0384]: cannot assign twice to immutable variable `x`
    --> src/main.rs:4:5
    |
    2 |     let x = 5;
    |         -
    |         |
    |         first assignment to `x`
    |         help: consider making this binding mutable: `mut x`
    3 |     println!("The value of x is: {}", x);
    4 |     x = 6;
    |     ^^^^^ cannot assign twice to immutable variable

    For more information about this error, try `rustc --explain E0384`.
    error: could not compile `variables` due to previous error
  #+end_src
*** =mut= kljuÄna reÄ

#+begin_src rust
fn main() {
    let mut x = 5;
    println!("The value of x is: {}", x);
    x = 6;
    println!("The value of x is: {}", x);
}
#+end_src
** Konstante - =const=
- SliÄno kao nepromenjive varijable sa sledeÄ‡im razlikama:
  - Uvek su nepromenjive
  - Mogu se inicijalizovati samo konstantnim izrazom (poznatim u vreme kompajliranja)
  - Validne za celokupno vreme izvrÅ¡avanja programa u opsegu vaÅ¾enja gde su
    definisane (/scope/)
  - Mora se eksplicitno definisati tip
- Kompajler Ä‡e konstante "ubaciti" na mestu upotrebe
- Po konvenciji imena konstanti se piÅ¡u velikim slovima

  #+begin_src rust
    const THREE_HOURS_IN_SECONDS: u32 = 60 * 60 * 3;
  #+end_src

** Tipovi podataka
*** Tipovi podataka
- Svaka vrednost u Rust-u ima tip. Tipovi moraju biti poznati u vreme
  kompajliranja (statiÄki tipiziran jezik).
- Kompajler Ä‡e probati da odredi tipove (/type inference/). Ako nije moguÄ‡e
  zahteva se da definiÅ¡emo tip eksplicitno.

  Npr:
  #+begin_src rust
    let guess: u32 = "42".parse().expect("Not a number!");
  #+end_src
  Ovde nije moguÄ‡e odrediti tip jer =str::parse= funkcija moÅ¾e vratiti razliÄite
  brojne tipove (funkcija je generiÄka) a ne postoji naÄin da se tip automatski
  odredi.

  Signatura je:
  #+begin_src rust
    pub fn parse<F>(&self) -> Result<F, <F as FromStr>::Err>
    where
        F: FromStr
  #+end_src
*** /Integer/ tipovi

| DuÅ¾ina  | Signed | Unsigned |
|---------+--------+----------|
| 8-bit   | i8     | u8       |
| 16-bit  | i16    | u16      |
| 32-bit  | i32    | u32      |
| 64-bit  | i64    | u64      |
| 128-bit | i128   | u128     |
| arch    | isize  | usize    |

*** Literali brojeva

| Literali       | Primeri     |
|----------------+-------------|
| Decimal        | 98_222      |
| Hex            | 0xff        |
| Octal          | 0o77        |
| Binary         | 0b1111_0000 |
| Byte (u8 only) | b'A'        |

*** /Floating-Point/ tipovi

#+begin_src rust
fn main() {
    let x = 2.0; // f64

    let y: f32 = 3.0; // f32
}
#+end_src

IEEE-754 standard

*** Operacije nad brojevima

#+begin_src rust
fn main() {
    // addition
    let sum = 5 + 10;

    // subtraction
    let difference = 95.5 - 4.3;

    // multiplication
    let product = 4 * 30;

    // division
    let quotient = 56.7 / 32.2;
    let floored = 2 / 3; // Results in 0

    // remainder
    let remainder = 43 % 5;
}
#+end_src

*** /Boolean/ tip
#+begin_src rust
fn main() {
    let t = true;

    let f: bool = false; // with explicit type annotation
}
#+end_src

*** Tip karaktera

#+begin_src rust
fn main() {
    let c = 'z';
    let z = 'â„¤';
    let heart_eyed_cat = 'ğŸ˜»';
}
#+end_src

*** Torke (/tuples/)
#+begin_src rust
fn main() {
    let tup: (i32, f64, u8) = (500, 6.4, 1);
}
#+end_src

- Raspakivanje torki (/destructuring/):
#+begin_src rust
fn main() {
    let tup = (500, 6.4, 1);

    let (x, y, z) = tup;

    println!("The value of y is: {}", y);
}
#+end_src

#+REVEAL: split

Pristup elementima torke:
#+begin_src rust
fn main() {
    let x: (i32, f64, u8) = (500, 6.4, 1);

    let five_hundred = x.0;

    let six_point_four = x.1;

    let one = x.2;
}
#+end_src

*** Nizovni tip
- Svaki element nizovnog tipa mora imati isti tip
- Dimenzija niza je nepromenjiva (alociran je na steku)
    #+begin_src rust
    fn main() {
        let a = [1, 2, 3, 4, 5];
    }
    #+end_src

- Tip se moÅ¾e eksplitino definisati na sledeÄ‡i naÄin (niz duÅ¾ine =5= tipa =i32=):
    #+begin_src rust
    let a: [i32; 5] = [1, 2, 3, 4, 5];
    #+end_src

- Inicijalizacija svih elemenata na istu vrednost se obavlja na sledeÄ‡i naÄin:
  #+begin_src rust
  let a = [3; 5];
  #+end_src
  Gde je vrednost svakog elementa =3= a duÅ¾ina niza =5=.

#+REVEAL: split

Indeksni pristup:

#+begin_src rust
fn main() {
    let a = [1, 2, 3, 4, 5];

    let first = a[0];
    let second = a[1];
}
#+end_src

** Funkcije
*** Funkcije
#+begin_src rust
fn main() {
    println!("Hello, world!");

    another_function();
}

fn another_function() {
    println!("Another function.");
}
#+end_src
- Za imenovanje funkcija kao i varijabli koristi se /snake_case/.
*** Funkcije - parametri
#+begin_src rust
fn main() {
    print_labeled_measurement(5, 'h');
}

fn print_labeled_measurement(value: i32, unit_label: char) {
    println!("The measurement is: {}{}", value, unit_label);
}
#+end_src

*** Iskazi i izrazi
- Rust je jezik baziran na izrazima (/expression-based/)
- Iskazi (/statements/) su jeziÄke konstrukcije koje nemaju povratnu vrednost.
  Izrazi (/expressions/) se evaluiraju u odreÄ‘eni rezultat, tj. imaju vrednost.
- Primer: =let= je iskaz tj. nema povratnu vrednost. Ovo moÅ¾ete pisati:
  #+begin_src rust
  let y = 6;
  #+end_src
  Ali ovo ne:
  #+begin_src rust
  let x = (let y = 6);
  #+end_src

#+REVEAL: split

Blok koda je takoÄ‘e izraz. Å ta je vrednost u koju se evaluira?

#+begin_src rust
{
    let x = 3;
    x + 1
}
#+end_src

Vrednost bloka je vrednost poslednjeg izraza, tj. =x+1=. Primetite da tu ne
koristimo =;= jer terminacija ovim karakterom pretvara izraz u iskaz.

#+REVEAL: split

Zbog ovoga je sasvim legalno da piÅ¡emo:

#+begin_src rust
fn main() {
    let y = {
        let x = 3;
        x + 1
    };

    println!("The value of y is: {}", y);
}
#+end_src

#+RESULTS:
: The value of y is: 4
*** Povratne vrednosti funkcija
Vrednost funkcije je vrednost bloka koji predstavlja telo funkcije, dakle
poslednjeg izraza unutar tela funkcije.

#+begin_src rust
fn five() -> i32 {
    5
}

fn main() {
    let x = five();

    println!("The value of x is: {}", x);
}
#+end_src

#+RESULTS:
: The value of x is: 5

#+REVEAL: split

Ili na primer:
#+begin_src rust
fn main() {
    let x = plus_one(5);

    println!("The value of x is: {}", x);
}

fn plus_one(x: i32) -> i32 {
    x + 1
}
#+end_src

#+RESULTS:
: The value of x is: 6

#+REVEAL: split

Ukoliko izraz =x+1= terminiramo sa =;= kod se neÄ‡e kompajlirati jer funkcija
deklariÅ¡e da vraÄ‡a tip =i32= dok sada vraÄ‡a =()= (tzv. /unit type/) odnosno nema
povratnu vrednost jer je poslednja instrukcija iskaz.

#+begin_src rust
fn main() {
    let x = plus_one(5);

    println!("The value of x is: {}", x);
}

fn plus_one(x: i32) -> i32 {
    x + 1;
}
#+end_src

#+begin_example
error[E0308]: mismatched types
 --> src/main.rs:8:24
  |
8 | fn plus_one(x: i32) -> i32 {
  |    --------            ^^^ expected `i32`, found `()`
  |    |
  |    implicitly returns `()` as its body has no tail or `return` expression
9 |     x + 1;
  |          - help: consider removing this semicolon

For more information about this error, try `rustc --explain E0308`.
error: could not compile `cargo4UyKF0` due to previous error
#+end_example

** Komentari
Komentari se piÅ¡u posle =//= ili u formi blok komentara =/*.... */= kao i u C++-u.
Ovo bi bili validni komentari:
#+begin_src rust
// So weâ€™re doing something complicated here, long enough that we need
// multiple lines of comments to do it! Whew! Hopefully, this comment will
// explain whatâ€™s going on.

fn main() {
    let lucky_number = 7; // Iâ€™m feeling lucky today
}
...
fn main() {
    // Iâ€™m feeling lucky today
    let lucky_number = 7;
    /* this is block comment
       which can span multiple lines.
       Nesting is allowed.
     */
}
#+end_src

#+REVEAL: split

Postoje i komentari za dokumentaciju koji predstavljaju posebnu sintaksu za
komentare koji su deo API dokumentacije. Oni se piÅ¡u posle =///=. Na primer:
#+begin_src rust
/// Adds one to the number given.
///
/// # Examples
///
/// ```
/// let arg = 5;
/// let answer = my_crate::add_one(arg);
///
/// assert_eq!(6, answer);
/// ```
pub fn add_one(x: i32) -> i32 {
    x + 1
}
#+end_src
** Kontrola toka
*** =if= izrazi
#+begin_src rust
fn main() {
    let number = 3;

    if number < 5 {
        println!("condition was true");
    } else {
        println!("condition was false");
    }
}
#+end_src

*** =if-else=
#+begin_src rust
fn main() {
    let number = 6;

    if number % 4 == 0 {
        println!("number is divisible by 4");
    } else if number % 3 == 0 {
        println!("number is divisible by 3");
    } else if number % 2 == 0 {
        println!("number is divisible by 2");
    } else {
        println!("number is not divisible by 4, 3, or 2");
    }
}
#+end_src
*** =if= u =let= iskazima
=if= je izraz pa se moÅ¾e koristiti gde god moÅ¾emo pisati i bilo koji drugi izraz.

#+begin_src rust
fn main() {
    let condition = true;
    let number = if condition { 5 } else { 6 };

    println!("The value of number is: {}", number);
}
#+end_src

#+RESULTS:
: The value of number is: 5

#+REVEAL: split

Ali se grane moraju slagati po tipu. Ovo je pogreÅ¡no jer je prva grana tipa
=i32= dok je =else= grana tipa =str=.

#+begin_src rust
fn main() {
    let condition = true;

    let number = if condition { 5 } else { "six" };

    println!("The value of number is: {}", number);
}
#+end_src
*** Petlje
Rust ima tri tipa petlje:
- =loop= - za beskontaÄne petlje
- =while= - uslovna petlja
- =for= - petlja za iteraciju kroz iteratore

*** =loop=
#+begin_src rust
fn main() {
    loop {
        println!("again!");
    }
}
#+end_src

*** =loop= labele
Ukoliko imamo ugnjeÅ¾dene =loop= iskaze moÅ¾emo koristiti labele prilikom izlaska sa
=break= instrukcijom.

#+begin_src rust
fn main() {
    let mut count = 0;
    'counting_up: loop {
        println!("count = {}", count);
        let mut remaining = 10;

        loop {
            println!("remaining = {}", remaining);
            if remaining == 9 {
                break;
            }
            if count == 2 {
                break 'counting_up;
            }
            remaining -= 1;
        }

        count += 1;
    }
    println!("End count = {}", count);
}
#+end_src

*** =loop= kao izraz
=loop= moÅ¾e imati povratnu vrednost. Povratna vrednost se definiÅ¡e kao parametar
=break= instrukcije.

#+begin_src rust
fn main() {
    let mut counter = 0;

    let result = loop {
        counter += 1;

        if counter == 10 {
            break counter * 2;
        }
    };

    println!("The result is {}", result);
}
#+end_src
*** =while=
#+begin_src rust
fn main() {
    let mut number = 3;

    while number != 0 {
        println!("{}!", number);

        number -= 1;
    }

    println!("LIFTOFF!!!");
}
#+end_src
*** =for=
Iteraciju kroz ureÄ‘enu kolekciju, kao Å¡to je niz, moÅ¾emo obaviti sa =while= petljom.
#+begin_src rust
fn main() {
    let a = [10, 20, 30, 40, 50];
    let mut index = 0;

    while index < 5 {
        println!("the value is: {}", a[index]);

        index += 1;
    }
}
#+end_src

#+REVEAL: split
Ali je za tu namenu prirodnije i sigurnije koristiti =for= petlju. TakoÄ‘e Ä‡e se
program brÅ¾e izvrÅ¡avati.

#+begin_src rust
fn main() {
    let a = [10, 20, 30, 40, 50];

    for element in a {
        println!("the value is: {}", element);
    }
}
#+end_src

#+REVEAL: split
=for= petlje su najÄeÅ¡Ä‡i oblik petlji u upotrebi u Rust-u. Koriste se npr. i u
situaciji kada je potrebno izvrÅ¡iti petlju odreÄ‘eni broj puta.

#+begin_src rust
fn main() {
    for number in (1..4).rev() {
        println!("{}!", number);
    }
    println!("LIFTOFF!!!");
}
#+end_src

#+RESULTS:
: 3!
: 2!
: 1!
: LIFTOFF!!!

* VlasniÅ¡tvo i pozajmljivanje (/Ownership and borrowing/)
** VlasniÅ¡tvo
*** VlasniÅ¡tvo
- Jedan od najvaÅ¾nijih koncepata jezika.
- Skup pravila koji omoguÄ‡avaju upravljanje memorijom.
- Garancije za memorijsku sigurnost bez upotrebe /garbage collector/-a
- Sve provere se obavljaju u vreme kompajliranja - rezultuje odliÄnim
  performansama u vreme izvrÅ¡avanja.

*** Stek i hip (/Stack and Heap/)
- Stek - alokacija prostora za podatke Äija je veliÄina poznata u vreme
  kompajliranja.
  - BrÅ¾a alokacija i dealokacija - jednostavan mehanizam, LIFO struktura.
  - BrÅ¾i pristup - lokalne varijable, keÅ¡iranje pristupa.
- Hip - slobodna alokacija u vreme izvrÅ¡avanja.
  - Sporija alokacija i dealokacija.
  - Sporiji pristup - proizvoljna lokacija.

*** Pravila vlasniÅ¡tva
1. Svaka vrednost u Rust-u ima varijablu koja se naziva /vlasnikom/ (/owner/).
2. U svakom trenutku postoji samo jedan vlasnik.
3. Kada vlasnik izaÄ‘e iz opsega vaÅ¾enja (/scope/) vrednost se dealocira (/drop/).

*** Opseg vaÅ¾enja varijable (/Variable Scope/)

#+begin_src rust
{                      // s nije validno ovde jer joÅ¡ nije deklarisano
    let s = "hello";   // s je validno od ove pozicije

    // koristimo s
}   // ovde opseg prestaje da vaÅ¾i i s viÅ¡e nije validno
#+end_src

*** =String= tip

- Demonstracija vlasniÅ¡tva nad tipom koji se alocira na hipu.

  #+begin_src rust
  let mut s = String::from("hello");
  s.push_str(", world!"); // push_str() dodaje literal na string
  println!("{}", s); // hello, world!`
  #+end_src

- Memorija se alocira sa hipa u vreme izvrÅ¡avanja.
- Moramo vratiti memoriju alokatoru kada nam viÅ¡e nije potrebna.

#+REVEAL: split

- Alokacija stringa se obavlja na liniji:

  #+begin_src rust
  let mut s = String::from("hello");
  #+end_src

- Ali dealokacija je teÅ¾a:
  - /Garbage collector/
  - /Memory waste/
  - /Double-free/

#+REVEAL: split

- Rust kompajler Ä‡e dodati kod koji radi dealokaciju kada vlasnik napusti opseg vaÅ¾enja.
- Poziva se funkcija =drop= nad tipom i ova funkcija je zaduÅ¾ena da obavi dealokaciju.

  #+begin_src rust
  {
        let s = String::from("hello"); // s postaje validno

        // koristimo s
  }  // <- s izlazi iz opsega i poziva se "drop"
  #+end_src

*** Dodela vrednosti

- Kopiranje vrednosti =x= u =y=. Obe varijable sada imaju vrednost =5=.

  #+begin_src rust
  let x = 5;
  let y = x;
  #+end_src

- Ali sa =String= tipom deÅ¡ava se neÅ¡to drugo.

  #+begin_src rust
  let s1 = String::from("hello");
  #+end_src

#+attr_html: :style height: 400px;
#+ATTR_ORG: :width 300px
[[./images/string-type.png]]

#+REVEAL: split

- Ako bi se kopirao samo sadrÅ¾aj sa steka bez imali bismo sledeÄ‡u situaciju
  (tzv. /shallow copy/).

  #+begin_src rust
  let s1 = String::from("hello");
  let s2 = s1;
  #+end_src

#+attr_html: :style height: 400px;
#+ATTR_ORG: :width 300px
[[./images/string-type-2.png]]

Å to je problematiÄno jer kada i =s1= i =s2= napuste opseg pokuÅ¡aÄ‡e se dvostruka
dealokacija iste memorije na hipu (/double free/).

#+REVEAL: split

Ako bi se i hip memorija kopirala (tzv. /deep copy/) imali bismo validnu situaciju
ali bi takva operacija bila veoma "skupa".

#+attr_html: :style height: 500px;
#+ATTR_ORG: :width 300px
[[./images/string-type-3.png]]

*** PremeÅ¡tanje (/Move/)

Ako probamo da kompajliramo sledeÄ‡i kod:

#+begin_src rust
let s1 = String::from("hello");
let s2 = s1;

println!("{}, world!", s1);
#+end_src

DobiÄ‡emo greÅ¡ku:

#+begin_example
$ cargo run
   Compiling ownership v0.1.0 (file:///projects/ownership)
error[E0382]: borrow of moved value: `s1`
 --> src/main.rs:5:28
  |
2 |     let s1 = String::from("hello");
  |         -- move occurs because `s1` has type `String`, which does not implement the `Copy` trait
3 |     let s2 = s1;
  |              -- value moved here
4 |
5 |     println!("{}, world!", s1);
  |                            ^^ value borrowed here after move

For more information about this error, try `rustc --explain E0382`.
error: could not compile `ownership` due to previous error
#+end_example

#+REVEAL: split

Ono Å¡to nam kompajler kaÅ¾e je da se u iskazu:

#+begin_src rust
let s2 = s1;
#+end_src

promenio vlasnik ovog stringa. Novi vlasnik je sada =s2= dok je varijabla =s1=
postala nevalidna i nije je viÅ¡e moguÄ‡e koristiti.

KaÅ¾emo da se obavilo "premeÅ¡tanje" (/move/) vrednosti iz =s1= u =s2=.

#+attr_html: :style height: 400px;
#+ATTR_ORG: :width 300px
[[./images/string-type-4.png]]

ÄŒime se ispunjava prvo pravilo vlasniÅ¡tva i spreÄava /double free/ greÅ¡ka.

*** Kloniranje

Posledica prethodnog je da Rust nikada neÄ‡e automatski obaviti duboko kopiranje
varijable jer bi to moglo da izazove loÅ¡e performanse.

Duboko kopiranje (stek+hip) radimo sa =clone= metodom:

#+begin_src rust
let s1 = String::from("hello");
let s2 = s1.clone();

println!("s1 = {}, s2 = {}", s1, s2);
#+end_src

Sada je lako pronaÄ‡i u kodu sva mesta gde se obavlja potencijalno "skupa"
operacija dubokog kopiranja.

*** /Copy/ tipovi

Kako onda radi primer koji smo videli prethodno? ZaÅ¡to ne dolazi do premeÅ¡tanja
i invalidacije =y= varijable?

#+begin_src rust
let x = 5;
let y = x;

println!("x = {}, y = {}", x, y);
#+end_src

- Kod prostih tipova Äija je veliÄina poznata u vreme kompajliranja i koji mogu
  u celosti stati na stek nema razlike izmeÄ‘u dubokog i plitkog kopiranja.
- Ovakvi tipovi su anotirani sa /Copy/ trejtom (/Trait/). Tipovi koji su na ovaj
  naÄin anotirani ne obavljaju premeÅ¡tanje veÄ‡ uvek kopiranje.
- Implikacija je da se varijabla sa desne strane dodele moÅ¾e koristiti i nakon
  dodele.
- Rust Ä‡e spreÄiti /Copy/ anotaciju ako tip implementira i /Drop/ jer to znaÄi da
  radi neku specijalnu alokaciju pa mu je potrebna i posebna dealokacija Å¡to
  znaÄi da mora da se radi premeÅ¡tanje.

*** VlasniÅ¡tvo i funkcije

- Semantika prenosa parametara kod poziva funkcija je sliÄna semantici dodele.

#+begin_src rust
fn main() {
    let s = String::from("hello");  // s postaje validno

    takes_ownership(s);             // s vrednost se premeÅ¡ta u funkciju...
                                    // ... tako da s nije validno od ove pozicije

    let x = 5;                      // x postaje validno

    makes_copy(x);                  // x bi se premestilo u funkciju,
                                    // ali i32 je Copy, tako da je ok
                                    // da se x koristi i posle

} // x izlazi iz opsega, zatim s. Ali poÅ¡to je s premeÅ¡teno niÅ¡ta posebno se
  // ne deÅ¡ava.

fn takes_ownership(some_string: String) { // some_string ulazi u opseg
    println!("{}", some_string);
} // some_string izlazi iz opsega i poziva se `drop`. Memorija sa hipa se
  // oslobaÄ‘a.

fn makes_copy(some_integer: i32) { // some_integer ulazi u opseg
    println!("{}", some_integer);
} // some_integer izlazi iz opsega. PoÅ¡to nije 'Drop', niÅ¡ta posebno se ne
  // dogaÄ‘a (osim "skidanja" sa steka naravno)
#+end_src

*** Povratne vrednosti i opsezi

Prilikom vraÄ‡anja vrednosti iz funkcije takoÄ‘e moÅ¾e doÄ‡i do premeÅ¡tanja vlasniÅ¡tva.

#+begin_src rust
fn main() {
    let s1 = gives_ownership();         // gives_ownership premeÅ¡ta povratnu
                                        // vrednost u s1

    let s2 = String::from("hello");     // s2 postaje validno

    let s3 = takes_and_gives_back(s2);  // s2 se premeÅ¡ta u funkciju
                                        // takes_and_gives_back, koja premeÅ¡ta
                                        // povratnu vrednost u s3
} // s3 izlazi iz opsega i poziva se `drop`. s2 je premeÅ¡tena pa se niÅ¡ta
  // ne deÅ¡ava. s1 takoÄ‘e izlazi iz opsega i dealocira se.

fn gives_ownership() -> String {             // gives_ownership Ä‡e premestiti
                                             // svoju povratnu vrednost u funkciju
                                             // koja je poziva

    let some_string = String::from("yours"); // some_string postaje validno

    some_string                              // some_string se premeÅ¡ta
                                             // u funkciju pozivaoca
}

// Ova funkcija uzima vlasniÅ¡tvo nad stringom i vraÄ‡a ga nazad
fn takes_and_gives_back(a_string: String) -> String { // a_string postaje validno

    a_string  // a_string se premeÅ¡ta u funkciju pozivaoca
}
#+end_src

#+REVEAL: split

- ÄŒesto nam je potrebno da varijablu koristimo i posle slanja u funkciju.
- Mogli bi je stalo vraÄ‡ati zajedno sa rezultatom funkcije na primer upotrebom torki.

#+begin_src rust
fn main() {
    let s1 = String::from("hello");

    let (s2, len) = calculate_length(s1);

    println!("The length of '{}' is {}.", s2, len);
}

fn calculate_length(s: String) -> (String, usize) {
    let length = s.len();

    (s, length)
}
#+end_src

Ali je to naporno. Postoji koncept u Rust-u koji je namenjen u ovakvim
situacijama i baziran je na referencama i pozajmljivanju vrednosti.
** Reference i pozajmljivanje (/References and Borrowing/)
*** Reference i pozajmljivanje (/References and Borrowing/)
- Referenca je poput pointera, sadrÅ¾i adresu vrednosti koju poseduje neka druga
  varijabla.
- Za razliku od pointera, reference u Rust-u su garantovano validne.

#+begin_src rust
fn main() {
    let s1 = String::from("hello");

    let len = calculate_length(&s1);

    println!("The length of '{}' is {}.", s1, len);
}

fn calculate_length(s: &String) -> usize {
    s.len()
}
#+end_src

#+attr_html: :style height: 400px;
#+ATTR_ORG: :width 300px
[[./images/reference.png]]

*** Referenciranje

- Primena operatora =&= nad varijablom nazivamo /referenciranje/.

  #+begin_src rust
  let s1 = String::from("hello");
  let len = calculate_length(&s1);
  #+end_src

- Sintaksa =&s1= nam omoguÄ‡ava da kreiramo referencu na vrednost Äiji vlasnik je
  =s1= bez uzimanja vlasniÅ¡tva.
- PoÅ¡to referenca nije vlasnik ne dolazi do dealokacije prilikom izlaska iz
  opsega.
- Operacija obrnuta referenciranju naziva se /dereferenciranje/ i vrÅ¡i se =*=
  operatorom nad referencom (npr. =*s2= je vrednost na koju referencira =s2=).
- Operaciju referenciranja nazivamo pozajmljivanjem (/borrowing/).

#+REVEAL: split

- TakoÄ‘e, parametar funkcije moÅ¾e biti referenca.
#+begin_src rust
fn calculate_length(s: &String) -> usize { // s je referenca na String
    s.len()
} // s izlazi iz opsega ali poÅ¡to nema vlasniÅ¡tvo nad vrednoÅ¡Ä‡u
  // niÅ¡ta se ne deÅ¡ava.
#+end_src

*** Promena pozajmljene vrednosti

Å ta se deÅ¡ava ukoliko pokuÅ¡amo da modifikujemo pozajmljenu vrednost?

#+begin_src rust
fn main() {
    let s = String::from("hello");
    change(&s);
}

fn change(some_string: &String) {
    some_string.push_str(", world");
}
#+end_src

#+begin_example
$ cargo run
   Compiling ownership v0.1.0 (file:///projects/ownership)
error[E0596]: cannot borrow `*some_string` as mutable, as it is behind a `&` reference
 --> src/main.rs:8:5
  |
7 | fn change(some_string: &String) {
  |                        ------- help: consider changing this to be a mutable reference: `&mut String`
8 |     some_string.push_str(", world");
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ `some_string` is a `&` reference, so the data it refers
  to cannot be borrowed as mutable

For more information about this error, try `rustc --explain E0596`.
error: could not compile `ownership` due to previous error
#+end_example

*** Promenjive reference

Kao i varijable, i reference su podrazumevano nepromenjiva (/immutable/). Moramo
biti eksplicitni ukoliko nam treba promenjiva referenca.

#+begin_src rust
fn main() {
    let mut s = String::from("hello");
    change(&mut s);
}

fn change(some_string: &mut String) {
    some_string.push_str(", world");
}
#+end_src

*** ViÅ¡e promenjivih referenci nad istom vrednoÅ¡Ä‡u

Rust ne dozvoljava da isti podatak u jednom trenutku ima viÅ¡e promenjivih
referenci.

#+begin_src rust
let mut s = String::from("hello");

let r1 = &mut s;
let r2 = &mut s;

println!("{}, {}", r1, r2);
#+end_src

#+begin_example
$ cargo run
   Compiling ownership v0.1.0 (file:///projects/ownership)
error[E0499]: cannot borrow `s` as mutable more than once at a time
 --> src/main.rs:5:14
  |
4 |     let r1 = &mut s;
  |              ------ first mutable borrow occurs here
5 |     let r2 = &mut s;
  |              ^^^^^^ second mutable borrow occurs here
6 |
7 |     println!("{}, {}", r1, r2);
  |                        -- first borrow later used here

For more information about this error, try `rustc --explain E0499`.
error: could not compile `ownership` due to previous error
#+end_example

#+REVEAL: split

Ovim ograniÄenjem Rust, u vreme kompajliranja, spreÄava klasu greÅ¡aka koje
dovode do nedefinisanog ponaÅ¡anja i koje zovemo /data races/. Ove greÅ¡ke se veoma
teÅ¡ko otkrivaju i otklanjaju i mogu nastati ukoliko su zadovoljeni sledeÄ‡i
uslovi:

- Dva ili viÅ¡e pointera pristupaju istim podacima u isto vreme,
- Bar jedan pointer se koristi za izmenu podatka,
- Ne postoji mehanizam za sinhronizaciju pristupa.

#+REVEAL: split

ViÅ¡e promenjivih referenci moÅ¾emo imati ali ne u istom opsegu:

#+begin_src rust
let mut s = String::from("hello");

{
    let r1 = &mut s;
} // r1 ovde izlazi iz opsega tako da moÅ¾emo krairati nove reference

let r2 = &mut s;
#+end_src

*** Kombinacija promenjivih i nepromenjivih referenci

SliÄno pravilo postoji i ukoliko imamo kombinaciju promenjivih i nepromenjivih
referenci:

#+begin_src rust
let mut s = String::from("hello");

let r1 = &s; // ovo je OK
let r2 = &s; // ovo je OK
let r3 = &mut s; // GREÅ KA!

println!("{}, {}, and {}", r1, r2, r3);
#+end_src

#+begin_example
$ cargo run
   Compiling ownership v0.1.0 (file:///projects/ownership)
error[E0502]: cannot borrow `s` as mutable because it is also borrowed as immutable
 --> src/main.rs:6:14
  |
4 |     let r1 = &s; // no problem
  |              -- immutable borrow occurs here
5 |     let r2 = &s; // no problem
6 |     let r3 = &mut s; // BIG PROBLEM
  |              ^^^^^^ mutable borrow occurs here
7 |
8 |     println!("{}, {}, and {}", r1, r2, r3);
  |                                -- immutable borrow later used here

For more information about this error, try `rustc --explain E0502`.
error: could not compile `ownership` due to previous error
#+end_example

#+REVEAL: split

- Ne moÅ¾emo istovremeno imati nepromenjive i promenjive reference jer korisnici
  nepromenjivih referenci ne oÄekuju da se podaci menjaju.
- MoÅ¾emo imati viÅ¡e nepromenjivih referenci jer niko ne moÅ¾e da menja podatke i
  time utiÄe na druge.

*** Opseg vaÅ¾enja reference

Opseg vaÅ¾enja reference poÄinje od mesta gde je uvedena pa do njene poslednje
upotrebe. Na primer, ovo je validno:

#+begin_src rust
let mut s = String::from("hello");

let r1 = &s; // OK
let r2 = &s; // OK
println!("{} and {}", r1, r2);
// varijable r1 i r2 se ne koriste u nastavku pa njihov opseg
// prestaje da vaÅ¾i.

let r3 = &mut s; // zato je ovo OK
println!("{}", r3);
#+end_src

Ova osobina referenci se naziva /Non-Lexical Lifetimes (NLL)/.

*** "ViseÄ‡e" reference
- U jezicima sa pointerima lako je kreirati pointer na deo memorije koji je dealociran.
- Rust garantovano spreÄava ovakve greÅ¡ke. Reference su uvek validne u Rust-u.

#+begin_src rust
fn main() {
    let reference_to_nothing = dangle();
}

fn dangle() -> &String {
    let s = String::from("hello");

    &s
}
#+end_src

#+REVEAL: split

#+begin_example
$ cargo run
   Compiling ownership v0.1.0 (file:///projects/ownership)
error[E0106]: missing lifetime specifier
 --> src/main.rs:5:16
  |
5 | fn dangle() -> &String {
  |                ^ expected named lifetime parameter
  |
  = help: this function's return type contains a borrowed value, but there is no value
  for it to be borrowed from
help: consider using the `'static` lifetime
  |
5 | fn dangle() -> &'static String {
  |                ~~~~~~~~

For more information about this error, try `rustc --explain E0106`.
error: could not compile `ownership` due to previous error
#+end_example

- Mehanizam koji ovo spreÄava naziva se "vreme Å¾ivota" (/lifetime/) i biÄ‡e
  detaljnije obraÄ‘eno u nastavku.
- U prevodu Rust nam poruÄuje:

  #+begin_quote
  Tip povratne vrednosti ove funkcije je pozajmljena vrednost, ali vrednost koja
  je pozajmljena posle povratka viÅ¡e ne postoji.
  #+end_quote

*** Å ta se taÄno desilo

#+begin_src rust
fn dangle() -> &String { // dangle vraÄ‡a referencu na String

    let s = String::from("hello"); // s je novi String

    &s // VraÄ‡amo referencu na String s
} // s izlazi iz opsega i poziva se `drop`. Memorija se oslobaÄ‘a.
  // OPASNOST! VraÄ‡ena referenca Ä‡e biti "viseÄ‡a".
#+end_src

Kako se moÅ¾e reÅ¡iti. VratiÄ‡emo posedovanu (/owned/) vrednost, tj uradiÄ‡emo
premeÅ¡tanje vrednosti u funkciju pozivaoca.

#+begin_src rust
fn no_dangle() -> String {
    let s = String::from("hello");

    s
}
#+end_src

*** Pravila referenciranja

1. U svakom trenutku moÅ¾emo imati ili jednu promenjivu ili proizvoljan broj
   nepromenjivih referenci.
1. Reference uvek moraju biti validne.
** IseÄci (/Slice/ tip)
*** /Slice/
- IseÄci (/slices/) omoguÄ‡avaju referenciranje kontinualne sekvence unutar
  kolekcije umesto cele kolekcije

*** Primer
Funkcija koja za zadati string vraÄ‡a prvu reÄ.

#+begin_src rust
fn first_word(s: &String) -> usize {
    let bytes = s.as_bytes();

    for (i, &item) in bytes.iter().enumerate() {
        if item == b' ' {
            return i;
        }
    }

    s.len()
}
#+end_src

- Dakle, vraÄ‡amo indeks kraja reÄi. Pozivaoc sada ima potrebne informacije da doÄ‘e do traÅ¾ene reÄi.
- Problem: dva podatka koja su u vezi ali moramo tu vezu ruÄno da odrÅ¾avamo jer
  nemamo garanciju da Ä‡e broj koji je vraÄ‡en biti validan i u buduÄ‡nosti (npr.
  string moÅ¾e da se promeni ili da izaÄ‘e iz opsega).

#+REVEAL: split

#+begin_src rust
fn main() {
    let mut s = String::from("hello world");

    let word = first_word(&s); // word Ä‡e dobiti vrednost 5

    s.clear(); // string s postaje ""

    // word je i dalje 5 iako to viÅ¡e nije ispravno
}
#+end_src

#+REVEAL: split

Problem postaje joÅ¡ ozbiljniji ako npr. napiÅ¡emo funkciju =second_word= koja vraÄ‡a
drugu reÄ zadatog stringa. Po analogiji sa prethodnim, trebali bi da vratimo
poÄetak i kraj druge reÄi.

#+begin_src rust
fn second_word(s: &String) -> (usize, usize) {
#+end_src

Sada imamo tri podatka o kojima moramo da vodimo raÄuna.

*** String iseÄak

Problem reÅ¡avamo upotrebom iseÄaka.

#+begin_src rust
let s = String::from("hello world");

let hello = &s[0..5];
let world = &s[6..11];
#+end_src

#+REVEAL_HTML: <div class="column" style="float:left; width: 50%">
Sintaksa =s[x..y]= kreira iseÄak nad sekvencom =s=. S obzirom da ovaj tip (=[T]=) nema
poznatu veliÄinu u vreme kompajliranja, ne moÅ¾emo ga alocirati na steku, odnosno
ne moÅ¾emo ga dodeliti lokalnim varijablama ili prosleÄ‘ivati kao parametar
funkcije. Zato se u praksi koristi referenca na iseÄak (=&[T]=) (Äesto se zove i
/fat pointer/).

Dakle, u praksi mnogo ÄeÅ¡Ä‡e sreÄ‡emo sintaksu =&s[x..y]=.
#+REVEAL_HTML: </div>

#+REVEAL_HTML: <div class="column" style="float:right; width: 50%">
#+attr_html: :style height: 600px;
#+ATTR_ORG: :width 300px
[[./images/slice.png]]
#+REVEAL_HTML: </div>

#+REVEAL_HTML: <div style="clear: both;">
*** IseÄci i sintaksa opsega (/range/)

#+begin_src rust
let s = String::from("hello");

let slice = &s[0..2];
let slice = &s[..2];
#+end_src

#+begin_src rust
let s = String::from("hello");

let len = s.len();

let slice = &s[3..len];
let slice = &s[3..];
#+end_src

#+begin_src rust
let s = String::from("hello");

let len = s.len();

let slice = &s[0..len];
let slice = &s[..];
#+end_src

*** Modifikacija primera da koristi string iseÄke

#+begin_src rust
fn first_word(s: &String) -> &str {
    let bytes = s.as_bytes();

    for (i, &item) in bytes.iter().enumerate() {
        if item == b' ' {
            return &s[0..i];
        }
    }

    &s[..]
}
#+end_src

Isti API i za =second_word=.

#+begin_src rust
fn second_word(s: &String) -> &str {
#+end_src

#+REVEAL: split

Sada nam kompajler osigurava da uvek imamo validnu referencu na reÄ.
#+begin_src rust
fn main() {
    let mut s = String::from("hello world");

    let word = first_word(&s);

    s.clear(); // GREÅ KA!

    println!("the first word is: {}", word);
}
#+end_src

#+begin_example
$ cargo run
   Compiling ownership v0.1.0 (file:///projects/ownership)
error[E0502]: cannot borrow `s` as mutable because it is also borrowed as immutable
  --> src/main.rs:18:5
   |
16 |     let word = first_word(&s);
   |                           -- immutable borrow occurs here
17 |
18 |     s.clear(); // error!
   |     ^^^^^^^^^ mutable borrow occurs here
19 |
20 |     println!("the first word is: {}", word);
   |                                       ---- immutable borrow later used here

For more information about this error, try `rustc --explain E0502`.
error: could not compile `ownership` due to previous error
#+end_example

Ne samo da je API lakÅ¡i za upotrebu veÄ‡ je Äitava klasa greÅ¡aka koje se teÅ¡ko
otkrivaju eliminisana u vreme kompajliranja.

*** String literali su reference na iseÄke

#+begin_src rust
let s = "Hello, world!";
#+end_src

Tip od =s= je =&str=. =str= je string iseÄak.

*** String iseÄci kao parametri funkcija

#+begin_src rust
fn first_word(s: &String) -> &str {
#+end_src

Ali Ä‡e iskusni Rust programeri pisati:

#+begin_src rust
fn first_word(s: &str) -> &str {
#+end_src

Jer Ä‡e ova funkcija moÄ‡i da se koristi i za =&str= i za =&String=. Ovde se
upotrebljava tzv. /Deref Coercion/ odnosno moguÄ‡nosti tipova da se dereferenciraju
u drugi tip. Npr. =&String= Ä‡e se automatski dereferencirati u =&str= ukoliko je to
potrebno. Operacija je efikasna.

#+REVEAL: split

#+begin_src rust
fn main() {
    let my_string = String::from("hello world");

    // `first_word` works on slices of `String`s, whether partial or whole
    let word = first_word(&my_string[0..6]);
    let word = first_word(&my_string[..]);
    // `first_word` also works on references to `String`s, which are equivalent
    // to whole slices of `String`s
    let word = first_word(&my_string);

    let my_string_literal = "hello world";

    // `first_word` works on slices of string literals, whether partial or whole
    let word = first_word(&my_string_literal[0..6]);
    let word = first_word(&my_string_literal[..]);

    // Because string literals *are* string slices already,
    // this works too, without the slice syntax!
    let word = first_word(my_string_literal);
}
#+end_src

*** Upotreba iseÄaka nad drugim strukturama

#+begin_src rust
let a = [1, 2, 3, 4, 5];

let slice = &a[1..3]; // referenca na iseÄak tipa &[i32]

assert_eq!(slice, &[2, 3]);
#+end_src

* Strukture
* Enumeracije i podudaranje obrazaca (/Pattern Matching/)
** /Enum/ tip
*** /Enum/ tip
- Definisanje tipa navoÄ‘enjem svih moguÄ‡ih varijanti
- Varijanta moÅ¾e da sadrÅ¾i dodatne podatke
- SliÄno sa algebarskim tipovima podataka (/algebraic data types/) u funkcionalnim
  jezicima, npr. F#, OCaml i Haskell-u. Ova vrsta algebarskog tipa je poznata i
  pod nazivom /sum type/.

*** Primer - IP adresa
- IP adresa predstavlja identifikaciju mreÅ¾nih interfejsa u ureÄ‘ajima koji
  komuniciraju posredstvom Internet protokola (/Internet Protocol - IP/).
- Trenutno imamo u upotrebi staru verziju 4 i novu verziju 6 koja Ä‡e vremenom
  zameniti verziju 4.
- Verzija 4 je duÅ¾ine 32 bita i navodi se kao Äetiri okteta u obliku npr.
  =192.0.2.1=
- Verzija 6 je duÅ¾ine 128 bita i navodi se kao 8 grupa od po 4 heksa cifre
  razdvojene sa =:=, npr. =2001:db8:0:1234:0:567:8:1=

#+REVEAL: split

U Rust-u moÅ¾emo pisati sledeÄ‡e:

#+begin_src rust
enum IpAddrKind {
    V4,
    V6,
}
#+end_src

Dok vrednosti moÅ¾emo kreirati sa:
#+begin_src rust
let four = IpAddrKind::V4;
let six = IpAddrKind::V6;
#+end_src

*** Primer - IP adresa - funkcija

Sada moÅ¾emo pisati funkciju koja prima ovaj tip Äime je moguÄ‡e proslediti bilo
koju varijantu kao argument.

#+begin_src rust
fn route(ip_kind: IpAddrKind) {}

...

route(IpAddrKind::V4);
route(IpAddrKind::V6);
#+end_src

*** Primer - IP adresa - vrednost

- Ali kako da definiÅ¡emo konkretnu vrednost IP adrese?
- Prva ideja bi mogla biti da koristimo strukturu.

#+begin_src rust
enum IpAddrKind {
    V4,
    V6,
}

struct IpAddr {
    kind: IpAddrKind,
    address: String,
}

let home = IpAddr {
    kind: IpAddrKind::V4,
    address: String::from("127.0.0.1"),
};

let loopback = IpAddr {
    kind: IpAddrKind::V6,
    address: String::from("::1"),
};
#+end_src

#+REVEAL: split

Ali, sa =enum= tipom moÅ¾emo to uraditi i bolje. =Enum= varijante mogu sadrÅ¾ati
dodatne podatke.

#+begin_src rust
enum IpAddr {
    V4(String),
    V6(String),
}

let home = IpAddr::V4(String::from("127.0.0.1"));

let loopback = IpAddr::V6(String::from("::1"));
#+end_src

#+REVEAL: split
Vrednost sadrÅ¾ana u varijanti ne mora biti ista za sve varijante. Na primer,
IPv4 se sastoji od 4 okteta i moÅ¾da Å¾elimo da vrednost navodimo i Äuvamo u tom
obliku.

#+begin_src rust
enum IpAddr {
    V4(u8, u8, u8, u8),
    V6(String),
}

let home = IpAddr::V4(127, 0, 0, 1);

let loopback = IpAddr::V6(String::from("::1"));
#+end_src

*** Primer - IP adresa - std biblioteka

U standardnoj biblioteci moÅ¾emo pronaÄ‡i tip =IpAddr=. Definisan je na sledeÄ‡i
naÄin.

#+begin_src rust
struct Ipv4Addr {
    // --snip--
}

struct Ipv6Addr {
    // --snip--
}

enum IpAddr {
    V4(Ipv4Addr),
    V6(Ipv6Addr),
}
#+end_src

*** Primer  - /Message/

#+begin_src rust
enum Message {
    Quit,
    Move { x: i32, y: i32 },
    Write(String),
    ChangeColor(i32, i32, i32),
}
#+end_src

#+REVEAL: split
SledeÄ‡e strukture sadrÅ¾e iste podatke kao prethodni =enum= tip.

#+begin_src rust
struct QuitMessage; // unit struct
struct MoveMessage {
    x: i32,
    y: i32,
}
struct WriteMessage(String); // tuple struct
struct ChangeColorMessage(i32, i32, i32); // tuple struct
#+end_src

Ali, prednost =enum= tipa je Å¡to je to jedinstven tip pa moÅ¾emo npr. napraviti
funkciju koja prima bilo koju vrednost/varijantu ovog tipa.

#+REVEAL: split
Nad =enum= tipom, kao i drugim tipovima, moÅ¾emo implementirati metode upotrebom
=imlp= kljuÄne reÄi.

#+begin_src rust
impl Message {
    fn call(&self) {
        // telo metode se ovde definiÅ¡e
    }
}

let m = Message::Write(String::from("hello"));
m.call();
#+end_src

** =Option= enumeracija
*** =Option= enumeracija

- ÄŒest sluÄaj da vrednost moÅ¾e biti neÅ¡to ili niÅ¡ta.
- Npr. ako funkcija vraÄ‡a prvi element iz liste koja nije prazna dobiÄ‡emo prvi
  element, meÄ‘utim ako je lista prazna povratna vrednost je niÅ¡ta.
- Ovaj koncept se u razliÄitim jezicima razliÄito implementira. ÄŒesto se koristi
  specijalna vrednost =null= (ili =nil=, =none= i sl.) i sve varijable mogu biti =null=
  ili =non-null=. Problem je Å¡to programer ne definiÅ¡e moguÄ‡nost ove vrednosti
  kroz tip pa samim tim kompajler nema moguÄ‡nost da proveri da li kod ispravno
  obraÄ‘uje ovu moguÄ‡nost.

#+REVEAL: split

U prezentaciji iz 2009 godine pod nazivom /Null References: The Billion Dollar
Mistake/ Tony Hoare, koji je prvi uveo =null= vrednost kao koncept je napisao
sledeÄ‡e:

#+begin_quote
I call it my billion-dollar mistake. At that time, I was designing the first
comprehensive type system for references in an object-oriented language. My goal
was to ensure that all use of references should be absolutely safe, with
checking performed automatically by the compiler. But I couldnâ€™t resist the
temptation to put in a null reference, simply because it was so easy to
implement. This has led to innumerable errors, vulnerabilities, and system
crashes, which have probably caused a billion dollars of pain and damage in the
last forty years.
#+end_quote

#+REVEAL: split

=Option= je generiÄki =enum= tip u Rust-u.
#+begin_src rust
enum Option<T> {
    None,
    Some(T),
}
#+end_src

Primeri upotrebe:
#+begin_src rust
let some_number = Some(5);           // tip je Option<i32>
let some_string = Some("a string");  // tip je Option<&str>

let absent_number: Option<i32> = None;    // nemoguÄ‡ inference
#+end_src

*** ZaÅ¡to je =Option<T>= bolji od =null=?

#+begin_src rust
let x: i8 = 5;
let y: Option<i8> = Some(5);

let sum = x + y;
#+end_src

#+begin_example
$ cargo run
   Compiling enums v0.1.0 (file:///projects/enums)
error[E0277]: cannot add `Option<i8>` to `i8`
 --> src/main.rs:5:17
  |
5 |     let sum = x + y;
  |                 ^ no implementation for `i8 + Option<i8>`
  |
  = help: the trait `Add<Option<i8>>` is not implemented for `i8`

For more information about this error, try `rustc --explain E0277`.
error: could not compile `enums` due to previous error
#+end_example

*** Kako obraÄ‘ivati =Option<T>= podatke?

- Moramo eksplicitno obraditi vrednost =Option<T>= i moguÄ‡nost da vrednost bude
  =None=.
- =Option<T>= tip ima [[https://doc.rust-lang.org/stable/std/option/enum.Option.html][bogat API]] koji je potrebno znati jer je ovaj tip vrlo Äesto
  u upotrebi.

#+begin_src rust
let x = Some(2);
let y = None;
assert_eq!(x.or(y), Some(2));

let x = None;
let y = Some(100);
assert_eq!(x.or(y), Some(100));
#+end_src

- ÄŒesto koristimo jeziÄke konstrukcije koje omoguÄ‡avaju obradu obe varijante.

** =match= konstrukcija za kontrolu toka
*** =match= izraz
- MoÄ‡an izraz kontrole toka baziran na podudaranju obrazaca (/Pattern Matching/).
- Obrazac moÅ¾e biti literal, naziv varijable, dÅ¾oker (/wildcards/) itd.
- =match= izraz Ä‡e izvrÅ¡iti podudaranje uz iscrpljivanje svih moguÄ‡nost. Ukoliko
  neka moguÄ‡nost nije obraÄ‘ena kompajler Ä‡e prijaviti greÅ¡ku.

*** =match= kao maÅ¡ina za sortiranje novÄiÄ‡a
Za poÄetak moÅ¾emo =match= izraz posmatrati kao automat za sortiranje novÄiÄ‡a.

#+begin_src rust
enum Coin {
    Penny,
    Nickel,
    Dime,
    Quarter,
}

fn value_in_cents(coin: Coin) -> u8 {
    match coin {
        Coin::Penny => 1,
        Coin::Nickel => 5,
        Coin::Dime => 10,
        Coin::Quarter => 25,
    }
}
#+end_src

- =match= poÄinje sa izrazom proizvoljnog tipa.
- U telu se nalaze "ruke" (/arms/) gde svaka ruka ima levu stranu koja predstavlja
  obrazac za podudaranje i desnu stranu (posle ~=>~) koja predstavlja kod koji se
  evaluira u sluÄaju podudaranja. Ruke su razdvojene zarezima.
- Ruke se podudaraju u redosledu navoÄ‘enja.
- Povratna vrednost celog =match= izraza biÄ‡e vrednost evaluiranog koda ruke Äije
  je podudaranje uspelo

#+REVEAL: split

MoÅ¾emo na desnoj strani koristiti proizvoljan izraz pa i blok koda.
#+begin_src rust
fn value_in_cents(coin: Coin) -> u8 {
    match coin {
        Coin::Penny => {
            println!("Lucky penny!");
            1
        }
        Coin::Nickel => 5,
        Coin::Dime => 10,
        Coin::Quarter => 25,
    }
}
#+end_src

*** Povezivanje imena pri podudaranju (/binding/)

#+begin_src rust
#[derive(Debug)]
enum UsState {
    Alabama,
    Alaska,
    Arizona,
    // --snip--
}

enum Coin {
    Penny,
    Nickel,
    Dime,
    Quarter(UsState),
}

fn value_in_cents(coin: Coin) -> u8 {
    match coin {
        Coin::Penny => 1,
        Coin::Nickel => 5,
        Coin::Dime => 10,
        Coin::Quarter(state) => {
            println!("State quarter from {:?}!", state);
            25
        }
    }
}
#+end_src

*** =match= je iscrpan

#+begin_src rust
fn value_in_cents(coin: Coin) -> u8 {
    match coin {
        Coin::Penny => 1,
        Coin::Nickel => 5,
        Coin::Dime => 10,
        Coin::Quarter(UsState::Alabama) | Coin::Quarter(UsState::Alaska) => 25
    }
}
#+end_src

#+begin_example
$ cargo run
   Compiling match_test v0.1.0 (/home/igor/NTP/match_test)
error[E0004]: non-exhaustive patterns: `Quarter(Arizona)` not covered
  --> src/main.rs:21:11
   |
13 | / enum Coin {
14 | |     Penny,
15 | |     Nickel,
16 | |     Dime,
17 | |     Quarter(UsState),
   | |     ------- not covered
18 | | }
   | |_- `Coin` defined here
...
21 |       match coin {
   |             ^^^^ pattern `Quarter(Arizona)` not covered
   |
   = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms
   = note: the matched value is of type `Coin`
#+end_example

*** Podudaranje sa =Option<T>= tipom

#+begin_src rust
fn plus_one(x: Option<i32>) -> Option<i32> {
    match x {
        None => None,
        Some(i) => Some(i + 1),
    }
}

let five = Some(5);
let six = plus_one(five);
let none = plus_one(None);
#+end_src

#+REVEAL: split

PoÅ¡to je =match= iscrpan ne moÅ¾emo zaboraviti da obradimo =None= sluÄaj.

#+begin_src rust
fn plus_one(x: Option<i32>) -> Option<i32> {
    match x {
        Some(i) => Some(i + 1),
    }
}
#+end_src

#+begin_example
$ cargo run
   Compiling enums v0.1.0 (file:///projects/enums)
error[E0004]: non-exhaustive patterns: `None` not covered
   --> src/main.rs:3:15
    |
3   |         match x {
    |               ^ pattern `None` not covered
    |
    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms
    = note: the matched value is of type `Option<i32>`

For more information about this error, try `rustc --explain E0004`.
error: could not compile `enums` due to previous error
#+end_example

*** Podrazumevana obrada preostalih sluÄajeva

- Å½elimo na specifiÄan naÄin obradimo samo nekoliko sluÄajeva dok za sve ostale
  radimo podrazumevanu obradu.

#+begin_src rust
let dice_roll = 9;
match dice_roll {
    3 => add_fancy_hat(),
    7 => remove_fancy_hat(),
    other => move_player(other),
}

fn add_fancy_hat() {}
fn remove_fancy_hat() {}
fn move_player(num_spaces: u8) {}
#+end_src

- Rust Ä‡e nas upozoriti ako dodamo ruku posle one koja obraÄ‘uje sve sluÄajeve
  jer ta se ruka nikada neÄ‡e upotrebiti.

#+REVEAL: split

Ako Å¾elimo da obradimo sve sluÄajeve ali nas vrednost ne interesuje moÅ¾emo
koristiti =_=.

#+begin_src rust
let dice_roll = 9;
match dice_roll {
    3 => add_fancy_hat(),
    7 => remove_fancy_hat(),
    _ => reroll(),
}

fn add_fancy_hat() {}
fn remove_fancy_hat() {}
fn reroll() {}
#+end_src
** =if let= kontrola toka

=if let= nam omoguÄ‡ava kombinaciju =if= i =let= iskaze u manje opÅ¡iran iskaz za obradu
samo jednog sluÄaja poklapanja i ignorisanje ostalih.

#+begin_src rust
let config_max = Some(3u8);
match config_max {
    Some(max) => println!("The maximum is configured to be {}", max),
    _ => (),
}
#+end_src

Ovo moÅ¾emo konciznije iskazati sa:

#+begin_src rust
let config_max = Some(3u8);
if let Some(max) = config_max {
    println!("The maximum is configured to be {}", max);
}
#+end_src

- Gubimo iscrpnost =match= izraza.
- Sintaksni Å¡eÄ‡er u situacijama kada Å¾elimo da ignoriÅ¡emo ostale moguÄ‡nosti.

#+REVEAL: split

#+begin_note
Obrasci za podudaranje [[https://doc.rust-lang.org/book/ch18-02-refutability.html][mogu imati dve forme]]: poniÅ¡tiv (/refutable/) i neponiÅ¡tiv
(/irrefutable/). Obrazac koji uvek mora uspeti (npr. =let x = 5;=) je neponiÅ¡tiv.
Obrazac koji ne mora da uspe uvek je poniÅ¡tiv (npr. =if let Some(x) = a_value=
neÄ‡e uspeti za ~a_value==None~).

Parametri funkcija, =let= iskazi i =for= petlje prihvataju samo neponiÅ¡tive obrasce
jer program ne moÅ¾e uraditi niÅ¡ta smisleno ukoliko podudaranje ne uspe.

=if let= i =while let= prihvataju i poniÅ¡tive i neponiÅ¡tive obrasce ali Ä‡e nas
kompajler upozoriti ukoliko koristimo neponiÅ¡tive.
#+end_note

#+REVEAL: split
MoÅ¾emo koristiti i =else= granu. SledeÄ‡e je ekvivalentno.

#+begin_src rust
let mut count = 0;
match coin {
    Coin::Quarter(state) => println!("State quarter from {:?}!", state),
    _ => count += 1,
}
#+end_src

#+begin_src rust
let mut count = 0;
if let Coin::Quarter(state) = coin {
    println!("State quarter from {:?}!", state);
} else {
    count += 1;
}
#+end_src

* Moduli
* Kolekcije
* Obrada greÅ¡aka
* GeneriÄki tipovi, osobine (/Traits/) i Å¾ivotni vek (/Lifetimes/)
** GeneriÄki tipovi (/generics/)
*** GeneriÄki tipovi (/generics/)
- Mehanizam za eliminaciju dupliranja koda.
- GeneriÄki tipovi su apstraktne zamene za konkretne tipove u druge osobine u
  vreme izvrÅ¡avanja.
- OmoguÄ‡avaju nam da na apstraktan naÄin iskaÅ¾emo osobine tipova i njihove veze
  sa drugim tipovima bez znanja o tome koji Ä‡e se konkretni tipovi naÄ‡i na
  njihovom mestu u vreme kompajliranja i izvrÅ¡avanja koda.
- Na primer funkcije mogu primiti generiÄke parametre. TakoÄ‘e, sloÅ¾eni tipovi
  mogu biti parametrizovani generiÄkim tipovima (primer je =Option<T>=).

*** Uklanjanje duplog koda upotrebom funkcija

#+begin_src rust
fn main() {
    let number_list = vec![34, 50, 25, 100, 65];

    let mut largest = number_list[0];

    for number in number_list {
        if number > largest {
            largest = number;
        }
    }

    println!("The largest number is {}", largest);
}
#+end_src

#+REVEAL: split

#+begin_src rust
fn main() {
    let number_list = vec![34, 50, 25, 100, 65];

    let mut largest = number_list[0];

    for number in number_list {
        if number > largest {
            largest = number;
        }
    }

    println!("The largest number is {}", largest);

    let number_list = vec![102, 34, 6000, 89, 54, 2, 43, 8];

    let mut largest = number_list[0];

    for number in number_list {
        if number > largest {
            largest = number;
        }
    }

    println!("The largest number is {}", largest);
}
#+end_src

#+REVEAL: split

#+begin_src rust
fn largest(list: &[i32]) -> i32 {
    let mut largest = list[0];

    for &item in list {
        if item > largest {
            largest = item;
        }
    }

    largest
}

fn main() {
    let number_list = vec![34, 50, 25, 100, 65];

    let result = largest(&number_list);
    println!("The largest number is {}", result);

    let number_list = vec![102, 34, 6000, 89, 54, 2, 43, 8];

    let result = largest(&number_list);
    println!("The largest number is {}", result);
}
#+end_src


#+REVEAL: split

Postupak eliminacije duplog koda je podrazumevao sledeÄ‡e:

1. Identifikacija duplog koda.
2. Ekstrakcija koda u funkciju, definisanje parametara i povratne vrednosti.
3. Zamena instanci duplog koda sa pozivom funkcije.

*** Uklanjanje duplog koda upotrebom generiÄkih funkcija

Imamo funkciju za pronalaÅ¾enje najveÄ‡eg elementa u listi sa razliÄitim tipovima.
#+begin_src rust
fn largest_i32(list: &[i32]) -> i32 {
    let mut largest = list[0];
    for &item in list {
        if item > largest {
            largest = item;
        }
    }
    largest
}

fn largest_char(list: &[char]) -> char {
    let mut largest = list[0];
    for &item in list {
        if item > largest {
            largest = item;
        }
    }
    largest
}

fn main() {
    let number_list = vec![34, 50, 25, 100, 65];
    let result = largest_i32(&number_list);
    println!("The largest number is {}", result);
    let char_list = vec!['y', 'm', 'a', 'q'];
    let result = largest_char(&char_list);
    println!("The largest char is {}", result);
}
#+end_src

#+REVEAL: split

Funkcije su gotovo identiÄne. Razlika je samo u tipu. PiÅ¡emo generiÄku funkciju
tako Å¡to definiÅ¡emo generiÄki tip unutar =<>= posle naziva funkcije:

#+begin_src rust
fn largest<T>(list: &[T]) -> T {
#+end_src

=T= je generiÄki tip i u vreme kompajliranja biÄ‡e zamenjen sa konkretnim tipom.

#+REVEAL: split

Sada je naÅ¡ kod sledeÄ‡i:

#+begin_src rust
fn largest<T>(list: &[T]) -> T {
    let mut largest = list[0];

    for &item in list {
        if item > largest {
            largest = item;
        }
    }

    largest
}

fn main() {
    let number_list = vec![34, 50, 25, 100, 65];

    let result = largest(&number_list);
    println!("The largest number is {}", result);

    let char_list = vec!['y', 'm', 'a', 'q'];

    let result = largest(&char_list);
    println!("The largest char is {}", result);
}
#+end_src

#+REVEAL: split

Ali se ne kompajlira.

#+begin_src rust
$ cargo run
   Compiling chapter10 v0.1.0 (file:///projects/chapter10)
error[E0369]: binary operation `>` cannot be applied to type `T`
 --> src/main.rs:5:17
  |
5 |         if item > largest {
  |            ---- ^ ------- T
  |            |
  |            T
  |
help: consider restricting type parameter `T`
  |
1 | fn largest<T: std::cmp::PartialOrd>(list: &[T]) -> T {
  |             ++++++++++++++++++++++

For more information about this error, try `rustc --explain E0369`.
error: could not compile `chapter10` due to previous error
#+end_src

Tip =T= moÅ¾e biti bilo koji tip pa i tip koji ne definiÅ¡e operaciju =>= koja se
koristi u kodu. Dakle, moramo ograniÄiti koji tipovi su moguÄ‡i.

VideÄ‡emo kako se ovo radi u nastavku u priÄi o osobinama (/Traits/).

*** GeneriÄki tipovi u strukturama

#+begin_src rust
struct Point<T> {
    x: T,
    y: T,
}

fn main() {
    let integer = Point { x: 5, y: 10 };
    let float = Point { x: 1.0, y: 4.0 };
}
#+end_src

#+REVEAL: split

Tipovi oba polja moraju biti isti.

#+begin_src rust
struct Point<T> {
    x: T,
    y: T,
}

fn main() {
    let wont_work = Point { x: 5, y: 4.0 };
}
#+end_src

#+begin_example
$ cargo run
   Compiling chapter10 v0.1.0 (file:///projects/chapter10)
error[E0308]: mismatched types
 --> src/main.rs:7:38
  |
7 |     let wont_work = Point { x: 5, y: 4.0 };
  |                                      ^^^ expected integer, found floating-point number

For more information about this error, try `rustc --explain E0308`.
error: could not compile `chapter10` due to previous error
#+end_example

#+REVEAL: split

Ako Å¾elimo da polja imaju razliÄite tipove onda moramo imati razliÄite generiÄke tipove.

#+begin_src rust
struct Point<T, U> {
    x: T,
    y: U,
}

fn main() {
    let both_integer = Point { x: 5, y: 10 };
    let both_float = Point { x: 1.0, y: 4.0 };
    let integer_and_float = Point { x: 5, y: 4.0 };
}
#+end_src

*** GeneriÄki tipovi u enumeracijama

#+begin_src rust
enum Option<T> {
    Some(T),
    None,
}
#+end_src

#+REVEAL: split

#+begin_src rust
enum Result<T, E> {
    Ok(T),
    Err(E),
}
#+end_src

*** Definicije metoda

#+begin_src rust
struct Point<T> {
    x: T,
    y: T,
}

impl<T> Point<T> {
    fn x(&self) -> &T {
        &self.x
    }
}

fn main() {
    let p = Point { x: 5, y: 10 };

    println!("p.x = {}", p.x());
}
#+end_src

PoÅ¡to smo naveli =<T>= iza kljuÄne reÄi =impl= Rust dalje zna da je tip =T= generiÄki
a ne konkretni tip tako da je metoda =x= za =Point<T>= definisana nad svim tipovima
=T=.

#+REVEAL: split

Mogli smo npr. metodu definisati samo za odreÄ‘eni =Point= tip.

#+begin_src rust
impl Point<f32> {
    fn distance_from_origin(&self) -> f32 {
        (self.x.powi(2) + self.y.powi(2)).sqrt()
    }
}
#+end_src

Ovaj =impl= blok definiÅ¡e metodu =distance_from_origin= ali samo za =Point<f32>= dok
ostali =Point= tipovi neÄ‡e imati ovu metodu.

*** GeneriÄki tipovi u metodama i =impl= blokovima

GeneriÄki tipovi u strukturama i metodama ne moraju biti isti. Na primer, moÅ¾emo
kreirati metodu =mixup= koja uzima dve instance =Point= i vraÄ‡a novi =Point= tip gde
Ä‡e prvo polje imati isti tip kao prva taÄka a drugo polje kao druga taÄka.

#+begin_src rust
struct Point<X1, Y1> {
    x: X1,
    y: Y1,
}

impl<X1, Y1> Point<X1, Y1> {
    fn mixup<X2, Y2>(self, other: Point<X2, Y2>) -> Point<X1, Y2> {
        Point {
            x: self.x,
            y: other.y,
        }
    }
}

fn main() {
    let p1 = Point { x: 5, y: 10.4 };
    let p2 = Point { x: "Hello", y: 'c' };
    let p3 = p1.mixup(p2);
    println!("p3.x = {}, p3.y = {}", p3.x, p3.y);
}
#+end_src

- GeneriÄki tipovi =X2= i =Y2= su navedeni samo u metodi jer su relevantni samo u
  njenom kontekstu.

*** Performanse

Upotreba generiÄkog koda ne dovodi do degradacije performansi. Rust koristi
tehniku monomorfizacije (/Monomorphization/) kod koje Ä‡e kompajler instancirati
konkretan kod za svaki tip posebno.

To bi znaÄilo sledeÄ‡e. Ako imamo kod:

#+begin_src rust
let integer = Some(5);
let float = Some(5.0)
#+end_src

Kompajler Ä‡e proizvesti kod ekvivalentan sledeÄ‡em:
#+begin_src rust
enum Option_i32 {
    Some(i32),
    None,
}

enum Option_f64 {
    Some(f64),
    None,
}

fn main() {
    let integer = Option_i32::Some(5);
    let float = Option_f64::Some(5.0);
}
#+end_src
** Osobine (/Traits/) - definisanje zajedniÄkog ponaÅ¡anja
*** /Traits/
- /Trait/ definiÅ¡e funkcionalnost koju tip moÅ¾e deliti sa drugim tipovima.
- U drugim jezicima sliÄan koncept naziva se interfejs.
- MoÅ¾emo koristiti /ograniÄenja kroz osobine/ (/Trait bounds/) da definiÅ¡emo da
  generiÄki tip mora zadovoljiti odreÄ‘ena ograniÄenja.

*** Definisanje osobina

- Primer definisanja media agregator biblioteke koja moÅ¾e da prikaze saÅ¾etak
  podataka koji se moÅ¾e Äuvati u =NewsArticle= ili =Tweet= instanci.
- DefiniÅ¡emo =Summary= osobinu da opiÅ¡emo ovu funkcionalnost.

#+begin_src rust
pub trait Summary {
    fn summarize(&self) -> String;
}
#+end_src

*** Implementacija osobina

#+begin_src rust
pub struct NewsArticle {
    pub headline: String,
    pub location: String,
    pub author: String,
    pub content: String,
}

impl Summary for NewsArticle {
    fn summarize(&self) -> String {
        format!("{}, by {} ({})", self.headline, self.author, self.location)
    }
}

pub struct Tweet {
    pub username: String,
    pub content: String,
    pub reply: bool,
    pub retweet: bool,
}

impl Summary for Tweet {
    fn summarize(&self) -> String {
        format!("{}: {}", self.username, self.content)
    }
}
#+end_src

#+REVEAL: split

Metode osobina se pozivaju kao i obiÄne metode. Jedina razlika je u tome Å¡to
metode osobina moraju biti dostupne u opsegu (ukljuÄiti ih sa =use=).

#+begin_src rust
use aggregator::{Summary, Tweet};

fn main() {
    let tweet = Tweet {
        username: String::from("horse_ebooks"),
        content: String::from(
            "of course, as you probably already know, people",
        ),
        reply: false,
        retweet: false,
    };

    println!("1 new tweet: {}", tweet.summarize());
}
#+end_src

#+REVEAL: split

#+begin_note
OgraniÄenje u upotrebi osobina je da moÅ¾emo implementirati osobinu nad tipom
jedino ako je bar jedno od njih lokalno za naÅ¡ sanduk. Ovo pravilo je deo skupa
pravila koji se nazivaju /coherence/. Konkretno ovo pravilo zove se /orphan rule/ i
spreÄava nekompatibilne implementacije osobina nad tipovima od strane viÅ¡e
sanduka.

Bez ovog pravila moglo bi se desiti da dva razliÄita sanduka implementiraju istu
osobinu nad istim tipom na razliÄite naÄine i kompajler ne bi znao koju verziju
da koristi.
#+end_note
*** Podrazumevana implementacija

Osobina moÅ¾e imati podrazumevanu implementaciju metoda.

#+begin_src rust
pub trait Summary {
    fn summarize(&self) -> String {
        String::from("(Read more...)")
    }
}
#+end_src

Da bi koristili podrazumevanu implementaciju moÅ¾emo navesti prazno telo u =impl=
bloku:

#+begin_src rust
impl Summary for NewsArticle {}
#+end_src

#+REVEAL: split

I zatim moÅ¾emo pozvati =summarize= metodu:

#+begin_src rust
let article = NewsArticle {
        headline: String::from("Penguins win the Stanley Cup Championship!"),
        location: String::from("Pittsburgh, PA, USA"),
        author: String::from("Iceburgh"),
        content: String::from(
            "The Pittsburgh Penguins once again are the best \
             hockey team in the NHL.",
        ),
    };

    println!("New article available! {}", article.summarize());
#+end_src

#+REVEAL: split

- Podrazumevana implementacija moÅ¾e biti redefinisana prilikom implementacije.
- TakoÄ‘e, podrazumevane metode mogu pozivati druge metode.

#+begin_src rust
pub trait Summary {
    fn summarize_author(&self) -> String;

    fn summarize(&self) -> String {
        format!("(Read more from {}...)", self.summarize_author())
    }
}
#+end_src

Sada je potrebno i dovoljno da prilikom implementacije definiÅ¡emo
=summarize_author= metodu:

#+begin_src rust
impl Summary for Tweet {
    fn summarize_author(&self) -> String {
        format!("@{}", self.username)
    }
}
#+end_src
*** Osobine kao parametri

- Sada moÅ¾emo koristiti osobine da definiÅ¡emo funkcije koje rade nad parametrima
  razliÄitog tipa.

#+begin_src rust
pub fn notify(item: &impl Summary) {
    println!("Breaking news! {}", item.summarize());
}
#+end_src

Sada funkcija =notify= radi nad svim tipovima koji implementiraju =Summary=

#+REVEAL: split

Prethodna upotreba =impl= kod parametra je sintaksni Å¡eÄ‡er za opÅ¡ti oblik
navoÄ‘enja ograniÄenja kroz osobine.

#+begin_src rust
pub fn notify<T: Summary>(item: &T) {
    println!("Breaking news! {}", item.summarize());
}
#+end_src

OgraniÄenja kroz osobine (/Trait bounds/) stavljamo posle dvotaÄke kod navoÄ‘enja
generiÄkog tipa. Kompajler Ä‡e verifikovati da sve Å¡to koristimo nad vrednostima
ovog tipa unutar funkcije je zaista definisano osobinama navedenim u zaglavlju.

#+REVEAL: split

=impl Trait= sintakse je konciznija kod jednostavnih primera ali je puna sintaksa
bolja kod sloÅ¾enijih primera.

Na primer:

#+begin_src rust
pub fn notify(item1: &impl Summary, item2: &impl Summary) {
#+end_src

bi u punoj sintaksi bilo:

#+begin_src rust
pub fn notify<T: Summary>(item1: &T, item2: &T) {
#+end_src

*** ViÅ¡estruke osobine kod ograniÄenja

MoÅ¾emo definisati i viÅ¡e ograniÄenja upotrebom =+= sintakse. Na primer, ako
parametar mora da implementira =Summary= i =Display=:
#+begin_src rust
pub fn notify(item: &(impl Summary + Display)) {
#+end_src

ili u punoj sintaksi:

#+begin_src rust
pub fn notify<T: Summary + Display>(item: &T) {
#+end_src

*** =where= klauzula u ograniÄenjima

- Ukoliko imamo viÅ¡e ograniÄenja osnovna sintaksa moÅ¾e da smanji Äitkost.

#+begin_src rust
fn some_function<T: Display + Clone, U: Clone + Debug>(t: &T, u: &U) -> i32 {
#+end_src

- =where= klauzula izmeÅ¡ta definisanje ograniÄenja posle zaglavlja funkcije Äime
  se postiÅ¾e bolja Äitkost:

#+begin_src rust
fn some_function<T, U>(t: &T, u: &U) -> i32
    where T: Display + Clone,
          U: Clone + Debug
{
#+end_src

*** =impl Trait= kao povratna vrednost funkcije
#+begin_src rust
fn returns_summarizable() -> impl Summary {
    Tweet {
        username: String::from("horse_ebooks"),
        content: String::from(
            "of course, as you probably already know, people",
        ),
        reply: false,
        retweet: false,
    }
}
#+end_src

Posebno znaÄajno u kontekstu zatvorenja (/closures/) i iteratora gde je konkretan
tip previÅ¡e sloÅ¾en za pisanje ili je poznat samo kompajleru.

#+begin_note
=impl Trait= sintaksa za povratne vrednosti je moguÄ‡a samo ako funkcija vraÄ‡a
jedan tip koji implementira datu osobinu. Na primer, ova funkcija neÄ‡e raditi
ako funkcija moÅ¾e vratiti =NewsArticle= ili =Tweet=.
#+end_note

*** Popravka =largest= generiÄke funkcije

Na prethodnim sladovima imali smo funkciju =largest=. Sada moÅ¾emo da zavrÅ¡imo
njenu definiciju.

GreÅ¡ka je bila sledeÄ‡a:
#+begin_example
$ cargo run
   Compiling chapter10 v0.1.0 (file:///projects/chapter10)
error[E0369]: binary operation `>` cannot be applied to type `T`
 --> src/main.rs:5:17
  |
5 |         if item > largest {
  |            ---- ^ ------- T
  |            |
  |            T
  |
help: consider restricting type parameter `T`
  |
1 | fn largest<T: std::cmp::PartialOrd>(list: &[T]) -> T {
  |             ++++++++++++++++++++++

For more information about this error, try `rustc --explain E0369`.
error: could not compile `chapter10` due to previous error
#+end_example

#+REVEAL: split

Dakle, moramo ograniÄiti tipove na one koji podrÅ¾avaju poreÄ‘nje. Ova osobina se
u standardnoj biblioteci zove =std::cmp::PartialOrd=, pa Ä‡emo prepraviti zaglavlje
funkcije na sledeÄ‡i naÄin:

#+begin_src rust
fn largest<T: PartialOrd>(list: &[T]) -> T {
#+end_src

#+REVEAL: split

MeÄ‘utim, sada imamo joÅ¡ jednu greÅ¡ku:
#+begin_example
$ cargo run
   Compiling chapter10 v0.1.0 (file:///projects/chapter10)
error[E0508]: cannot move out of type `[T]`, a non-copy slice
 --> src/main.rs:2:23
  |
2 |     let mut largest = list[0];
  |                       ^^^^^^^
  |                       |
  |                       cannot move out of here
  |                       move occurs because `list[_]` has type `T`, which does not implement the `Copy` trait
  |                       help: consider borrowing here: `&list[0]`

error[E0507]: cannot move out of a shared reference
 --> src/main.rs:4:18
  |
4 |     for &item in list {
  |         -----    ^^^^
  |         ||
  |         |data moved here
  |         |move occurs because `item` has type `T`, which does not implement the `Copy` trait
  |         help: consider removing the `&`: `item`

Some errors have detailed explanations: E0507, E0508.
For more information about an error, try `rustc --explain E0507`.
error: could not compile `chapter10` due to 2 previous errors
#+end_example

#+REVEAL: split

Uvodimo dodatno ograniÄenje da generiÄki tip mora biti i =Copy=. Tako da je puno
reÅ¡enje sledeÄ‡e:

#+begin_src rust
fn largest<T: PartialOrd + Copy>(list: &[T]) -> T {
    let mut largest = list[0];

    for &item in list {
        if item > largest {
            largest = item;
        }
    }

    largest
}

fn main() {
    let number_list = vec![34, 50, 25, 100, 65];

    let result = largest(&number_list);
    println!("The largest number is {}", result);

    let char_list = vec!['y', 'm', 'a', 'q'];

    let result = largest(&char_list);
    println!("The largest char is {}", result);
}
#+end_src

*** Upotreba osobina ograniÄenja za uslovnu implementaciju metoda

Ako Å¾elimo da implementiramo metodu samo nad tipovima koji implementiraju
odreÄ‘ene osobine.
#+begin_src rust
use std::fmt::Display;

struct Pair<T> {
    x: T,
    y: T,
}

impl<T> Pair<T> {
    fn new(x: T, y: T) -> Self {
        Self { x, y }
    }
}

impl<T: Display + PartialOrd> Pair<T> {
    fn cmp_display(&self) {
        if self.x >= self.y {
            println!("The largest member is x = {}", self.x);
        } else {
            println!("The largest member is y = {}", self.y);
        }
    }
}
#+end_src

** Validacija referenci kroz Å¾ivotni vek (/Lifetimes/)
*** Å½ivotni vek (/Lifetime/)
- Svaka referenca ima Å¾ivotni vek, opseg u kome je referenca validna.
- U dosta situacija kompajler automatski moÅ¾e da zakljuÄi koji je Å¾ivotni vek
  reference. Kada to nije u stanju moramo da uradimo ruÄnu anotaciju.
- Anotacijama Å¾ivotnog veka dovodimo u vezu Å¾ivotni vek razliÄitih referenci.

*** SpreÄavanje "viseÄ‡ih" referenci

#+begin_src rust
{
        let r;

        {
            let x = 5;
            r = &x;
        }

        println!("r: {}", r);
    }

#+end_src

#+begin_example
 cargo run
   Compiling chapter10 v0.1.0 (file:///projects/chapter10)
error[E0597]: `x` does not live long enough
  --> src/main.rs:7:17
   |
7  |             r = &x;
   |                 ^^ borrowed value does not live long enough
8  |         }
   |         - `x` dropped here while still borrowed
9  |
10 |         println!("r: {}", r);
   |                           - borrow later used here

For more information about this error, try `rustc --explain E0597`.
error: could not compile `chapter10` due to previous error
#+end_example

*** /Borrow Checker/
- Rust kompajler ima komponentu /borrow checker/ koja proverava da li su sve
  pozajmice validne.

#+begin_src rust
{
    let r;                // ---------+-- 'a
                          //          |
    {                     //          |
        let x = 5;        // -+-- 'b  |
        r = &x;           //  |       |
    }                     // -+       |
                          //          |
    println!("r: {}", r); //          |
}                         // ---------+
#+end_src

- Program je odbaÄen jer =r= referencira vrednost Äiji Å¾ivotni vek (='b=) je kraÄ‡i
  od Å¾ivotnog veka varijable =r= (='a=). Ukoliko bi se ovo dozvolilo, =r= bi u jednom
  delu referencirala nevalidnu vrednost.

#+REVEAL: split

Varijable imaju Å¾ivotni vek koji je jednak sinstaksnom opsegu u kome je
varijabla definisana. Å½ivotni vek imaju i reference koje pozajmljuju vrednost i
smeÅ¡taju se u varijable (npr. =r=&x= iz prethodnog primera).

#+begin_note
Jedno od pravila je da referenca na varijablu (tj. vrednost) ne moÅ¾e da Å¾ivi
duÅ¾e od same varijable. Odnosno /Å¾ivotni vek varijable mora da sadrÅ¾i Å¾ivotni
vek reference pozajmljene od te varijable/.
#+end_note

#+begin_src rust
{
    let r;
    {
        let x = 5;
        r = &x;           // -+- &x ne moÅ¾e da Å¾ivi duÅ¾e od
    }                     // -+  ovog Å¾ivotnog veka
    println!("r: {}", r);
}
#+end_src

#+REVEAL: split

Ako smestimo referencu u varijablu, referenca mora biti ispravna za ceo Å¾ivotni
vek varijable u koju je smeÅ¡tena.

#+begin_note
KaÅ¾emo da /Å¾ivotni vek reference mora da sadrÅ¾i Å¾ivotni vek varijable u koju je
smeÅ¡tena/.
#+end_note

#+begin_src rust
{
    let r;
    {
        let x = 5;
        r = &x;           // -+- Å¾ivotni vek bilo Äega Å¡to
    }                     //  |  se smesti u r mora da Å¾ivi
    println!("r: {}", r); // -+  bar ovoliko
}
#+end_src

Vidimo da ovo pravilo nije zadovoljeno. =&x= ne Å¾ivi dovoljno dugo jer =x= ne Å¾ivi
dovoljno dugo.

#+REVEAL: split

Ako prethodna dva pravila objedinimo moÅ¾emo reÄ‡i da:

#+begin_note
/Å½ivotni vek varijable mora da sadrÅ¾i Å¾ivotni vek svih varijabli koje pozajmljuju
vrednost od posmatrane varijable/.
#+end_note

Odnosno, varijabla moÅ¾e otiÄ‡i iz opsega tek kada ne postoji viÅ¡e ni jedna
varijabla koja Äuva pozajmljenu vrednost.

#+REVEAL: split

SledeÄ‡i kod je prihvaÄ‡en. Referenca =r= ne Å¾ivi duÅ¾e od podatka koji referencira
(=x=).

#+begin_src rust
{
    let x = 5;            // ----------+-- 'b
                          //           |
    let r = &x;           // --+-- 'a  |
                          //   |       |
    println!("r: {}", r); //   |       |
                          // --+       |
}                         // ----------+
#+end_src

*** GeneriÄki Å¾ivotni vekovi u funkcijama

- Kreiramo funkciju =longest= koja vraÄ‡a duÅ¾i od dva prosleÄ‘ena stringa.
  ProsleÄ‘ujemo referencu na string iseÄak =&str=.

#+begin_src rust
fn main() {
    let string1 = String::from("abcd");
    let string2 = "xyz";

    let result = longest(string1.as_str(), string2);
    println!("The longest string is {}", result);
}
#+end_src

#+REVEAL: split

Ovaj program nije prihvaÄ‡en.
#+begin_src rust
fn longest(x: &str, y: &str) -> &str {
    if x.len() > y.len() {
        x
    } else {
        y
    }
}
#+end_src

#+begin_example
$ cargo run
   Compiling chapter10 v0.1.0 (file:///projects/chapter10)
error[E0106]: missing lifetime specifier
 --> src/main.rs:9:33
  |
9 | fn longest(x: &str, y: &str) -> &str {
  |               ----     ----     ^ expected named lifetime parameter
  |
  = help: this function's return type contains a borrowed value, but the signature does not say
  whether it is borrowed from `x` or `y`
help: consider introducing a named lifetime parameter
  |
9 | fn longest<'a>(x: &'a str, y: &'a str) -> &'a str {
  |           ++++     ++          ++          ++

For more information about this error, try `rustc --explain E0106`.
error: could not compile `chapter10` due to previous error
#+end_example

#+REVEAL: split

- ZaÅ¡to program nije prihvaÄ‡en?
- /Borrow checker/ nije u stanju da odredi u kojoj relaciji su reference =x= i =y= sa
  povratnom vrednoÅ¡Ä‡u koja je takoÄ‘e referenca.
- Tj. povratna vrednost mora biti pozajmljena od nekud, ali kompajler ne moÅ¾e da
  odredi da li je pozamljena od =x= ili =y= ili od neke globalne vrednosti.
- Ova informacija je potrebna da bi se obavila kalkulacija i provera Å¾ivotnog veka.

*** Sintaksa za anotaciju Å¾ivotnog veka

- Da bi pomogli kompajleru reference oznaÄavamo sa Å¾ivotnim vekom i time
  dovodimo u vezu razliÄite reference (npr. parametre i povratne vrednosti
  funkcije).
- Anotacija je oblika ='a=. Iza apostrofa se piÅ¡e ime anotacije koje je najÄeÅ¡Ä‡e
  jedno malo slovo sa poÄetka alfabeta (='a, 'b,...=).
- *VaÅ¾no:* anotacije Å¾ivotnog veka ne menjaju Å¾ivotni vek reference veÄ‡ samo
  pomaÅ¾u kompajleru u proveri.

#+begin_src rust
&i32        // referenca
&'a i32     // referenca sa eksplicitnim Å¾ivotnim vekom
&'a mut i32 // promenjiva referenca sa eksplicitnim Å¾ivotnim vekom
#+end_src

- Jedna anotacija nema puno smisla. Funkciju imaju tek kada anotiramo viÅ¡e
  referenci jer se dovode u vezu ako imaju isto ime.
- Uvedimo funkciju =lt= koja vraÄ‡a Å¾ivotni vek varijable/vrednosti i relaciju
  izmeÄ‘u Å¾ivotnih vekova ='aâ‰¥'b= odnosno ='bâ‰¤'a= koja znaÄi da ='a= obuhvata ='b=
  odnosno ='b= je sadrÅ¾ano u ='a=.

*** Anotacija Å¾ivotnog veka u signaturama funkcija

- SledeÄ‡a anotacija za funkciju =longest= je ispravna jer referenca koja se vraÄ‡a
  moÅ¾e biti =x= ili =y= u zavisnosti od duÅ¾ine stringa. Stoga je potrebno da imamo
  stroÅ¾iji uslov da je Å¾ivotni vek povratne vrednosti u vezi sa Å¾ivotnim vekom
  oba parametra.

#+begin_src rust
fn longest<'a>(x: &'a str, y: &'a str) -> &'a str {
    if x.len() > y.len() {
        x
    } else {
        y
    }
}
#+end_src

- Ovim kaÅ¾emo kompajleru da za neki generiÄki Å¾ivotni vek ='a=, funkcija prima dve
  reference Äiji Å¾ivotni vek vrednosti obuhvata ='a= i vraÄ‡a referencu koja mora
  biti validna bar koliko i Å¾ivotni vek ='a= tj. Å¾ivotni vek povratne reference
  mora da obuvati ='a=. Ukoliko takav Å¾ivotni vek postoji kod se prihvata.
- Signatura dovodi u vezu obe ulazne reference sa izlaznom.

#+REVEAL: split

Posmatrajmo kod koji poziva funkciju =longest=:

#+begin_src rust
fn main() {
    let string1 = String::from("abcd");
    {
        let string2 = "xyz";
        let result = longest(string1.as_str(), string2);
    }
    println!("The longest string is {}", result);
}
#+end_src

Za kod mora da postoji ='a= tako da vaÅ¾i:

#+begin_example
lt(string1) â‰¥ 'a     # Å¾ivotni vek vrednosti prvog parametara sadrÅ¾i 'a
lt(string2) â‰¥ 'a     # Å¾ivotni vek vrednosti drugog parametara sadrÅ¾i 'a
'a â‰¥ lt(result)       # 'a mora da sadrÅ¾i Å¾ivotni veku result varijable
#+end_example

Å to ne moÅ¾e biti ispunjeno istovremeno, tj. ne postoji ='a= koje ispunjava ova
ograniÄenja.

#+REVEAL: split

Drugi naÄin razmiÅ¡ljanja je da povratna vrednost funkcije pozajmljuje od
vrednosti ulaznih parametara oznaÄenih istim imenom Å¾ivotnog veka.

#+begin_src rust
fn main() {
    let string1 = String::from("abcd");
    {
        let string2 = "xyz";
        let result = longest(string1.as_str(), string2);
    }
    println!("The longest string is {}", result);
}
#+end_src

Å to znaÄi da =result= pozajmljuje od =string1= i =string2= i ta pozajmica traje sve
vreme Å¾ivota varijable =result= Å¡to ne moÅ¾e biti validno jer varijabla Å¾ivi duÅ¾e
od vrednosti =string2=.

Iako, moÅ¾emo videti da Ä‡e, zbog duÅ¾ine stringa, vraÄ‡ena vrednost biti =string1= i
program je validan, kompajler ovo ne moÅ¾e da zakljuÄi.

* Literatura
- Steve Klabnik and Carol Nichols: [[https://doc.rust-lang.org/book/][The Rust Programming Language]], no starch press.
- Slice is NOT reference, https://github.com/rust-lang/book/issues/3070
- [[https://rust-lang.github.io/rfcs/0505-api-comment-conventions.html][RFC 505: API documentation conventions]]
