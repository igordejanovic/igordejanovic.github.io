# -*- ispell-dictionary: "sr"; -*-
#+TITLE: Програмски језик Раст
#+SUBTITLE: Базирано на верзији 1.65.0. У изради.
#+EXPORT_FILE_NAME: index.html
#+EXPORT_REVEAL_HLEVEL: 10
#+SETUPFILE: ../../courses-startup-cyr.org

* Увод
- Језик опште намене, компајлиран и статички типизиран са инференцом типова
- Системско програмирање али са особинама вишег нивоа апстракције као што су
  функционално програмирање
- 2010, Graydon Hoare, Mozilla Research
- Перформансе и сигурност
- Не користи /garbage collector/ али обезбеђује меморијску сигурност кроз /borrow
  checker/
- Синтаксно сличан C++. Утицај и OCaml-а, Haskell-а и Erlang-а.
- Користи се у великим фирмама: Amazon, Facebook, Google, Microsoft...
- Више година за редом на SO упитнику први у категорији /"most loved programming
  languages"/

* Инсталација и подешавање
** Инсталација
- Раст стиже са алатом за управљање ланцем алата (енг. /toolchain/) -- =rustup=

#+begin_src sh
$ curl --proto '=https' --tlsv1.2 https://sh.rustup.rs -sSf | sh
#+end_src

- Провера инсталације:

#+begin_src sh
~> rustc --version
rustc 1.65.0 (897e37553 2022-11-02)
#+end_src

** Преглед инсталације
#+begin_src sh
~> rustup show
Default host: x86_64-unknown-linux-gnu
rustup home:  /home/igor/.rustup

installed toolchains
--------------------

stable-x86_64-unknown-linux-gnu (default)
nightly-x86_64-unknown-linux-gnu

active toolchain
----------------

stable-x86_64-unknown-linux-gnu (default)
rustc 1.58.1 (db9d1b20b 2022-01-20)
#+end_src

** Ажурирање
За ажурирање инсталације на најновију верзију:

#+begin_src sh
rustup update
#+end_src

** Документација
Раст стиже са веома добром документацијом и књигама које су доступне директно из
инсталације:

#+begin_src sh
rustup doc
#+end_src

* Почетак
** Hello, World!
#+begin_src sh
$ mkdir hello_world
$ cd hello_world
#+end_src

File =main.rs=:
#+begin_src rust
fn main() {
    println!("Hello, world!");
}
#+end_src

** Компајлирање и покретање
#+begin_src sh
$ rustc main.rs
$ ./main
Hello, world!
#+end_src

** Hello, Cargo!
- Алат за разрешавање зависности и управљање пројектом.

#+begin_src sh
~> cargo --version
cargo 1.65.0 (4bc8f24d3 2022-10-20)
#+end_src

- Креирање пројекта са =cargo= алатом:

#+begin_src sh
$ cargo new hello_cargo
$ cd hello_cargo
#+end_src

** Садржај креираног пројекта
Фајл =cargo.toml= чува конфигурацију пројекта. Формат је [[https://toml.io/en/][TOML]] (/Tom’s Obvious,
Minimal Language/):

#+begin_src toml
[package]
name = "hello_cargo"
version = "0.1.0"
edition = "2021"

[dependencies]
#+end_src

Fajl =src/main.rs=:
#+begin_src rust
fn main() {
    println!("Hello, world!");
}
#+end_src

** Покретање
#+begin_src rust
$ cargo build
   Compiling hello_cargo v0.1.0 (file:///projects/hello_cargo)
    Finished dev [unoptimized + debuginfo] target(s) in 2.85 secs
#+end_src

Извршни фајл се може наћи на локацији =target/debug/hello_cargo=:

#+begin_src sh
$ ./target/debug/hello_cargo
Hello, world!
#+end_src

Али =cargo= омогућава и једноставнији начин покретања:
#+begin_src sh
$ cargo run
    Finished dev [unoptimized + debuginfo] target(s) in 0.0 secs
     Running `target/debug/hello_cargo`
Hello, world!
#+end_src

** Провера
Такође је могуће брзо проверити да ли се код компајлира:

#+begin_src sh
$ cargo check
   Checking hello_cargo v0.1.0 (file:///projects/hello_cargo)
    Finished dev [unoptimized + debuginfo] target(s) in 0.32 secs
#+end_src

** Изградња финалне верзије
- У току развоја користимо изградњу за дебаговање која се брже заврши али
  генерисани извршни код није оптималан.

- За финалну верзију је потребно изградњу обавити на следећи начин:

    #+begin_src rust
    cargo build --release
    #+end_src

- Ово ће обавити додатне оптимизације које ће дуже трајати али ће крајњи код
  бити оптимизован.

** =cargo= као конвенција
Практично сви Раст пројекти користе =cargo= тако да је унификован начин изградње
пројеката. Углавном се своди на:

#+begin_src sh
$ git clone example.org/someproject
$ cd someproject
$ cargo build
#+end_src
* Игра погађања бројева
** Подешавање пројекта
#+begin_src rust
$ cargo new guessing_game
$ cd guessing_game
#+end_src

Фајл =Cargo.toml=:
#+begin_src toml
[package]
name = "guessing_game"
version = "0.1.0"
edition = "2021"

[dependencies]
#+end_src

Фајл =src/main.rs=:
#+begin_src rust
fn main() {
    println!("Hello, world!");
}
#+end_src

#+REVEAL: split

#+begin_src sh
$ cargo run
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
    Finished dev [unoptimized + debuginfo] target(s) in 1.50s
     Running `target/debug/guessing_game`
Hello, world!
#+end_src

** Преузимање броја са стандардног улаза
#+begin_src rust
use std::io;

fn main() {
    println!("Guess the number!");

    println!("Please input your guess.");

    let mut guess = String::new();

    io::stdin()
        .read_line(&mut guess)
        .expect("Failed to read line");

    println!("You guessed: {}", guess);
}
#+end_src

** Променљивост (/mutability/)
- Варијабле су подразумевано непромењиве (/immutable/).
- Уколико желимо варијаблу чија вредност може да се мења користимо кључну реч
  =mut=.

  #+begin_src rust
  let apples = 5; // immutable
  let mut bananas = 5; // mutable
  #+end_src

- Исто важи и за параметре и аргументе функција:

  #+begin_src rust
  io::stdin()
      .read_line(&mut guess)
  #+end_src

** Обрада могућих грешака употребом =Result= типа
=read_line= може да заврши неуспешно. Зато враћа =io::Result= тип који представља
тип енумерације (/enum/) и има две могуће вредности: =Ok= и =Err=.

#+begin_src rust
io::stdin()
    .read_line(&mut guess)
    .expect("Failed to read line");
#+end_src

=expect= je имплементиран тако да ће у случају =Ok= варијанте вратити вредност која
је садржана унутар варијанте док ће у случају =Err= варијанте прекинути извршавање
програма.

#+begin_src rust
pub fn expect(self, msg: &str) -> T
    where
        E: fmt::Debug,
    {
        match self {
            Ok(t) => t,
            Err(e) => unwrap_failed(msg, &e),
        }
    }
#+end_src

** Покретање
#+begin_src rust
$ cargo run
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
    Finished dev [unoptimized + debuginfo] target(s) in 6.44s
     Running `target/debug/guessing_game`
Guess the number!
Please input your guess.
6
You guessed: 6
#+end_src

** Генерисање случајног броја
Користимо =rand= пакет (сандук - /crate/ у терминологији /Cargo/-a).

Секција =[dependencies]= у фајлу =Cargo.toml=:
#+begin_src toml
[dependencies]
rand = "0.8.3"
#+end_src

#+begin_src sh
$ cargo build
    Updating crates.io index
  Downloaded rand v0.8.3
  Downloaded libc v0.2.86
  ...
   Compiling rand_chacha v0.3.0
   Compiling rand v0.8.3
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
    Finished dev [unoptimized + debuginfo] target(s) in 2.53s
#+end_src

/Cargo/ користи [[https://semver.org/][Semantic Versioning]]. Раст пакети се преузимају са сајта [[https://crates.io/][crates.io]]
и кеширају локално.

** Поновљивост изградње - /Cargo.lock/
- Свако следеће покретање изградње користи исте верзије.
- Први пут када се покрене =cargo build= креира се фајл =Cargo.lock= са
  информацијама о верзијама свих сандука који су инсталирани.
- =Cargo.lock= је потребно чувати у систему контроле верзија (нпр. =git=) да би се
  осигурала поновљивост.

** Ажурирање сандука
- Ажурирање на нове верзије сандука се обавља са:

  #+begin_src sh
  $ cargo update
    Updating crates.io index
    Updating rand v0.8.3 -> v0.8.4
  #+end_src
- Поштује се семантичко верзионирање тј. аутоматски се ажурира на следећу
  верзију која је мања од наредне главне (/major/) верзије.
- Ако прелазимо на нову главну верзију то морамо урадити изменом верзије у
  =Cargo.toml= фајлу.

** Генерисање случајног броја
Фајл =src/main.rs=:
#+begin_src rust
use std::io;
use rand::Rng;

fn main() {
    println!("Guess the number!");

    let secret_number = rand::thread_rng().gen_range(1..101);

    println!("The secret number is: {}", secret_number);

    println!("Please input your guess.");

    let mut guess = String::new();

    io::stdin()
        .read_line(&mut guess)
        .expect("Failed to read line");

    println!("You guessed: {}", guess);
}
#+end_src

У =gen_range= користимо израз опсега (/range expression/). Интервал је затворен на
доњој граници и отворен на горњој. За интервал затворен и од горе можемо
писати ~1..=100~.

** Документација за локалне сандуке
Да би знали које методе и функције су нам доступне можемо користити уграђену
документацију за сандуке пројекта. Документацију добијамо са:

#+begin_src sh
cargo doc --open
#+end_src

** Покретање програма
#+begin_src sh
$ cargo run
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
    Finished dev [unoptimized + debuginfo] target(s) in 2.53s
     Running `target/debug/guessing_game`
Guess the number!
The secret number is: 7
Please input your guess.
4
You guessed: 4
#+end_src

** Поређење тајног броја са задатим
Фајл =src/main.rs=
#+begin_src rust
use rand::Rng;
use std::cmp::Ordering;
use std::io;

fn main() {
    // --snip--

    println!("You guessed: {}", guess);

    match guess.cmp(&secret_number) {
        Ordering::Less => println!("Too small!"),
        Ordering::Greater => println!("Too big!"),
        Ordering::Equal => println!("You win!"),
    }
}
#+end_src
- Користимо =std::cmp::Ordering= енумерисани тип који има варијанте =Less=, =Greater=
  и =Equal=
- =match= израз пореди задату вредност са вредностима задатим у телу и извршава
  грану која се подудара. Гране =match= израза се у Раст терминологији зову "руке"
  (/arms/).

** Поправка типова
Код са претходног слајда није исправан:
#+begin_src sh
$ cargo build
   Compiling libc v0.2.86
   ...
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
error[E0308]: mismatched types
  --> src/main.rs:22:21
   |
22 |     match guess.cmp(&secret_number) {
   |                     ^^^^^^^^^^^^^^ expected struct `String`, found integer
   |
   = note: expected reference `&String`
              found reference `&{integer}`

error[E0283]: type annotations needed for `{integer}`
   --> src/main.rs:8:44
    |
8   |     let secret_number = rand::thread_rng().gen_range(1..101);
    |         -------------                      ^^^^^^^^^ cannot infer type for type `{integer}`
    |         |
    |         consider giving `secret_number` a type
    |
    = note: multiple `impl`s satisfying `{integer}: SampleUniform` found in the `rand` crate:
            - impl SampleUniform for i128;
            - impl SampleUniform for i16;
            - impl SampleUniform for i32;
            - impl SampleUniform for i64;
            and 8 more
...
#+end_src

#+REVEAL: split

Основа грешке је неслагање типова. Са улаза прихватамо =String= док нам је тајни
број =integer=.

** Конверзија стринга у број
Проблем решавамо конверзијом стринга са улаза у бројни тип.

#+begin_src rust
// --snip--

    let mut guess = String::new();

    io::stdin()
        .read_line(&mut guess)
        .expect("Failed to read line");

    let guess: u32 = guess.trim().parse().expect("Please type a number!");

    println!("You guessed: {}", guess);

    match guess.cmp(&secret_number) {
        Ordering::Less => println!("Too small!"),
        Ordering::Greater => println!("Too big!"),
        Ordering::Equal => println!("You win!"),
    }
#+end_src

#+REVEAL: split

Сада се програм компајлира.

#+begin_src sh
$ cargo run
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
    Finished dev [unoptimized + debuginfo] target(s) in 0.43s
     Running `target/debug/guessing_game`
Guess the number!
The secret number is: 58
Please input your guess.
  76
You guessed: 76
Too big!
#+end_src

** Омогућавање вишеструког погађања - употреба петље
Фајл =src/main.rs=:
#+begin_src rust
// --snip--

    println!("The secret number is: {}", secret_number);

    loop {
        println!("Please input your guess.");

        // --snip--

        match guess.cmp(&secret_number) {
            Ordering::Less => println!("Too small!"),
            Ordering::Greater => println!("Too big!"),
            Ordering::Equal => println!("You win!"),
        }
    }
}
#+end_src

** Прекид рада
Проблем је како прекинути програм када корисник погоди број?

#+begin_src rust
// --snip--

        match guess.cmp(&secret_number) {
            Ordering::Less => println!("Too small!"),
            Ordering::Greater => println!("Too big!"),
            Ordering::Equal => {
                println!("You win!");
                break;
            }
        }
    }
}
#+end_src

** Руковање неисправним улазом
#+begin_src rust
// --snip--

        io::stdin()
            .read_line(&mut guess)
            .expect("Failed to read line");

        let guess: u32 = match guess.trim().parse() {
            Ok(num) => num,
            Err(_) => continue,
        };

        println!("You guessed: {}", guess);

        // --snip--
#+end_src

Потребно је још обрисати линију која приказује генерисани број.

** Финални код
#+begin_src rust
use rand::Rng;
use std::cmp::Ordering;
use std::io;

fn main() {
    println!("Guess the number!");
    let secret_number = rand::thread_rng().gen_range(1..101);

    loop {
        println!("Please input your guess.");
        let mut guess = String::new();
        io::stdin()
            .read_line(&mut guess)
            .expect("Failed to read line");
        let guess: u32 = match guess.trim().parse() {
            Ok(num) => num,
            Err(_) => continue,
        };
        println!("You guessed: {}", guess);
        match guess.cmp(&secret_number) {
            Ordering::Less => println!("Too small!"),
            Ordering::Greater => println!("Too big!"),
            Ordering::Equal => {
                println!("You win!");
                break;
            }
        }
    }
}
#+end_src

* Основни програмски концепти
** Варијабле и променљивост (/mutability/)
*** Варијабле и променљивост (/mutability/)
- Варијабле су подразумевано непромењиве.
- Једном када добију вредност (/binding/) та вредност се не може променити

  #+begin_src rust
    fn main() {
        let x = 5;
        println!("The value of x is: {}", x);
        x = 6;     // greška
        println!("The value of x is: {}", x);
    }
  #+end_src

  #+REVEAL: split

  #+begin_src sh
    $ cargo run
    Compiling variables v0.1.0 (file:///projects/variables)
    error[E0384]: cannot assign twice to immutable variable `x`
    --> src/main.rs:4:5
    |
    2 |     let x = 5;
    |         -
    |         |
    |         first assignment to `x`
    |         help: consider making this binding mutable: `mut x`
    3 |     println!("The value of x is: {}", x);
    4 |     x = 6;
    |     ^^^^^ cannot assign twice to immutable variable

    For more information about this error, try `rustc --explain E0384`.
    error: could not compile `variables` due to previous error
  #+end_src
*** =mut= кључна реч

#+begin_src rust
fn main() {
    let mut x = 5;
    println!("The value of x is: {}", x);
    x = 6;
    println!("The value of x is: {}", x);
}
#+end_src
** Константе - =const=
- Слично као непромењиве варијабле са следећим разликама:
  - Увек су непромењиве
  - Могу се иницијализовати само константним изразом (познатим у време
    компајлирања)
  - Валидне за целокупно време извршавања програма у опсегу важења где су
    дефинисане (/scope/)
  - Мора се експлицитно дефинисати тип
- Компајлер ће константе "убацити" на месту употребе
- По конвенцији имена константи се пишу великим словима

  #+begin_src rust
    const THREE_HOURS_IN_SECONDS: u32 = 60 * 60 * 3;
  #+end_src

** Типови података
*** Типови података
- Свака вредност у Расту има тип. Типови морају бити познати у време
  компајлирања (/статички типизиран језик/).
- Компајлер ће пробати да одреди типове (/type inference/). Ако није могуће
  захтева се да дефинишемо тип експлицитно.

  Нпр:
  #+begin_src rust
    let guess: u32 = "42".parse().expect("Not a number!");
  #+end_src
  Овде није могуће одредити тип јер =str::parse= функција може вратити различите
  бројне типове (функција је генеричка) а не постоји начин да се тип аутоматски
  одреди.

  Сигнатура је:
  #+begin_src rust
    pub fn parse<F>(&self) -> Result<F, <F as FromStr>::Err>
    where
        F: FromStr
  #+end_src
*** /Integer/ типови

| Дужина  | Signed | Unsigned |
|---------+--------+----------|
| 8-bit   | i8     | u8       |
| 16-bit  | i16    | u16      |
| 32-bit  | i32    | u32      |
| 64-bit  | i64    | u64      |
| 128-bit | i128   | u128     |
| arch    | isize  | usize    |

*** Литерали бројева

| Литерали       | Примери     |
|----------------+-------------|
| Decimal        | 98_222      |
| Hex            | 0xff        |
| Octal          | 0o77        |
| Binary         | 0b1111_0000 |
| Byte (u8 only) | b'A'        |

*** /Floating-Point/ типови

#+begin_src rust
fn main() {
    let x = 2.0; // f64

    let y: f32 = 3.0; // f32
}
#+end_src

IEEE-754 стандард

*** Операције над бројевима

#+begin_src rust
fn main() {
    // addition
    let sum = 5 + 10;

    // subtraction
    let difference = 95.5 - 4.3;

    // multiplication
    let product = 4 * 30;

    // division
    let quotient = 56.7 / 32.2;
    let floored = 2 / 3; // Results in 0

    // remainder
    let remainder = 43 % 5;
}
#+end_src

*** /Boolean/ тип
#+begin_src rust
fn main() {
    let t = true;

    let f: bool = false; // with explicit type annotation
}
#+end_src

*** Тип карактера

#+begin_src rust
fn main() {
    let c = 'z';
    let z = 'ℤ';
    let heart_eyed_cat = '😻';
}
#+end_src

*** Торке (/tuples/)
#+begin_src rust
fn main() {
    let tup: (i32, f64, u8) = (500, 6.4, 1);
}
#+end_src

- Распакивање торки (/destructuring/):
#+begin_src rust
fn main() {
    let tup = (500, 6.4, 1);

    let (x, y, z) = tup;

    println!("The value of y is: {}", y);
}
#+end_src

#+REVEAL: split

Приступ елементима торке:
#+begin_src rust
fn main() {
    let x: (i32, f64, u8) = (500, 6.4, 1);

    let five_hundred = x.0;

    let six_point_four = x.1;

    let one = x.2;
}
#+end_src

*** Низовни тип
- Сваки елемент низовног типа мора имати исти тип
- Димензија низа је непромењива (алоциран је на стеку)
    #+begin_src rust
    fn main() {
        let a = [1, 2, 3, 4, 5];
    }
    #+end_src

- Тип се може експлицитно дефинисати на следећи начин (низ дужине =5= типа =i32=):
    #+begin_src rust
    let a: [i32; 5] = [1, 2, 3, 4, 5];
    #+end_src

- Иницијализација свих елемената на исту вредност се обавља на следећи начин:
  #+begin_src rust
  let a = [3; 5];
  #+end_src
  Где је вредност сваког елемента =3= а дужина низа =5=.

#+REVEAL: split

Индексни приступ:

#+begin_src rust
fn main() {
    let a = [1, 2, 3, 4, 5];

    let first = a[0];
    let second = a[1];
}
#+end_src

** Функције
*** Функције
#+begin_src rust
fn main() {
    println!("Hello, world!");

    another_function();
}

fn another_function() {
    println!("Another function.");
}
#+end_src
- За именовање функција као и варијабли користи се /snake_case/.
*** Funkcije - parametri
#+begin_src rust
fn main() {
    print_labeled_measurement(5, 'h');
}

fn print_labeled_measurement(value: i32, unit_label: char) {
    println!("The measurement is: {}{}", value, unit_label);
}
#+end_src

*** Искази и изрази
- Рaст је језик базиран на изразима (/expression-based/)
- Искази (/statements/) су језичке конструкције које немају повратну вредност.
  Изрази (/expressions/) се евалуирају у одређени резултат, тј. имају вредност.
- Пример: =let= је исказ тј. нема повратну вредност. Ово можете писати:
  #+begin_src rust
  let y = 6;
  #+end_src
  Ali ovo ne:
  #+begin_src rust
  let x = (let y = 6);
  #+end_src

#+REVEAL: split

Блок кода је такође израз. Шта је вредност у коју се евалуира?

#+begin_src rust
{
    let x = 3;
    x + 1
}
#+end_src

Вредност блока је вредност последњег израза, тј. =x+1=. Приметите да ту не
користимо =;= јер терминација овим карактером претвара израз у исказ.

#+REVEAL: split

Због овога је сасвим легално да пишемо:

#+begin_src rust
fn main() {
    let y = {
        let x = 3;
        x + 1
    };

    println!("The value of y is: {}", y);
}
#+end_src

#+RESULTS:
: The value of y is: 4
*** Повратне вредности функција
Вредност функције је вредност блока који представља тело функције, дакле
последњег израза унутар тела функције.

#+begin_src rust
fn five() -> i32 {
    5
}

fn main() {
    let x = five();

    println!("The value of x is: {}", x);
}
#+end_src

#+RESULTS:
: The value of x is: 5

#+REVEAL: split

Или на пример:
#+begin_src rust
fn main() {
    let x = plus_one(5);

    println!("The value of x is: {}", x);
}

fn plus_one(x: i32) -> i32 {
    x + 1
}
#+end_src

#+RESULTS:
: The value of x is: 6

#+REVEAL: split

Уколико израз =x+1= терминирамо са =;= код се неће компајлирати јер функција
декларише да враћа тип =i32= док сада враћа =()= (тзв. /unit type/) односно нема
повратну вредност јер је последња инструкција исказ.

#+begin_src rust
fn main() {
    let x = plus_one(5);

    println!("The value of x is: {}", x);
}

fn plus_one(x: i32) -> i32 {
    x + 1;
}
#+end_src

#+begin_example
error[E0308]: mismatched types
 --> src/main.rs:8:24
  |
8 | fn plus_one(x: i32) -> i32 {
  |    --------            ^^^ expected `i32`, found `()`
  |    |
  |    implicitly returns `()` as its body has no tail or `return` expression
9 |     x + 1;
  |          - help: consider removing this semicolon

For more information about this error, try `rustc --explain E0308`.
error: could not compile `cargo4UyKF0` due to previous error
#+end_example

** Коментари
Коментари се пишу после =//= или у форми блок коментара =/*.... */= као и у C++-у.
Ово би били валидни коментари:
#+begin_src rust
// So we’re doing something complicated here, long enough that we need
// multiple lines of comments to do it! Whew! Hopefully, this comment will
// explain what’s going on.

fn main() {
    let lucky_number = 7; // I’m feeling lucky today
}
...
fn main() {
    // I’m feeling lucky today
    let lucky_number = 7;
    /* this is block comment
       which can span multiple lines.
       Nesting is allowed.
     */
}
#+end_src

#+REVEAL: split

Постоје и коментари за документацију који представљају посебну синтаксу за
коментаре који су део API документације. Они се пишу после =///=. На пример:
#+begin_src rust
/// Adds one to the number given.
///
/// # Examples
///
/// ```
/// let arg = 5;
/// let answer = my_crate::add_one(arg);
///
/// assert_eq!(6, answer);
/// ```
pub fn add_one(x: i32) -> i32 {
    x + 1
}
#+end_src
** Контрола тока
*** =if= изрази
#+begin_src rust
fn main() {
    let number = 3;

    if number < 5 {
        println!("condition was true");
    } else {
        println!("condition was false");
    }
}
#+end_src

*** =if-else=
#+begin_src rust
fn main() {
    let number = 6;

    if number % 4 == 0 {
        println!("number is divisible by 4");
    } else if number % 3 == 0 {
        println!("number is divisible by 3");
    } else if number % 2 == 0 {
        println!("number is divisible by 2");
    } else {
        println!("number is not divisible by 4, 3, or 2");
    }
}
#+end_src
*** =if= у =let= исказима
=if= је израз па се може користити где год можемо писати и било који други израз.

#+begin_src rust
fn main() {
    let condition = true;
    let number = if condition { 5 } else { 6 };

    println!("The value of number is: {}", number);
}
#+end_src

#+RESULTS:
: The value of number is: 5

#+REVEAL: split

Али се гране морају слагати по типу. Ово је погрешно јер је прва грана типа
=i32= док је =else= грана типа =str=.

#+begin_src rust
fn main() {
    let condition = true;

    let number = if condition { 5 } else { "six" };

    println!("The value of number is: {}", number);
}
#+end_src
*** Петље
Рaст има три типа петље:
- =loop= - за бесконачне петље
- =while= - условна петља
- =for= - петља за итерацију кроз елементе итерабилних типова

*** =loop=
#+begin_src rust
fn main() {
    loop {
        println!("again!");
    }
}
#+end_src

*** =loop= лабеле
Уколико имамо угњеждене =loop= исказе можемо користити лабеле приликом изласка са
=break= инструкцијом.

#+begin_src rust
fn main() {
    let mut count = 0;
    'counting_up: loop {
        println!("count = {}", count);
        let mut remaining = 10;

        loop {
            println!("remaining = {}", remaining);
            if remaining == 9 {
                break;
            }
            if count == 2 {
                break 'counting_up;
            }
            remaining -= 1;
        }

        count += 1;
    }
    println!("End count = {}", count);
}
#+end_src

*** =loop= као израз
=loop= може имати повратну вредност. Повратна вредност се дефинише као параметар
=break= инструкције.

#+begin_src rust
fn main() {
    let mut counter = 0;

    let result = loop {
        counter += 1;

        if counter == 10 {
            break counter * 2;
        }
    };

    println!("The result is {}", result);
}
#+end_src
*** =while=
#+begin_src rust
fn main() {
    let mut number = 3;

    while number != 0 {
        println!("{}!", number);

        number -= 1;
    }

    println!("LIFTOFF!!!");
}
#+end_src
*** =for=
Итерацију кроз уређену колекцију, као што је низ, можемо обавити са =while= петљом.
#+begin_src rust
fn main() {
    let a = [10, 20, 30, 40, 50];
    let mut index = 0;

    while index < 5 {
        println!("the value is: {}", a[index]);

        index += 1;
    }
}
#+end_src

#+REVEAL: split
Али је за ту намену природније и сигурније користити =for= петљу. Такође ће се
програм брже извршавати.

#+begin_src rust
fn main() {
    let a = [10, 20, 30, 40, 50];

    for element in a {
        println!("the value is: {}", element);
    }
}
#+end_src

#+REVEAL: split
=for= петље су најчешћи облик петљи у употреби у Расту. Користе се нпр. и у
ситуацији када је потребно извршити петљу одређени број пута.

#+begin_src rust
fn main() {
    for number in (1..4).rev() {
        println!("{}!", number);
    }
    println!("LIFTOFF!!!");
}
#+end_src

#+RESULTS:
: 3!
: 2!
: 1!
: LIFTOFF!!!
*** =for= и итератори
Приликом итерације употребом =for= исказа имплицитно се позива метода
=into_iter()= над колекцијом. Ова метода конзумира елементе колекције.

#+begin_src rust
fn main() {
    let names = vec!["Bob", "Frank", "Ferris"];

    for name in names.into_iter() {
        match name {
            "Ferris" => println!("There is a rustacean among us!"),
            _ => println!("Hello {}", name),
        }
    }

    // println!("names: {:?}", names); -- FIXME: колекција овде није доступна
}
#+end_src

#+REVEAL: split

#+begin_src rust
fn main() {
    let names = vec!["Bob", "Frank", "Ferris"];

    for name in names.iter() {
        match name {
            &"Ferris" => println!("There is a rustacean among us!"),
            // TODO ^ Try deleting the & and matching just "Ferris"
            _ => println!("Hello {}", name),
        }
    }

    println!("names: {:?}", names);
}
#+end_src

#+RESULTS:
: Hello Bob
: Hello Frank
: There is a rustacean among us!
: names: ["Bob", "Frank", "Ferris"]

#+REVEAL: split

#+begin_src rust
fn main() {
    let mut names = vec!["Bob", "Frank", "Ferris"];

    for name in names.iter_mut() {
        *name = match name {
            &mut "Ferris" => "There is a rustacean among us!",
            _ => "Hello",
        }
    }

    println!("names: {:?}", names);
}
#+end_src

#+RESULTS:
: names: ["Hello", "Hello", "There is a rustacean among us!"]

* Власништво и позајмљивање (/Ownership and borrowing/)
** Власништво
*** Власништво
- Један од најважнијих концепата језика.
- Скуп правила који омогућавају управљање меморијом.
- Гаранције за меморијску сигурност без употребе /garbage collector/-а
- Све провере се обављају у време компајлирања - резултује одличним
  перформансама у време извршавања.

*** Стек и хип (/Stack and Heap/)
- Стек - алокација простора за податке чија је величина позната у време
  компајлирања.
  - Бржа алокација и деалокација - једноставан механизам, LIFO структура.
  - Бржи приступ - локалне варијабле, кеширање приступа.
- Хип - слободна алокација у време извршавања.
  - Спорија алокација и деалокација.
  - Спорији приступ - произвољна локација.

*** Правила власништва
1. Свака вредност у Расту има варијаблу која се назива /власником/ (/owner/).
2. У сваком тренутку постоји само један власник.
3. Када власник изађе из опсега важења (/scope/) вредност се деалоцира (/drop/).

*** Опсег важења варијабле (/Variable Scope/)

#+begin_src rust
{                      // s није валидно овде јер још није декларисано
    let s = "hello";   // s је валидно од ове позиције

    // користимо s
}   // овде опсег престаје да важи и s више није валидно
#+end_src

*** =String= тип

- Демонстрација власништва над типом који се алоцира на хипу.

  #+begin_src rust
  let mut s = String::from("hello");
  s.push_str(", world!"); // push_str() додаје литерал на стринг
  println!("{}", s); // hello, world!`
  #+end_src

- Меморија се алоцира са хипа у време извршавања.
- Морамо вратити меморију алокатору када нам више није потребна.

#+REVEAL: split

- Алокација стринга се обавља на линији:

  #+begin_src rust
  let mut s = String::from("hello");
  #+end_src

- Али деалокација је тежа:
  - /Garbage collector/
  - /Memory waste/
  - /Double-free/

#+REVEAL: split

- Раст компајлер ће додати кôд који ради деалокацију када власник напусти опсег важења.
- Позива се функција =drop= над типом и ова функција је задужена да обави деалокацију.

  #+begin_src rust
  {
        let s = String::from("hello"); // s постаје валидно

        // користимо s
  }  // <- s излази из опсега и позива се "drop"
  #+end_src

*** Додела вредности
- Копирање вредности =x= у =y=. Обе варијабле сада имају вредност =5=.

  #+begin_src rust
  let x = 5;
  let y = x;
  #+end_src

- Али са =String= типом дешава се нешто друго.

  #+begin_src rust
  let s1 = String::from("hello");
  #+end_src

#+attr_html: :style height: 400px;
#+ATTR_ORG: :width 300px
[[./images/string-type.png]]

#+REVEAL: split

- Ако би се копирао само садржај са стека имали бисмо следећу ситуацију (тзв.
  /shallow copy/).

  #+begin_src rust
  let s1 = String::from("hello");
  let s2 = s1;
  #+end_src

#+attr_html: :style height: 400px;
#+ATTR_ORG: :width 300px
[[./images/string-type-2.png]]

Што је проблематично јер када и =s1= и =s2= напусте опсег покушаће се двострука
деалокација исте меморије на хипу (/double free/).

#+REVEAL: split

Ако би се и хип меморија копирала (tzv. /deep copy/) имали бисмо валидну ситуацију
али би таква операција била веома "скупа".

#+attr_html: :style height: 500px;
#+ATTR_ORG: :width 300px
[[./images/string-type-3.png]]

*** Премештање (/Move/)
Ако пробамо да компајлирамо следећи код:

#+begin_src rust
let s1 = String::from("hello");
let s2 = s1;

println!("{}, world!", s1);
#+end_src

Добићемо грешку:

#+begin_example
$ cargo run
   Compiling ownership v0.1.0 (file:///projects/ownership)
error[E0382]: borrow of moved value: `s1`
 --> src/main.rs:5:28
  |
2 |     let s1 = String::from("hello");
  |         -- move occurs because `s1` has type `String`, which does not implement the `Copy` trait
3 |     let s2 = s1;
  |              -- value moved here
4 |
5 |     println!("{}, world!", s1);
  |                            ^^ value borrowed here after move

For more information about this error, try `rustc --explain E0382`.
error: could not compile `ownership` due to previous error
#+end_example

#+REVEAL: split

Оно што нам компајлер каже је да се у исказу:

#+begin_src rust
let s2 = s1;
#+end_src

променио власник овог стринга. Нови власник је сада =s2= док је варијабла =s1=
постала невалидна и није је више могуће користити.

Кажемо да се обавило "премештање" (/move/) вредности из =s1= у =s2=.

#+attr_html: :style height: 400px;
#+ATTR_ORG: :width 300px
[[./images/string-type-4.png]]

Чиме се испуњава прво правило власништва и спречава /double free/ грешка.

*** Клонирање
Последица претходног је да Раст никада неће аутоматски обавити дубоко копирање
варијабле јер би то могло да изазове лоше перформансе.

Дубоко копирање (стек+хип) радимо са =clone= методом:

#+begin_src rust
let s1 = String::from("hello");
let s2 = s1.clone();

println!("s1 = {}, s2 = {}", s1, s2);
#+end_src

Сада је лако пронаћи у коду сва места где се обавља потенцијално "скупа"
операција дубоког копирања.

*** /Copy/ типови
Како онда ради пример који смо видели претходно? Зашто не долази до премештања
и инвалидације =y= варијабле?

#+begin_src rust
let x = 5;
let y = x;

println!("x = {}, y = {}", x, y);
#+end_src

- Код простих типова чија је величина позната у време компајлирања и који могу
  у целости стати на стек нема разлике између дубоког и плитког копирања.
- Овакви типови су анотирани са /Copy/ особином (/Trait/). Типови који су на овај
  начин анотирани не обављају премештање већ увек копирање.
- Импликација је да се варијабла са десне стране доделе може користити и након
  доделе.
- Раст ће спречити /Copy/ анотацију ако тип имплементира и /Drop/ јер то значи да
  ради неку специјалну алокацију па му је потребна и посебна деалокација што
  значи да мора да се ради премештање.

*** Власништво и функције
- Семантика преноса параметара код позива функција је слична семантици доделе.

#+begin_src rust
fn main() {
    let s = String::from("hello");  // s постаје валидно

    takes_ownership(s);             // s вредност се премешта у функцију...
                                    // ... тако да s није валидно од ове позиције

    let x = 5;                      // x постаје валидно

    makes_copy(x);                  // x би се преместило у функцију,
                                    // али i32 је Copy, тако да је ok
                                    // да се x користи и после

} // x излази из опсега, затим s. Али пошто је s премештено ништа посебно се
  // не дешава.

fn takes_ownership(some_string: String) { // some_string улази у опсег
    println!("{}", some_string);
} // some_string излази из опсега и позива се `drop`. Меморија са хипа се
  // ослобађа.

fn makes_copy(some_integer: i32) { // some_integer улази у опсег
    println!("{}", some_integer);
} // some_integer излази из опсега. Пошто није 'Drop', ништа посебно се не
  // догађа (осим "скидања" са стека наравно)
#+end_src

*** Повратне вредности и опсези
Приликом враћања вредности из функције такође може доћи до премештања власништва.

#+begin_src rust
fn main() {
    let s1 = gives_ownership();         // gives_ownership премешта повратну
                                        // вредност у s1

    let s2 = String::from("hello");     // s2 постаје валидно

    let s3 = takes_and_gives_back(s2);  // s2 се премешта у функцију
                                        // takes_and_gives_back, која премешта
                                        // повратну вредност у s3
} // s3 излази из опсега и позива се `drop`. s2 је премештена па се ништа
  // не дешава. s1 такође излази из опсега и деалоцира се.

fn gives_ownership() -> String {             // gives_ownership ће преместити
                                             // своју повратну вредност у функцију
                                             // која је позива

    let some_string = String::from("yours"); // some_string постаје валидно

    some_string                              // some_string се премешта
                                             // у функцију позиваоца
}

// Ова функција узима власништво над стрингом и враћа га назад
fn takes_and_gives_back(a_string: String) -> String { // a_string постаје валидно

    a_string  // a_string се премешта у функцију позиваоца
}
#+end_src

#+REVEAL: split

- Често нам је потребно да варијаблу користимо и после слања у функцију.
- Могли би је стало враћати заједно са резултатом функције на пример употребом торки.

#+begin_src rust
fn main() {
    let s1 = String::from("hello");

    let (s2, len) = calculate_length(s1);

    println!("The length of '{}' is {}.", s2, len);
}

fn calculate_length(s: String) -> (String, usize) {
    let length = s.len();

    (s, length)
}
#+end_src

Али је то напорно. Постоји концепт у Раст који је намењен оваквим
ситуацијама и базиран је на референцама и позајмљивању вредности.
** Референце и позајмљивање (/References and Borrowing/)
*** Референце и позајмљивање (/References and Borrowing/)
- Референца је попут поинтера, садржи адресу вредности коју поседује нека друга
  варијабла.
- За разлику од поинтера, референце у Расту су гарантовано валидне.

#+begin_src rust
fn main() {
    let s1 = String::from("hello");

    let len = calculate_length(&s1);

    println!("The length of '{}' is {}.", s1, len);
}

fn calculate_length(s: &String) -> usize {
    s.len()
}
#+end_src

#+attr_html: :style height: 400px;
#+ATTR_ORG: :width 300px
[[./images/reference.png]]

*** Референцирање
- Примена оператора =&= над варијаблом називамо /референцирање/.

  #+begin_src rust
  let s1 = String::from("hello");
  let len = calculate_length(&s1);
  #+end_src

- Синтакса =&s1= нам омогућава да креирамо референцу на вредност чији власник је
  =s1= без узимања власништва.
- Пошто референца није власник не долази до деалокације приликом изласка из
  опсега.
- Операција обрнута референцирању назива се /дереференцирање/ и врши се =*=
  оператором над референцом (нпр. =*s2= је вредност на коју референцира =s2=).
- Операцију референцирања називамо позајмљивањем (/borrowing/).

#+REVEAL: split

- Параметар функције може бити референца.
#+begin_src rust
fn calculate_length(s: &String) -> usize { // s је референца на String
    s.len()
} // s излази из опсега али пошто нема власништво над вредношћу
  // ништа се не дешава.
#+end_src

*** Промена позајмљене вредности
Шта се дешава уколико покушамо да модификујемо позајмљену вредност?

#+begin_src rust
fn main() {
    let s = String::from("hello");
    change(&s);
}

fn change(some_string: &String) {
    some_string.push_str(", world");
}
#+end_src

#+begin_example
$ cargo run
   Compiling ownership v0.1.0 (file:///projects/ownership)
error[E0596]: cannot borrow `*some_string` as mutable, as it is behind a `&` reference
 --> src/main.rs:8:5
  |
7 | fn change(some_string: &String) {
  |                        ------- help: consider changing this to be a mutable reference: `&mut String`
8 |     some_string.push_str(", world");
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ `some_string` is a `&` reference, so the data it refers
  to cannot be borrowed as mutable

For more information about this error, try `rustc --explain E0596`.
error: could not compile `ownership` due to previous error
#+end_example

*** Промењиве референце
Као и варијабле, и референце су подразумевано непромењива (/immutable/). Морамо
бити експлицитни уколико нам треба промењива референца.

#+begin_src rust
fn main() {
    let mut s = String::from("hello");
    change(&mut s);
}

fn change(some_string: &mut String) {
    some_string.push_str(", world");
}
#+end_src

*** Више промењивих референци над истом вредношћу
Раст не дозвољава да исти податак у једном тренутку има више промењивих
референци.

#+begin_src rust
let mut s = String::from("hello");

let r1 = &mut s;
let r2 = &mut s;

println!("{}, {}", r1, r2);
#+end_src

#+begin_example
$ cargo run
   Compiling ownership v0.1.0 (file:///projects/ownership)
error[E0499]: cannot borrow `s` as mutable more than once at a time
 --> src/main.rs:5:14
  |
4 |     let r1 = &mut s;
  |              ------ first mutable borrow occurs here
5 |     let r2 = &mut s;
  |              ^^^^^^ second mutable borrow occurs here
6 |
7 |     println!("{}, {}", r1, r2);
  |                        -- first borrow later used here

For more information about this error, try `rustc --explain E0499`.
error: could not compile `ownership` due to previous error
#+end_example

#+REVEAL: split

Овим ограничењем Раст, у време компајлирања, спречава класу грешака које
доводе до недефинисаног понашања и које зовемо /data races/. Ове грешке се веома
тешко откривају и отклањају и могу настати уколико су задовољени следећи
услови:

- Два или више поинтера приступају истим подацима у исто време,
- Бар један поинтер се користи за измену податка,
- Не постоји механизам за синхронизацију приступа.

#+REVEAL: split

Више промењивих референци можемо имати али не у истом опсегу:

#+begin_src rust
let mut s = String::from("hello");

{
    let r1 = &mut s;
} // r1 овде излази из опсега тако да можемо краирати нове референце

let r2 = &mut s;
#+end_src

*** Комбинација промењивих и непромењивих референци
Слично правило постоји и уколико имамо комбинацију промењивих и непромењивих
референци:

#+begin_src rust
let mut s = String::from("hello");

let r1 = &s; // ovo je OK
let r2 = &s; // ovo je OK
let r3 = &mut s; // GREŠKA!

println!("{}, {}, and {}", r1, r2, r3);
#+end_src

#+begin_example
$ cargo run
   Compiling ownership v0.1.0 (file:///projects/ownership)
error[E0502]: cannot borrow `s` as mutable because it is also borrowed as immutable
 --> src/main.rs:6:14
  |
4 |     let r1 = &s; // no problem
  |              -- immutable borrow occurs here
5 |     let r2 = &s; // no problem
6 |     let r3 = &mut s; // BIG PROBLEM
  |              ^^^^^^ mutable borrow occurs here
7 |
8 |     println!("{}, {}, and {}", r1, r2, r3);
  |                                -- immutable borrow later used here

For more information about this error, try `rustc --explain E0502`.
error: could not compile `ownership` due to previous error
#+end_example

#+REVEAL: split

- Не можемо истовремено имати непромењиве и промењиве референце јер корисници
  непромењивих референци не очекују да се подаци мењају.
- Можемо имати више непромењивих референци јер нико не може да мења податке и
  тиме утиче на друге.
- Промењиве референце често зовемо и /јединствене референце/ јер када су оне
  активне не може постојати друга референца на исту вредност.

*** Опсег важења референце
Опсег важења референце почиње од места где је уведена па до њене последње
употребе. На пример, ово је валидно:

#+begin_src rust
let mut s = String::from("hello");

let r1 = &s; // OK
let r2 = &s; // OK
println!("{} and {}", r1, r2);
// варијабле r1 и r2 се не користе у наставку па њихов опсег
// престаје да важи.

let r3 = &mut s; // зато је ово OK
println!("{}", r3);
#+end_src

Ова особина референци се назива /Non-Lexical Lifetimes (NLL)/.

*** "Висеће" референце
- У језицима са поинтерима лако је креирати поинтер на део меморије који је деалоциран.
- Раст гарантовано спречава овакве грешке. Референце су увек валидне у Расту.

#+begin_src rust
fn main() {
    let reference_to_nothing = dangle();
}

fn dangle() -> &String {
    let s = String::from("hello");

    &s
}
#+end_src

#+REVEAL: split

#+begin_example
$ cargo run
   Compiling ownership v0.1.0 (file:///projects/ownership)
error[E0106]: missing lifetime specifier
 --> src/main.rs:5:16
  |
5 | fn dangle() -> &String {
  |                ^ expected named lifetime parameter
  |
  = help: this function's return type contains a borrowed value, but there is no value
  for it to be borrowed from
help: consider using the `'static` lifetime
  |
5 | fn dangle() -> &'static String {
  |                ~~~~~~~~

For more information about this error, try `rustc --explain E0106`.
error: could not compile `ownership` due to previous error
#+end_example

- Механизам који ово спречава назива се "време живота" (/lifetime/) и биће
  детаљније обрађено у наставку.
- У преводу Раст нам поручује:

  #+begin_quote
  Тип повратне вредности ове функције је позајмљена вредност, али не постоји
  улазни параметар од кога може да се позајми.
  #+end_quote

*** Шта се тачно десило?
#+begin_src rust
fn dangle() -> &String { // dangle враћа референцу на String

    let s = String::from("hello"); // s је нови String

    &s // Враћамо референцу на String s
} // s излази из опсега и позива се `drop`. Меморија се ослобађа.
  // ОПАСНОСТ! Враћена референца ће бити "висећа".
#+end_src

Како се може решити. Вратићемо поседовану (/owned/) вредност, тј урадићемо
премештање вредности у функцију позиваоца.

#+begin_src rust
fn no_dangle() -> String {
    let s = String::from("hello");

    s
}
#+end_src

*** Правила референцирања
1. У сваком тренутку можемо имати или једну промењиву или произвољан број
   непромењивих референци.
2. Референце увек морају бити валидне.

** Исечци (/Slice/ тип)
*** /Slice/
- Исечци (/slices/) омогућавају референцирање континуалне секвенце унутар
  колекције уместо целе колекције

*** Пример
Функција која за задати стринг враћа прву реч.

#+begin_src rust
fn first_word(s: &String) -> usize {
    let bytes = s.as_bytes();

    for (i, &item) in bytes.iter().enumerate() {
        if item == b' ' {
            return i;
        }
    }

    s.len()
}
#+end_src

- Дакле, враћамо индекс краја речи. Позиваоц сада има потребне информације да дође до тражене речи.
- Проблем: два податка која су у вези али морамо ту везу ручно да одржавамо јер
  немамо гаранцију да ће број који је враћен бити валидан и у будућности (нпр.
  стринг може да се промени или да изађе из опсега).

#+REVEAL: split

#+begin_src rust
fn main() {
    let mut s = String::from("hello world");

    let word = first_word(&s); // word ће добити вредност 5

    s.clear(); // стринг s постаје ""

    // word је и даље 5 иако то више није исправно
}
#+end_src

#+REVEAL: split

Проблем постаје још озбиљнији ако нпр. напишемо функцију =second_word= која враћа
другу реч задатог стринга. По аналогији са претходним, требали би да вратимо
почетак и крај друге речи.

#+begin_src rust
fn second_word(s: &String) -> (usize, usize) {
#+end_src

Сада имамо три податка о којима морамо да водимо рачуна.

*** Стринг исечак
Проблем решавамо употребом исечака.

#+begin_src rust
let s = String::from("hello world");

let hello = &s[0..5];
let world = &s[6..11];
#+end_src

#+REVEAL_HTML: <div class="column" style="float:left; width: 55%">
Синтакса =s[x..y]= креира исечак над секвенцом =s=. С обзиром да овај тип (=[T]=) нема
познату величину у време компајлирања, не можемо га алоцирати на стеку, односно
не можемо га доделити локалним варијаблама или прослеђивати као параметар
функције. Зато се у пракси користи референца на исечак (=&[T]=) (често се зове и
/fat pointer/).

Дакле, у пракси много чешће срећемо синтаксу =&s[x..y]=.
#+REVEAL_HTML: </div>

#+REVEAL_HTML: <div class="column" style="float:right; width: 45%">
#+attr_html: :style height: 500px;
#+ATTR_ORG: :width 300px
[[./images/slice.png]]
#+REVEAL_HTML: </div>

#+REVEAL_HTML: <div style="clear: both;">

*** Исечци и синтакса опсега (/range/)
#+begin_src rust
let s = String::from("hello");

let slice = &s[0..2];
let slice = &s[..2];
#+end_src

#+begin_src rust
let s = String::from("hello");

let len = s.len();

let slice = &s[3..len];
let slice = &s[3..];
#+end_src

#+begin_src rust
let s = String::from("hello");

let len = s.len();

let slice = &s[0..len];
let slice = &s[..];
#+end_src

*** Модификација примера да користи стринг исечке
#+begin_src rust
fn first_word(s: &String) -> &str {
    let bytes = s.as_bytes();

    for (i, &item) in bytes.iter().enumerate() {
        if item == b' ' {
            return &s[0..i];
        }
    }

    &s[..]
}
#+end_src

Исти API и за =second_word=.

#+begin_src rust
fn second_word(s: &String) -> &str {
#+end_src

#+REVEAL: split

Сада нам компајлер осигурава да увек имамо валидну референцу на реч.
#+begin_src rust
fn main() {
    let mut s = String::from("hello world");

    let word = first_word(&s);

    s.clear(); // ГРЕШКА!

    println!("the first word is: {}", word);
}
#+end_src

#+begin_example
$ cargo run
   Compiling ownership v0.1.0 (file:///projects/ownership)
error[E0502]: cannot borrow `s` as mutable because it is also borrowed as immutable
  --> src/main.rs:18:5
   |
16 |     let word = first_word(&s);
   |                           -- immutable borrow occurs here
17 |
18 |     s.clear(); // error!
   |     ^^^^^^^^^ mutable borrow occurs here
19 |
20 |     println!("the first word is: {}", word);
   |                                       ---- immutable borrow later used here

For more information about this error, try `rustc --explain E0502`.
error: could not compile `ownership` due to previous error
#+end_example

Не само да је API лакши за употребу већ је читава класа грешака које се тешко
откривају елиминисана у време компајлирања.

*** Стринг литерали су референце на исечке
#+begin_src rust
let s = "Hello, world!";
#+end_src

Тип од =s= је =&str=. =str= је стринг исечак.

*** Стринг исечци као параметри функција
#+begin_src rust
fn first_word(s: &String) -> &str {
#+end_src

Али ће искусни Раст програмери писати:

#+begin_src rust
fn first_word(s: &str) -> &str {
#+end_src

Јер ће ова функција моћи да се користи и за =&str= и за =&String=. Овде се
употребљава тзв. /Deref Coercion/ односно могућности типова да се дереференцирају
у други тип. Нпр. =&String= ће се аутоматски дереференцирати у =&str= уколико је то
потребно. Операција је ефикасна.

#+REVEAL: split

#+begin_src rust
fn main() {
    let my_string = String::from("hello world");

    // `first_word` works on slices of `String`s, whether partial or whole
    let word = first_word(&my_string[0..6]);
    let word = first_word(&my_string[..]);
    // `first_word` also works on references to `String`s, which are equivalent
    // to whole slices of `String`s
    let word = first_word(&my_string);

    let my_string_literal = "hello world";

    // `first_word` works on slices of string literals, whether partial or whole
    let word = first_word(&my_string_literal[0..6]);
    let word = first_word(&my_string_literal[..]);

    // Because string literals *are* string slices already,
    // this works too, without the slice syntax!
    let word = first_word(my_string_literal);
}
#+end_src

*** Употреба исечака над другим структурама
#+begin_src rust
let a = [1, 2, 3, 4, 5];

let slice = &a[1..3]; // референца на исечак типа &[i32]

assert_eq!(slice, &[2, 3]);
#+end_src

* Структуре
** =struct= тип
Кориснички тип који омогућава груписање више логички повезаних вредности - поља
(/fields/).

У Расту постоје три врсте структура:
- Структуре торки (/tuple structs/) - у основи представљају именоване торке
- Класичне Ц-овске структуре
- Јединичне структуре (/unit structs/) - структуре без атрибута

** Дефиниција структуре
#+begin_src rust
struct User {
    active: bool,
    username: String,
    email: String,
    sign_in_count: u64,
}
#+end_src

** Креирање инстанце структуре
#+begin_src rust
fn main() {
    let user1 = User {
        active: true,
        username: String::from("someusername123"),
        email: String::from("someone@example.com"),
        sign_in_count: 1,
    };
}
#+end_src

** Промена вредности поља
#+begin_src rust
fn main() {
    let mut user1 = User {
        active: true,
        username: String::from("someusername123"),
        email: String::from("someone@example.com"),
        sign_in_count: 1,
    };

    user1.email = String::from("anotheremail@example.com");
}
#+end_src

** Креирање структуре путем функције
#+begin_src rust
fn build_user(email: String, username: String) -> User {
    User {
        active: true,
        username: username,
        email: email,
        sign_in_count: 1,
    }
}
#+end_src

** Употреба скраћеног облика
#+begin_src rust
fn build_user(email: String, username: String) -> User {
    User {
        active: true,
        username,
        email,
        sign_in_count: 1,
    }
}
#+end_src

** Креирање инстанце из друге инстанце употребом синтаксе за ажурирање (/update syntax/)
Уместо:
#+begin_src rust
fn main() {
    // --snip--
    let user2 = User {
        active: user1.active,
        username: user1.username,
        email: String::from("another@example.com"),
        sign_in_count: user1.sign_in_count,
    };
}
#+end_src

Можемо писати:
#+begin_src rust
fn main() {
    let user2 = User {
        email: String::from("another@example.com"),
        ..user1
    };
}
#+end_src

** Структуре торки
Тзв. /именоване торке/. Поља немају имена, приступа им се као код обичних торки
употребом =x.n= синтаксе где је =n= редни број поља.

#+begin_src rust
struct Color(i32, i32, i32);
struct Point(i32, i32, i32);

fn main() {
    let black = Color(0, 0, 0);
    let origin = Point(5, 8, 0);
    let y = origin.1;
    println!("{}", y);
}
#+end_src

#+RESULTS:
: 8

** Јединичне структуре - без поља
Користе се за креирање типова који имају понашање (имплементирају особине) али
не чувају податке (тзв. [[https://doc.rust-lang.org/nomicon/exotic-sizes.html#zero-sized-types-zsts][Zero Sized Types (ZSTs)]])

#+begin_src rust
struct AlwaysEqual;

fn main() {
    let subject = AlwaysEqual;
}
#+end_src

** Разни примери
#+begin_src rust
#[derive(Debug)]
struct Person {
    name: String,
    age: u8,
}

// A unit struct
struct Unit;

// A tuple struct
struct Pair(i32, f32);

// A struct with two fields
struct Point {
    x: f32,
    y: f32,
}
// Structs can be reused as fields of another struct
struct Rectangle {
    // A rectangle can be specified by where the top left and bottom right
    // corners are in space.
    top_left: Point,
    bottom_right: Point,
}
#+end_src

#+REVEAL: split

#+begin_src rust
// Create struct with field init shorthand
let name = String::from("Peter");
let age = 27;
let peter = Person { name, age };

// Print debug struct
println!("{:?}", peter);

// Instantiate a `Point`
let point: Point = Point { x: 10.3, y: 0.4 };

// Access the fields of the point
println!("point coordinates: ({}, {})", point.x, point.y);

// Make a new point by using struct update syntax to use the fields of our
// other one
let bottom_right = Point { x: 5.2, ..point };

// `bottom_right.y` will be the same as `point.y` because we used that field
// from `point`
println!("second point: ({}, {})", bottom_right.x, bottom_right.y);
#+end_src

#+REVEAL: split

#+begin_src rust
// Destructure the point using a `let` binding
let Point { x: left_edge, y: top_edge } = point;

let _rectangle = Rectangle {
    // struct instantiation is an expression too
    top_left: Point { x: left_edge, y: top_edge },
    bottom_right: bottom_right,
};

// Instantiate a unit struct
let _unit = Unit;

// Instantiate a tuple struct
let pair = Pair(1, 0.1);

// Access the fields of a tuple struct
println!("pair contains {:?} and {:?}", pair.0, pair.1);

// Destructure a tuple struct
let Pair(integer, decimal) = pair;

println!("pair contains {:?} and {:?}", integer, decimal);
#+end_src

* Енумерације
** /Enum/ тип
*** /Enum/ тип
- Дефинисање типа навођењем свих могућих варијанти
- Варијанта може да садржи додатне податке
- Слично са алгебарским типовима података (/algebraic data types/) у функционалним
  језицима, нпр. F#, OCaml и Haskell-у. Ова врста алгебарског типа је позната и
  под називом /sum type/.

*** Пример - IP адреса
- IP адреса представља идентификацију мрежних интерфејса у уређајима који
  комуницирају посредством Интернет протокола (/Internet Protocol - IP/).
- Тренутно имамо у употреби стару верзију 4 и нову верзију 6 која ће временом
  заменити верзију 4.
- Верзија 4 је дужине 32 бита и наводи се као четири октета у облику нпр.
  =192.0.2.1=
- Верзија 6 је дужине 128 бита и наводи се као 8 група од по 4 хекса цифре
  раздвојене са =:=, нпр. =2001:db8:0:1234:0:567:8:1=

#+REVEAL: split

У Расту можемо писати следеће:

#+begin_src rust
enum IpAddrKind {
    V4,
    V6,
}
#+end_src

Док вредности можемо креирати са:
#+begin_src rust
let four = IpAddrKind::V4;
let six = IpAddrKind::V6;
#+end_src

*** Пример - IP адреса - функција

Сада можемо писати функцију која прима овај тип чиме је могуће проследити било
коју варијанту као аргумент.

#+begin_src rust
fn route(ip_kind: IpAddrKind) {}

...

route(IpAddrKind::V4);
route(IpAddrKind::V6);
#+end_src

*** Пример - IP адреса - вредност

- Али како да дефинишемо конкретну вредност IP адресе?
- Прва идеја би могла бити да користимо структуру.

#+begin_src rust
enum IpAddrKind {
    V4,
    V6,
}

struct IpAddr {
    kind: IpAddrKind,
    address: String,
}

let home = IpAddr {
    kind: IpAddrKind::V4,
    address: String::from("127.0.0.1"),
};

let loopback = IpAddr {
    kind: IpAddrKind::V6,
    address: String::from("::1"),
};
#+end_src

#+REVEAL: split

Али, са =enum= типом можемо то урадити и боље. =Enum= варијанте могу садржати
додатне податке.

#+begin_src rust
enum IpAddr {
    V4(String),
    V6(String),
}

let home = IpAddr::V4(String::from("127.0.0.1"));

let loopback = IpAddr::V6(String::from("::1"));
#+end_src

#+REVEAL: split
Вредност садржана у варијанти не мора бити иста за све варијанте. На пример,
IPv4 се састоји од 4 октета и можда желимо да вредност наводимо и чувамо у том
облику.

#+begin_src rust
enum IpAddr {
    V4(u8, u8, u8, u8),
    V6(String),
}

let home = IpAddr::V4(127, 0, 0, 1);

let loopback = IpAddr::V6(String::from("::1"));
#+end_src

*** Пример - IP адреса - std библиотека

У стандардној библиотеци можемо пронаћи тип =IpAddr=. Дефинисан је на следећи
начин.

#+begin_src rust
struct Ipv4Addr {
    // --snip--
}

struct Ipv6Addr {
    // --snip--
}

enum IpAddr {
    V4(Ipv4Addr),
    V6(Ipv6Addr),
}
#+end_src

*** Пример  - /Message/

#+begin_src rust
enum Message {
    Quit,
    Move { x: i32, y: i32 },
    Write(String),
    ChangeColor(i32, i32, i32),
}
#+end_src

#+REVEAL: split
Следеће структуре садрже исте податке као претходни =enum= тип.

#+begin_src rust
struct QuitMessage; // unit struct
struct MoveMessage {
    x: i32,
    y: i32,
}
struct WriteMessage(String); // tuple struct
struct ChangeColorMessage(i32, i32, i32); // tuple struct
#+end_src

Али, предност =enum= типа је што је то јединствен тип па можемо нпр. направити
функцију која прима било коју вредност/варијанту овог типа.

#+REVEAL: split
Над =enum= типом, као и другим типовима, можемо имплементирати методе употребом
=imlp= кључне речи.

#+begin_src rust
impl Message {
    fn call(&self) {
        // тело методе се овде дефинише
    }
}

let m = Message::Write(String::from("hello"));
m.call();
#+end_src
*** Пример - /WebEvent/
#+begin_src rust
enum WebEvent {
    // An `enum` variant may either be `unit-like`,
    PageLoad,
    PageUnload,
    // like tuple structs,
    KeyPress(char),
    Paste(String),
    // or c-like structures.
    Click { x: i64, y: i64 },
}

fn inspect(event: WebEvent) {
    match event {
        WebEvent::PageLoad => println!("page loaded"),
        WebEvent::PageUnload => println!("page unloaded"),
        // Destructure `c` from inside the `enum` variant.
        WebEvent::KeyPress(c) => println!("pressed '{}'.", c),
        WebEvent::Paste(s) => println!("pasted \"{}\".", s),
        // Destructure `Click` into `x` and `y`.
        WebEvent::Click { x, y } => {
            println!("clicked at x={}, y={}.", x, y);
        },
    }
}
#+end_src

#+REVEAL: split

#+begin_src rust
fn main() {
    let pressed = WebEvent::KeyPress('x');
    // `to_owned()` creates an owned `String` from a string slice.
    let pasted  = WebEvent::Paste("my text".to_owned());
    let click   = WebEvent::Click { x: 20, y: 80 };
    let load    = WebEvent::PageLoad;
    let unload  = WebEvent::PageUnload;

    inspect(pressed);
    inspect(pasted);
    inspect(click);
    inspect(load);
    inspect(unload);
}
#+end_src

#+RESULTS:
: pressed 'x'.
: pasted "my text".
: clicked at x=20, y=80.
: page loaded
: page unloaded

*** Употреба =use= кључне речи
Варијанте можемо импортовати у текући опсег тако да се може избећи пуна
квалификација варијанти енумерисаног типа.

#+begin_src rust
enum Status {
    Rich,
    Poor,
}

enum Work {
    Civilian,
    Soldier,
}
#+end_src

#+REVEAL: split

#+begin_src rust
fn main() {
    // Explicitly `use` each name so they are available without
    // manual scoping.
    use crate::Status::{Poor, Rich};
    // Automatically `use` each name inside `Work`.
    use crate::Work::*;

    // Equivalent to `Status::Poor`.
    let status = Poor;
    // Equivalent to `Work::Civilian`.
    let work = Civilian;

    match status {
        // Note the lack of scoping because of the explicit `use` above.
        Rich => println!("The rich have lots of money!"),
        Poor => println!("The poor have no money..."),
    }

    match work {
        // Note again the lack of scoping.
        Civilian => println!("Civilians work!"),
        Soldier  => println!("Soldiers fight!"),
    }
}
#+end_src

*** Ц-овски енумерисани тип
Енумерисани тип у Расту се може користити као у Ц-у.

#+begin_src rust
// enum with implicit discriminator (starts at 0)
enum Number {
    Zero,
    One,
    Two,
}

// enum with explicit discriminator
enum Color {
    Red = 0xff0000,
    Green = 0x00ff00,
    Blue = 0x0000ff,
}

fn main() {
    // `enums` can be cast as integers.
    println!("zero is {}", Number::Zero as i32);
    println!("one is {}", Number::One as i32);

    println!("roses are #{:06x}", Color::Red as i32);
    println!("violets are #{:06x}", Color::Blue as i32);
}
#+end_src

#+RESULTS:
: zero is 0
: one is 1
: roses are #ff0000
: violets are #0000ff

*** Тест случај - повезана листа

#+begin_src rust
use crate::List::*;
enum List {
    Cons(u32, Box<List>),
    Nil,
}
impl List {
    fn new() -> List {
        Nil
    }
    fn prepend(self, elem: u32) -> List {
        Cons(elem, Box::new(self))
    }
    fn len(&self) -> u32 {
        match *self {
            Cons(_, ref tail) => 1 + tail.len(),
            Nil => 0
        }
    }
    fn stringify(&self) -> String {
        match *self {
            Cons(head, ref tail) => {
                format!("{}, {}", head, tail.stringify())
            },
            Nil => {
                format!("Nil")
            },
        }
    }
}
#+end_src

#+REVEAL: split

#+begin_src rust
fn main() {
    // Create an empty linked list
    let mut list = List::new();
    // Prepend some elements
    list = list.prepend(1);
    list = list.prepend(2);
    list = list.prepend(3);

    // Show the final state of the list
    println!("linked list has length: {}", list.len());
    println!("{}", list.stringify());
}
#+end_src

#+RESULTS:
: linked list has length: 3
: 3, 2, 1, Nil

** =Option= енумерација
*** =Option= енумерација
- Чест случај да вредност може бити нешто или ништа.
- Нпр. ако функција враћа први елемент из листе која није празна добићемо први
  елемент, међутим ако је листа празна повратна вредност је ништа.
- Овај концепт се у различитим језицима различито имплементира. Често се користи
  специјална вредност =null= (или =nil=, =none= и сл.) и све варијабле могу бити =null=
  или =non-null=. Проблем је што програмер не дефинише могућност ове вредности
  кроз тип па самим тим компајлер нема могућност да провери да ли код исправно
  обрађује ову могућност.

#+REVEAL: split

У презентацији из 2009 године под називом /Null References: The Billion Dollar
Mistake/ Tony Hoare, који је први увео =null= вредност као концепт је написао
следеће:

#+begin_quote
I call it my billion-dollar mistake. At that time, I was designing the first
comprehensive type system for references in an object-oriented language. My goal
was to ensure that all use of references should be absolutely safe, with
checking performed automatically by the compiler. But I couldn’t resist the
temptation to put in a null reference, simply because it was so easy to
implement. This has led to innumerable errors, vulnerabilities, and system
crashes, which have probably caused a billion dollars of pain and damage in the
last forty years.
#+end_quote

#+REVEAL: split

=Option= је генерички =enum= тип у Расту.
#+begin_src rust
enum Option<T> {
    None,
    Some(T),
}
#+end_src

Примери употребе:
#+begin_src rust
let some_number = Some(5);           // тип је Option<i32>
let some_string = Some("a string");  // тип је Option<&str>

let absent_number: Option<i32> = None;    // немогућа инференца
#+end_src

*** Зашто је =Option<T>= бољи од =null=?
#+begin_src rust
let x: i8 = 5;
let y: Option<i8> = Some(5);

let sum = x + y;
#+end_src

#+begin_example
$ cargo run
   Compiling enums v0.1.0 (file:///projects/enums)
error[E0277]: cannot add `Option<i8>` to `i8`
 --> src/main.rs:5:17
  |
5 |     let sum = x + y;
  |                 ^ no implementation for `i8 + Option<i8>`
  |
  = help: the trait `Add<Option<i8>>` is not implemented for `i8`

For more information about this error, try `rustc --explain E0277`.
error: could not compile `enums` due to previous error
#+end_example

*** Како обрађивати =Option<T>= податке?
- Морамо експлицитно обрадити вредност =Option<T>= и могућност да вредност буде
  =None=.
- =Option<T>= тип има [[https://doc.rust-lang.org/stable/std/option/enum.Option.html][богат API]] који је потребно знати јер је овај тип врло често
  у употреби.

#+begin_src rust
let x = Some(2);
let y = None;
assert_eq!(x.or(y), Some(2));

let x = None;
let y = Some(100);
assert_eq!(x.or(y), Some(100));
#+end_src

- Често користимо језичке конструкције које омогућавају обраду обе варијанте.

* Сложена контрола тока и подударање образаца (/Pattern Matching/)
** =match= израз
- Моћан израз контроле тока базиран на подударању образаца (/Pattern Matching/).
- Образац може бити литерал, назив варијабле, џокер (/wildcards/) итд.
- =match= израз ће извршити подударање уз исцрпљивање свих могућност. Уколико
  нека могућност није обрађена компајлер ће пријавити грешку.

** =match= као машина за сортирање новчића
За почетак можемо =match= израз посматрати као аутомат за сортирање новчића.

#+begin_src rust
enum Coin {
    Penny,
    Nickel,
    Dime,
    Quarter,
}

fn value_in_cents(coin: Coin) -> u8 {
    match coin {
        Coin::Penny => 1,
        Coin::Nickel => 5,
        Coin::Dime => 10,
        Coin::Quarter => 25,
    }
}
#+end_src

- =match= почиње са изразом произвољног типа.
- У телу се налазе "руке" (/arms/) где свака рука има леву страну која представља
  образац за подударање и десну страну (после ~=>~) која представља код који се
  евалуира у случају подударања. Руке су раздвојене зарезима.

#+REVEAL: split

- Руке се подударају у редоследу навођења.
- Повратна вредност целог =match= израза биће вредност евалуираног кода руке чије
  је подударање успело

#+REVEAL: split

Можемо на десној страни користити произвољан израз па и блок кода.
#+begin_src rust
fn value_in_cents(coin: Coin) -> u8 {
    match coin {
        Coin::Penny => {
            println!("Lucky penny!");
            1
        }
        Coin::Nickel => 5,
        Coin::Dime => 10,
        Coin::Quarter => 25,
    }
}
#+end_src

** Повезивање имена при подударању (/binding/)
#+begin_src rust
#[derive(Debug)]
enum UsState {
    Alabama,
    Alaska,
    Arizona,
    // --snip--
}

enum Coin {
    Penny,
    Nickel,
    Dime,
    Quarter(UsState),
}

fn value_in_cents(coin: Coin) -> u8 {
    match coin {
        Coin::Penny => 1,
        Coin::Nickel => 5,
        Coin::Dime => 10,
        Coin::Quarter(state) => {
            println!("State quarter from {:?}!", state);
            25
        }
    }
}
#+end_src

** =match= је исцрпан
#+begin_src rust
fn value_in_cents(coin: Coin) -> u8 {
    match coin {
        Coin::Penny => 1,
        Coin::Nickel => 5,
        Coin::Dime => 10,
        Coin::Quarter(UsState::Alabama) | Coin::Quarter(UsState::Alaska) => 25
    }
}
#+end_src

#+begin_example
$ cargo run
   Compiling match_test v0.1.0 (/home/igor/NTP/match_test)
error[E0004]: non-exhaustive patterns: `Quarter(Arizona)` not covered
  --> src/main.rs:21:11
   |
13 | / enum Coin {
14 | |     Penny,
15 | |     Nickel,
16 | |     Dime,
17 | |     Quarter(UsState),
   | |     ------- not covered
18 | | }
   | |_- `Coin` defined here
...
21 |       match coin {
   |             ^^^^ pattern `Quarter(Arizona)` not covered
   |
   = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms
   = note: the matched value is of type `Coin`
#+end_example

** Подударање са =Option<T>= типом
#+begin_src rust
fn plus_one(x: Option<i32>) -> Option<i32> {
    match x {
        None => None,
        Some(i) => Some(i + 1),
    }
}

let five = Some(5);
let six = plus_one(five);
let none = plus_one(None);
#+end_src

#+REVEAL: split

Пошто је =match= исцрпан не можемо заборавити да обрадимо =None= случај.

#+begin_src rust
fn plus_one(x: Option<i32>) -> Option<i32> {
    match x {
        Some(i) => Some(i + 1),
    }
}
#+end_src

#+begin_example
$ cargo run
   Compiling enums v0.1.0 (file:///projects/enums)
error[E0004]: non-exhaustive patterns: `None` not covered
   --> src/main.rs:3:15
    |
3   |         match x {
    |               ^ pattern `None` not covered
    |
    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms
    = note: the matched value is of type `Option<i32>`

For more information about this error, try `rustc --explain E0004`.
error: could not compile `enums` due to previous error
#+end_example

** Подразумевана обрада преосталих случајева
- Желимо на специфичан начин обрадимо само неколико случајева док за све остале
  радимо подразумевану обраду.

#+begin_src rust
let dice_roll = 9;
match dice_roll {
    3 => add_fancy_hat(),
    7 => remove_fancy_hat(),
    other => move_player(other),
}

fn add_fancy_hat() {}
fn remove_fancy_hat() {}
fn move_player(num_spaces: u8) {}
#+end_src

- Раст ће нас упозорити ако додамо руку после оне која обрађује све случајеве
  јер та се рука никада неће употребити.

#+REVEAL: split

Ако желимо да обрадимо све случајеве али нас вредност не интересује можемо
користити =_=.

#+begin_src rust
let dice_roll = 9;
match dice_roll {
    3 => add_fancy_hat(),
    7 => remove_fancy_hat(),
    _ => reroll(),
}

fn add_fancy_hat() {}
fn remove_fancy_hat() {}
fn reroll() {}
#+end_src
** Распакивање (/Destructuring/)
*** Распакивање торки
#+begin_src rust
fn main() {
    let triple = (0, -2, 3);
    // TODO ^ Try different values for `triple`

    println!("Tell me about {:?}", triple);
    // Match can be used to destructure a tuple
    match triple {
        // Destructure the second and third elements
        (0, y, z) => println!("First is `0`, `y` is {:?}, and `z` is {:?}", y, z),
        (1, ..)  => println!("First is `1` and the rest doesn't matter"),
        (.., 2)  => println!("last is `2` and the rest doesn't matter"),
        (3, .., 4)  => println!("First is `3`, last is `4`, and the rest doesn't matter"),
        // `..` can be used to ignore the rest of the tuple
        _      => println!("It doesn't matter what they are"),
        // `_` means don't bind the value to a variable
    }
}
#+end_src

*** Распакивање исечака
#+begin_src rust
fn main() {
    let array = [4, -2, 6];

    match array {
        [0, second, third] =>
            println!("array[0] = 0, array[1] = {}, array[2] = {}", second, third),
        [1, _, third] => println!(
            "array[0] = 1, array[2] = {} and array[1] was ignored",
            third
        ),
        [-1, second, ..] => println!(
            "array[0] = -1, array[1] = {} and all the other ones were ignored",
            second
        ),
        [3, second, tail @ ..] => println!(
            "array[0] = 3, array[1] = {} and the other elements were {:?}",
            second, tail
        ),
        [first, middle @ .., last] => println!(
            "array[0] = {}, middle = {:?}, array[2] = {}",
            first, middle, last
        ),
    }
}
#+end_src

#+RESULTS:
: array[0] = 4, middle = [-2], array[2] = 6

*** Распакивање енумерација
#+begin_src rust
#[allow(dead_code)]
enum Color {
    Red,
    Blue,
    Green,
    RGB(u32, u32, u32),
    HSV(u32, u32, u32),
    HSL(u32, u32, u32),
    CMY(u32, u32, u32),
    CMYK(u32, u32, u32, u32),
}
fn main() {
    let color = Color::RGB(122, 17, 40);
    println!("What color is it?");
    match color {
        Color::Red   => println!("The color is Red!"),
        Color::Blue  => println!("The color is Blue!"),
        Color::Green => println!("The color is Green!"),
        Color::RGB(r, g, b) =>
            println!("Red: {}, green: {}, and blue: {}!", r, g, b),
        Color::HSV(h, s, v) =>
            println!("Hue: {}, saturation: {}, value: {}!", h, s, v),
        Color::HSL(h, s, l) =>
            println!("Hue: {}, saturation: {}, lightness: {}!", h, s, l),
        Color::CMY(c, m, y) =>
            println!("Cyan: {}, magenta: {}, yellow: {}!", c, m, y),
        Color::CMYK(c, m, y, k) =>
            println!("Cyan: {}, magenta: {}, yellow: {}, key (black): {}!", c, m, y, k),
    }
}
#+end_src

*** Распакивање референци
#+begin_src rust
fn main() {
    let reference = &4;

    match reference {
        &val => println!("Got a value via destructuring: {:?}", val),
    }
    match *reference {
        val => println!("Got a value via dereferencing: {:?}", val),
    }
    let _not_a_reference = 3;

    let ref _is_a_reference = 3;

    let value = 5;
    let mut mut_value = 6;
    match value {
        ref r => println!("Got a reference to a value: {:?}", r),
    }
    match mut_value {
        ref mut m => {
            ,*m += 10;
            println!("We added 10. `mut_value`: {:?}", m);
        },
    }
}
#+end_src

#+RESULTS:
: Got a value via destructuring: 4
: Got a value via dereferencing: 4
: Got a reference to a value: 5
: We added 10. `mut_value`: 16

*** Распакивање структура
#+begin_src rust
fn main() {
    struct Foo {
        x: (u32, u32),
        y: u32,
    }

    let foo = Foo { x: (1, 2), y: 3 };
    match foo {
        Foo { x: (1, b), y } => println!("First of x is 1, b = {},  y = {} ", b, y),

        // you can destructure structs and rename the variables,
        // the order is not important
        Foo { y: 2, x: i } => println!("y is 2, i = {:?}", i),

        // and you can also ignore some variables:
        Foo { y, .. } => println!("y = {}, we don't care about x", y),
        // this will give an error: pattern does not mention field `x`
        //Foo { y } => println!("y = {}", y),
    }
}
#+end_src

** =if let= kontrola toka
=if let= нам омогућава комбинацију =if= и =let= исказа у мање опширан исказ за обраду
само једног случаја поклапања и игнорисање осталих.

#+begin_src rust
let config_max = Some(3u8);
match config_max {
    Some(max) => println!("The maximum is configured to be {}", max),
    _ => (),
}
#+end_src

Ово можемо концизније исказати са:

#+begin_src rust
let config_max = Some(3u8);
if let Some(max) = config_max {
    println!("The maximum is configured to be {}", max);
}
#+end_src

- Губимо исцрпност =match= израза.
- Синтаксни шећер у ситуацијама када желимо да игноришемо остале могућности.

#+REVEAL: split

** Поништиви и непоништиви обрасци
#+begin_note
Обрасци за подударање [[https://doc.rust-lang.org/book/ch18-02-refutability.html][могу имати две форме]]: поништив (/refutable/) и непоништив
(/irrefutable/). Образац који увек мора успети (нпр. =let x = 5;=) је непоништив.
Образац који не мора да успе увек је поништив (нпр. =if let Some(x) = a_value=
неће успети за ~a_value==None~).

Параметри функција, =let= искази и =for= петље прихватају само непоништиве обрасце
јер програм не може урадити ништа смислено уколико подударање не успе.

=if let= и =while let= прихватају и поништиве и непоништиве обрасце али ће нас
компајлер упозорити уколико користимо непоништиве.
#+end_note

#+REVEAL: split

Можемо користити и =else= грану. Следеће је еквивалентно.

#+begin_src rust
let mut count = 0;
match coin {
    Coin::Quarter(state) => println!("State quarter from {:?}!", state),
    _ => count += 1,
}
#+end_src

#+begin_src rust
let mut count = 0;
if let Coin::Quarter(state) = coin {
    println!("State quarter from {:?}!", state);
} else {
    count += 1;
}
#+end_src

** =let else=
Омогућава употребу поништивих образаца у исказима доделе. Уколико додела не
успева можемо дивергирати са =else= граном (нпр. =break=, =return=, =panic!=).

#+begin_src rust
use std::str::FromStr;

fn get_count_item(s: &str) -> (u64, &str) {
    let mut it = s.split(' ');
    let (Some(count_str), Some(item)) = (it.next(), it.next()) else {
        panic!("Can't segment count item pair: '{s}'");
    };
    let Ok(count) = u64::from_str(count_str) else {
        panic!("Can't parse integer: '{count_str}'");
    };
    (count, item)
}

assert_eq!(get_count_item("3 chairs"), (3, "chairs"));
#+end_src

** =while let=
Слично као =if let= и =while let= чини одређене конструкције са подударањем образаца
језгровитије.

На пример, ако имамо нешто попут:
#+begin_src rust
// Make `optional` of type `Option<i32>`
let mut optional = Some(0);

// Repeatedly try this test.
loop {
    match optional {
        // If `optional` destructures, evaluate the block.
        Some(i) => {
            if i > 9 {
                println!("Greater than 9, quit!");
                optional = None;
            } else {
                println!("`i` is `{:?}`. Try again.", i);
                optional = Some(i + 1);
            }
        },
        // Quit the loop when the destructure fails:
        _ => { break; }
    }
}
#+end_src

#+REVEAL: split

То можемо написати као:
#+begin_src rust
fn main() {
    // Make `optional` of type `Option<i32>`
    let mut optional = Some(0);

    // This reads: "while `let` destructures `optional` into
    // `Some(i)`, evaluate the block (`{}`). Else `break`.
    while let Some(i) = optional {
        if i > 9 {
            println!("Greater than 9, quit!");
            optional = None;
        } else {
            println!("`i` is `{:?}`. Try again.", i);
            optional = Some(i + 1);
        }
    }
}
#+end_src

* Колекције
** Вектор (=Vec<T>=)
*** Шта је вектор?
- Линеарна структура која омогућава смештање података у суседне локације у меморији.
- Хомогена структура. Елементи морају бити истог типа.

*** Креирање новог вектора
#+begin_src rust
let v: Vec<i32> = Vec::new();
#+end_src

- Морали смо додати анотацију типа јер је вектор генерички тип и компајлер не
  зна тип елемента које ћемо смештати у вектор.

- Ако креирамо вектор са већ постојећим елементима чешће користимо =vec!= макро:

  #+begin_src rust
    let v = vec![1, 2, 3];
  #+end_src
*** Ажурирање вектора
#+begin_src rust
let mut v = Vec::new();
v.push(5);
v.push(6);
v.push(7);
v.push(8);
#+end_src

*** Читање елемената вектора
- Индексни приступ или употреба =get= методе.

#+begin_src rust
let v = vec![1, 2, 3, 4, 5];

let third: &i32 = &v[2];
println!("The third element is {third}");

let third: Option<&i32> = v.get(2);
match third {
    Some(third) => println!("The third element is {third}"),
    None => println!("There is no third element."),
}
#+end_src

- Индексни приступ може да доведе до прекида програма уколико индексирамо ван
  опсега валидних индекса.
- =get= метода увек успева и враћа =Option<&T>=.

#+REVEAL: split

#+begin_src rust
let v = vec![1, 2, 3, 4, 5];

let does_not_exist = &v[100];
let does_not_exist = v.get(100);
#+end_src

- Први индексни приступ ће изазвати панику.
- Приступ са =get= би вратио =None=.

*** Провера позајмљивања у контексту вектора
- [[*Референце и позајмљивање (/References and Borrowing/)][Правила позајмљивања]] важе и у контексту вектора. Не можемо истовремено имати
  промењиву и непромењиву референцу на елемент вектора.

#+begin_src rust
let mut v = vec![1, 2, 3, 4, 5];
let first = &v[0];
v.push(6);
println!("The first element is: {first}");
#+end_src

#+begin_src
$ cargo run
   Compiling collections v0.1.0 (file:///projects/collections)
error[E0502]: cannot borrow `v` as mutable because it is also borrowed as immutable
 --> src/main.rs:6:5
  |
4 |     let first = &v[0];
  |                  - immutable borrow occurs here
5 |
6 |     v.push(6);
  |     ^^^^^^^^^ mutable borrow occurs here
7 |
8 |     println!("The first element is: {first}");
  |                                      ----- immutable borrow later used here

For more information about this error, try `rustc --explain E0502`.
error: could not compile `collections` due to previous error
#+end_src

#+REVEAL: split

#+begin_note
Имамо референцу на први елемент вектора а покушавамо промењивом референцом да
додамо на крај. Ово делује као да би било безбедно.

/Зашто Раст не дозвољава овакве операције?/

Приликом додавања новог елемента може доћи до попуњавања текуће алоциране зоне и
алоцирања нове зоне уз премештање свих елемената на нову локацију чиме би све
текуће референце постале невалидне. Правило позајмљивања спречава овакве грешке.
#+end_note

*** Итерација преко елемената вектора

#+begin_src rust
let v = vec![100, 32, 57];
for i in &v {
    println!("{i}");
}
#+end_src

#+RESULTS:
: 100
: 32
: 57

#+begin_note
Пошто итерирамо преко позајмљене вредности =&v=, тип од =i= ће бити позајмљен
(=&u32=). Уколико би итерирали преко поседоване вредности =for i in v= тада би сви
елементи из вектора били премештени (тј. конзумирани) од стране =for= петље и не
би могли више да им приступимо.
#+end_note

#+REVEAL: split

#+begin_src rust
let mut v = vec![100, 32, 57];
for i in &mut v {
    ,*i += 50;
}
println!("{v:?}");
#+end_src

#+RESULTS:
: [150, 82, 107]

*** Смештање елемената различитог типа
- Вектор може садржати само елементе истог типа.
- Уколико желимо да сместимо елементе различитог типа користимо енумерације.

#+begin_src rust
#[derive(Debug)]
enum SpreadsheetCell {
    Int(i32),
    Float(f64),
    Text(String),
}
let row = vec![
    SpreadsheetCell::Int(3),
    SpreadsheetCell::Text(String::from("blue")),
    SpreadsheetCell::Float(10.12),
];
println!("{row:?}");
#+end_src

#+RESULTS:
: [Int(3), Text("blue"), Float(10.12)]

- Употреба енумерација осигурава да ћемо обрадити све могуће случајеве нпр. =match= изразом.

*** Ослобађање елемената вектора
- Вектор ће деалоцирати своје елементе када власник напусти опсег важења.

#+begin_src rust
{
    let v = vec![1, 2, 3, 4];

    // do stuff with v
} // <- v goes out of scope and is freed here
#+end_src

** =String=
*** Шта је стринг?
- Раст има само један тип стринга подржан директно од стране језика - =str= који
  се обично користи у позајмљеној форми =&str= - стринг исечак који представља
  референцу на UTF-8 енкодован садржај.
- Тип =String=, дефинисан у Раст стандардној библиотеци, је растући, промењиви,
  поседовани UTF-8 енкодовани стринг тип.

*** Креирање новог стринга
- Нова празна =String= вредност се креира на следећи начин:
#+begin_src rust
let mut s = String::new();
#+end_src

Обично користимо =to_string= методу типа који имплементира =Display= особину да би
добили почетну вреност стринга.

#+begin_src rust
let data = "initial contents";

let s = data.to_string();

// the method also works on a literal directly:
let s = "initial contents".to_string();
#+end_src

Такође, можемо користити =String::from=:
#+begin_src rust
let s = String::from("initial contents");
#+end_src

*** Стринг може да садржи произвољну UTF-8 вредност
#+begin_src rust
let hello = String::from("السلام عليكم");
let hello = String::from("Dobrý den");
let hello = String::from("Hello");
let hello = String::from("שָׁלוֹם");
let hello = String::from("नमस्ते");
let hello = String::from("こんにちは");
let hello = String::from("안녕하세요");
let hello = String::from("你好");
let hello = String::from("Olá");
let hello = String::from("Здравствуйте");
let hello = String::from("Hola");
#+end_src

*** Ажурирање стринга
#+begin_src rust
let mut s = String::from("foo");
s.push_str("bar");
#+end_src

#+begin_src rust
let mut s1 = String::from("foo");
let s2 = "bar";
s1.push_str(s2);
println!("s2 is {s2}");
#+end_src

=s2= је позајмљено и може да се користи после додавања.

#+REVEAL: split

- Додавање једног карактера:
  #+begin_src rust
    let mut s = String::from("lo");
    s.push('l');
  #+end_src

*** Употреба =+= оператора
#+begin_src rust
let s1 = String::from("Hello, ");
let s2 = String::from("world!");
let s3 = s1 + &s2; // note s1 has been moved here and can no longer be used
#+end_src

=+= оператор конзумира први операнд тако да у претходном примеру =s1= варијабла не
важи после задње линије.

=+= оператор интерно користи =add= методу чија сигнатура је нешто попут:

#+begin_src rust
fn add(self, s: &str) -> String {
#+end_src

#+begin_note
Обратите пажњу да је други параметар типа =&str= док је прослеђен тип =&String=.
Компајлер ово прихвата. Зашто?

Користи се техника [[https://doc.rust-lang.org/std/ops/trait.Deref.html#more-on-deref-coercion][Deref coercion]], јер =String= имплементира особину =Deref<Target=str>=.
#+end_note

*** Употреба =format!= макроа
Уместо:
#+begin_src rust
let s1 = String::from("tic");
let s2 = String::from("tac");
let s3 = String::from("toe");

let s = s1 + "-" + &s2 + "-" + &s3;
#+end_src

Можемо писати:
#+begin_src rust
let s1 = String::from("tic");
let s2 = String::from("tac");
let s3 = String::from("toe");

let s = format!("{s1}-{s2}-{s3}");
#+end_src

*** Индексни приступ унутар стринга
#+begin_src rust
let s1 = String::from("hello");
let h = s1[0];
#+end_src

#+begin_src
$ cargo run
   Compiling collections v0.1.0 (file:///projects/collections)
error[E0277]: the type `String` cannot be indexed by `{integer}`
 --> src/main.rs:3:13
  |
3 |     let h = s1[0];
  |             ^^^^^ `String` cannot be indexed by `{integer}`
  |
  = help: the trait `Index<{integer}>` is not implemented for `String`
  = help: the following other types implement trait `Index<Idx>`:
            <String as Index<RangeFrom<usize>>>
            <String as Index<RangeFull>>
            <String as Index<RangeInclusive<usize>>>
            <String as Index<RangeTo<usize>>>
            <String as Index<RangeToInclusive<usize>>>
            <String as Index<std::ops::Range<usize>>>

For more information about this error, try `rustc --explain E0277`.
error: could not compile `collections` due to previous error
#+end_src

/Зашто?/

*** Чување стринга у меморији
#+begin_src rust
let hello = String::from("Hola");
println!("{}", hello.len());
#+end_src

#+RESULTS:
: 4

#+begin_src rust
let hello = String::from("Здраво");
println!("{}", hello.len());   // Дужина није 6 већ 12!
#+end_src

#+RESULTS:
: 12

Шта би требао да врати елемент на одређеном индексу?

*** Различити погледи на стринг
Три начина посматрања стринга: низ бајтова, низ скалара и низ графем кластера.

На пример, хинди реч "“नम�ते" ће у меморији бити следећи низ бајтова:
#+begin_src
[224, 164, 168, 224, 164, 174, 224, 164, 184, 224, 165, 141, 224, 164, 164,
224, 165, 135]
#+end_src

Ако исту реч посматрамо као низ скалара или карактера (Раст =char= тип) онда имамо
следеће вредности:

#+begin_src
['न', 'म', 'स', '◌्', 'त', '◌े ']
#+end_src

Четврти и шести карактер су дијакритици тј. немају смисла сами за себе.

Ако посматрамо исти садржај као графем кластере (најприближније концепту слова)
онда видимо следеће:

#+begin_src rust
["न", "म", "स्", "ते"]
#+end_src

*** Сложеност индексног приступа
Додатни разлог зашто не треба дозволити индексни приступ код стрингова јесте
чињеница да индексни приступ увак има сложеност =O(1)= што се код стрингова не
може гарантовати.

*** Креирање исечака
Могуће је креирање исечака стрингова с тим да је на програмеру да обезбеди да се
границе исечака налазе на крајевима =char= типа тј. није могуће да играница исечка
буде унутар карактера.

На пример, ово је могуће:
#+begin_src rust
let hello = "Здраво";
let s = &hello[0..4];
println!("{s}")
#+end_src

#+RESULTS:
: Зд

Али ово је грешка:
#+begin_src rust
let hello = "Здраво";
let s = &hello[0..3];
println!("{s}")
#+end_src

#+begin_src
thread 'main' panicked at 'byte index 3 is not a char boundary; it is inside 'д' (bytes 2..4)
of `Здраво`', src/main.rs:4:10
#+end_src

*** Итерација преко стрингова
Начин да обрадимо све елементе стринга је да итерирамо, при чему имамо две
методе:

- =chars= - ако желимо да обрадимо стринг као низ карактера
  #+begin_src rust
    for c in "Зд".chars() {
        println!("{c}");
    }
  #+end_src

- =bytes= - ако желимо да обрадимо стринг као низ бајтова
  #+begin_src rust
    for b in "Зд".bytes() {
        println!("{b}");
    }
  #+end_src

** Хеш мапа (=HashMap<K, V>=)
*** Шта је хеш мапа?
- Генеричка, хомогена структура која чува парове кључ-вреност.
- У другим језицима се зове још и: хеш табела, речник или асоцијативни низ.
- Корисно у ситацијама када је потребно пронаћи везани податак не по индексу већ
  по другој вредности.

*** Креирање хеш мапе
#+begin_src rust
use std::collections::HashMap;

let mut scores = HashMap::new();

scores.insert(String::from("Blue"), 10);
scores.insert(String::from("Yellow"), 50);
#+end_src

*** Приступање елементима хеш мапе
#+begin_src rust
use std::collections::HashMap;

let mut scores = HashMap::new();

scores.insert(String::from("Blue"), 10);
scores.insert(String::from("Yellow"), 50);

let team_name = String::from("Blue");
let score = scores.get(&team_name).copied().unwrap_or(0);
#+end_src

- =get= метода враћа тип =Option<&T>=, дакле =None= вредност ако за дати кључ не
  постоји везана вредност. Позивамо =copied= да добијемо =Option<T>= са копираном
  вредношћу.

*** Итерација преко парова кључ-вредност
#+begin_src rust
use std::collections::HashMap;

let mut scores = HashMap::new();

scores.insert(String::from("Blue"), 10);
scores.insert(String::from("Yellow"), 50);

for (key, value) in &scores {
    println!("{key}: {value}");
}
#+end_src

#+RESULTS:
: Yellow: 50
: Blue: 10

*** Хеш мапа и власништво
- Ако тип имплементира =Copy= особину биће копиран у мапу, у супротном биће
  премештен и хеш мапа постаје власник.

#+begin_src rust
use std::collections::HashMap;

let field_name = String::from("Favorite color");
let field_value = String::from("Blue");

let mut map = HashMap::new();
map.insert(field_name, field_value);
// field_name and field_value are invalid at this point, try using them and
// see what compiler error you get!
#+end_src

*** Ажурирање хеш мапе - преписивање вредности
#+begin_src rust
use std::collections::HashMap;

let mut scores = HashMap::new();

scores.insert(String::from("Blue"), 10);
scores.insert(String::from("Blue"), 25);

println!("{:?}", scores);
#+end_src

#+RESULTS:
: {"Blue": 25}

*** Ажурирање хеш мапе - додавање уклолико кључ не постоји
#+begin_src rust
use std::collections::HashMap;

let mut scores = HashMap::new();
scores.insert(String::from("Blue"), 10);

scores.entry(String::from("Yellow")).or_insert(50);
scores.entry(String::from("Blue")).or_insert(50);

println!("{:?}", scores);
#+end_src

#+RESULTS:
: {"Yellow": 50, "Blue": 10}

Користимо =Entry API=.

*** Ажурирање хеш мапе - на основу старе вредности
#+begin_src rust
use std::collections::HashMap;

let text = "hello world wonderful world";

let mut map = HashMap::new();

for word in text.split_whitespace() {
    let count = map.entry(word).or_insert(0);
    *count += 1;
}

println!("{:?}", map);
#+end_src

#+RESULTS:
: {"wonderful": 1, "hello": 1, "world": 2}

* Обрада грешака
** Категорије грешака у Расту
- грешке код којих је могућ опоравак (/recoverable/)
  - Грешке које очекивано могу да се десе у току рада и које можемо да обрадимо
    и наставимо извршавање без нарушавања конзитентности стања програма.
- грешке код којих опоравак није могућ (/unrecoverable/)
  - Увек су симптом багова у програму, нпр. читање ван опсега низа.
  - Једини логичан поступак је прекид рада програма.
- Већина језика не прави разлику већ све обрађује на исти начин, најчешће
  употребом механизма изузетака.

** =panic!=
- Макро који доводи до прекида програма. Позивамо га када програм заврши у стању
  у коме није могућ опоравак.

#+begin_src rust
fn main() {
    panic!("crash and burn");
}
#+end_src

#+begin_src sh
$ cargo run
   Compiling panic v0.1.0 (file:///projects/panic)
    Finished dev [unoptimized + debuginfo] target(s) in 0.25s
     Running `target/debug/panic`
thread 'main' panicked at 'crash and burn', src/main.rs:2:5
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace
#+end_src

** =panic!= повратни траг (/backtrace/)

#+begin_src rust
fn main() {
    let v = vec![1, 2, 3];

    v[99];
}
#+end_src

#+begin_src sh
$ cargo run
   Compiling panic v0.1.0 (file:///projects/panic)
    Finished dev [unoptimized + debuginfo] target(s) in 0.27s
     Running `target/debug/panic`
thread 'main' panicked at 'index out of bounds: the len is 3 but the index is 99', src/main.rs:4:5
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace
#+end_src

#+REVEAL: split

- Читамо линије повратног трага од горе до доле и интересује нас да пронађемо
  прво место где се помиње наш код. То је локација која је изазвала прекид.
#+begin_src sh
$ RUST_BACKTRACE=1 cargo run
thread 'main' panicked at 'index out of bounds: the len is 3 but the index is 99', src/main.rs:4:5
stack backtrace:
   0: rust_begin_unwind
             at /rustc/e092d0b6b43f2de967af0887873151bb1c0b18d3/library/std/src/panicking.rs:584:5
   1: core::panicking::panic_fmt
             at /rustc/e092d0b6b43f2de967af0887873151bb1c0b18d3/library/core/src/panicking.rs:142:14
   2: core::panicking::panic_bounds_check
             at /rustc/e092d0b6b43f2de967af0887873151bb1c0b18d3/library/core/src/panicking.rs:84:5
   3: <usize as core::slice::index::SliceIndex<[T]>>::index
             at /rustc/e092d0b6b43f2de967af0887873151bb1c0b18d3/library/core/src/slice/index.rs:242:10
   4: core::slice::index::<impl core::ops::index::Index<I> for [T]>::index
             at /rustc/e092d0b6b43f2de967af0887873151bb1c0b18d3/library/core/src/slice/index.rs:18:9
   5: <alloc::vec::Vec<T,A> as core::ops::index::Index<I>>::index
             at /rustc/e092d0b6b43f2de967af0887873151bb1c0b18d3/library/alloc/src/vec/mod.rs:2591:9
   6: panic::main
             at ./src/main.rs:4:5
   7: core::ops::function::FnOnce::call_once
             at /rustc/e092d0b6b43f2de967af0887873151bb1c0b18d3/library/core/src/ops/function.rs:248:5
note: Some details are omitted, run with `RUST_BACKTRACE=full` for a verbose backtrace.
#+end_src

#+REVEAL: split

#+begin_note
У програмском језику Ц, читање ван опсега је недефинисано понашање и компајлер
може да произведе кôд који ради произвољну ствар. Најчешће ће да чита са
локације која се налази иза краја низа што представља грешку /buffer overread/
која доводи до сигурносних пропуста.
#+end_note
** Опоравак од грешке - =Result<T,E>=
- Многе грешке су очекиване током нормалног извршавања програма.
- На пример, ако покушамо отварање фајла, он можда не постоји тако да би
  опоравак од грешке могао бити његово креирање.
- Код оваквих грешака Раст користи генерички тип =Result<T,E>=:

#+begin_src rust
enum Result<T, E> {
    Ok(T),
    Err(E),
}
#+end_src

** Отварање фајла

Фајл: =src/main.rs=:
#+begin_src rust
use std::fs::File;

fn main() {
    let greeting_file_result = File::open("hello.txt");
}
#+end_src

- Варијабла =greeting_file_result= ће бити типа =Result<std::fs::File,
  std::io::Error>=. Уколико је враћена варијанта =Ok= она ће у себи садржати фајл,
  уколико се врати варијанта =Err=, у њој ће бити грешка типа =std::io::Error=.

#+REVEAL: split

- У сваком случају морамо обрадити обе варијанте.
Фајл: =src/main.rs=:
#+begin_src rust
use std::fs::File;

fn main() {
    let greeting_file_result = File::open("hello.txt");

    let greeting_file = match greeting_file_result {
        Ok(file) => file,
        Err(error) => panic!("Problem opening the file: {:?}", error),
    };
}
#+end_src

** Препознавање различитих грешака
- Желимо да креирамо фајл уколико не постоји. Морамо да проверимо коју грешку
  смо добили.

#+begin_src rust
use std::fs::File;
use std::io::ErrorKind;

fn main() {
    let greeting_file_result = File::open("hello.txt");

    let greeting_file = match greeting_file_result {
        Ok(file) => file,
        Err(error) => match error.kind() {
            ErrorKind::NotFound => match File::create("hello.txt") {
                Ok(fc) => fc,
                Err(e) => panic!("Problem creating the file: {:?}", e),
            },
            other_error => {
                panic!("Problem opening the file: {:?}", other_error);
            }
        },
    };
}
#+end_src

#+REVEAL: split

- Алтернативно можемо користити API =Result= типа:

#+begin_src rust
use std::fs::File;
use std::io::ErrorKind;

fn main() {
    let greeting_file = File::open("hello.txt").unwrap_or_else(|error| {
        if error.kind() == ErrorKind::NotFound {
            File::create("hello.txt").unwrap_or_else(|error| {
                panic!("Problem creating the file: {:?}", error);
            })
        } else {
            panic!("Problem opening the file: {:?}", error);
        }
    });
}
#+end_src

** Пречица =unwrap=

- С обзиром да је оваква обрада честа, постоји пречица тако да можемо писати
  доста краће:

#+begin_src rust
use std::fs::File;

fn main() {
    let greeting_file = File::open("hello.txt").unwrap();
}
#+end_src

#+begin_src
thread 'main' panicked at 'called `Result::unwrap()` on an `Err` value: Os {
code: 2, kind: NotFound, message: "No such file or directory" }',
src/main.rs:4:49
#+end_src

** Пречица =expect=
- Или, уколико желимо да дамо више информација у случају прекида:

#+begin_src rust
use std::fs::File;

fn main() {
    let greeting_file = File::open("hello.txt")
        .expect("hello.txt should be included in this project");
}
#+end_src

#+begin_src
thread 'main' panicked at 'hello.txt should be included in this project: Os {
code: 2, kind: NotFound, message: "No such file or directory" }',
src/main.rs:5:10
#+end_src

** Пропагација грешака

#+begin_src rust
use std::fs::File;
use std::io::{self, Read};

fn read_username_from_file() -> Result<String, io::Error> {
    let username_file_result = File::open("hello.txt");

    let mut username_file = match username_file_result {
        Ok(file) => file,
        Err(e) => return Err(e),
    };

    let mut username = String::new();

    match username_file.read_to_string(&mut username) {
        Ok(_) => Ok(username),
        Err(e) => Err(e),
    }
}
#+end_src

Сада позиваоц може да одлучи како да обради грешку. Нпр. може да:
- прекине програм са =panic!=
- користи подразумевано корисничко име
- пронађе корисничко име на неком другом месту (нпр. из базе података)

** Пречица за пропагацију грешака - оператор =?=

#+begin_src rust
use std::fs::File;
use std::io::{self, Read};

fn read_username_from_file() -> Result<String, io::Error> {
    let mut username_file = File::open("hello.txt")?;
    let mut username = String::new();
    username_file.read_to_string(&mut username)?;
    Ok(username)
}
#+end_src

- Оператор =?= елиминише тзв. /boilerplate/ код.
- Функција мора да враћа компатибилан тип да би могла да се користи ова пречица.

#+REVEAL: split

#+begin_note
Постоји значајна разлика између =?= оператора и =match= израза. =?= оператор ће
аутоматски радити конверзију грешака за све грешке које имплементирају =From=
особину. На пример, ако нека наша грешка =OurError= имплементира конверзију из
=std::io::Error= тако што имамо =impl From<std::io::Error> for OurError= тада можемо
декларисати да наша функција враћа =OurError= и даље користити пречицу =?= на
местима која резултују са =std::io::Error=.
#+end_note

** Додатно скраћење кода
- Употребом повезаних позива /chain call/ можемо додатно поједноставити код:

#+begin_src rust
use std::fs::File;
use std::io::{self, Read};

fn read_username_from_file() -> Result<String, io::Error> {
    let mut username = String::new();

    File::open("hello.txt")?.read_to_string(&mut username)?;

    Ok(username)
}
#+end_src

** Употреба =?= оператора код =Option= типа
#+begin_src rust
fn last_char_of_first_line(text: &str) -> Option<char> {
    text.lines().next()?.chars().last()
}
#+end_src

** Употреба =?= оператора у функцији =main=

#+begin_src rust
use std::error::Error;
use std::fs::File;

fn main() -> Result<(), Box<dyn Error>> {
    let greeting_file = File::open("hello.txt")?;

    Ok(())
}
#+end_src

* Пакети, сандуци и модули
** Организација програмског кода
- Са порастом величине пројекта расте значај организације кода.
- Раст механизми за организацију кода су:
  - Пакети
  - Сандуци (/crates/)
  - Модули и кључна реч =use=
  - Путање (/paths/)
** Сандуци (/crates/)
- Сандук представља најмању количину кода коју Раст компајлер обрађује у једном тренутку.
- Сандук може бити у форми /бинарног сандука/ и /библиотечког сандука/.
- Бинарни сандук представља програме који могу да се компајлирају и покрену. Ови
  сандуци имају функцију =main= која представља улазну тачку.
- Библиотечки сандуци представљају функционалност намењену за дељење са другим пројектима.
- Корен сандука представља почетни фајл од кога Раст компајлер креће, односно
  представља коренски модул.

** Пакети
- Пакет представља скуп логички повезаних сандука којима се управља на
  јединствен начин.
- Пакет мора имати бар један сандук.
- Пакет може имати произвољно много бинарних сандука али највише један
  библиотечки сандук.

** Креирање пакета

#+begin_src sh
$ cargo new my-project
     Created binary (application) `my-project` package
$ ls my-project
Cargo.toml
src
$ ls my-project/src
main.rs
#+end_src

- Сваки пакети у корену има =Cargo.toml= конфигурациони фајл.
- Према конвенцији корен бинарног сандука је =src/main.rs=, док је корен
  библиотечког сандука =src/lib.rs=.
- Ако пакет има више бинарних сандука, коренски фајлови се смештају у фолдер =src/bin=.

** Структура пакета
#+begin_src text
backyard
├── Cargo.lock
├── Cargo.toml              <- конфигурација пакета
└── src
    ├── garden
    │   └── vegetables.rs   <- модул
    ├── garden.rs           <- модул
    └── main.rs             <- корен бинарног сандука
#+end_src

** Груписање повезаног кода у модуле
- У циљу читљивости, лакшег проналаска и поновне искористљивости, модули нам омогућавају организацију кода унутар сандука у виду стабла.
- Модули, такође, омогућавају дефинисање правила приступа. Сви елементи унутар
  модула су подразумевано приватни.

** Пример употребе модула
#+begin_src sh
cargo new restaurant --lib
#+end_src

Фајл: src/lib.rs
#+begin_src rust
mod front_of_house {
    mod hosting {
        fn add_to_waitlist() {}

        fn seat_at_table() {}
    }

    mod serving {
        fn take_order() {}

        fn serve_order() {}

        fn take_payment() {}
    }
}
#+end_src

Модули могу имати друге модуле, структуре, енумерације, константе, особине итд.

** Стабло модула (/module tree/)
Модули се повезују и чине структуру типа стабла чији корен је корен сандука
(=main.rs= ili =lib.rs=).

#+begin_src text
crate
 └── front_of_house
     ├── hosting
     │   ├── add_to_waitlist
     │   └── seat_at_table
     └── serving
         ├── take_order
         ├── serve_order
         └── take_payment
#+end_src

Аналогија је систем фајлова и фолдера.

** Путање унутар стабла модула
Елементи Раст кода се могу референцирати путањама које синтаксни елемент за
навигацију над стаблом модула.

Постоје две врсте путања:
- /апсолутна путања/ - пуна путања која почиње од корена сандука. Започиње са
  речју =crate=.
- /релативна путања/ - путања која се гради релативно од позиције где се наводи.
  Може да користи кључне речи =self= i =super=.

** Пример апсолутне и релативне путање
#+begin_src rust
mod front_of_house {
    mod hosting {
        fn add_to_waitlist() {}
    }
}

pub fn eat_at_restaurant() {
    // Absolute path
    crate::front_of_house::hosting::add_to_waitlist();

    // Relative path
    front_of_house::hosting::add_to_waitlist();
}
#+end_src

** Видљивост елемената унутар модула
- Претходни пример се не компајлира.

#+begin_src rust
$ cargo build
   Compiling restaurant v0.1.0 (file:///projects/restaurant)
error[E0603]: module `hosting` is private
 --> src/lib.rs:9:28
  |
9 |     crate::front_of_house::hosting::add_to_waitlist();
  |                            ^^^^^^^ private module
  |
note: the module `hosting` is defined here
 --> src/lib.rs:2:5
  |
2 |     mod hosting {
  |     ^^^^^^^^^^^

error[E0603]: module `hosting` is private
  --> src/lib.rs:12:21
   |
12 |     front_of_house::hosting::add_to_waitlist();
   |                     ^^^^^^^ private module
   |
note: the module `hosting` is defined here
  --> src/lib.rs:2:5
   |
2  |     mod hosting {
   |     ^^^^^^^^^^^

For more information about this error, try `rustc --explain E0603`.
error: could not compile `restaurant` due to 2 previous errors
#+end_src

#+REVEAL: split

Ако учинимо модул =hosting= јавним:

#+begin_src rust
mod front_of_house {
    pub mod hosting {
        fn add_to_waitlist() {}
    }
}

pub fn eat_at_restaurant() {
    // Absolute path
    crate::front_of_house::hosting::add_to_waitlist();

    // Relative path
    front_of_house::hosting::add_to_waitlist();
}
#+end_src

#+REVEAL: split

И даље имамо грешку:
#+begin_src rust
$ cargo build
   Compiling restaurant v0.1.0 (file:///projects/restaurant)
error[E0603]: function `add_to_waitlist` is private
 --> src/lib.rs:9:37
  |
9 |     crate::front_of_house::hosting::add_to_waitlist();
  |                                     ^^^^^^^^^^^^^^^ private function
  |
note: the function `add_to_waitlist` is defined here
 --> src/lib.rs:3:9
  |
3 |         fn add_to_waitlist() {}
  |         ^^^^^^^^^^^^^^^^^^^^

error[E0603]: function `add_to_waitlist` is private
  --> src/lib.rs:12:30
   |
12 |     front_of_house::hosting::add_to_waitlist();
   |                              ^^^^^^^^^^^^^^^ private function
   |
note: the function `add_to_waitlist` is defined here
  --> src/lib.rs:3:9
   |
3  |         fn add_to_waitlist() {}
   |         ^^^^^^^^^^^^^^^^^^^^

For more information about this error, try `rustc --explain E0603`.
error: could not compile `restaurant` due to 2 previous errors
#+end_src

#+REVEAL: split

Морамо учинити и функцију =add_to_waitlist= јавном јер иако је модул јаван његови
елементи су подразумевано приватни.

#+begin_src rust
mod front_of_house {
    pub mod hosting {
        pub fn add_to_waitlist() {}
    }
}

pub fn eat_at_restaurant() {
    // Absolute path
    crate::front_of_house::hosting::add_to_waitlist();

    // Relative path
    front_of_house::hosting::add_to_waitlist();
}
#+end_src

** Јавни API

Код који је јавно доступан ван библиотечког сандука чини јавни API библиотеке и
представља "уговор" са корисницима библиотеке. Стога је важно поштовати одређена
правила измене ових елемената.

Делови кода који нису споља јавно доступни могу слободно да се мењају јер неће
утицати на кориснике.

** Релативне путање и употреба =super=
- =super= се користи у ситуацији када релативну путању креирамо са почетком у
  родитељском модулу.

#+begin_src rust
fn deliver_order() {}

mod back_of_house {
    fn fix_incorrect_order() {
        cook_order();
        super::deliver_order();
    }

    fn cook_order() {}
}
#+end_src

** Јавни приступ структурама и енумерацијама
- Постоји одређена разлика у третирању =pub= кључне речи када су у питању
  структуре и енумерације.
- Структуре које имају јавни приступ и даље подразумевано имају приватан приступ пољима.
#+begin_src rust
mod back_of_house {
    pub struct Breakfast {
        pub toast: String,
        seasonal_fruit: String,
    }
    impl Breakfast {
        pub fn summer(toast: &str) -> Breakfast {
            Breakfast {
                toast: String::from(toast),
                seasonal_fruit: String::from("peaches"),
            }
        }
    }
}
pub fn eat_at_restaurant() {
    let mut meal = back_of_house::Breakfast::summer("Rye");

    meal.toast = String::from("Wheat");
    println!("I'd like {} toast please", meal.toast);

    // Следећа линија се не компајлира јер је поље приватно
    // meal.seasonal_fruit = String::from("blueberries");
}
#+end_src

#+REVEAL: split

Са друге стране, варијанте енумерација су увек јавне:

#+begin_src rust
mod back_of_house {
    pub enum Appetizer {
        Soup,
        Salad,
    }
}

pub fn eat_at_restaurant() {
    let order1 = back_of_house::Appetizer::Soup;
    let order2 = back_of_house::Appetizer::Salad;
}
#+end_src

** Увођење елемената у опсег - кључна реч =use=
- Употреба пуних путања за свако навођење језичког елемента је оптерећујуће и
  лоше утиче на читкост кода.
- Употребом кључне речи =use= можемо увести елемент у текући опсег.

#+begin_src rust
mod front_of_house {
    pub mod hosting {
        pub fn add_to_waitlist() {}
    }
}

use crate::front_of_house::hosting;

pub fn eat_at_restaurant() {
    hosting::add_to_waitlist();
}
#+end_src

Аналогно креирању пречица (/shortcuts/) у фајл систему.

** =use= само креира пречицу
Следећи пример се не компајлира јер смо поморили функцију =eat_at_restaurant= у
модул =customer= и релативна пречица више није валидна.

#+begin_src rust
mod front_of_house {
    pub mod hosting {
        pub fn add_to_waitlist() {}
    }
}

use crate::front_of_house::hosting;

mod customer {
    pub fn eat_at_restaurant() {
        hosting::add_to_waitlist();
    }
}
#+end_src

** Креирање идиоматских путања
- Када уводимо функцију у опсег обично то радимо увођењем родитељског модула
  како смо видели на претходном примеру.
- Ако уводимо типове (структуре, енумерације) наводимо их директно.
- На пример, увођење структуре =HashMap= из стандардне библиотеке:

#+begin_src rust
use std::collections::HashMap;

fn main() {
    let mut map = HashMap::new();
    map.insert(1, 2);
}
#+end_src

** Употреба кључне речи =as= за промену имена
Раст не дозвољава да постоје различити елементи у опсегу са истим именом.
Уколико желимо да уведемо елементе са истим називом можемо:
- Увести родитељски модул, као у следећем примеру:
  #+begin_src rust
    use std::fmt;
    use std::io;
    fn function1() -> fmt::Result {
        // --snip--
    }

    fn function2() -> io::Result<()> {
        // --snip--
    }
  #+end_src

- Променити име у текућем опсегу употребом кључне речи =as=.
  #+begin_src rust
    use std::fmt::Result;
    use std::io::Result as IoResult;
    fn function1() -> Result {
        // --snip--
    }

    fn function2() -> IoResult<()> {
        // --snip--
    }
  #+end_src

** Реекспорт имена са =pub use=
- Када уведемо име у опсег са =use= он је приватан за приступ споља.
- Уколико желимо да буде јаван споља можемо користити =pub use=.

#+begin_src rust
mod front_of_house {
    pub mod hosting {
        pub fn add_to_waitlist() {}
    }
}

pub use crate::front_of_house::hosting;

pub fn eat_at_restaurant() {
    hosting::add_to_waitlist();
}
#+end_src

- Ово се често користи када јавни API библиотеке треба да буде различит од
  интерне организације кода.

** Употреба екстерних пакета

Фајл =Cargo.toml=:
#+begin_src rust
...
[dependencies]
rand = "0.8.5"
...
#+end_src

И затим можемо увести елементе из =rand= сандука са:
#+begin_src rust
use rand::Rng;

fn main() {
    let secret_number = rand::thread_rng().gen_range(1..=100);
}
#+end_src

#+REVEAL: split

Пакети се подразумевано преузимају са =crates.io=. =std= библиотека је сандук, увек
је локално присутан, није потребно посебно га наводити у конфигурацији али је
елементе које користимо потребно увести.

#+begin_src rust
use std::collections::HashMap;
#+end_src

** Угњеждене путање при увођењу
- Ако уводимо више елемената из истог модула можемо користити скраћени угњеждени
  запис.

- На пример:
  #+begin_src rust
    // --snip--
    use std::cmp::Ordering;
    use std::io;
    // --snip--
  #+end_src

- Можемо писати као:
  #+begin_src rust
    // --snip--
    use std::{cmp::Ordering, io};
    // --snip--
  #+end_src

#+REVEAL: split

- Moжемо истовремено увести и модул и неке од његових елемената. На пример,
  уместо:
  #+begin_src rust
    use std::io;
    use std::io::Write;
  #+end_src
- Можемо писати:
  #+begin_src rust
    use std::io::{self, Write};
  #+end_src

** /Glob/ оператор

- Ако желимо да уведемо све елементе неког модула можемо писати:
  #+begin_src rust
    use std::collections::*;
  #+end_src

** Подела модула у посебне фајлове
Модуле често пишемо у посебним фајловима због лакшег приступа и организације.

Фајл =src/lib.rs=:
#+begin_src rust
pub mod front_of_house;    // <- наводимо име фајла модула

pub use crate::front_of_house::hosting;

pub fn eat_at_restaurant() {
    hosting::add_to_waitlist();
}
#+end_src

А затим у фајлу =src/front_of_house.rs=
#+begin_src rust
pub mod hosting {
    pub fn add_to_waitlist() {}
}
#+end_src

#+REVEAL: split

А можемо даље декомпоновати и извући модул =hosting= из фајла =front_of_house.rs=:

Фајл =src/front_of_house.rs=:
#+begin_src rust
pub mod hosting;
#+end_src

Фајл =src/front_of_house/hosting.rs=:
#+begin_src rust
pub fn add_to_waitlist() {}
#+end_src

#+begin_note
=mod= је потребно навести само једном. Тиме се модул увезује у стабло модула и
могуће га је референцирати путањама из остатка кода. Односно, =mod= није исто што
и =include= из других програмских језика.
#+end_note

* Тестирање
** Тестирање
#+begin_quote
Program testing can be a very effective way to show the presence of bugs, but it
is hopelessly inadequate for showing their absence.

                            -- Edsger W. Dijkstra, “The Humble Programmer”, 1972
#+end_quote

#+REVEAL: split

- Раст систем типова и провера позајмица спречава појаву шире класе логичких
  грешака али не може да предупреди појаву свих грешака. На пример, Раст не може
  да провери да ће одређан функција да ради тачно оно што је програмер замислио.
- Одређена класа логичких грешака захтева креирање тестова.

** Како писати тестове?

1. Поставити потребно стање и податке.
2. Извршити код који се тестира са датим улазима.
3. Потврдити да је резултат извршавања очекиван.

** Анатомија тест функције
#+begin_src rust
$ cargo new adder --lib
     Created library `adder` project
$ cd adder
#+end_src

Генерисан тест ће бити:

Фајл =src/lib.rs=:
#+begin_src rust
#[cfg(test)]
mod tests {
    #[test]
    fn it_works() {
        let result = 2 + 2;
        assert_eq!(result, 4);
    }
}
#+end_src

** Покретање теста
#+begin_src sh
$ cargo test
   Compiling adder v0.1.0 (file:///projects/adder)
    Finished test [unoptimized + debuginfo] target(s) in 0.57s
     Running unittests src/lib.rs (target/debug/deps/adder-92948b65e88960b4)

running 1 test
test tests::it_works ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

   Doc-tests adder

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s
#+end_src

** Пример теста 1

#+begin_src rust
#[derive(Debug)]
struct Rectangle {
    width: u32,
    height: u32,
}

impl Rectangle {
    fn can_hold(&self, other: &Rectangle) -> bool {
        self.width > other.width && self.height > other.height
    }
}
#+end_src

#+REVEAL: split

#+begin_src rust
#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn larger_can_hold_smaller() {
        let larger = Rectangle {
            width: 8,
            height: 7,
        };
        let smaller = Rectangle {
            width: 5,
            height: 1,
        };

        assert!(larger.can_hold(&smaller));
    }
}
#+end_src

#+REVEAL: split

#+begin_src sh
$ cargo test
   Compiling rectangle v0.1.0 (file:///projects/rectangle)
    Finished test [unoptimized + debuginfo] target(s) in 0.66s
     Running unittests src/lib.rs (target/debug/deps/rectangle-6584c4561e48942e)

running 1 test
test tests::larger_can_hold_smaller ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

   Doc-tests rectangle

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s
#+end_src

** Пример теста 2
#+begin_src rust
#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn larger_can_hold_smaller() {
        // --snip--
    }

    #[test]
    fn smaller_cannot_hold_larger() {
        let larger = Rectangle {
            width: 8,
            height: 7,
        };
        let smaller = Rectangle {
            width: 5,
            height: 1,
        };

        assert!(!smaller.can_hold(&larger));
    }
}
#+end_src

#+REVEAL: split

#+begin_src sh
$ cargo test
   Compiling rectangle v0.1.0 (file:///projects/rectangle)
    Finished test [unoptimized + debuginfo] target(s) in 0.66s
     Running unittests src/lib.rs (target/debug/deps/rectangle-6584c4561e48942e)

running 2 tests
test tests::larger_can_hold_smaller ... ok
test tests::smaller_cannot_hold_larger ... ok

test result: ok. 2 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

   Doc-tests rectangle

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s
#+end_src

** Неуспешан тест

- Намерно уводимо грешку у код да видимо како излгеда када тест не успева:
#+begin_src rust
// --snip--
impl Rectangle {
    fn can_hold(&self, other: &Rectangle) -> bool {
        self.width < other.width && self.height > other.height
    }
}
#+end_src

#+REVEAL: split

#+begin_src sh
$ cargo test
   Compiling rectangle v0.1.0 (file:///projects/rectangle)
    Finished test [unoptimized + debuginfo] target(s) in 0.66s
     Running unittests src/lib.rs (target/debug/deps/rectangle-6584c4561e48942e)

running 2 tests
test tests::larger_can_hold_smaller ... FAILED
test tests::smaller_cannot_hold_larger ... ok

failures:

---- tests::larger_can_hold_smaller stdout ----
thread 'tests::larger_can_hold_smaller' panicked at 'assertion failed: larger.can_hold(&smaller)', src/lib.rs:28:9
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

failures:
    tests::larger_can_hold_smaller

test result: FAILED. 1 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

error: test failed, to rerun pass `--lib`
#+end_src

** Тестирање једнакости и неједнакости - =assert_eq!= и =assert_ne!=

#+begin_src rust
pub fn add_two(a: i32) -> i32 {
    a + 2
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn it_adds_two() {
        assert_eq!(4, add_two(2));
    }
}
#+end_src

#+REVEAL: split

#+begin_src sh
$ cargo test
   Compiling adder v0.1.0 (file:///projects/adder)
    Finished test [unoptimized + debuginfo] target(s) in 0.58s
     Running unittests src/lib.rs (target/debug/deps/adder-92948b65e88960b4)

running 1 test
test tests::it_adds_two ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

   Doc-tests adder

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s
#+end_src

#+REVEAL: split

Уколико тест не успе:

#+begin_src rust
pub fn add_two(a: i32) -> i32 {
    a + 3
}
#+end_src

#+REVEAL: split

#+begin_src sh
$ cargo test
   Compiling adder v0.1.0 (file:///projects/adder)
    Finished test [unoptimized + debuginfo] target(s) in 0.61s
     Running unittests src/lib.rs (target/debug/deps/adder-92948b65e88960b4)

running 1 test
test tests::it_adds_two ... FAILED

failures:

---- tests::it_adds_two stdout ----
thread 'tests::it_adds_two' panicked at 'assertion failed: `(left == right)`
  left: `4`,
 right: `5`', src/lib.rs:11:9
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace


failures:
    tests::it_adds_two

test result: FAILED. 0 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

error: test failed, to rerun pass `--lib`
#+end_src

** Произвољна корисничка порука
#+begin_src rust
#[test]
    fn greeting_contains_name() {
        let result = greeting("Carol");
        assert!(
            result.contains("Carol"),
            "Greeting did not contain name, value was `{}`",
            result
        );
    }

#+end_src

#+REVEAL: split

#+begin_src sh
$ cargo test
   Compiling greeter v0.1.0 (file:///projects/greeter)
    Finished test [unoptimized + debuginfo] target(s) in 0.93s
     Running unittests src/lib.rs (target/debug/deps/greeter-170b942eb5bf5e3a)

running 1 test
test tests::greeting_contains_name ... FAILED

failures:

---- tests::greeting_contains_name stdout ----
thread 'tests::greeting_contains_name'
panicked at 'Greeting did not contain name, value was `Hello!`', src/lib.rs:12:9
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace


failures:
    tests::greeting_contains_name

test result: FAILED. 0 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out;
finished in 0.00s

error: test failed, to rerun pass `--lib`
#+end_src

** Провера =should_panic=

#+begin_src rust
pub struct Guess {
    value: i32,
}

impl Guess {
    pub fn new(value: i32) -> Guess {
        if value < 1 || value > 100 {
            panic!("Guess value must be between 1 and 100, got {}.", value);
        }

        Guess { value }
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    #[should_panic]
    fn greater_than_100() {
        Guess::new(200);
    }
}
#+end_src

#+REVEAL: split

#+begin_src rust
impl Guess {
    pub fn new(value: i32) -> Guess {
        if value < 1 {
            panic!(
                "Guess value must be greater than or equal to 1, got {}.",
                value
            );
        } else if value > 100 {
            panic!(
                "Guess value must be less than or equal to 100, got {}.",
                value
            );
        }
        Guess { value }
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    #[test]
    #[should_panic(expected = "less than or equal to 100")]
    fn greater_than_100() {
        Guess::new(200);
    }
}
#+end_src
** Филтрирање тестова при покретању
#+begin_src rust
pub fn add_two(a: i32) -> i32 {
    a + 2
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn add_two_and_two() {
        assert_eq!(4, add_two(2));
    }

    #[test]
    fn add_three_and_two() {
        assert_eq!(5, add_two(3));
    }

    #[test]
    fn one_hundred() {
        assert_eq!(102, add_two(100));
    }
}
#+end_src

#+REVEAL: split

#+begin_src sh
$ cargo test one_hundred
   Compiling adder v0.1.0 (file:///projects/adder)
    Finished test [unoptimized + debuginfo] target(s) in 0.69s
     Running unittests src/lib.rs (target/debug/deps/adder-92948b65e88960b4)

running 1 test
test tests::one_hundred ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 2 filtered out; finished in 0.00s
#+end_src

#+REVEAL: split

#+begin_src sh
$ cargo test add
   Compiling adder v0.1.0 (file:///projects/adder)
    Finished test [unoptimized + debuginfo] target(s) in 0.61s
     Running unittests src/lib.rs (target/debug/deps/adder-92948b65e88960b4)

running 2 tests
test tests::add_three_and_two ... ok
test tests::add_two_and_two ... ok

test result: ok. 2 passed; 0 failed; 0 ignored; 0 measured; 1 filtered out; finished in 0.00s
#+end_src

* Генерички типови, особине (/Traits/) и животни век (/Lifetimes/)
** Генерички типови (/generics/)
*** Генерички типови (/generics/)
- Механизам за елиминацију дуплирања кода.
- Генерички типови су апстрактне замене за конкретне типове у друге особине у
  време извршавања.
- Омогућавају нам да на апстрактан начин искажемо особине типова и њихове везе
  са другим типовима без знања о томе који ће се конкретни типови наћи на
  њиховом месту у време компајлирања и извршавања кода.
- На пример функције могу примити генеричке параметре. Такође, сложени типови
  могу бити параметризовани генеричким типовима (пример је =Option<T>=).

*** Уклањање дуплог кода употребом функција
#+begin_src rust
fn main() {
    let number_list = vec![34, 50, 25, 100, 65];

    let mut largest = number_list[0];

    for number in number_list {
        if number > largest {
            largest = number;
        }
    }

    println!("The largest number is {}", largest);
}
#+end_src

#+REVEAL: split

#+begin_src rust
fn main() {
    let number_list = vec![34, 50, 25, 100, 65];

    let mut largest = number_list[0];

    for number in number_list {
        if number > largest {
            largest = number;
        }
    }

    println!("The largest number is {}", largest);

    let number_list = vec![102, 34, 6000, 89, 54, 2, 43, 8];

    let mut largest = number_list[0];

    for number in number_list {
        if number > largest {
            largest = number;
        }
    }

    println!("The largest number is {}", largest);
}
#+end_src

Дуплирање кода!

#+REVEAL: split

Елиминишемо дуплирање увођењем функције.

#+begin_src rust
fn largest(list: &[i32]) -> i32 {
    let mut largest = list[0];

    for &item in list {
        if item > largest {
            largest = item;
        }
    }

    largest
}

fn main() {
    let number_list = vec![34, 50, 25, 100, 65];

    let result = largest(&number_list);
    println!("The largest number is {}", result);

    let number_list = vec![102, 34, 6000, 89, 54, 2, 43, 8];

    let result = largest(&number_list);
    println!("The largest number is {}", result);
}
#+end_src


#+REVEAL: split

Поступак елиминације дуплог кода је подразумевао следеће:

1. Идентификација дуплог кода.
2. Екстракција кода у функцију, дефинисање параметара и повратне вредности.
3. Замена инстанци дуплог кода са позивом функције.

*** Уклањање дуплог кода употребом генеричких функција
Имамо функцију за проналажење највећег елемента у листи са различитим типовима.
#+begin_src rust
fn largest_i32(list: &[i32]) -> i32 {
    let mut largest = list[0];
    for &item in list {
        if item > largest {
            largest = item;
        }
    }
    largest
}
fn largest_char(list: &[char]) -> char {
    let mut largest = list[0];
    for &item in list {
        if item > largest {
            largest = item;
        }
    }
    largest
}
fn main() {
    let number_list = vec![34, 50, 25, 100, 65];
    let result = largest_i32(&number_list);
    println!("The largest number is {}", result);
    let char_list = vec!['y', 'm', 'a', 'q'];
    let result = largest_char(&char_list);
    println!("The largest char is {}", result);
}
#+end_src

#+REVEAL: split

Функције су готово идентичне. Разлика је само у типу. Пишемо генеричку функцију
тако што дефинишемо генерички тип унутар =<>= после назива функције:

#+begin_src rust
fn largest<T>(list: &[T]) -> T {
#+end_src

=T= је генерички тип и у време компајлирања биће замењен са конкретним типом.

#+REVEAL: split

Сада је наш код следећи:

#+begin_src rust
fn largest<T>(list: &[T]) -> T {
    let mut largest = list[0];

    for &item in list {
        if item > largest {
            largest = item;
        }
    }

    largest
}

fn main() {
    let number_list = vec![34, 50, 25, 100, 65];

    let result = largest(&number_list);
    println!("The largest number is {}", result);

    let char_list = vec!['y', 'm', 'a', 'q'];

    let result = largest(&char_list);
    println!("The largest char is {}", result);
}
#+end_src

#+REVEAL: split

Али се не компајлира.

#+begin_src rust
$ cargo run
   Compiling chapter10 v0.1.0 (file:///projects/chapter10)
error[E0369]: binary operation `>` cannot be applied to type `T`
 --> src/main.rs:5:17
  |
5 |         if item > largest {
  |            ---- ^ ------- T
  |            |
  |            T
  |
help: consider restricting type parameter `T`
  |
1 | fn largest<T: std::cmp::PartialOrd>(list: &[T]) -> T {
  |             ++++++++++++++++++++++

For more information about this error, try `rustc --explain E0369`.
error: could not compile `chapter10` due to previous error
#+end_src

Тип =T= може бити било који тип па и тип који не дефинише операцију =>= која се
користи у коду. Дакле, морамо ограничити који типови су могући.

Видећемо како се ово ради у наставку у причи о особинама (/Traits/).

*** Генерички типови у структурама
#+begin_src rust
struct Point<T> {
    x: T,
    y: T,
}

fn main() {
    let integer = Point { x: 5, y: 10 };
    let float = Point { x: 1.0, y: 4.0 };
}
#+end_src

#+REVEAL: split

Типови оба поља морају бити исти.

#+begin_src rust
struct Point<T> {
    x: T,
    y: T,
}

fn main() {
    let wont_work = Point { x: 5, y: 4.0 };
}
#+end_src

#+begin_example
$ cargo run
   Compiling chapter10 v0.1.0 (file:///projects/chapter10)
error[E0308]: mismatched types
 --> src/main.rs:7:38
  |
7 |     let wont_work = Point { x: 5, y: 4.0 };
  |                                      ^^^ expected integer, found floating-point number

For more information about this error, try `rustc --explain E0308`.
error: could not compile `chapter10` due to previous error
#+end_example

#+REVEAL: split

Ако желимо да поља имају различите типове онда морамо имати различите генеричке типове.

#+begin_src rust
struct Point<T, U> {
    x: T,
    y: U,
}

fn main() {
    let both_integer = Point { x: 5, y: 10 };
    let both_float = Point { x: 1.0, y: 4.0 };
    let integer_and_float = Point { x: 5, y: 4.0 };
}
#+end_src

*** Генерички типови у енумерацијама
#+begin_src rust
enum Option<T> {
    Some(T),
    None,
}
#+end_src

#+REVEAL: split

#+begin_src rust
enum Result<T, E> {
    Ok(T),
    Err(E),
}
#+end_src

*** Дефиниције метода
#+begin_src rust
struct Point<T> {
    x: T,
    y: T,
}

impl<T> Point<T> {
    fn x(&self) -> &T {
        &self.x
    }
}

fn main() {
    let p = Point { x: 5, y: 10 };

    println!("p.x = {}", p.x());
}
#+end_src

Пошто смо навели =<T>= иза кључне речи =impl= Раст даље зна да је тип =T= генерички
а не конкретни тип тако да је метода =x= за =Point<T>= дефинисана над свим типовима
=T=.

#+REVEAL: split

Могли смо нпр. методу дефинисати само за одређени =Point= тип.

#+begin_src rust
impl Point<f32> {
    fn distance_from_origin(&self) -> f32 {
        (self.x.powi(2) + self.y.powi(2)).sqrt()
    }
}
#+end_src

Овај =impl= блок дефинише методу =distance_from_origin= али само за =Point<f32>= док
остали =Point= типови неће имати ову методу.

*** Генерички типови у методама и =impl= блоковима
Генерички типови у структурама и методама не морају бити исти. На пример, можемо
креирати методу =mixup= која узима две инстанце =Point= и враћа нови =Point= тип где
ће прво поље имати исти тип као прва тачка а друго поље као друга тачка.

#+begin_src rust
struct Point<X1, Y1> {
    x: X1,
    y: Y1,
}

impl<X1, Y1> Point<X1, Y1> {
    fn mixup<X2, Y2>(self, other: Point<X2, Y2>) -> Point<X1, Y2> {
        Point {
            x: self.x,
            y: other.y,
        }
    }
}

fn main() {
    let p1 = Point { x: 5, y: 10.4 };
    let p2 = Point { x: "Hello", y: 'c' };
    let p3 = p1.mixup(p2);
    println!("p3.x = {}, p3.y = {}", p3.x, p3.y);
}
#+end_src

- Генерички типови =X2= и =Y2= су наведени само у методи јер су релевантни само у
  њеном контексту.

*** Перформансе
Употреба генеричког кода не доводи до деградације перформанси. Раст користи
технику мономорфизације (/Monomorphization/) код које ће компајлер инстанцирати
конкретан код за сваки тип посебно.

То би значило следеће. Ако имамо код:

#+begin_src rust
let integer = Some(5);
let float = Some(5.0)
#+end_src

Компајлер ће произвести код еквивалентан следећем:
#+begin_src rust
enum Option_i32 {
    Some(i32),
    None,
}

enum Option_f64 {
    Some(f64),
    None,
}

fn main() {
    let integer = Option_i32::Some(5);
    let float = Option_f64::Some(5.0);
}
#+end_src
** Особине (/Traits/) - дефинисање заједничког понашања
*** Особине (/Traits/)
- Особина дефинише функционалност коју тип може делити са другим типовима.
- У другим језицима сличан концепт назива се интерфејс.
- Можемо користити /ограничења кроз особине/ (/Trait bounds/) да дефинишемо да
  генерички тип мора задовољити одређена ограничења.

*** Дефинисање особина
- Пример дефинисања /media aggregator/ библиотеке која може да приказе сажетак
  података који се може чувати у =NewsArticle= или =Tweet= инстанци.
- Дефинишемо =Summary= особину да опишемо ову функционалност.

#+begin_src rust
pub trait Summary {
    fn summarize(&self) -> String;
}
#+end_src

*** Имплементација особина
#+begin_src rust
pub struct NewsArticle {
    pub headline: String,
    pub location: String,
    pub author: String,
    pub content: String,
}

impl Summary for NewsArticle {
    fn summarize(&self) -> String {
        format!("{}, by {} ({})", self.headline, self.author, self.location)
    }
}

pub struct Tweet {
    pub username: String,
    pub content: String,
    pub reply: bool,
    pub retweet: bool,
}

impl Summary for Tweet {
    fn summarize(&self) -> String {
        format!("{}: {}", self.username, self.content)
    }
}
#+end_src

#+REVEAL: split

Методе особина се позивају као и обичне методе. Једина разлика је у томе што
методе особина морају бити доступне у опсегу (укључити их са =use=).

#+begin_src rust
use aggregator::{Summary, Tweet};

fn main() {
    let tweet = Tweet {
        username: String::from("horse_ebooks"),
        content: String::from(
            "of course, as you probably already know, people",
        ),
        reply: false,
        retweet: false,
    };

    println!("1 new tweet: {}", tweet.summarize());
}
#+end_src

#+REVEAL: split

#+begin_note
Ограничење у употреби особина је да можемо имплементирати особину над типом
једино ако је бар једно од њих локално за наш сандук. Ово правило је део скупа
правила који се називају /coherence/. Конкретно ово правило зове се /orphan rule/ и
спречава некомпатибилне имплементације особина над типовима од стране више
сандука.

Без овог правила могло би се десити да два различита сандука имплементирају исту
особину над истим типом на различите начине и компајлер не би знао коју верзију
да користи.
#+end_note
*** Подразумевана имплементација
Особина може имати подразумевану имплементацију метода.

#+begin_src rust
pub trait Summary {
    fn summarize(&self) -> String {
        String::from("(Read more...)")
    }
}
#+end_src

Да би користили подразумевану имплементацију можемо навести празно тело у =impl=
блоку:

#+begin_src rust
impl Summary for NewsArticle {}
#+end_src

#+REVEAL: split

И затим можемо позвати =summarize= методу:

#+begin_src rust
let article = NewsArticle {
        headline: String::from("Penguins win the Stanley Cup Championship!"),
        location: String::from("Pittsburgh, PA, USA"),
        author: String::from("Iceburgh"),
        content: String::from(
            "The Pittsburgh Penguins once again are the best \
             hockey team in the NHL.",
        ),
    };

    println!("New article available! {}", article.summarize());
#+end_src

#+REVEAL: split

- Подразумевана имплементација може бити редефинисана приликом имплементације.
- Такође, подразумеване методе могу позивати друге методе.

#+begin_src rust
pub trait Summary {
    fn summarize_author(&self) -> String;

    fn summarize(&self) -> String {
        format!("(Read more from {}...)", self.summarize_author())
    }
}
#+end_src

Сада је потребно и довољно да приликом имплементације дефинишемо
=summarize_author= методу:

#+begin_src rust
impl Summary for Tweet {
    fn summarize_author(&self) -> String {
        format!("@{}", self.username)
    }
}
#+end_src
*** Особине као параметри
- Сада можемо користити особине да дефинишемо функције које раде над параметрима
  различитог типа.

#+begin_src rust
pub fn notify(item: &impl Summary) {
    println!("Breaking news! {}", item.summarize());
}
#+end_src

Функција =notify= ради над свим типовима који имплементирају =Summary=.

#+REVEAL: split

Претходна употреба =impl= код параметра је синтаксни шећер за општи облик
навођења ограничења кроз особине.

#+begin_src rust
pub fn notify<T: Summary>(item: &T) {
    println!("Breaking news! {}", item.summarize());
}
#+end_src

Ограничења кроз особине (/Trait bounds/) стављамо после двотачке код навођења
генеричког типа. Компајлер ће верификовати да све што користимо над вредностима
овог типа унутар функције је заиста дефинисано особинама наведеним у заглављу.

#+REVEAL: split

=impl Trait= синтаксе је концизнија код једноставних примера али је пуна синтакса
боља код сложенијих примера.

На пример:

#+begin_src rust
pub fn notify(item1: &impl Summary, item2: &impl Summary) {
#+end_src

би у пуној синтакси било:

#+begin_src rust
pub fn notify<T: Summary>(item1: &T, item2: &T) {
#+end_src

*** Вишеструке особине код ограничења
Можемо дефинисати и више ограничења употребом =+= синтаксе. На пример, ако
параметар мора да имплементира =Summary= и =Display=:
#+begin_src rust
pub fn notify(item: &(impl Summary + Display)) {
#+end_src

или у пуној синтакси:

#+begin_src rust
pub fn notify<T: Summary + Display>(item: &T) {
#+end_src

*** =where= клаузула у ограничењима
- Уколико имамо више ограничења основна синтакса може да смањи читкост.

#+begin_src rust
fn some_function<T: Display + Clone, U: Clone + Debug>(t: &T, u: &U) -> i32 {
#+end_src

- =where= клаузула измешта дефинисање ограничења после заглавља функције чиме
  се постиже боља читкост:

#+begin_src rust
fn some_function<T, U>(t: &T, u: &U) -> i32
    where T: Display + Clone,
          U: Clone + Debug
{
#+end_src

*** =impl Trait= као повратна вредност функције
#+begin_src rust
fn returns_summarizable() -> impl Summary {
    Tweet {
        username: String::from("horse_ebooks"),
        content: String::from(
            "of course, as you probably already know, people",
        ),
        reply: false,
        retweet: false,
    }
}
#+end_src

Посебно значајно у контексту затворења (/closures/) и итератора где је конкретан
тип превише сложен за писање или је познат само компајлеру.

#+begin_note
=impl Trait= синтакса за повратне вредности је могућа само ако функција враћа
један тип који имплементира дату особину. На пример, ова функција неће радити
ако функција може вратити =NewsArticle= или =Tweet=.
#+end_note

*** Поправка =largest= генеричке функције
На претходним сладовима имали смо функцију =largest=. Сада можемо да завршимо
њену дефиницију.

Грешка је била следећа:
#+begin_example
$ cargo run
   Compiling chapter10 v0.1.0 (file:///projects/chapter10)
error[E0369]: binary operation `>` cannot be applied to type `T`
 --> src/main.rs:5:17
  |
5 |         if item > largest {
  |            ---- ^ ------- T
  |            |
  |            T
  |
help: consider restricting type parameter `T`
  |
1 | fn largest<T: std::cmp::PartialOrd>(list: &[T]) -> T {
  |             ++++++++++++++++++++++

For more information about this error, try `rustc --explain E0369`.
error: could not compile `chapter10` due to previous error
#+end_example

#+REVEAL: split

Дакле, морамо ограничити типове на оне који подржавају поређење. Ова особина се
у стандардној библиотеци зове =std::cmp::PartialOrd=, па ћемо преправити заглавље
функције на следећи начин:

#+begin_src rust
fn largest<T: PartialOrd>(list: &[T]) -> T {
#+end_src

#+REVEAL: split

Међутим, сада имамо још једну грешку:
#+begin_example
$ cargo run
   Compiling chapter10 v0.1.0 (file:///projects/chapter10)
error[E0508]: cannot move out of type `[T]`, a non-copy slice
 --> src/main.rs:2:23
  |
2 |     let mut largest = list[0];
  |                       ^^^^^^^
  |                       |
  |                       cannot move out of here
  |                       move occurs because `list[_]` has type `T`, which does not implement the `Copy` trait
  |                       help: consider borrowing here: `&list[0]`

error[E0507]: cannot move out of a shared reference
 --> src/main.rs:4:18
  |
4 |     for &item in list {
  |         -----    ^^^^
  |         ||
  |         |data moved here
  |         |move occurs because `item` has type `T`, which does not implement the `Copy` trait
  |         help: consider removing the `&`: `item`

Some errors have detailed explanations: E0507, E0508.
For more information about an error, try `rustc --explain E0507`.
error: could not compile `chapter10` due to 2 previous errors
#+end_example

#+REVEAL: split

Уводимо додатно ограничење да генерички тип мора бити и =Copy=. Тако да је пуно
решење следеће:

#+begin_src rust
fn largest<T: PartialOrd + Copy>(list: &[T]) -> T {
    let mut largest = list[0];

    for &item in list {
        if item > largest {
            largest = item;
        }
    }

    largest
}

fn main() {
    let number_list = vec![34, 50, 25, 100, 65];

    let result = largest(&number_list);
    println!("The largest number is {}", result);

    let char_list = vec!['y', 'm', 'a', 'q'];

    let result = largest(&char_list);
    println!("The largest char is {}", result);
}
#+end_src

*** Употреба особина ограничења за условну имплементацију метода
Ако желимо да имплементирамо методу само над типовима који имплементирају
одређене особине.
#+begin_src rust
use std::fmt::Display;

struct Pair<T> {
    x: T,
    y: T,
}

impl<T> Pair<T> {
    fn new(x: T, y: T) -> Self {
        Self { x, y }
    }
}

impl<T: Display + PartialOrd> Pair<T> {
    fn cmp_display(&self) {
        if self.x >= self.y {
            println!("The largest member is x = {}", self.x);
        } else {
            println!("The largest member is y = {}", self.y);
        }
    }
}
#+end_src

** Валидација референци кроз животни век (/Lifetimes/)
*** Животни век (/Lifetime/)
- Свака референца има животни век, опсег у коме је референца валидна.
- У доста ситуација компајлер аутоматски може да закључи који је животни век
  референце. Када то није у стању морамо да урадимо ручну анотацију.
- Анотацијама животног века доводимо у везу животни век различитих референци.

*** Спречавање "висећих" референци
#+begin_src rust
{
    let r;

    {
        let x = 5;
        r = &x;
    }

    println!("r: {}", r);
}

#+end_src

#+begin_example
 cargo run
   Compiling chapter10 v0.1.0 (file:///projects/chapter10)
error[E0597]: `x` does not live long enough
  --> src/main.rs:7:17
   |
7  |             r = &x;
   |                 ^^ borrowed value does not live long enough
8  |         }
   |         - `x` dropped here while still borrowed
9  |
10 |         println!("r: {}", r);
   |                           - borrow later used here

For more information about this error, try `rustc --explain E0597`.
error: could not compile `chapter10` due to previous error
#+end_example

*** /Borrow Checker/
- Раст компајлер има компоненту /borrow checker/ која проверава да ли су све
  позајмице валидне.

#+begin_src rust
{
    let r;                // ---------+-- 'a
                          //          |
    {                     //          |
        let x = 5;        // -+-- 'b  |
        r = &x;           //  |       |
    }                     // -+       |
                          //          |
    println!("r: {}", r); //          |
}                         // ---------+
#+end_src

- Програм је одбачен јер =r= референцира вредност чији животни век (='b=) је краћи
  од животног века варијабле =r= (='a=). Уколико би се ово дозволило, =r= би у једном
  делу референцирала невалидну вредност.

#+REVEAL: split

Варијабле имају животни век који је једнак синтаксном опсегу у коме је
варијабла дефинисана. Животни век имају и референце које позајмљују вредност и
смештају се у варијабле (нпр. =r=&x= из претходног примера).

#+begin_note
Једно од правила је да референца на варијаблу (тј. вредност) не може да живи
дуже од саме варијабле. Односно /животни век варијабле мора да садржи животни
век референце позајмљене од те варијабле/.
#+end_note

#+begin_src rust
{
    let r;
    {
        let x = 5;
        r = &x;           // -+- &x не може да живи дуже од
    }                     // -+  овог животног века
    println!("r: {}", r);
}
#+end_src

#+REVEAL: split

Ако сместимо референцу у варијаблу, референца мора бити исправна за цео животни
век варијабле у коју је смештена.

#+begin_note
Кажемо да /животни век референце мора да садржи животни век варијабле у коју је
смештена/.
#+end_note

#+begin_src rust
{
    let r;
    {
        let x = 5;
        r = &x;           // -+- животни век било чега што
    }                     //  |  се смести у r мора да живи
    println!("r: {}", r); // -+  бар оволико
}
#+end_src

Видимо да ово правило није задовољено. =&x= не живи довољно дуго јер =x= не живи
довољно дуго.

#+REVEAL: split

Ако претходна два правила објединимо можемо рећи да:

#+begin_note
/Животни век варијабле мора да садржи животни век свих варијабли које позајмљују
вредност од посматране варијабле/.
#+end_note

Односно, варијабла може отићи из опсега тек када не постоји више ни једна
варијабла која чува позајмљену вредност.

#+REVEAL: split

Следећи код је прихваћен. Референца =r= не живи дуже од податка који референцира
(=x=).

#+begin_src rust
{
    let x = 5;            // ----------+-- 'b
                          //           |
    let r = &x;           // --+-- 'a  |
                          //   |       |
    println!("r: {}", r); //   |       |
                          // --+       |
}                         // ----------+
#+end_src

*** Генерички животни векови у функцијама
- Креирамо функцију =longest= која враћа дужи од два прослеђена стринга.
  Прослеђујемо референцу на стринг исечак =&str=.

#+begin_src rust
fn main() {
    let string1 = String::from("abcd");
    let string2 = "xyz";

    let result = longest(string1.as_str(), string2);
    println!("The longest string is {}", result);
}
#+end_src

#+REVEAL: split

Овај програм није прихваћен.
#+begin_src rust
fn longest(x: &str, y: &str) -> &str {
    if x.len() > y.len() {
        x
    } else {
        y
    }
}
#+end_src

#+begin_example
$ cargo run
   Compiling chapter10 v0.1.0 (file:///projects/chapter10)
error[E0106]: missing lifetime specifier
 --> src/main.rs:9:33
  |
9 | fn longest(x: &str, y: &str) -> &str {
  |               ----     ----     ^ expected named lifetime parameter
  |
  = help: this function's return type contains a borrowed value, but the signature does not say
  whether it is borrowed from `x` or `y`
help: consider introducing a named lifetime parameter
  |
9 | fn longest<'a>(x: &'a str, y: &'a str) -> &'a str {
  |           ++++     ++          ++          ++

For more information about this error, try `rustc --explain E0106`.
error: could not compile `chapter10` due to previous error
#+end_example

#+REVEAL: split

- Зашто програм није прихваћен?
- /Borrow checker/ није у стању да одреди у којој релацији су референце =x= и =y= са
  повратном вредношћу која је такође референца.
- Тј. повратна вредност мора бити позајмљена однекуд, али компајлер не може да
  одреди да ли је позајмљена од =x= или =y= или од неке глобалне вредности.
- Ова информација је потребна да би се обавила калкулација и провера животног века.

*** Синтакса за анотацију животног века
- Да би помогли компајлеру референце означавамо са животним веком и тиме
  доводимо у везу различите референце (нпр. параметре и повратне вредности
  функције).
- Анотација је облика ='a=. Иза апострофа се пише име анотације које је најчешће
  једно мало слово са почетка алфабета (='a, 'b,...=).
- *Важно:* анотације животног века не мењају животни век референце већ само
  помажу компајлеру у провери.

#+begin_src rust
&i32        // референца
&'a i32     // референца са експлицитним животним веком
&'a mut i32 // промењива референца са експлицитним животним веком
#+end_src

- Једна анотација нема пуно смисла. Функцију имају тек када анотирамо више
  референци јер се доводе у везу ако имају исто име.
- Уведимо функцију =lt= која враћа животни век варијабле/вредности и релацију
  између животних векова ='a≥'b= односно ='b≤'a= која значи да ='a= обухвата ='b=
  односно ='b= је садржано у ='a=.

*** Анотација животног века у сигнатурама функција
- Следећа анотација за функцију =longest= је исправна јер референца која се враћа
  може бити =x= или =y= у зависности од дужине стринга. Стога је потребно да имамо
  строжији услов да је животни век повратне вредности у вези са животним веком
  оба параметра.

#+begin_src rust
fn longest<'a>(x: &'a str, y: &'a str) -> &'a str {
    if x.len() > y.len() {
        x
    } else {
        y
    }
}
#+end_src

- Овим кажемо компајлеру да за неки генерички животни век ='a=, функција прима две
  референце чији животни век вредности обухвата ='a= и враћа референцу која мора
  бити валидна бар колико и животни век ='a= тј. животни век повратне референце
  мора да обухвати ='a=. Уколико такав животни век постоји код се прихвата.
- Сигнатура доводи у везу обе улазне референце са излазном.

#+REVEAL: split

Посматрајмо код који позива функцију =longest=:

#+begin_src rust
fn main() {
    let string1 = String::from("abcd");
    {
        let string2 = "xyz";
        let result = longest(string1.as_str(), string2);
    }
    println!("The longest string is {}", result);
}
#+end_src

За код мора да постоји ='a= тако да важи:

#+begin_example
lt(string1) ≥ 'a     # животни век вредности првог параметара садржи 'a
lt(string2) ≥ 'a     # животни век вредности другог параметара садржи 'a
'a ≥ lt(result)       # 'a мора да садржи животни веку result варијабле
#+end_example

Што не може бити испуњено истовремено, тј. не постоји ='a= које испуњава ова
ограничења.

#+REVEAL: split

Други начин размишљања је да повратна вредност функције позајмљује од
вредности улазних параметара означених истим именом животног века.

#+begin_src rust
fn main() {
    let string1 = String::from("abcd");
    {
        let string2 = "xyz";
        let result = longest(string1.as_str(), string2);
    }
    println!("The longest string is {}", result);
}
#+end_src

Што значи да =result= позајмљује од =string1= и =string2= и та позајмица траје све
време живота варијабле =result= што не може бити валидно јер варијабла живи дуже
од вредности =string2=.

Иако, можемо видети да ће, због дужине стринга, враћена вредност бити =string1= и
програм је валидан, компајлер ово не може да закључи.
*** Ментални модел у контексту животног века
- Навођење анотације животног века зависи од тога шта функција ради.
- На пример:

#+begin_src rust
fn longest<'a>(x: &'a str, y: &str) -> &'a str {
    x
}
#+end_src

- У овом случају враћамо животни век првог параметра чиме саопштавамо компајлеру
  да се позајмица врши искључиво од првог параметра.

#+REVEAL: split

- Ако не позајмимо од улазних параметара морамо вратити референцу на вредност
  креирану унутар функције, што није дозвољено.

#+begin_src rust
fn longest<'a>(x: &str, y: &str) -> &'a str {
    let result = String::from("really long string");
    result.as_str()
}
#+end_src

#+begin_src
$ cargo run
   Compiling chapter10 v0.1.0 (file:///projects/chapter10)
error[E0515]: cannot return reference to local variable `result`
  --> src/main.rs:11:5
   |
11 |     result.as_str()
   |     ^^^^^^^^^^^^^^^ returns a reference to data owned by the current function

For more information about this error, try `rustc --explain E0515`.
error: could not compile `chapter10` due to previous error
#+end_src

Немогуће је вратити референцу на локалну промењиву јер би то била висећа
референца. Решење у овом случају је да вратимо поседовану вредност.

#+REVEAL: split

#+begin_note
Дакле, синтакса за анотацију животних векова доводи у везу животне векове
улазних параметара и повратних вредности. Наводи се само код референци.

На основу анотације, Раст је у стању да обави провере и обезбеди операције које
су меморијски сигурне и забрани операције које би могле да доведу до нарушавања
меморијске сигурности.

Анотације животног века истовремено представљају и корисне информације
програмерима јер је лако видети у каквој су вези улазни параметри и излазне
вредности.
#+end_note

*** Анотације животног века у декларацијама структура
- Сложени типови који у себи садрже референце морају увести анотације као врсту
  генеричког типа.

#+begin_src rust
struct ImportantExcerpt<'a> {
    part: &'a str,
}

fn main() {
    let novel = String::from("Call me Ishmael. Some years ago...");
    let first_sentence = novel.split('.').next().expect("Could not find a '.'");
    let i = ImportantExcerpt {
        part: first_sentence,
    };
}
#+end_src

*** Елизија животног века
- Имали смо претходно пример у коме нисмо дефинисали анотације животног века.

#+begin_src rust
fn first_word(s: &str) -> &str {
    let bytes = s.as_bytes();

    for (i, &item) in bytes.iter().enumerate() {
        if item == b' ' {
            return &s[0..i];
        }
    }

    &s[..]
}
#+end_src

- Постоје одређена правила које називамо /правилима елизије животног века/
  (/lifetime elision rules/) и која омогућавају да се избегне анотирање животног
  века када је анотација очигледна.

*** Правила елизије животног века
1. Компајлер креира животни век за сваку референцу у параметрима функције:

#+begin_src rust
fn foo<'a>(x: &'a i32)
fn foo<'a, 'b>(x: &'a i32, y: &'b i32)
итд.
#+end_src

#+REVEAL: split

2. Када имамо тачно један улазни животни век, он је додељен свим референцама у
   повратној вредности:

#+begin_src rust
fn foo<'a>(x: &'a i32) -> &'a i32
#+end_src

#+REVEAL: split

3. Ако има више улазних животних векова али је један улазни параметар =&self= ili
   =&mut self= тада се овај животни век додељује свим излазним референцема.

*** Пример елизије 1

#+begin_src rust
fn first_word(s: &str) -> &str {
#+end_src

#+REVEAL: split

Правило 1.

#+begin_src rust
fn first_word<'a>(s: &'a str) -> &str {
#+end_src

#+REVEAL: split

Правило 2.

#+begin_src rust
fn first_word<'a>(s: &'a str) -> &'a str {
#+end_src

*** Пример елизије 2

#+begin_src rust
fn longest(x: &str, y: &str) -> &str {
#+end_src

#+REVEAL: split

Правило 1.

#+begin_src rust
fn longest<'a, 'b>(x: &'a str, y: &'b str) -> &str {
#+end_src

- Не можемо да применимо ни правило 2 ни правило 3. И даље нам излазни параметар
  нема анотацију -> анотација мора ручно да се обави.
*** Анотација животног века у методама
#+begin_src rust
impl<'a> ImportantExcerpt<'a> {
    fn level(&self) -> i32 {
        3
    }
}
#+end_src

- На основу правила 1. не морамо да анотирамо улазну референцу.

#+REVEAL: split

#+begin_src rust
impl<'a> ImportantExcerpt<'a> {
    fn announce_and_return_part(&self, announcement: &str) -> &str {
        println!("Attention please: {}", announcement);
        self.part
    }
}
#+end_src

- На основу правила 1 не морамо да анотирамо улазне референце а на основу
  правила 3 не морамо да анотирамо ни повратну вредност.

*** Животни век =static=
- Специјалан животни век који означавамо са ='static= означава животни век
  целокупног трајања извршавања програма.
- Овај животни век имају статичке вредности јер су такве вредности смештене
  директно у извршну датотеку тј. нису алоциране у току извршавања програма.

#+begin_src rust
let s: &'static str = "I have a static lifetime.";
#+end_src

*** Генерички типови, ограничење кроз особине и животни век
#+begin_src rust
use std::fmt::Display;

fn longest_with_an_announcement<'a, T>(
    x: &'a str,
    y: &'a str,
    ann: T,
) -> &'a str
where
    T: Display,
{
    println!("Announcement! {}", ann);
    if x.len() > y.len() {
        x
    } else {
        y
    }
}
#+end_src

* TODO Функционално програмирање, затворења и итератори
* TODO Макрои
* TODO ООП, паметни поинтери, конкурентно програмирање
* Литература
- Steve Klabnik and Carol Nichols: [[https://doc.rust-lang.org/book/][The Rust Programming Language]], no starch press.
- Rust by Example, https://doc.rust-lang.org/stable/rust-by-example/index.html
- Slice is NOT reference, https://github.com/rust-lang/book/issues/3070
- Google: Comprehensive Rust, https://google.github.io/comprehensive-rust/
- [[https://rust-lang.github.io/rfcs/0505-api-comment-conventions.html][RFC 505: API documentation conventions]]
