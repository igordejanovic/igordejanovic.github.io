<!DOCTYPE html>
<html lang="sr">
<head>
<meta charset="utf-8"/>
<title>Програмски језик Раст</title>
<meta name="author" content="Игор Дејановић"/>
<style type="text/css">
.underline { text-decoration: underline; }
</style>
<link rel="stylesheet" href="../../../s/reveal.js/css/reveal.css"/>

<link rel="stylesheet" href="../../../s/reveal.js/css/theme/simple.css" id="theme"/>

<link rel="stylesheet" href="../../../s/reveal-slides.css"/>

<link rel="stylesheet" href="../../../s/highlight-styles/docco.css"/>
<link rel="stylesheet" href=""/>

<!-- If the query includes 'print-pdf', include the PDF print sheet -->
<script>
    if( window.location.search.match( /print-pdf/gi ) ) {
        var link = document.createElement( 'link' );
        link.rel = 'stylesheet';
        link.type = 'text/css';
        link.href = '../../../s/reveal.js/css/print/pdf.css';
        document.getElementsByTagName( 'head' )[0].appendChild( link );
    }
</script>
<base target="_blank">
</head>
<body>
<div class="reveal">
<div class="slides">
<section id="sec-title-slide">
<h1 class="title">Програмски језик Раст</h1>
<h2 class="subtitle">Базирано на верзији 1.65.0. У изради.</h2>
<h2 class="author">Проф. др Игор Дејановић (<a href="mailto:igord at uns ac rs">igord at uns ac rs</a>)</h2>
<p class="date">Креирано 2023-11-20 Mon 11:01, притисни ESC за мапу, "м" за мени, Ctrl+Shift+F за претрагу</p>
</section>
<section>
<section id="slide-1">
<h2 id="1"><span class="section-number-2">1.</span> Увод</h2>
<ul>
<li>Језик опште намене, компајлиран и статички типизиран са инференцом типова</li>
<li>Системско програмирање али са особинама вишег нивоа апстракције као што су
функционално програмирање</li>
<li>2010, Graydon Hoare, Mozilla Research</li>
<li>Перформансе и сигурност</li>
<li>Не користи <i>garbage collector</i> али обезбеђује меморијску сигурност кроз <i>borrow
checker</i></li>
<li>Синтаксно сличан C++. Утицај и OCaml-а, Haskell-а и Erlang-а.</li>
<li>Користи се у великим фирмама: Amazon, Facebook, Google, Microsoft&#x2026;</li>
<li>Више година за редом на SO упитнику први у категорији <i>"most loved programming
languages"</i></li>

</ul>
</section>
</section>
<section>
<section id="slide-2">
<h2 id="2"><span class="section-number-2">2.</span> Инсталација и подешавање</h2>
<div class="outline-text-2" id="text-2">
</div>
</section>
<section id="slide-2-1">
<h3 id="2-1"><span class="section-number-3">2.1.</span> Инсталација</h3>
<ul>
<li>Раст стиже са алатом за управљање ланцем алата (енг. <i>toolchain</i>) &#x2013; <code>rustup</code></li>

</ul>

<div class="org-src-container">

<pre><code class="sh" >$ curl --proto '=https' --tlsv1.2 https://sh.rustup.rs -sSf | sh
</code></pre>
</div>

<ul>
<li>Провера инсталације:</li>

</ul>

<div class="org-src-container">

<pre><code class="sh" >~&gt; rustc --version
rustc 1.65.0 (897e37553 2022-11-02)
</code></pre>
</div>
</section>
<section id="slide-2-2">
<h3 id="2-2"><span class="section-number-3">2.2.</span> Преглед инсталације</h3>
<div class="org-src-container">

<pre><code class="sh" >~&gt; rustup show
Default host: x86_64-unknown-linux-gnu
rustup home:  /home/igor/.rustup

installed toolchains
--------------------

stable-x86_64-unknown-linux-gnu (default)
nightly-x86_64-unknown-linux-gnu

active toolchain
----------------

stable-x86_64-unknown-linux-gnu (default)
rustc 1.58.1 (db9d1b20b 2022-01-20)
</code></pre>
</div>
</section>
<section id="slide-2-3">
<h3 id="2-3"><span class="section-number-3">2.3.</span> Ажурирање</h3>
<p>
За ажурирање инсталације на најновију верзију:
</p>

<div class="org-src-container">

<pre><code class="sh" >rustup update
</code></pre>
</div>
</section>
<section id="slide-2-4">
<h3 id="2-4"><span class="section-number-3">2.4.</span> Документација</h3>
<p>
Раст стиже са веома добром документацијом и књигама које су доступне директно из
инсталације:
</p>

<div class="org-src-container">

<pre><code class="sh" >rustup doc
</code></pre>
</div>
</section>
</section>
<section>
<section id="slide-3">
<h2 id="3"><span class="section-number-2">3.</span> Почетак</h2>
<div class="outline-text-2" id="text-3">
</div>
</section>
<section id="slide-3-1">
<h3 id="3-1"><span class="section-number-3">3.1.</span> Hello, World!</h3>
<div class="org-src-container">

<pre><code class="sh" >$ mkdir hello_world
$ cd hello_world
</code></pre>
</div>

<p>
File <code>main.rs</code>:
</p>
<div class="org-src-container">

<pre><code class="rust" >fn main() {
    println!("Hello, world!");
}
</code></pre>
</div>
</section>
<section id="slide-3-2">
<h3 id="3-2"><span class="section-number-3">3.2.</span> Компајлирање и покретање</h3>
<div class="org-src-container">

<pre><code class="sh" >$ rustc main.rs
$ ./main
Hello, world!
</code></pre>
</div>
</section>
<section id="slide-3-3">
<h3 id="3-3"><span class="section-number-3">3.3.</span> Hello, Cargo!</h3>
<ul>
<li>Алат за разрешавање зависности и управљање пројектом.</li>

</ul>

<div class="org-src-container">

<pre><code class="sh" >~&gt; cargo --version
cargo 1.65.0 (4bc8f24d3 2022-10-20)
</code></pre>
</div>

<ul>
<li>Креирање пројекта са <code>cargo</code> алатом:</li>

</ul>

<div class="org-src-container">

<pre><code class="sh" >$ cargo new hello_cargo
$ cd hello_cargo
</code></pre>
</div>
</section>
<section id="slide-3-4">
<h3 id="3-4"><span class="section-number-3">3.4.</span> Садржај креираног пројекта</h3>
<p>
Фајл <code>cargo.toml</code> чува конфигурацију пројекта. Формат је <a href="https://toml.io/en/">TOML</a> (<i>Tom’s Obvious,
Minimal Language</i>):
</p>

<div class="org-src-container">

<pre><code class="toml" >[package]
name = "hello_cargo"
version = "0.1.0"
edition = "2021"

[dependencies]
</code></pre>
</div>

<p>
Fajl <code>src/main.rs</code>:
</p>
<div class="org-src-container">

<pre><code class="rust" >fn main() {
    println!("Hello, world!");
}
</code></pre>
</div>
</section>
<section id="slide-3-5">
<h3 id="3-5"><span class="section-number-3">3.5.</span> Покретање</h3>
<div class="org-src-container">

<pre><code class="rust" >$ cargo build
   Compiling hello_cargo v0.1.0 (file:///projects/hello_cargo)
    Finished dev [unoptimized + debuginfo] target(s) in 2.85 secs
</code></pre>
</div>

<p>
Извршни фајл се може наћи на локацији <code>target/debug/hello_cargo</code>:
</p>

<div class="org-src-container">

<pre><code class="sh" >$ ./target/debug/hello_cargo
Hello, world!
</code></pre>
</div>

<p>
Али <code>cargo</code> омогућава и једноставнији начин покретања:
</p>
<div class="org-src-container">

<pre><code class="sh" >$ cargo run
    Finished dev [unoptimized + debuginfo] target(s) in 0.0 secs
     Running `target/debug/hello_cargo`
Hello, world!
</code></pre>
</div>
</section>
<section id="slide-3-6">
<h3 id="3-6"><span class="section-number-3">3.6.</span> Провера</h3>
<p>
Такође је могуће брзо проверити да ли се код компајлира:
</p>

<div class="org-src-container">

<pre><code class="sh" >$ cargo check
   Checking hello_cargo v0.1.0 (file:///projects/hello_cargo)
    Finished dev [unoptimized + debuginfo] target(s) in 0.32 secs
</code></pre>
</div>
</section>
<section id="slide-3-7">
<h3 id="3-7"><span class="section-number-3">3.7.</span> Изградња финалне верзије</h3>
<ul>
<li>У току развоја користимо изградњу за дебаговање која се брже заврши али
генерисани извршни код није оптималан.</li>

<li><p>
За финалну верзију је потребно изградњу обавити на следећи начин:
</p>

<div class="org-src-container">

<pre><code class="rust" >    cargo build --release
</code></pre>
</div></li>

<li>Ово ће обавити додатне оптимизације које ће дуже трајати али ће крајњи код
бити оптимизован.</li>

</ul>
</section>
<section id="slide-3-8">
<h3 id="3-8"><span class="section-number-3">3.8.</span> <code>cargo</code> као конвенција</h3>
<p>
Практично сви Раст пројекти користе <code>cargo</code> тако да је унификован начин изградње
пројеката. Углавном се своди на:
</p>

<div class="org-src-container">

<pre><code class="sh" >$ git clone example.org/someproject
$ cd someproject
$ cargo build
</code></pre>
</div>
</section>
</section>
<section>
<section id="slide-4">
<h2 id="4"><span class="section-number-2">4.</span> Игра погађања бројева</h2>
<div class="outline-text-2" id="text-4">
</div>
</section>
<section id="slide-4-1">
<h3 id="4-1"><span class="section-number-3">4.1.</span> Подешавање пројекта</h3>
<div class="org-src-container">

<pre><code class="rust" >$ cargo new guessing_game
$ cd guessing_game
</code></pre>
</div>

<p>
Фајл <code>Cargo.toml</code>:
</p>
<div class="org-src-container">

<pre><code class="toml" >[package]
name = "guessing_game"
version = "0.1.0"
edition = "2021"

[dependencies]
</code></pre>
</div>

<p>
Фајл <code>src/main.rs</code>:
</p>
<div class="org-src-container">

<pre><code class="rust" >fn main() {
    println!("Hello, world!");
}
</code></pre>
</div>

</section>
<section>

<div class="org-src-container">

<pre><code class="sh" >$ cargo run
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
    Finished dev [unoptimized + debuginfo] target(s) in 1.50s
     Running `target/debug/guessing_game`
Hello, world!
</code></pre>
</div>
</section>
<section id="slide-4-2">
<h3 id="4-2"><span class="section-number-3">4.2.</span> Преузимање броја са стандардног улаза</h3>
<div class="org-src-container">

<pre><code class="rust" >use std::io;

fn main() {
    println!("Guess the number!");

    println!("Please input your guess.");

    let mut guess = String::new();

    io::stdin()
        .read_line(&amp;mut guess)
        .expect("Failed to read line");

    println!("You guessed: {}", guess);
}
</code></pre>
</div>
</section>
<section id="slide-4-3">
<h3 id="4-3"><span class="section-number-3">4.3.</span> Променљивост (<i>mutability</i>)</h3>
<ul>
<li>Варијабле су подразумевано непромењиве (<i>immutable</i>).</li>
<li><p>
Уколико желимо варијаблу чија вредност може да се мења користимо кључну реч
<code>mut</code>.
</p>

<div class="org-src-container">

<pre><code class="rust" >  let apples = 5; // immutable
  let mut bananas = 5; // mutable
</code></pre>
</div></li>

<li><p>
Исто важи и за параметре и аргументе функција:
</p>

<div class="org-src-container">

<pre><code class="rust" >  io::stdin()
      .read_line(&amp;mut guess)
</code></pre>
</div></li>

</ul>
</section>
<section id="slide-4-4">
<h3 id="4-4"><span class="section-number-3">4.4.</span> Обрада могућих грешака употребом <code>Result</code> типа</h3>
<p>
<code>read_line</code> може да заврши неуспешно. Зато враћа <code>io::Result</code> тип који представља
тип енумерације (<i>enum</i>) и има две могуће вредности: <code>Ok</code> и <code>Err</code>.
</p>

<div class="org-src-container">

<pre><code class="rust" >io::stdin()
    .read_line(&amp;mut guess)
    .expect("Failed to read line");
</code></pre>
</div>

<p>
<code>expect</code> je имплементиран тако да ће у случају <code>Ok</code> варијанте вратити вредност која
је садржана унутар варијанте док ће у случају <code>Err</code> варијанте прекинути извршавање
програма.
</p>

<div class="org-src-container">

<pre><code class="rust" >pub fn expect(self, msg: &amp;str) -&gt; T
    where
        E: fmt::Debug,
    {
        match self {
            Ok(t) =&gt; t,
            Err(e) =&gt; unwrap_failed(msg, &amp;e),
        }
    }
</code></pre>
</div>
</section>
<section id="slide-4-5">
<h3 id="4-5"><span class="section-number-3">4.5.</span> Покретање</h3>
<div class="org-src-container">

<pre><code class="rust" >$ cargo run
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
    Finished dev [unoptimized + debuginfo] target(s) in 6.44s
     Running `target/debug/guessing_game`
Guess the number!
Please input your guess.
6
You guessed: 6
</code></pre>
</div>
</section>
<section id="slide-4-6">
<h3 id="4-6"><span class="section-number-3">4.6.</span> Генерисање случајног броја</h3>
<p>
Користимо <code>rand</code> пакет (сандук - <i>crate</i> у терминологији <i>Cargo</i>-a).
</p>

<p>
Секција <code>[dependencies]</code> у фајлу <code>Cargo.toml</code>:
</p>
<div class="org-src-container">

<pre><code class="toml" >[dependencies]
rand = "0.8.3"
</code></pre>
</div>

<div class="org-src-container">

<pre><code class="sh" >$ cargo build
    Updating crates.io index
  Downloaded rand v0.8.3
  Downloaded libc v0.2.86
  ...
   Compiling rand_chacha v0.3.0
   Compiling rand v0.8.3
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
    Finished dev [unoptimized + debuginfo] target(s) in 2.53s
</code></pre>
</div>

<p>
<i>Cargo</i> користи <a href="https://semver.org/">Semantic Versioning</a>. Раст пакети се преузимају са сајта <a href="https://crates.io/">crates.io</a>
и кеширају локално.
</p>
</section>
<section id="slide-4-7">
<h3 id="4-7"><span class="section-number-3">4.7.</span> Поновљивост изградње - <i>Cargo.lock</i></h3>
<ul>
<li>Свако следеће покретање изградње користи исте верзије.</li>
<li>Први пут када се покрене <code>cargo build</code> креира се фајл <code>Cargo.lock</code> са
информацијама о верзијама свих сандука који су инсталирани.</li>
<li><code>Cargo.lock</code> је потребно чувати у систему контроле верзија (нпр. <code>git</code>) да би се
осигурала поновљивост.</li>

</ul>
</section>
<section id="slide-4-8">
<h3 id="4-8"><span class="section-number-3">4.8.</span> Ажурирање сандука</h3>
<ul>
<li><p>
Ажурирање на нове верзије сандука се обавља са:
</p>

<div class="org-src-container">

<pre><code class="sh" >  $ cargo update
    Updating crates.io index
    Updating rand v0.8.3 -&gt; v0.8.4
</code></pre>
</div></li>
<li>Поштује се семантичко верзионирање тј. аутоматски се ажурира на следећу
верзију која је мања од наредне главне (<i>major</i>) верзије.</li>
<li>Ако прелазимо на нову главну верзију то морамо урадити изменом верзије у
<code>Cargo.toml</code> фајлу.</li>

</ul>
</section>
<section id="slide-4-9">
<h3 id="4-9"><span class="section-number-3">4.9.</span> Генерисање случајног броја</h3>
<p>
Фајл <code>src/main.rs</code>:
</p>
<div class="org-src-container">

<pre><code class="rust" >use std::io;
use rand::Rng;

fn main() {
    println!("Guess the number!");

    let secret_number = rand::thread_rng().gen_range(1..101);

    println!("The secret number is: {}", secret_number);

    println!("Please input your guess.");

    let mut guess = String::new();

    io::stdin()
        .read_line(&amp;mut guess)
        .expect("Failed to read line");

    println!("You guessed: {}", guess);
}
</code></pre>
</div>

<p>
У <code>gen_range</code> користимо израз опсега (<i>range expression</i>). Интервал је затворен на
доњој граници и отворен на горњој. За интервал затворен и од горе можемо
писати <code>1..=100</code>.
</p>
</section>
<section id="slide-4-10">
<h3 id="4-10"><span class="section-number-3">4.10.</span> Документација за локалне сандуке</h3>
<p>
Да би знали које методе и функције су нам доступне можемо користити уграђену
документацију за сандуке пројекта. Документацију добијамо са:
</p>

<div class="org-src-container">

<pre><code class="sh" >cargo doc --open
</code></pre>
</div>
</section>
<section id="slide-4-11">
<h3 id="4-11"><span class="section-number-3">4.11.</span> Покретање програма</h3>
<div class="org-src-container">

<pre><code class="sh" >$ cargo run
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
    Finished dev [unoptimized + debuginfo] target(s) in 2.53s
     Running `target/debug/guessing_game`
Guess the number!
The secret number is: 7
Please input your guess.
4
You guessed: 4
</code></pre>
</div>
</section>
<section id="slide-4-12">
<h3 id="4-12"><span class="section-number-3">4.12.</span> Поређење тајног броја са задатим</h3>
<p>
Фајл <code>src/main.rs</code>
</p>
<div class="org-src-container">

<pre><code class="rust" >use rand::Rng;
use std::cmp::Ordering;
use std::io;

fn main() {
    // --snip--

    println!("You guessed: {}", guess);

    match guess.cmp(&amp;secret_number) {
        Ordering::Less =&gt; println!("Too small!"),
        Ordering::Greater =&gt; println!("Too big!"),
        Ordering::Equal =&gt; println!("You win!"),
    }
}
</code></pre>
</div>
<ul>
<li>Користимо <code>std::cmp::Ordering</code> енумерисани тип који има варијанте <code>Less</code>, <code>Greater</code>
и <code>Equal</code></li>
<li><code>match</code> израз пореди задату вредност са вредностима задатим у телу и извршава
грану која се подудара. Гране <code>match</code> израза се у Раст терминологији зову "руке"
(<i>arms</i>).</li>

</ul>
</section>
<section id="slide-4-13">
<h3 id="4-13"><span class="section-number-3">4.13.</span> Поправка типова</h3>
<p>
Код са претходног слајда није исправан:
</p>
<div class="org-src-container">

<pre><code class="sh" >$ cargo build
   Compiling libc v0.2.86
   ...
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
error[E0308]: mismatched types
  --&gt; src/main.rs:22:21
   |
22 |     match guess.cmp(&amp;secret_number) {
   |                     ^^^^^^^^^^^^^^ expected struct `String`, found integer
   |
   = note: expected reference `&amp;String`
              found reference `&amp;{integer}`

error[E0283]: type annotations needed for `{integer}`
   --&gt; src/main.rs:8:44
    |
8   |     let secret_number = rand::thread_rng().gen_range(1..101);
    |         -------------                      ^^^^^^^^^ cannot infer type for type `{integer}`
    |         |
    |         consider giving `secret_number` a type
    |
    = note: multiple `impl`s satisfying `{integer}: SampleUniform` found in the `rand` crate:
            - impl SampleUniform for i128;
            - impl SampleUniform for i16;
            - impl SampleUniform for i32;
            - impl SampleUniform for i64;
            and 8 more
...
</code></pre>
</div>

</section>
<section>

<p>
Основа грешке је неслагање типова. Са улаза прихватамо <code>String</code> док нам је тајни
број <code>integer</code>.
</p>
</section>
<section id="slide-4-14">
<h3 id="4-14"><span class="section-number-3">4.14.</span> Конверзија стринга у број</h3>
<p>
Проблем решавамо конверзијом стринга са улаза у бројни тип.
</p>

<div class="org-src-container">

<pre><code class="rust" >// --snip--

    let mut guess = String::new();

    io::stdin()
        .read_line(&amp;mut guess)
        .expect("Failed to read line");

    let guess: u32 = guess.trim().parse().expect("Please type a number!");

    println!("You guessed: {}", guess);

    match guess.cmp(&amp;secret_number) {
        Ordering::Less =&gt; println!("Too small!"),
        Ordering::Greater =&gt; println!("Too big!"),
        Ordering::Equal =&gt; println!("You win!"),
    }
</code></pre>
</div>

</section>
<section>

<p>
Сада се програм компајлира.
</p>

<div class="org-src-container">

<pre><code class="sh" >$ cargo run
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
    Finished dev [unoptimized + debuginfo] target(s) in 0.43s
     Running `target/debug/guessing_game`
Guess the number!
The secret number is: 58
Please input your guess.
  76
You guessed: 76
Too big!
</code></pre>
</div>
</section>
<section id="slide-4-15">
<h3 id="4-15"><span class="section-number-3">4.15.</span> Омогућавање вишеструког погађања - употреба петље</h3>
<p>
Фајл <code>src/main.rs</code>:
</p>
<div class="org-src-container">

<pre><code class="rust" >// --snip--

    println!("The secret number is: {}", secret_number);

    loop {
        println!("Please input your guess.");

        // --snip--

        match guess.cmp(&amp;secret_number) {
            Ordering::Less =&gt; println!("Too small!"),
            Ordering::Greater =&gt; println!("Too big!"),
            Ordering::Equal =&gt; println!("You win!"),
        }
    }
}
</code></pre>
</div>
</section>
<section id="slide-4-16">
<h3 id="4-16"><span class="section-number-3">4.16.</span> Прекид рада</h3>
<p>
Проблем је како прекинути програм када корисник погоди број?
</p>

<div class="org-src-container">

<pre><code class="rust" >// --snip--

        match guess.cmp(&amp;secret_number) {
            Ordering::Less =&gt; println!("Too small!"),
            Ordering::Greater =&gt; println!("Too big!"),
            Ordering::Equal =&gt; {
                println!("You win!");
                break;
            }
        }
    }
}
</code></pre>
</div>
</section>
<section id="slide-4-17">
<h3 id="4-17"><span class="section-number-3">4.17.</span> Руковање неисправним улазом</h3>
<div class="org-src-container">

<pre><code class="rust" >// --snip--

        io::stdin()
            .read_line(&amp;mut guess)
            .expect("Failed to read line");

        let guess: u32 = match guess.trim().parse() {
            Ok(num) =&gt; num,
            Err(_) =&gt; continue,
        };

        println!("You guessed: {}", guess);

        // --snip--
</code></pre>
</div>

<p>
Потребно је још обрисати линију која приказује генерисани број.
</p>
</section>
<section id="slide-4-18">
<h3 id="4-18"><span class="section-number-3">4.18.</span> Финални код</h3>
<div class="org-src-container">

<pre><code class="rust" >use rand::Rng;
use std::cmp::Ordering;
use std::io;

fn main() {
    println!("Guess the number!");
    let secret_number = rand::thread_rng().gen_range(1..101);

    loop {
        println!("Please input your guess.");
        let mut guess = String::new();
        io::stdin()
            .read_line(&amp;mut guess)
            .expect("Failed to read line");
        let guess: u32 = match guess.trim().parse() {
            Ok(num) =&gt; num,
            Err(_) =&gt; continue,
        };
        println!("You guessed: {}", guess);
        match guess.cmp(&amp;secret_number) {
            Ordering::Less =&gt; println!("Too small!"),
            Ordering::Greater =&gt; println!("Too big!"),
            Ordering::Equal =&gt; {
                println!("You win!");
                break;
            }
        }
    }
}
</code></pre>
</div>
</section>
</section>
<section>
<section id="slide-5">
<h2 id="5"><span class="section-number-2">5.</span> Основни програмски концепти</h2>
<div class="outline-text-2" id="text-5">
</div>
</section>
<section id="slide-5-1">
<h3 id="5-1"><span class="section-number-3">5.1.</span> Варијабле и променљивост (<i>mutability</i>)</h3>
<div class="outline-text-3" id="text-5-1">
</div>
</section>
<section id="slide-5-1-1">
<h4 id="5-1-1"><span class="section-number-4">5.1.1.</span> Варијабле и променљивост (<i>mutability</i>)</h4>
<ul>
<li>Варијабле су подразумевано непромењиве.</li>
<li><p>
Једном када добију вредност (<i>binding</i>) та вредност се не може променити
</p>

<div class="org-src-container">

<pre><code class="rust" >    fn main() {
        let x = 5;
        println!("The value of x is: {}", x);
        x = 6;     // greška
        println!("The value of x is: {}", x);
    }
</code></pre>
</div>

</section>
<section>

<div class="org-src-container">

<pre><code class="sh" >    $ cargo run
    Compiling variables v0.1.0 (file:///projects/variables)
    error[E0384]: cannot assign twice to immutable variable `x`
    --&gt; src/main.rs:4:5
    |
    2 |     let x = 5;
    |         -
    |         |
    |         first assignment to `x`
    |         help: consider making this binding mutable: `mut x`
    3 |     println!("The value of x is: {}", x);
    4 |     x = 6;
    |     ^^^^^ cannot assign twice to immutable variable

    For more information about this error, try `rustc --explain E0384`.
    error: could not compile `variables` due to previous error
</code></pre>
</div></li>

</ul>
</section>
<section id="slide-5-1-2">
<h4 id="5-1-2"><span class="section-number-4">5.1.2.</span> <code>mut</code> кључна реч</h4>
<div class="org-src-container">

<pre><code class="rust" >fn main() {
    let mut x = 5;
    println!("The value of x is: {}", x);
    x = 6;
    println!("The value of x is: {}", x);
}
</code></pre>
</div>
</section>
<section id="slide-5-2">
<h3 id="5-2"><span class="section-number-3">5.2.</span> Константе - <code>const</code></h3>
<ul>
<li>Слично као непромењиве варијабле са следећим разликама:
<ul>
<li>Увек су непромењиве</li>
<li>Могу се иницијализовати само константним изразом (познатим у време
компајлирања)</li>
<li>Валидне за целокупно време извршавања програма у опсегу важења где су
дефинисане (<i>scope</i>)</li>
<li>Мора се експлицитно дефинисати тип</li>

</ul></li>
<li>Компајлер ће константе "убацити" на месту употребе</li>
<li><p>
По конвенцији имена константи се пишу великим словима
</p>

<div class="org-src-container">

<pre><code class="rust" >    const THREE_HOURS_IN_SECONDS: u32 = 60 * 60 * 3;
</code></pre>
</div></li>

</ul>
</section>
<section id="slide-5-3">
<h3 id="5-3"><span class="section-number-3">5.3.</span> Типови података</h3>
<div class="outline-text-3" id="text-5-3">
</div>
</section>
<section id="slide-5-3-1">
<h4 id="5-3-1"><span class="section-number-4">5.3.1.</span> Типови података</h4>
<ul>
<li>Свака вредност у Расту има тип. Типови морају бити познати у време
компајлирања (<i>статички типизиран језик</i>).</li>
<li><p>
Компајлер ће пробати да одреди типове (<i>type inference</i>). Ако није могуће
захтева се да дефинишемо тип експлицитно.
</p>

<p>
Нпр:
</p>
<div class="org-src-container">

<pre><code class="rust" >    let guess: u32 = "42".parse().expect("Not a number!");
</code></pre>
</div>
<p>
Овде није могуће одредити тип јер <code>str::parse</code> функција може вратити различите
бројне типове (функција је генеричка) а не постоји начин да се тип аутоматски
одреди.
</p>

<p>
Сигнатура је:
</p>
<div class="org-src-container">

<pre><code class="rust" >    pub fn parse&lt;F&gt;(&amp;self) -&gt; Result&lt;F, &lt;F as FromStr&gt;::Err&gt;
    where
        F: FromStr
</code></pre>
</div></li>

</ul>
</section>
<section id="slide-5-3-2">
<h4 id="5-3-2"><span class="section-number-4">5.3.2.</span> <i>Integer</i> типови</h4>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">Дужина</th>
<th scope="col" class="org-left">Signed</th>
<th scope="col" class="org-left">Unsigned</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">8-bit</td>
<td class="org-left">i8</td>
<td class="org-left">u8</td>
</tr>

<tr>
<td class="org-left">16-bit</td>
<td class="org-left">i16</td>
<td class="org-left">u16</td>
</tr>

<tr>
<td class="org-left">32-bit</td>
<td class="org-left">i32</td>
<td class="org-left">u32</td>
</tr>

<tr>
<td class="org-left">64-bit</td>
<td class="org-left">i64</td>
<td class="org-left">u64</td>
</tr>

<tr>
<td class="org-left">128-bit</td>
<td class="org-left">i128</td>
<td class="org-left">u128</td>
</tr>

<tr>
<td class="org-left">arch</td>
<td class="org-left">isize</td>
<td class="org-left">usize</td>
</tr>
</tbody>
</table>
</section>
<section id="slide-5-3-3">
<h4 id="5-3-3"><span class="section-number-4">5.3.3.</span> Литерали бројева</h4>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">Литерали</th>
<th scope="col" class="org-left">Примери</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">Decimal</td>
<td class="org-left">98_222</td>
</tr>

<tr>
<td class="org-left">Hex</td>
<td class="org-left">0xff</td>
</tr>

<tr>
<td class="org-left">Octal</td>
<td class="org-left">0o77</td>
</tr>

<tr>
<td class="org-left">Binary</td>
<td class="org-left">0b1111_0000</td>
</tr>

<tr>
<td class="org-left">Byte (u8 only)</td>
<td class="org-left">b'A'</td>
</tr>
</tbody>
</table>
</section>
<section id="slide-5-3-4">
<h4 id="5-3-4"><span class="section-number-4">5.3.4.</span> <i>Floating-Point</i> типови</h4>
<div class="org-src-container">

<pre><code class="rust" >fn main() {
    let x = 2.0; // f64

    let y: f32 = 3.0; // f32
}
</code></pre>
</div>

<p>
IEEE-754 стандард
</p>
</section>
<section id="slide-5-3-5">
<h4 id="5-3-5"><span class="section-number-4">5.3.5.</span> Операције над бројевима</h4>
<div class="org-src-container">

<pre><code class="rust" >fn main() {
    // addition
    let sum = 5 + 10;

    // subtraction
    let difference = 95.5 - 4.3;

    // multiplication
    let product = 4 * 30;

    // division
    let quotient = 56.7 / 32.2;
    let floored = 2 / 3; // Results in 0

    // remainder
    let remainder = 43 % 5;
}
</code></pre>
</div>
</section>
<section id="slide-5-3-6">
<h4 id="5-3-6"><span class="section-number-4">5.3.6.</span> <i>Boolean</i> тип</h4>
<div class="org-src-container">

<pre><code class="rust" >fn main() {
    let t = true;

    let f: bool = false; // with explicit type annotation
}
</code></pre>
</div>
</section>
<section id="slide-5-3-7">
<h4 id="5-3-7"><span class="section-number-4">5.3.7.</span> Тип карактера</h4>
<div class="org-src-container">

<pre><code class="rust" >fn main() {
    let c = 'z';
    let z = 'ℤ';
    let heart_eyed_cat = '😻';
}
</code></pre>
</div>
</section>
<section id="slide-5-3-8">
<h4 id="5-3-8"><span class="section-number-4">5.3.8.</span> Торке (<i>tuples</i>)</h4>
<ul>
<li>Хетерогене структуре фиксне дужине.</li>

</ul>
<div class="org-src-container">

<pre><code class="rust" >fn main() {
    let tup: (i32, f64, u8) = (500, 6.4, 1);
}
</code></pre>
</div>

<ul>
<li>Распакивање торки (<i>destructuring</i>):</li>

</ul>
<div class="org-src-container">

<pre><code class="rust" >fn main() {
    let tup = (500, 6.4, 1);

    let (x, y, z) = tup;

    println!("The value of y is: {}", y);
}
</code></pre>
</div>

</section>
<section>

<p>
Приступ елементима торке:
</p>
<div class="org-src-container">

<pre><code class="rust" >fn main() {
    let mut x: (i32, f64, u8) = (500, 6.4, 1);

    let five_hundred = x.0;

    let six_point_four = x.1;

    let one = x.2;

    // Уколико је торка промењива можемо извршити доделу
    x.2 = 2;
    println!("{x:?}")
}
</code></pre>
</div>

<pre class="example">
(500, 6.4, 2)
</pre>
</section>
<section id="slide-5-3-9">
<h4 id="5-3-9"><span class="section-number-4">5.3.9.</span> Низовни тип</h4>
<ul>
<li>Сваки елемент низовног типа мора имати исти тип</li>
<li><p>
Димензија низа је непромењива (алоциран је на стеку)
</p>
<div class="org-src-container">

<pre><code class="rust" >    fn main() {
        let a = [1, 2, 3, 4, 5];
    }
</code></pre>
</div></li>

<li><p>
Тип се може експлицитно дефинисати на следећи начин (низ дужине <code>5</code> типа <code>i32</code>):
</p>
<div class="org-src-container">

<pre><code class="rust" >    let a: [i32; 5] = [1, 2, 3, 4, 5];
</code></pre>
</div></li>

<li><p>
Иницијализација свих елемената на исту вредност се обавља на следећи начин:
</p>
<div class="org-src-container">

<pre><code class="rust" >  let a = [3; 5];
</code></pre>
</div>
<p>
Где је вредност сваког елемента <code>3</code> а дужина низа <code>5</code>.
</p></li>

</ul>

</section>
<section>

<p>
Индексни приступ:
</p>

<div class="org-src-container">

<pre><code class="rust" >fn main() {
    let a = [1, 2, 3, 4, 5];

    let first = a[0];
    let second = a[1];
}
</code></pre>
</div>

<p>
Конверзија низа у хомогену торку:
</p>
<div class="org-src-container">

<pre><code class="rust" >fn main() {
    let a = [1, 2, 3];
    let tup: (u32, u32, u32) = a.into();
    println!("{tup:?}")
}
</code></pre>
</div>

<pre class="example">
(1, 2, 3)
</pre>
</section>
<section id="slide-5-4">
<h3 id="5-4"><span class="section-number-3">5.4.</span> Функције</h3>
<div class="outline-text-3" id="text-5-4">
</div>
</section>
<section id="slide-5-4-1">
<h4 id="5-4-1"><span class="section-number-4">5.4.1.</span> Функције</h4>
<div class="org-src-container">

<pre><code class="rust" >fn main() {
    println!("Hello, world!");

    another_function();
}

fn another_function() {
    println!("Another function.");
}
</code></pre>
</div>
<ul>
<li>За именовање функција као и варијабли користи се <i>snake_case</i>.</li>

</ul>
</section>
<section id="slide-5-4-2">
<h4 id="5-4-2"><span class="section-number-4">5.4.2.</span> Funkcije - parametri</h4>
<div class="org-src-container">

<pre><code class="rust" >fn main() {
    print_labeled_measurement(5, 'h');
}

fn print_labeled_measurement(value: i32, unit_label: char) {
    println!("The measurement is: {}{}", value, unit_label);
}
</code></pre>
</div>
</section>
<section id="slide-5-4-3">
<h4 id="5-4-3"><span class="section-number-4">5.4.3.</span> Искази и изрази</h4>
<ul>
<li>Рaст је језик базиран на изразима (<i>expression-based</i>)</li>
<li>Искази (<i>statements</i>) су језичке конструкције које немају повратну вредност.
Изрази (<i>expressions</i>) се евалуирају у одређени резултат, тј. имају вредност.</li>
<li><p>
Пример: <code>let</code> је исказ тј. нема повратну вредност. Ово можете писати:
</p>
<div class="org-src-container">

<pre><code class="rust" >  let y = 6;
</code></pre>
</div>
<p>
Ali ovo ne:
</p>
<div class="org-src-container">

<pre><code class="rust" >  let x = (let y = 6);
</code></pre>
</div></li>

</ul>

</section>
<section>

<p>
Блок кода је такође израз. Шта је вредност у коју се евалуира?
</p>

<div class="org-src-container">

<pre><code class="rust" >{
    let x = 3;
    x + 1
}
</code></pre>
</div>

<p>
Вредност блока је вредност последњег израза, тј. <code>x+1</code>. Приметите да ту не
користимо <code>;</code> јер терминација овим карактером претвара израз у исказ.
</p>

</section>
<section>

<p>
Због овога је сасвим легално да пишемо:
</p>

<div class="org-src-container">

<pre><code class="rust" >fn main() {
    let y = {
        let x = 3;
        x + 1
    };

    println!("The value of y is: {}", y);
}
</code></pre>
</div>

<pre class="example">
The value of y is: 4
</pre>
</section>
<section id="slide-5-4-4">
<h4 id="5-4-4"><span class="section-number-4">5.4.4.</span> Повратне вредности функција</h4>
<p>
Вредност функције је вредност блока који представља тело функције, дакле
последњег израза унутар тела функције.
</p>

<div class="org-src-container">

<pre><code class="rust" >fn five() -&gt; i32 {
    5
}

fn main() {
    let x = five();

    println!("The value of x is: {}", x);
}
</code></pre>
</div>

<pre class="example">
The value of x is: 5
</pre>


</section>
<section>

<p>
Или на пример:
</p>
<div class="org-src-container">

<pre><code class="rust" >fn main() {
    let x = plus_one(5);

    println!("The value of x is: {}", x);
}

fn plus_one(x: i32) -&gt; i32 {
    x + 1
}
</code></pre>
</div>

<pre class="example">
The value of x is: 6
</pre>


</section>
<section>

<p>
Уколико израз <code>x+1</code> терминирамо са <code>;</code> код се неће компајлирати јер функција
декларише да враћа тип <code>i32</code> док сада враћа <code>()</code> (тзв. <i>unit type</i>) односно нема
повратну вредност јер је последња инструкција исказ.
</p>

<div class="org-src-container">

<pre><code class="rust" >fn main() {
    let x = plus_one(5);

    println!("The value of x is: {}", x);
}

fn plus_one(x: i32) -&gt; i32 {
    x + 1;
}
</code></pre>
</div>

<pre class="example" id="orgfab40e2">
error[E0308]: mismatched types
 --&gt; src/main.rs:8:24
  |
8 | fn plus_one(x: i32) -&gt; i32 {
  |    --------            ^^^ expected `i32`, found `()`
  |    |
  |    implicitly returns `()` as its body has no tail or `return` expression
9 |     x + 1;
  |          - help: consider removing this semicolon

For more information about this error, try `rustc --explain E0308`.
error: could not compile `cargo4UyKF0` due to previous error
</pre>
</section>
<section id="slide-5-5">
<h3 id="5-5"><span class="section-number-3">5.5.</span> Коментари</h3>
<p>
Коментари се пишу после <code>//</code> или у форми блок коментара <code>/*.... */</code> као и у C++-у.
Ово би били валидни коментари:
</p>
<div class="org-src-container">

<pre><code class="rust" >// So we’re doing something complicated here, long enough that we need
// multiple lines of comments to do it! Whew! Hopefully, this comment will
// explain what’s going on.

fn main() {
    let lucky_number = 7; // I’m feeling lucky today
}
...
fn main() {
    // I’m feeling lucky today
    let lucky_number = 7;
    /* this is block comment
       which can span multiple lines.
       Nesting is allowed.
     */
}
</code></pre>
</div>

</section>
<section>

<p>
Постоје и коментари за документацију који представљају посебну синтаксу за
коментаре који су део API документације. Они се пишу после <code>///</code>. На пример:
</p>
<div class="org-src-container">

<pre><code class="rust" >/// Adds one to the number given.
///
/// # Examples
///
/// ```
/// let arg = 5;
/// let answer = my_crate::add_one(arg);
///
/// assert_eq!(6, answer);
/// ```
pub fn add_one(x: i32) -&gt; i32 {
    x + 1
}
</code></pre>
</div>
</section>
<section id="slide-5-6">
<h3 id="5-6"><span class="section-number-3">5.6.</span> Контрола тока</h3>
<div class="outline-text-3" id="text-5-6">
</div>
</section>
<section id="slide-5-6-1">
<h4 id="5-6-1"><span class="section-number-4">5.6.1.</span> <code>if</code> изрази</h4>
<div class="org-src-container">

<pre><code class="rust" >fn main() {
    let number = 3;

    if number &lt; 5 {
        println!("condition was true");
    } else {
        println!("condition was false");
    }
}
</code></pre>
</div>
</section>
<section id="slide-5-6-2">
<h4 id="5-6-2"><span class="section-number-4">5.6.2.</span> <code>if-else</code></h4>
<div class="org-src-container">

<pre><code class="rust" >fn main() {
    let number = 6;

    if number % 4 == 0 {
        println!("number is divisible by 4");
    } else if number % 3 == 0 {
        println!("number is divisible by 3");
    } else if number % 2 == 0 {
        println!("number is divisible by 2");
    } else {
        println!("number is not divisible by 4, 3, or 2");
    }
}
</code></pre>
</div>
</section>
<section id="slide-5-6-3">
<h4 id="5-6-3"><span class="section-number-4">5.6.3.</span> <code>if</code> у <code>let</code> исказима</h4>
<p>
<code>if</code> је израз па се може користити где год можемо писати и било који други израз.
</p>

<div class="org-src-container">

<pre><code class="rust" >fn main() {
    let condition = true;
    let number = if condition { 5 } else { 6 };

    println!("The value of number is: {}", number);
}
</code></pre>
</div>

<pre class="example">
The value of number is: 5
</pre>


</section>
<section>

<p>
Али се гране морају слагати по типу. Ово је погрешно јер је прва грана типа
<code>i32</code> док је <code>else</code> грана типа <code>str</code>.
</p>

<div class="org-src-container">

<pre><code class="rust" >fn main() {
    let condition = true;

    let number = if condition { 5 } else { "six" };

    println!("The value of number is: {}", number);
}
</code></pre>
</div>
</section>
<section id="slide-5-6-4">
<h4 id="5-6-4"><span class="section-number-4">5.6.4.</span> Петље</h4>
<p>
Рaст има три типа петље:
</p>
<ul>
<li><code>loop</code> - за бесконачне петље</li>
<li><code>while</code> - условна петља</li>
<li><code>for</code> - петља за итерацију кроз елементе итерабилних типова</li>

</ul>
</section>
<section id="slide-5-6-5">
<h4 id="5-6-5"><span class="section-number-4">5.6.5.</span> <code>loop</code></h4>
<div class="org-src-container">

<pre><code class="rust" >fn main() {
    loop {
        println!("again!");
    }
}
</code></pre>
</div>
</section>
<section id="slide-5-6-6">
<h4 id="5-6-6"><span class="section-number-4">5.6.6.</span> <code>loop</code> лабеле</h4>
<p>
Уколико имамо угњеждене <code>loop</code> исказе можемо користити лабеле приликом изласка са
<code>break</code> инструкцијом.
</p>

<div class="org-src-container">

<pre><code class="rust" >fn main() {
    let mut count = 0;
    'counting_up: loop {
        println!("count = {}", count);
        let mut remaining = 10;

        loop {
            println!("remaining = {}", remaining);
            if remaining == 9 {
                break;
            }
            if count == 2 {
                break 'counting_up;
            }
            remaining -= 1;
        }

        count += 1;
    }
    println!("End count = {}", count);
}
</code></pre>
</div>
</section>
<section id="slide-5-6-7">
<h4 id="5-6-7"><span class="section-number-4">5.6.7.</span> <code>loop</code> као израз</h4>
<p>
<code>loop</code> може имати повратну вредност. Повратна вредност се дефинише као параметар
<code>break</code> инструкције.
</p>

<div class="org-src-container">

<pre><code class="rust" >fn main() {
    let mut counter = 0;

    let result = loop {
        counter += 1;

        if counter == 10 {
            break counter * 2;
        }
    };

    println!("The result is {}", result);
}
</code></pre>
</div>
</section>
<section id="slide-5-6-8">
<h4 id="5-6-8"><span class="section-number-4">5.6.8.</span> <code>while</code></h4>
<div class="org-src-container">

<pre><code class="rust" >fn main() {
    let mut number = 3;

    while number != 0 {
        println!("{}!", number);

        number -= 1;
    }

    println!("LIFTOFF!!!");
}
</code></pre>
</div>
</section>
<section id="slide-5-6-9">
<h4 id="5-6-9"><span class="section-number-4">5.6.9.</span> <code>for</code></h4>
<p>
Итерацију кроз уређену колекцију, као што је низ, можемо обавити са <code>while</code> петљом.
</p>
<div class="org-src-container">

<pre><code class="rust" >fn main() {
    let a = [10, 20, 30, 40, 50];
    let mut index = 0;

    while index &lt; 5 {
        println!("the value is: {}", a[index]);

        index += 1;
    }
}
</code></pre>
</div>

</section>
<section>
<p>
Али је за ту намену природније и сигурније користити <code>for</code> петљу. Такође ће се
програм брже извршавати.
</p>

<div class="org-src-container">

<pre><code class="rust" >fn main() {
    let a = [10, 20, 30, 40, 50];

    for element in a {
        println!("the value is: {}", element);
    }
}
</code></pre>
</div>

</section>
<section>
<p>
<code>for</code> петље су најчешћи облик петљи у употреби у Расту. Користе се нпр. и у
ситуацији када је потребно извршити петљу одређени број пута.
</p>

<div class="org-src-container">

<pre><code class="rust" >fn main() {
    for number in (1..4).rev() {
        println!("{}!", number);
    }
    println!("LIFTOFF!!!");
}
</code></pre>
</div>

<pre class="example">
3!
2!
1!
LIFTOFF!!!
</pre>
</section>
<section id="slide-5-6-10">
<h4 id="5-6-10"><span class="section-number-4">5.6.10.</span> <code>for</code> и итератори</h4>
<p>
Приликом итерације употребом <code>for</code> исказа имплицитно се позива метода
<code>into_iter()</code> над колекцијом. Ова метода конзумира елементе колекције.
</p>

<div class="org-src-container">

<pre><code class="rust" >fn main() {
    let names = vec!["Bob", "Frank", "Ferris"];

    for name in names.into_iter() {
        match name {
            "Ferris" =&gt; println!("There is a rustacean among us!"),
            _ =&gt; println!("Hello {}", name),
        }
    }

    // println!("names: {:?}", names); -- FIXME: колекција овде није доступна
}
</code></pre>
</div>

</section>
<section>

<div class="org-src-container">

<pre><code class="rust" >fn main() {
    let names = vec!["Bob", "Frank", "Ferris"];

    for name in names.iter() {
        match name {
            &amp;"Ferris" =&gt; println!("There is a rustacean among us!"),
            // TODO ^ Try deleting the &amp; and matching just "Ferris"
            _ =&gt; println!("Hello {}", name),
        }
    }

    println!("names: {:?}", names);
}
</code></pre>
</div>

<pre class="example">
Hello Bob
Hello Frank
There is a rustacean among us!
names: ["Bob", "Frank", "Ferris"]
</pre>


</section>
<section>

<div class="org-src-container">

<pre><code class="rust" >fn main() {
    let mut names = vec!["Bob", "Frank", "Ferris"];

    for name in names.iter_mut() {
        *name = match name {
            &amp;mut "Ferris" =&gt; "There is a rustacean among us!",
            _ =&gt; "Hello",
        }
    }

    println!("names: {:?}", names);
}
</code></pre>
</div>

<pre class="example">
names: ["Hello", "Hello", "There is a rustacean among us!"]
</pre>
</section>
</section>
<section>
<section id="slide-6">
<h2 id="6"><span class="section-number-2">6.</span> Власништво и позајмљивање (<i>Ownership and borrowing</i>)</h2>
<div class="outline-text-2" id="text-6">
</div>
</section>
<section id="slide-6-1">
<h3 id="6-1"><span class="section-number-3">6.1.</span> Власништво</h3>
<div class="outline-text-3" id="text-6-1">
</div>
</section>
<section id="slide-6-1-1">
<h4 id="6-1-1"><span class="section-number-4">6.1.1.</span> Власништво</h4>
<ul>
<li>Један од најважнијих концепата језика.</li>
<li>Скуп правила који омогућавају управљање меморијом.</li>
<li>Гаранције за меморијску сигурност без употребе <i>garbage collector</i>-а</li>
<li>Све провере се обављају у време компајлирања - резултује одличним
перформансама у време извршавања.</li>

</ul>
</section>
<section id="slide-6-1-2">
<h4 id="6-1-2"><span class="section-number-4">6.1.2.</span> Стек и хип (<i>Stack and Heap</i>)</h4>
<ul>
<li>Стек - алокација простора за податке чија је величина позната у време
компајлирања.
<ul>
<li>Бржа алокација и деалокација - једноставан механизам, LIFO структура.</li>
<li>Бржи приступ - локалне варијабле, кеширање приступа.</li>

</ul></li>
<li>Хип - слободна алокација у време извршавања.
<ul>
<li>Спорија алокација и деалокација.</li>
<li>Спорији приступ - произвољна локација.</li>

</ul></li>

</ul>
</section>
<section id="slide-6-1-3">
<h4 id="6-1-3"><span class="section-number-4">6.1.3.</span> Правила власништва</h4>
<ol>
<li>Свака вредност у Расту има варијаблу која се назива <i>власником</i> (<i>owner</i>).</li>
<li>У сваком тренутку постоји само један власник.</li>
<li>Када власник изађе из опсега важења (<i>scope</i>) вредност се деалоцира (<i>drop</i>).</li>

</ol>
</section>
<section id="slide-6-1-4">
<h4 id="6-1-4"><span class="section-number-4">6.1.4.</span> Опсег важења варијабле (<i>Variable Scope</i>)</h4>
<div class="org-src-container">

<pre><code class="rust" >{                      // s није валидно овде јер још није декларисано
    let s = "hello";   // s је валидно од ове позиције

    // користимо s
}   // овде опсег престаје да важи и s више није валидно
</code></pre>
</div>
</section>
<section id="slide-6-1-5">
<h4 id="6-1-5"><span class="section-number-4">6.1.5.</span> <code>String</code> тип</h4>
<ul>
<li><p>
Демонстрација власништва над типом који се алоцира на хипу.
</p>

<div class="org-src-container">

<pre><code class="rust" >  let mut s = String::from("hello");
  s.push_str(", world!"); // push_str() додаје литерал на стринг
  println!("{}", s); // hello, world!`
</code></pre>
</div></li>

<li>Меморија се алоцира са хипа у време извршавања.</li>
<li>Морамо вратити меморију алокатору када нам више није потребна.</li>

</ul>

</section>
<section>

<ul>
<li><p>
Алокација стринга се обавља на линији:
</p>

<div class="org-src-container">

<pre><code class="rust" >  let mut s = String::from("hello");
</code></pre>
</div></li>

<li>Али деалокација је тежа:
<ul>
<li><i>Garbage collector</i></li>
<li><i>Memory waste</i></li>
<li><i>Double-free</i></li>

</ul></li>

</ul>

</section>
<section>

<ul>
<li>Раст компајлер ће додати кôд који ради деалокацију када власник напусти опсег важења.</li>
<li><p>
Позива се функција <code>drop</code> над типом и ова функција је задужена да обави деалокацију.
</p>

<div class="org-src-container">

<pre><code class="rust" >  {
        let s = String::from("hello"); // s постаје валидно

        // користимо s
  }  // &lt;- s излази из опсега и позива се "drop"
</code></pre>
</div></li>

</ul>
</section>
<section id="slide-6-1-6">
<h4 id="6-1-6"><span class="section-number-4">6.1.6.</span> Додела вредности</h4>
<ul>
<li><p>
Копирање вредности <code>x</code> у <code>y</code>. Обе варијабле сада имају вредност <code>5</code>.
</p>

<div class="org-src-container">

<pre><code class="rust" >  let x = 5;
  let y = x;
</code></pre>
</div></li>

<li><p>
Али са <code>String</code> типом дешава се нешто друго.
</p>

<div class="org-src-container">

<pre><code class="rust" >  let s1 = String::from("hello");
</code></pre>
</div></li>

</ul>


<div id="orgcc85690" class="figure">
<p><img src="./images/string-type.png" alt="string-type.png" style="height: 400px;" />
</p>
</div>

</section>
<section>

<ul>
<li><p>
Ако би се копирао само садржај са стека имали бисмо следећу ситуацију (тзв.
<i>shallow copy</i>).
</p>

<div class="org-src-container">

<pre><code class="rust" >  let s1 = String::from("hello");
  let s2 = s1;
</code></pre>
</div></li>

</ul>


<div id="org59d8b5a" class="figure">
<p><img src="./images/string-type-2.png" alt="string-type-2.png" style="height: 400px;" />
</p>
</div>

<p>
Што је проблематично јер када и <code>s1</code> и <code>s2</code> напусте опсег покушаће се двострука
деалокација исте меморије на хипу (<i>double free</i>).
</p>

</section>
<section>

<p>
Ако би се и хип меморија копирала (tzv. <i>deep copy</i>) имали бисмо валидну ситуацију
али би таква операција била веома "скупа".
</p>


<div id="org5d8c9ff" class="figure">
<p><img src="./images/string-type-3.png" alt="string-type-3.png" style="height: 500px;" />
</p>
</div>
</section>
<section id="slide-6-1-7">
<h4 id="6-1-7"><span class="section-number-4">6.1.7.</span> Премештање (<i>Move</i>)</h4>
<p>
Ако пробамо да компајлирамо следећи код:
</p>

<div class="org-src-container">

<pre><code class="rust" >let s1 = String::from("hello");
let s2 = s1;

println!("{}, world!", s1);
</code></pre>
</div>

<p>
Добићемо грешку:
</p>

<pre class="example" id="orgd4db015">
$ cargo run
   Compiling ownership v0.1.0 (file:///projects/ownership)
error[E0382]: borrow of moved value: `s1`
 --&gt; src/main.rs:5:28
  |
2 |     let s1 = String::from("hello");
  |         -- move occurs because `s1` has type `String`, which does not implement the `Copy` trait
3 |     let s2 = s1;
  |              -- value moved here
4 |
5 |     println!("{}, world!", s1);
  |                            ^^ value borrowed here after move

For more information about this error, try `rustc --explain E0382`.
error: could not compile `ownership` due to previous error
</pre>

</section>
<section>

<p>
Оно што нам компајлер каже је да се у исказу:
</p>

<div class="org-src-container">

<pre><code class="rust" >let s2 = s1;
</code></pre>
</div>

<p>
променио власник овог стринга. Нови власник је сада <code>s2</code> док је варијабла <code>s1</code>
постала невалидна и није је више могуће користити.
</p>

<p>
Кажемо да се обавило "премештање" (<i>move</i>) вредности из <code>s1</code> у <code>s2</code>.
</p>


<div id="org2fc1415" class="figure">
<p><img src="./images/string-type-4.png" alt="string-type-4.png" style="height: 400px;" />
</p>
</div>

<p>
Чиме се испуњава прво правило власништва и спречава <i>double free</i> грешка.
</p>
</section>
<section id="slide-6-1-8">
<h4 id="6-1-8"><span class="section-number-4">6.1.8.</span> Клонирање</h4>
<p>
Последица претходног је да Раст никада неће аутоматски обавити дубоко копирање
варијабле јер би то могло да изазове лоше перформансе.
</p>

<p>
Дубоко копирање (стек+хип) радимо са <code>clone</code> методом:
</p>

<div class="org-src-container">

<pre><code class="rust" >let s1 = String::from("hello");
let s2 = s1.clone();

println!("s1 = {}, s2 = {}", s1, s2);
</code></pre>
</div>

<p>
Сада је лако пронаћи у коду сва места где се обавља потенцијално "скупа"
операција дубоког копирања.
</p>
</section>
<section id="slide-6-1-9">
<h4 id="6-1-9"><span class="section-number-4">6.1.9.</span> <i>Copy</i> типови</h4>
<p>
Како онда ради пример који смо видели претходно? Зашто не долази до премештања
и инвалидације <code>y</code> варијабле?
</p>

<div class="org-src-container">

<pre><code class="rust" >let x = 5;
let y = x;

println!("x = {}, y = {}", x, y);
</code></pre>
</div>

<ul>
<li>Код простих типова чија је величина позната у време компајлирања и који могу
у целости стати на стек нема разлике између дубоког и плитког копирања.</li>
<li>Овакви типови имплементирају <i>Copy</i> особину (<i>Trait</i>). Вредности ових типова не
обављају премештање већ увек копирање.</li>
<li>Импликација је да се варијабла са десне стране доделе може користити и након
доделе.</li>
<li>Раст ће спречити имплементацију <i>Copy</i> особине ако тип имплементира и <i>Drop</i> јер
то значи да ради неку специјалну алокацију па му је потребна и посебна
деалокација што значи да мора да се ради премештање.</li>

</ul>
</section>
<section id="slide-6-1-10">
<h4 id="6-1-10"><span class="section-number-4">6.1.10.</span> Власништво и функције</h4>
<ul>
<li>Семантика преноса параметара код позива функција је слична семантици доделе.</li>

</ul>

<div class="org-src-container">

<pre><code class="rust" >fn main() {
    let s = String::from("hello");  // s постаје валидно

    takes_ownership(s);             // s вредност се премешта у функцију...
                                    // ... тако да s није валидно од ове позиције

    let x = 5;                      // x постаје валидно

    makes_copy(x);                  // x би се преместило у функцију,
                                    // али i32 је Copy, тако да је ok
                                    // да се x користи и после

} // x излази из опсега, затим s. Али пошто је s премештено ништа посебно се
  // не дешава.

fn takes_ownership(some_string: String) { // some_string улази у опсег
    println!("{}", some_string);
} // some_string излази из опсега и позива се `drop`. Меморија са хипа се
  // ослобађа.

fn makes_copy(some_integer: i32) { // some_integer улази у опсег
    println!("{}", some_integer);
} // some_integer излази из опсега. Пошто није 'Drop', ништа посебно се не
  // догађа (осим "скидања" са стека наравно)
</code></pre>
</div>
</section>
<section id="slide-6-1-11">
<h4 id="6-1-11"><span class="section-number-4">6.1.11.</span> Повратне вредности и опсези</h4>
<p>
Приликом враћања вредности из функције такође може доћи до премештања власништва.
</p>

<div class="org-src-container">

<pre><code class="rust" >fn main() {
    let s1 = gives_ownership();         // gives_ownership премешта повратну
                                        // вредност у s1

    let s2 = String::from("hello");     // s2 постаје валидно

    let s3 = takes_and_gives_back(s2);  // s2 се премешта у функцију
                                        // takes_and_gives_back, која премешта
                                        // повратну вредност у s3
} // s3 излази из опсега и позива се `drop`. s2 је премештена па се ништа
  // не дешава. s1 такође излази из опсега и деалоцира се.

fn gives_ownership() -&gt; String {             // gives_ownership ће преместити
                                             // своју повратну вредност у функцију
                                             // која је позива

    let some_string = String::from("yours"); // some_string постаје валидно

    some_string                              // some_string се премешта
                                             // у функцију позиваоца
}

// Ова функција узима власништво над стрингом и враћа га назад
fn takes_and_gives_back(a_string: String) -&gt; String { // a_string постаје валидно

    a_string  // a_string се премешта у функцију позиваоца
}
</code></pre>
</div>

</section>
<section>

<ul>
<li>Често нам је потребно да варијаблу користимо и после слања у функцију.</li>
<li>Могли би је стало враћати заједно са резултатом функције на пример употребом торки.</li>

</ul>

<div class="org-src-container">

<pre><code class="rust" >fn main() {
    let s1 = String::from("hello");

    let (s2, len) = calculate_length(s1);

    println!("The length of '{}' is {}.", s2, len);
}

fn calculate_length(s: String) -&gt; (String, usize) {
    let length = s.len();

    (s, length)
}
</code></pre>
</div>

<p>
Али је то напорно. Постоји концепт у Раст који је намењен оваквим
ситуацијама и базиран је на референцама и позајмљивању вредности.
</p>
</section>
<section id="slide-6-2">
<h3 id="6-2"><span class="section-number-3">6.2.</span> Референце и позајмљивање (<i>References and Borrowing</i>)</h3>
<div class="outline-text-3" id="text-6-2">
</div>
</section>
<section id="slide-6-2-1">
<h4 id="6-2-1"><span class="section-number-4">6.2.1.</span> Референце и позајмљивање (<i>References and Borrowing</i>)</h4>
<ul>
<li>Референца је попут поинтера, садржи адресу вредности коју поседује нека друга
варијабла.</li>
<li>За разлику од поинтера, референце у Расту су гарантовано валидне.</li>

</ul>

<div class="org-src-container">

<pre><code class="rust" >fn main() {
    let s1 = String::from("hello");

    let len = calculate_length(&amp;s1);

    println!("The length of '{}' is {}.", s1, len);
}

fn calculate_length(s: &amp;String) -&gt; usize {
    s.len()
}
</code></pre>
</div>


<div id="org1b84978" class="figure">
<p><img src="./images/reference.png" alt="reference.png" style="height: 400px;" />
</p>
</div>
</section>
<section id="slide-6-2-2">
<h4 id="6-2-2"><span class="section-number-4">6.2.2.</span> Референцирање</h4>
<ul>
<li><p>
Примена оператора <code>&amp;</code> над варијаблом називамо <i>референцирање</i>.
</p>

<div class="org-src-container">

<pre><code class="rust" >  let s1 = String::from("hello");
  let len = calculate_length(&amp;s1);
</code></pre>
</div></li>

<li>Синтакса <code>&amp;s1</code> нам омогућава да креирамо референцу на вредност чији власник је
<code>s1</code> без узимања власништва.</li>
<li>Пошто референца није власник не долази до деалокације приликом изласка из
опсега.</li>
<li>Операција обрнута референцирању назива се <i>дереференцирање</i> и врши се <code>*</code>
оператором над референцом (нпр. <code>*s2</code> је вредност на коју референцира <code>s2</code>).</li>
<li>Операцију референцирања називамо позајмљивањем (<i>borrowing</i>).</li>

</ul>

</section>
<section>

<ul>
<li>Параметар функције може бити референца.</li>

</ul>
<div class="org-src-container">

<pre><code class="rust" >fn calculate_length(s: &amp;String) -&gt; usize { // s је референца на String
    s.len()
} // s излази из опсега али пошто нема власништво над вредношћу
  // ништа се не дешава.
</code></pre>
</div>
</section>
<section id="slide-6-2-3">
<h4 id="6-2-3"><span class="section-number-4">6.2.3.</span> Промена позајмљене вредности</h4>
<p>
Шта се дешава уколико покушамо да модификујемо позајмљену вредност?
</p>

<div class="org-src-container">

<pre><code class="rust" >fn main() {
    let s = String::from("hello");
    change(&amp;s);
}

fn change(some_string: &amp;String) {
    some_string.push_str(", world");
}
</code></pre>
</div>

<pre class="example" id="org43ce387">
$ cargo run
   Compiling ownership v0.1.0 (file:///projects/ownership)
error[E0596]: cannot borrow `*some_string` as mutable, as it is behind a `&amp;` reference
 --&gt; src/main.rs:8:5
  |
7 | fn change(some_string: &amp;String) {
  |                        ------- help: consider changing this to be a mutable reference: `&amp;mut String`
8 |     some_string.push_str(", world");
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ `some_string` is a `&amp;` reference, so the data it refers
  to cannot be borrowed as mutable

For more information about this error, try `rustc --explain E0596`.
error: could not compile `ownership` due to previous error
</pre>
</section>
<section id="slide-6-2-4">
<h4 id="6-2-4"><span class="section-number-4">6.2.4.</span> Промењиве референце</h4>
<p>
Као и варијабле, и референце су подразумевано непромењива (<i>immutable</i>). Морамо
бити експлицитни уколико нам треба промењива референца.
</p>

<div class="org-src-container">

<pre><code class="rust" >fn main() {
    let mut s = String::from("hello");
    change(&amp;mut s);
}

fn change(some_string: &amp;mut String) {
    some_string.push_str(", world");
}
</code></pre>
</div>
</section>
<section id="slide-6-2-5">
<h4 id="6-2-5"><span class="section-number-4">6.2.5.</span> Више промењивих референци над истом вредношћу</h4>
<p>
Раст не дозвољава да исти податак у једном тренутку има више промењивих
референци.
</p>

<div class="org-src-container">

<pre><code class="rust" >let mut s = String::from("hello");

let r1 = &amp;mut s;
let r2 = &amp;mut s;

println!("{}, {}", r1, r2);
</code></pre>
</div>

<pre class="example" id="org7926e86">
$ cargo run
   Compiling ownership v0.1.0 (file:///projects/ownership)
error[E0499]: cannot borrow `s` as mutable more than once at a time
 --&gt; src/main.rs:5:14
  |
4 |     let r1 = &amp;mut s;
  |              ------ first mutable borrow occurs here
5 |     let r2 = &amp;mut s;
  |              ^^^^^^ second mutable borrow occurs here
6 |
7 |     println!("{}, {}", r1, r2);
  |                        -- first borrow later used here

For more information about this error, try `rustc --explain E0499`.
error: could not compile `ownership` due to previous error
</pre>

</section>
<section>

<p>
Овим ограничењем Раст, у време компајлирања, спречава класу грешака које
доводе до недефинисаног понашања и које зовемо <i>data races</i>. Ове грешке се веома
тешко откривају и отклањају и могу настати уколико су задовољени следећи
услови:
</p>

<ul>
<li>Два или више поинтера приступају истим подацима у исто време,</li>
<li>Бар један поинтер се користи за измену податка,</li>
<li>Не постоји механизам за синхронизацију приступа.</li>

</ul>

</section>
<section>

<p>
Више промењивих референци можемо имати али не у истом опсегу:
</p>

<div class="org-src-container">

<pre><code class="rust" >let mut s = String::from("hello");

{
    let r1 = &amp;mut s;
} // r1 овде излази из опсега тако да можемо краирати нове референце

let r2 = &amp;mut s;
</code></pre>
</div>
</section>
<section id="slide-6-2-6">
<h4 id="6-2-6"><span class="section-number-4">6.2.6.</span> Комбинација промењивих и непромењивих референци</h4>
<p>
Слично правило постоји и уколико имамо комбинацију промењивих и непромењивих
референци:
</p>

<div class="org-src-container">

<pre><code class="rust" >let mut s = String::from("hello");

let r1 = &amp;s; // ovo je OK
let r2 = &amp;s; // ovo je OK
let r3 = &amp;mut s; // GREŠKA!

println!("{}, {}, and {}", r1, r2, r3);
</code></pre>
</div>

<pre class="example" id="org513deda">
$ cargo run
   Compiling ownership v0.1.0 (file:///projects/ownership)
error[E0502]: cannot borrow `s` as mutable because it is also borrowed as immutable
 --&gt; src/main.rs:6:14
  |
4 |     let r1 = &amp;s; // no problem
  |              -- immutable borrow occurs here
5 |     let r2 = &amp;s; // no problem
6 |     let r3 = &amp;mut s; // BIG PROBLEM
  |              ^^^^^^ mutable borrow occurs here
7 |
8 |     println!("{}, {}, and {}", r1, r2, r3);
  |                                -- immutable borrow later used here

For more information about this error, try `rustc --explain E0502`.
error: could not compile `ownership` due to previous error
</pre>

</section>
<section>

<ul>
<li>Не можемо истовремено имати непромењиве и промењиве референце јер корисници
непромењивих референци не очекују да се подаци мењају.</li>
<li>Можемо имати више непромењивих референци јер нико не може да мења податке и
тиме утиче на друге.</li>
<li>Промењиве референце често зовемо и <i>јединствене референце</i> јер када су оне
активне не може постојати друга референца на исту вредност.</li>

</ul>
</section>
<section id="slide-6-2-7">
<h4 id="6-2-7"><span class="section-number-4">6.2.7.</span> Опсег важења референце</h4>
<p>
Опсег важења референце почиње од места где је уведена па до њене последње
употребе. На пример, ово је валидно:
</p>

<div class="org-src-container">

<pre><code class="rust" >let mut s = String::from("hello");

let r1 = &amp;s; // OK
let r2 = &amp;s; // OK
println!("{} and {}", r1, r2);
// варијабле r1 и r2 се не користе у наставку па њихов опсег
// престаје да важи.

let r3 = &amp;mut s; // зато је ово OK
println!("{}", r3);
</code></pre>
</div>

<p>
Ова особина референци се назива <i>Non-Lexical Lifetimes (NLL)</i>.
</p>
</section>
<section id="slide-6-2-8">
<h4 id="6-2-8"><span class="section-number-4">6.2.8.</span> "Висеће" референце</h4>
<ul>
<li>У језицима са поинтерима лако је креирати поинтер на део меморије који је деалоциран.</li>
<li>Раст гарантовано спречава овакве грешке. Референце су увек валидне у Расту.</li>

</ul>

<div class="org-src-container">

<pre><code class="rust" >fn main() {
    let reference_to_nothing = dangle();
}

fn dangle() -&gt; &amp;String {
    let s = String::from("hello");

    &amp;s
}
</code></pre>
</div>

</section>
<section>

<pre class="example" id="orgeb867dd">
$ cargo run
   Compiling ownership v0.1.0 (file:///projects/ownership)
error[E0106]: missing lifetime specifier
 --&gt; src/main.rs:5:16
  |
5 | fn dangle() -&gt; &amp;String {
  |                ^ expected named lifetime parameter
  |
  = help: this function's return type contains a borrowed value, but there is no value
  for it to be borrowed from
help: consider using the `'static` lifetime
  |
5 | fn dangle() -&gt; &amp;'static String {
  |                ~~~~~~~~

For more information about this error, try `rustc --explain E0106`.
error: could not compile `ownership` due to previous error
</pre>

<ul>
<li>Механизам који ово спречава назива се "време живота" (<i>lifetime</i>) и биће
детаљније обрађено у наставку.</li>
<li><p>
У преводу Раст нам поручује:
</p>

<blockquote>
<p>
Тип повратне вредности ове функције је позајмљена вредност, али не постоји
улазни параметар од кога може да се позајми.
</p>
</blockquote></li>

</ul>
</section>
<section id="slide-6-2-9">
<h4 id="6-2-9"><span class="section-number-4">6.2.9.</span> Шта се тачно десило?</h4>
<div class="org-src-container">

<pre><code class="rust" >fn dangle() -&gt; &amp;String { // dangle враћа референцу на String

    let s = String::from("hello"); // s је нови String

    &amp;s // Враћамо референцу на String s
} // s излази из опсега и позива се `drop`. Меморија се ослобађа.
  // ОПАСНОСТ! Враћена референца ће бити "висећа".
</code></pre>
</div>

<p>
Како се може решити. Вратићемо поседовану (<i>owned</i>) вредност, тј урадићемо
премештање вредности у функцију позиваоца.
</p>

<div class="org-src-container">

<pre><code class="rust" >fn no_dangle() -&gt; String {
    let s = String::from("hello");

    s
}
</code></pre>
</div>
</section>
<section id="slide-6-2-10">
<h4 id="6-2-10"><span class="section-number-4">6.2.10.</span> Правила референцирања</h4>
<ol>
<li>У сваком тренутку можемо имати или једну промењиву или произвољан број
непромењивих референци.</li>
<li>Референце увек морају бити валидне.</li>

</ol>
</section>
<section id="slide-6-3">
<h3 id="6-3"><span class="section-number-3">6.3.</span> Исечци (<i>Slice</i> тип)</h3>
<div class="outline-text-3" id="text-6-3">
</div>
</section>
<section id="slide-6-3-1">
<h4 id="6-3-1"><span class="section-number-4">6.3.1.</span> <i>Slice</i></h4>
<ul>
<li>Исечци (<i>slices</i>) омогућавају референцирање континуалне секвенце унутар
колекције уместо целе колекције</li>

</ul>
</section>
<section id="slide-6-3-2">
<h4 id="6-3-2"><span class="section-number-4">6.3.2.</span> Пример</h4>
<p>
Функција која за задати стринг враћа прву реч.
</p>

<div class="org-src-container">

<pre><code class="rust" >fn first_word(s: &amp;String) -&gt; usize {
    let bytes = s.as_bytes();

    for (i, &amp;item) in bytes.iter().enumerate() {
        if item == b' ' {
            return i;
        }
    }

    s.len()
}
</code></pre>
</div>

<ul>
<li>Дакле, враћамо индекс краја речи. Позиваоц сада има потребне информације да дође до тражене речи.</li>
<li>Проблем: два податка која су у вези али морамо ту везу ручно да одржавамо јер
немамо гаранцију да ће број који је враћен бити валидан и у будућности (нпр.
стринг може да се промени или да изађе из опсега).</li>

</ul>

</section>
<section>

<div class="org-src-container">

<pre><code class="rust" >fn main() {
    let mut s = String::from("hello world");

    let word = first_word(&amp;s); // word ће добити вредност 5

    s.clear(); // стринг s постаје ""

    // word је и даље 5 иако то више није исправно
}
</code></pre>
</div>

</section>
<section>

<p>
Проблем постаје још озбиљнији ако нпр. напишемо функцију <code>second_word</code> која враћа
другу реч задатог стринга. По аналогији са претходним, требали би да вратимо
почетак и крај друге речи.
</p>

<div class="org-src-container">

<pre><code class="rust" >fn second_word(s: &amp;String) -&gt; (usize, usize) {
</code></pre>
</div>

<p>
Сада имамо три податка о којима морамо да водимо рачуна.
</p>
</section>
<section id="slide-6-3-3">
<h4 id="6-3-3"><span class="section-number-4">6.3.3.</span> Стринг исечак</h4>
<p>
Проблем решавамо употребом исечака.
</p>

<div class="org-src-container">

<pre><code class="rust" >let s = String::from("hello world");

let hello = &amp;s[0..5];
let world = &amp;s[6..11];
</code></pre>
</div>

<div class="column" style="float:left; width: 55%">
<p>
Синтакса <code>s[x..y]</code> креира исечак над секвенцом <code>s</code>. С обзиром да овај тип (<code>[T]</code>) нема
познату величину у време компајлирања, не можемо га алоцирати на стеку, односно
не можемо га доделити локалним варијаблама или прослеђивати као параметар
функције. Зато се у пракси користи референца на исечак (<code>&amp;[T]</code>) (често се зове и
<i>fat pointer</i>).
</p>

<p>
Дакле, у пракси много чешће срећемо синтаксу <code>&amp;s[x..y]</code>.
</p>
</div>

<div class="column" style="float:right; width: 45%">

<div id="org712c6af" class="figure">
<p><img src="./images/slice.png" alt="slice.png" style="height: 500px;" />
</p>
</div>
</div>

<div style="clear: both;">
</section>
<section id="slide-6-3-4">
<h4 id="6-3-4"><span class="section-number-4">6.3.4.</span> Исечци и синтакса опсега (<i>range</i>)</h4>
<div class="org-src-container">

<pre><code class="rust" >let s = String::from("hello");

let slice = &amp;s[0..2];
let slice = &amp;s[..2];
</code></pre>
</div>

<div class="org-src-container">

<pre><code class="rust" >let s = String::from("hello");

let len = s.len();

let slice = &amp;s[3..len];
let slice = &amp;s[3..];
</code></pre>
</div>

<div class="org-src-container">

<pre><code class="rust" >let s = String::from("hello");

let len = s.len();

let slice = &amp;s[0..len];
let slice = &amp;s[..];
</code></pre>
</div>
</section>
<section id="slide-6-3-5">
<h4 id="6-3-5"><span class="section-number-4">6.3.5.</span> Модификација примера да користи стринг исечке</h4>
<div class="org-src-container">

<pre><code class="rust" >fn first_word(s: &amp;String) -&gt; &amp;str {
    let bytes = s.as_bytes();

    for (i, &amp;item) in bytes.iter().enumerate() {
        if item == b' ' {
            return &amp;s[0..i];
        }
    }

    &amp;s[..]
}
</code></pre>
</div>

<p>
Исти API и за <code>second_word</code>.
</p>

<div class="org-src-container">

<pre><code class="rust" >fn second_word(s: &amp;String) -&gt; &amp;str {
</code></pre>
</div>

</section>
<section>

<p>
Сада нам компајлер осигурава да увек имамо валидну референцу на реч.
</p>
<div class="org-src-container">

<pre><code class="rust" >fn main() {
    let mut s = String::from("hello world");

    let word = first_word(&amp;s);

    s.clear(); // ГРЕШКА!

    println!("the first word is: {}", word);
}
</code></pre>
</div>

<pre class="example" id="orge04c2a6">
$ cargo run
   Compiling ownership v0.1.0 (file:///projects/ownership)
error[E0502]: cannot borrow `s` as mutable because it is also borrowed as immutable
  --&gt; src/main.rs:18:5
   |
16 |     let word = first_word(&amp;s);
   |                           -- immutable borrow occurs here
17 |
18 |     s.clear(); // error!
   |     ^^^^^^^^^ mutable borrow occurs here
19 |
20 |     println!("the first word is: {}", word);
   |                                       ---- immutable borrow later used here

For more information about this error, try `rustc --explain E0502`.
error: could not compile `ownership` due to previous error
</pre>

<p>
Не само да је API лакши за употребу већ је читава класа грешака које се тешко
откривају елиминисана у време компајлирања.
</p>
</section>
<section id="slide-6-3-6">
<h4 id="6-3-6"><span class="section-number-4">6.3.6.</span> Стринг литерали су референце на исечке</h4>
<div class="org-src-container">

<pre><code class="rust" >let s = "Hello, world!";
</code></pre>
</div>

<p>
Тип од <code>s</code> је <code>&amp;str</code>. <code>str</code> је стринг исечак.
</p>
</section>
<section id="slide-6-3-7">
<h4 id="6-3-7"><span class="section-number-4">6.3.7.</span> Стринг исечци као параметри функција</h4>
<div class="org-src-container">

<pre><code class="rust" >fn first_word(s: &amp;String) -&gt; &amp;str {
</code></pre>
</div>

<p>
Али ће искусни Раст програмери писати:
</p>

<div class="org-src-container">

<pre><code class="rust" >fn first_word(s: &amp;str) -&gt; &amp;str {
</code></pre>
</div>

<p>
Јер ће ова функција моћи да се користи и за <code>&amp;str</code> и за <code>&amp;String</code>. Овде се
употребљава тзв. <i>Deref Coercion</i> односно могућности типова да се дереференцирају
у други тип. Нпр. <code>&amp;String</code> ће се аутоматски дереференцирати у <code>&amp;str</code> уколико је то
потребно. Операција је ефикасна.
</p>

</section>
<section>

<div class="org-src-container">

<pre><code class="rust" >fn main() {
    let my_string = String::from("hello world");

    // `first_word` works on slices of `String`s, whether partial or whole
    let word = first_word(&amp;my_string[0..6]);
    let word = first_word(&amp;my_string[..]);
    // `first_word` also works on references to `String`s, which are equivalent
    // to whole slices of `String`s
    let word = first_word(&amp;my_string);

    let my_string_literal = "hello world";

    // `first_word` works on slices of string literals, whether partial or whole
    let word = first_word(&amp;my_string_literal[0..6]);
    let word = first_word(&amp;my_string_literal[..]);

    // Because string literals *are* string slices already,
    // this works too, without the slice syntax!
    let word = first_word(my_string_literal);
}
</code></pre>
</div>
</section>
<section id="slide-6-3-8">
<h4 id="6-3-8"><span class="section-number-4">6.3.8.</span> Употреба исечака над другим структурама</h4>
<div class="org-src-container">

<pre><code class="rust" >let a = [1, 2, 3, 4, 5];

let slice = &amp;a[1..3]; // референца на исечак типа &amp;[i32]

assert_eq!(slice, &amp;[2, 3]);
</code></pre>
</div>
</section>
</section>
<section>
<section id="slide-7">
<h2 id="7"><span class="section-number-2">7.</span> Структуре</h2>
<div class="outline-text-2" id="text-7">
</div>
</section>
<section id="slide-7-1">
<h3 id="7-1"><span class="section-number-3">7.1.</span> <code>struct</code> тип</h3>
<p>
Кориснички тип који омогућава груписање више логички повезаних вредности - поља
(<i>fields</i>).
</p>

<p>
У Расту постоје три врсте структура:
</p>
<ul>
<li>Структуре торки (<i>tuple structs</i>) - у основи представљају именоване торке</li>
<li>Класичне Ц-овске структуре</li>
<li>Јединичне структуре (<i>unit structs</i>) - структуре без атрибута</li>

</ul>
</section>
<section id="slide-7-2">
<h3 id="7-2"><span class="section-number-3">7.2.</span> Дефиниција структуре</h3>
<div class="org-src-container">

<pre><code class="rust" >struct User {
    active: bool,
    username: String,
    email: String,
    sign_in_count: u64,
}
</code></pre>
</div>
</section>
<section id="slide-7-3">
<h3 id="7-3"><span class="section-number-3">7.3.</span> Креирање инстанце структуре</h3>
<div class="org-src-container">

<pre><code class="rust" >fn main() {
    let user1 = User {
        active: true,
        username: String::from("someusername123"),
        email: String::from("someone@example.com"),
        sign_in_count: 1,
    };
}
</code></pre>
</div>
</section>
<section id="slide-7-4">
<h3 id="7-4"><span class="section-number-3">7.4.</span> Промена вредности поља</h3>
<div class="org-src-container">

<pre><code class="rust" >fn main() {
    let mut user1 = User {
        active: true,
        username: String::from("someusername123"),
        email: String::from("someone@example.com"),
        sign_in_count: 1,
    };

    user1.email = String::from("anotheremail@example.com");
}
</code></pre>
</div>
</section>
<section id="slide-7-5">
<h3 id="7-5"><span class="section-number-3">7.5.</span> Креирање структуре путем функције</h3>
<div class="org-src-container">

<pre><code class="rust" >fn build_user(email: String, username: String) -&gt; User {
    User {
        active: true,
        username: username,
        email: email,
        sign_in_count: 1,
    }
}
</code></pre>
</div>
</section>
<section id="slide-7-6">
<h3 id="7-6"><span class="section-number-3">7.6.</span> Употреба скраћеног облика</h3>
<div class="org-src-container">

<pre><code class="rust" >fn build_user(email: String, username: String) -&gt; User {
    User {
        active: true,
        username,
        email,
        sign_in_count: 1,
    }
}
</code></pre>
</div>
</section>
<section id="slide-7-7">
<h3 id="7-7"><span class="section-number-3">7.7.</span> Креирање инстанце из друге инстанце употребом синтаксе за ажурирање (<i>update syntax</i>)</h3>
<p>
Уместо:
</p>
<div class="org-src-container">

<pre><code class="rust" >fn main() {
    // --snip--
    let user2 = User {
        active: user1.active,
        username: user1.username,
        email: String::from("another@example.com"),
        sign_in_count: user1.sign_in_count,
    };
}
</code></pre>
</div>

<p>
Можемо писати:
</p>
<div class="org-src-container">

<pre><code class="rust" >fn main() {
    let user2 = User {
        email: String::from("another@example.com"),
        ..user1
    };
}
</code></pre>
</div>

<ul>
<li class="fragment roll-in"><code>user1.username</code> је премештен у <code>user2</code> и не може више да се користи. Остатак
структуре може јер <code>user1.email</code> није премештен а остала поља су <i>Copy</i> типа.</li>

</ul>
</section>
<section id="slide-7-8">
<h3 id="7-8"><span class="section-number-3">7.8.</span> Структуре торки</h3>
<p>
Тзв. <i>именоване торке</i>. Поља немају имена, приступа им се као код обичних торки
употребом <code>x.n</code> синтаксе где је <code>n</code> редни број поља.
</p>

<div class="org-src-container">

<pre><code class="rust" >struct Color(i32, i32, i32);
struct Point(i32, i32, i32);

fn main() {
    let black = Color(0, 0, 0);
    let origin = Point(5, 8, 0);
    let y = origin.1;
    println!("{}", y);
}
</code></pre>
</div>

<pre class="example">
8
</pre>
</section>
<section id="slide-7-9">
<h3 id="7-9"><span class="section-number-3">7.9.</span> Јединичне структуре - без поља</h3>
<p>
Користе се за креирање типова који имају понашање (имплементирају особине) али
не чувају податке (тзв. <a href="https://doc.rust-lang.org/nomicon/exotic-sizes.html#zero-sized-types-zsts">Zero Sized Types (ZSTs)</a>)
</p>

<div class="org-src-container">

<pre><code class="rust" >struct AlwaysEqual;

fn main() {
    let subject = AlwaysEqual;
}
</code></pre>
</div>
</section>
<section id="slide-7-10">
<h3 id="7-10"><span class="section-number-3">7.10.</span> Разни примери</h3>
<div class="org-src-container">

<pre><code class="rust" >#[derive(Debug)]
struct Person {
    name: String,
    age: u8,
}

// A unit struct
struct Unit;

// A tuple struct
struct Pair(i32, f32);

// A struct with two fields
struct Point {
    x: f32,
    y: f32,
}
// Structs can be reused as fields of another struct
struct Rectangle {
    // A rectangle can be specified by where the top left and bottom right
    // corners are in space.
    top_left: Point,
    bottom_right: Point,
}
</code></pre>
</div>

</section>
<section>

<div class="org-src-container">

<pre><code class="rust" >// Create struct with field init shorthand
let name = String::from("Peter");
let age = 27;
let peter = Person { name, age };

// Print debug struct
println!("{:?}", peter);

// Instantiate a `Point`
let point: Point = Point { x: 10.3, y: 0.4 };

// Access the fields of the point
println!("point coordinates: ({}, {})", point.x, point.y);

// Make a new point by using struct update syntax to use the fields of our
// other one
let bottom_right = Point { x: 5.2, ..point };

// `bottom_right.y` will be the same as `point.y` because we used that field
// from `point`
println!("second point: ({}, {})", bottom_right.x, bottom_right.y);
</code></pre>
</div>

</section>
<section>

<div class="org-src-container">

<pre><code class="rust" >// Destructure the point using a `let` binding
let Point { x: left_edge, y: top_edge } = point;

let _rectangle = Rectangle {
    // struct instantiation is an expression too
    top_left: Point { x: left_edge, y: top_edge },
    bottom_right: bottom_right,
};

// Instantiate a unit struct
let _unit = Unit;

// Instantiate a tuple struct
let pair = Pair(1, 0.1);

// Access the fields of a tuple struct
println!("pair contains {:?} and {:?}", pair.0, pair.1);

// Destructure a tuple struct
let Pair(integer, decimal) = pair;

println!("pair contains {:?} and {:?}", integer, decimal);
</code></pre>
</div>
</section>
</section>
<section>
<section id="slide-8">
<h2 id="8"><span class="section-number-2">8.</span> Енумерације</h2>
<div class="outline-text-2" id="text-8">
</div>
</section>
<section id="slide-8-1">
<h3 id="8-1"><span class="section-number-3">8.1.</span> <i>Enum</i> тип</h3>
<div class="outline-text-3" id="text-8-1">
</div>
</section>
<section id="slide-8-1-1">
<h4 id="8-1-1"><span class="section-number-4">8.1.1.</span> <i>Enum</i> тип</h4>
<ul>
<li>Дефинисање типа навођењем свих могућих варијанти</li>
<li>Варијанта може да садржи додатне податке</li>
<li>Слично са алгебарским типовима података (<i>algebraic data types</i>) у функционалним
језицима, нпр. F#, OCaml и Haskell-у. Ова врста алгебарског типа је позната и
под називом <i>sum type</i>.</li>

</ul>
</section>
<section id="slide-8-1-2">
<h4 id="8-1-2"><span class="section-number-4">8.1.2.</span> Пример - IP адреса</h4>
<ul>
<li>IP адреса представља идентификацију мрежних интерфејса у уређајима који
комуницирају посредством Интернет протокола (<i>Internet Protocol - IP</i>).</li>
<li>Тренутно имамо у употреби стару верзију 4 и нову верзију 6 која ће временом
заменити верзију 4.</li>
<li>Верзија 4 је дужине 32 бита и наводи се као четири октета у облику нпр.
<code>192.0.2.1</code></li>
<li>Верзија 6 је дужине 128 бита и наводи се као 8 група од по 4 хекса цифре
раздвојене са <code>:</code>, нпр. <code>2001:db8:0:1234:0:567:8:1</code></li>

</ul>

</section>
<section>

<p>
У Расту можемо писати следеће:
</p>

<div class="org-src-container">

<pre><code class="rust" >enum IpAddrKind {
    V4,
    V6,
}
</code></pre>
</div>

<p>
Док вредности можемо креирати са:
</p>
<div class="org-src-container">

<pre><code class="rust" >let four = IpAddrKind::V4;
let six = IpAddrKind::V6;
</code></pre>
</div>
</section>
<section id="slide-8-1-3">
<h4 id="8-1-3"><span class="section-number-4">8.1.3.</span> Пример - IP адреса - функција</h4>
<p>
Сада можемо писати функцију која прима овај тип чиме је могуће проследити било
коју варијанту као аргумент.
</p>

<div class="org-src-container">

<pre><code class="rust" >fn route(ip_kind: IpAddrKind) {}

...

route(IpAddrKind::V4);
route(IpAddrKind::V6);
</code></pre>
</div>
</section>
<section id="slide-8-1-4">
<h4 id="8-1-4"><span class="section-number-4">8.1.4.</span> Пример - IP адреса - вредност</h4>
<ul>
<li>Али како да дефинишемо конкретну вредност IP адресе?</li>
<li>Прва идеја би могла бити да користимо структуру.</li>

</ul>

<div class="org-src-container">

<pre><code class="rust" >enum IpAddrKind {
    V4,
    V6,
}

struct IpAddr {
    kind: IpAddrKind,
    address: String,
}

let home = IpAddr {
    kind: IpAddrKind::V4,
    address: String::from("127.0.0.1"),
};

let loopback = IpAddr {
    kind: IpAddrKind::V6,
    address: String::from("::1"),
};
</code></pre>
</div>

</section>
<section>

<p>
Али, са <code>enum</code> типом можемо то урадити и боље. <code>Enum</code> варијанте могу садржати
додатне податке.
</p>

<div class="org-src-container">

<pre><code class="rust" >enum IpAddr {
    V4(String),
    V6(String),
}

let home = IpAddr::V4(String::from("127.0.0.1"));

let loopback = IpAddr::V6(String::from("::1"));
</code></pre>
</div>

</section>
<section>
<p>
Вредност садржана у варијанти не мора бити иста за све варијанте. На пример,
IPv4 се састоји од 4 октета и можда желимо да вредност наводимо и чувамо у том
облику.
</p>

<div class="org-src-container">

<pre><code class="rust" >enum IpAddr {
    V4(u8, u8, u8, u8),
    V6(String),
}

let home = IpAddr::V4(127, 0, 0, 1);

let loopback = IpAddr::V6(String::from("::1"));
</code></pre>
</div>
</section>
<section id="slide-8-1-5">
<h4 id="8-1-5"><span class="section-number-4">8.1.5.</span> Пример - IP адреса - std библиотека</h4>
<p>
У стандардној библиотеци можемо пронаћи тип <code>IpAddr</code>. Дефинисан је на следећи
начин.
</p>

<div class="org-src-container">

<pre><code class="rust" >struct Ipv4Addr {
    // --snip--
}

struct Ipv6Addr {
    // --snip--
}

enum IpAddr {
    V4(Ipv4Addr),
    V6(Ipv6Addr),
}
</code></pre>
</div>
</section>
<section id="slide-8-1-6">
<h4 id="8-1-6"><span class="section-number-4">8.1.6.</span> Пример  - <i>Message</i></h4>
<div class="org-src-container">

<pre><code class="rust" >enum Message {
    Quit,
    Move { x: i32, y: i32 },
    Write(String),
    ChangeColor(i32, i32, i32),
}
</code></pre>
</div>

</section>
<section>
<p>
Следеће структуре садрже исте податке као претходни <code>enum</code> тип.
</p>

<div class="org-src-container">

<pre><code class="rust" >struct QuitMessage; // unit struct
struct MoveMessage {
    x: i32,
    y: i32,
}
struct WriteMessage(String); // tuple struct
struct ChangeColorMessage(i32, i32, i32); // tuple struct
</code></pre>
</div>

<p>
Али, предност <code>enum</code> типа је што је то јединствен тип па можемо нпр. направити
функцију која прима било коју вредност/варијанту овог типа.
</p>

</section>
<section>
<p>
Над <code>enum</code> типом, као и другим типовима, можемо имплементирати методе употребом
<code>imlp</code> кључне речи.
</p>

<div class="org-src-container">

<pre><code class="rust" >impl Message {
    fn call(&amp;self) {
        // тело методе се овде дефинише
    }
}

let m = Message::Write(String::from("hello"));
m.call();
</code></pre>
</div>
</section>
<section id="slide-8-1-7">
<h4 id="8-1-7"><span class="section-number-4">8.1.7.</span> Пример - <i>WebEvent</i></h4>
<div class="org-src-container">

<pre><code class="rust" >enum WebEvent {
    // An `enum` variant may either be `unit-like`,
    PageLoad,
    PageUnload,
    // like tuple structs,
    KeyPress(char),
    Paste(String),
    // or c-like structures.
    Click { x: i64, y: i64 },
}

fn inspect(event: WebEvent) {
    match event {
        WebEvent::PageLoad =&gt; println!("page loaded"),
        WebEvent::PageUnload =&gt; println!("page unloaded"),
        // Destructure `c` from inside the `enum` variant.
        WebEvent::KeyPress(c) =&gt; println!("pressed '{}'.", c),
        WebEvent::Paste(s) =&gt; println!("pasted \"{}\".", s),
        // Destructure `Click` into `x` and `y`.
        WebEvent::Click { x, y } =&gt; {
            println!("clicked at x={}, y={}.", x, y);
        },
    }
}
</code></pre>
</div>

</section>
<section>

<div class="org-src-container">

<pre><code class="rust" >fn main() {
    let pressed = WebEvent::KeyPress('x');
    // `to_owned()` creates an owned `String` from a string slice.
    let pasted  = WebEvent::Paste("my text".to_owned());
    let click   = WebEvent::Click { x: 20, y: 80 };
    let load    = WebEvent::PageLoad;
    let unload  = WebEvent::PageUnload;

    inspect(pressed);
    inspect(pasted);
    inspect(click);
    inspect(load);
    inspect(unload);
}
</code></pre>
</div>

<pre class="example">
pressed 'x'.
pasted "my text".
clicked at x=20, y=80.
page loaded
page unloaded
</pre>
</section>
<section id="slide-8-1-8">
<h4 id="8-1-8"><span class="section-number-4">8.1.8.</span> Употреба <code>use</code> кључне речи</h4>
<p>
Варијанте можемо импортовати у текући опсег тако да се може избећи пуна
квалификација варијанти енумерисаног типа.
</p>

<div class="org-src-container">

<pre><code class="rust" >enum Status {
    Rich,
    Poor,
}

enum Work {
    Civilian,
    Soldier,
}
</code></pre>
</div>

</section>
<section>

<div class="org-src-container">

<pre><code class="rust" >fn main() {
    // Explicitly `use` each name so they are available without
    // manual scoping.
    use crate::Status::{Poor, Rich};
    // Automatically `use` each name inside `Work`.
    use crate::Work::*;

    // Equivalent to `Status::Poor`.
    let status = Poor;
    // Equivalent to `Work::Civilian`.
    let work = Civilian;

    match status {
        // Note the lack of scoping because of the explicit `use` above.
        Rich =&gt; println!("The rich have lots of money!"),
        Poor =&gt; println!("The poor have no money..."),
    }

    match work {
        // Note again the lack of scoping.
        Civilian =&gt; println!("Civilians work!"),
        Soldier  =&gt; println!("Soldiers fight!"),
    }
}
</code></pre>
</div>
</section>
<section id="slide-8-1-9">
<h4 id="8-1-9"><span class="section-number-4">8.1.9.</span> Ц-овски енумерисани тип</h4>
<p>
Енумерисани тип у Расту се може користити као у Ц-у.
</p>

<div class="org-src-container">

<pre><code class="rust" >// enum with implicit discriminator (starts at 0)
enum Number {
    Zero,
    One,
    Two,
}

// enum with explicit discriminator
enum Color {
    Red = 0xff0000,
    Green = 0x00ff00,
    Blue = 0x0000ff,
}

fn main() {
    // `enums` can be cast as integers.
    println!("zero is {}", Number::Zero as i32);
    println!("one is {}", Number::One as i32);

    println!("roses are #{:06x}", Color::Red as i32);
    println!("violets are #{:06x}", Color::Blue as i32);
}
</code></pre>
</div>

<pre class="example">
zero is 0
one is 1
roses are #ff0000
violets are #0000ff
</pre>
</section>
<section id="slide-8-1-10">
<h4 id="8-1-10"><span class="section-number-4">8.1.10.</span> Тест случај - повезана листа</h4>
<div class="org-src-container">

<pre><code class="rust" >use crate::List::*;
enum List {
    Cons(u32, Box&lt;List&gt;),
    Nil,
}
impl List {
    fn new() -&gt; List {
        Nil
    }
    fn prepend(self, elem: u32) -&gt; List {
        Cons(elem, Box::new(self))
    }
    fn len(&amp;self) -&gt; u32 {
        match *self {
            Cons(_, ref tail) =&gt; 1 + tail.len(),
            Nil =&gt; 0
        }
    }
    fn stringify(&amp;self) -&gt; String {
        match *self {
            Cons(head, ref tail) =&gt; {
                format!("{}, {}", head, tail.stringify())
            },
            Nil =&gt; {
                format!("Nil")
            },
        }
    }
}
</code></pre>
</div>

</section>
<section>

<div class="org-src-container">

<pre><code class="rust" >fn main() {
    // Create an empty linked list
    let mut list = List::new();
    // Prepend some elements
    list = list.prepend(1);
    list = list.prepend(2);
    list = list.prepend(3);

    // Show the final state of the list
    println!("linked list has length: {}", list.len());
    println!("{}", list.stringify());
}
</code></pre>
</div>

<pre class="example">
linked list has length: 3
3, 2, 1, Nil
</pre>
</section>
<section id="slide-8-2">
<h3 id="8-2"><span class="section-number-3">8.2.</span> <code>Option</code> енумерација</h3>
<div class="outline-text-3" id="text-8-2">
</div>
</section>
<section id="slide-8-2-1">
<h4 id="8-2-1"><span class="section-number-4">8.2.1.</span> <code>Option</code> енумерација</h4>
<ul>
<li>Чест случај да вредност може бити нешто или ништа.</li>
<li>Нпр. ако функција враћа први елемент из листе која није празна добићемо први
елемент, међутим ако је листа празна повратна вредност је ништа.</li>
<li>Овај концепт се у различитим језицима различито имплементира. Често се користи
специјална вредност <code>null</code> (или <code>nil</code>, <code>none</code> и сл.) и све варијабле могу бити <code>null</code>
или <code>non-null</code>. Проблем је што програмер не дефинише могућност ове вредности
кроз тип па самим тим компајлер нема могућност да провери да ли кôд исправно
обрађује ову могућност.</li>

</ul>

</section>
<section>

<p>
У презентацији из 2009 године под називом <i>Null References: The Billion Dollar
Mistake</i> Tony Hoare, који је први увео <code>null</code> вредност као концепт је написао
следеће:
</p>

<blockquote>
<p>
I call it my billion-dollar mistake. At that time, I was designing the first
comprehensive type system for references in an object-oriented language. My goal
was to ensure that all use of references should be absolutely safe, with
checking performed automatically by the compiler. But I couldn’t resist the
temptation to put in a null reference, simply because it was so easy to
implement. This has led to innumerable errors, vulnerabilities, and system
crashes, which have probably caused a billion dollars of pain and damage in the
last forty years.
</p>
</blockquote>

</section>
<section>

<p>
<code>Option</code> је генерички <code>enum</code> тип у Расту.
</p>
<div class="org-src-container">

<pre><code class="rust" >enum Option&lt;T&gt; {
    None,
    Some(T),
}
</code></pre>
</div>

<p>
Примери употребе:
</p>
<div class="org-src-container">

<pre><code class="rust" >let some_number = Some(5);           // тип је Option&lt;i32&gt;
let some_string = Some("a string");  // тип је Option&lt;&amp;str&gt;

let absent_number: Option&lt;i32&gt; = None;    // немогућа инференца
</code></pre>
</div>
</section>
<section id="slide-8-2-2">
<h4 id="8-2-2"><span class="section-number-4">8.2.2.</span> Зашто је <code>Option&lt;T&gt;</code> бољи од <code>null</code>?</h4>
<div class="org-src-container">

<pre><code class="rust" >let x: i8 = 5;
let y: Option&lt;i8&gt; = Some(5);

let sum = x + y;
</code></pre>
</div>

<pre class="example" id="orgc4de14d">
$ cargo run
   Compiling enums v0.1.0 (file:///projects/enums)
error[E0277]: cannot add `Option&lt;i8&gt;` to `i8`
 --&gt; src/main.rs:5:17
  |
5 |     let sum = x + y;
  |                 ^ no implementation for `i8 + Option&lt;i8&gt;`
  |
  = help: the trait `Add&lt;Option&lt;i8&gt;&gt;` is not implemented for `i8`

For more information about this error, try `rustc --explain E0277`.
error: could not compile `enums` due to previous error
</pre>
</section>
<section id="slide-8-2-3">
<h4 id="8-2-3"><span class="section-number-4">8.2.3.</span> Како обрађивати <code>Option&lt;T&gt;</code> податке?</h4>
<ul>
<li>Морамо експлицитно обрадити вредност <code>Option&lt;T&gt;</code> и могућност да вредност буде
<code>None</code>.</li>
<li><code>Option&lt;T&gt;</code> тип има <a href="https://doc.rust-lang.org/stable/std/option/enum.Option.html">богат API</a> који је потребно знати јер је овај тип врло често
у употреби.</li>

</ul>

<div class="org-src-container">

<pre><code class="rust" >let x = Some(2);
let y = None;
assert_eq!(x.or(y), Some(2));

let x = None;
let y = Some(100);
assert_eq!(x.or(y), Some(100));
</code></pre>
</div>

<ul>
<li>Често користимо језичке конструкције које омогућавају обраду обе варијанте.</li>

</ul>
</section>
</section>
<section>
<section id="slide-9">
<h2 id="9"><span class="section-number-2">9.</span> Сложена контрола тока и подударање образаца (<i>Pattern Matching</i>)</h2>
<div class="outline-text-2" id="text-9">
</div>
</section>
<section id="slide-9-1">
<h3 id="9-1"><span class="section-number-3">9.1.</span> <code>match</code> израз</h3>
<ul>
<li>Моћан израз контроле тока базиран на подударању образаца (<i>Pattern Matching</i>).</li>
<li>Образац може бити литерал, назив варијабле, џокер (<i>wildcards</i>) итд.</li>
<li><code>match</code> израз ће извршити подударање уз исцрпљивање свих могућност. Уколико
нека могућност није обрађена компајлер ће пријавити грешку.</li>

</ul>
</section>
<section id="slide-9-2">
<h3 id="9-2"><span class="section-number-3">9.2.</span> <code>match</code> као машина за сортирање новчића</h3>
<p>
За почетак можемо <code>match</code> израз посматрати као аутомат за сортирање новчића.
</p>

<div class="org-src-container">

<pre><code class="rust" >enum Coin {
    Penny,
    Nickel,
    Dime,
    Quarter,
}

fn value_in_cents(coin: Coin) -&gt; u8 {
    match coin {
        Coin::Penny =&gt; 1,
        Coin::Nickel =&gt; 5,
        Coin::Dime =&gt; 10,
        Coin::Quarter =&gt; 25,
    }
}
</code></pre>
</div>

<ul>
<li><code>match</code> почиње са изразом произвољног типа.</li>
<li>У телу се налазе "руке" (<i>arms</i>) где свака рука има леву страну која представља
образац за подударање и десну страну (после <code>=&gt;</code>) која представља кôд који се
евалуира у случају подударања. Руке су раздвојене зарезима.</li>

</ul>

</section>
<section>

<ul>
<li>Руке се подударају у редоследу навођења.</li>
<li>Повратна вредност целог <code>match</code> израза биће вредност евалуираног кода руке чије
је подударање успело</li>

</ul>

</section>
<section>

<p>
Можемо на десној страни користити произвољан израз па и блок кода.
</p>
<div class="org-src-container">

<pre><code class="rust" >fn value_in_cents(coin: Coin) -&gt; u8 {
    match coin {
        Coin::Penny =&gt; {
            println!("Lucky penny!");
            1
        }
        Coin::Nickel =&gt; 5,
        Coin::Dime =&gt; 10,
        Coin::Quarter =&gt; 25,
    }
}
</code></pre>
</div>
</section>
<section id="slide-9-3">
<h3 id="9-3"><span class="section-number-3">9.3.</span> Повезивање имена при подударању (<i>binding</i>)</h3>
<div class="org-src-container">

<pre><code class="rust" >#[derive(Debug)]
enum UsState {
    Alabama,
    Alaska,
    Arizona,
    // --snip--
}

enum Coin {
    Penny,
    Nickel,
    Dime,
    Quarter(UsState),
}

fn value_in_cents(coin: Coin) -&gt; u8 {
    match coin {
        Coin::Penny =&gt; 1,
        Coin::Nickel =&gt; 5,
        Coin::Dime =&gt; 10,
        Coin::Quarter(state) =&gt; {
            println!("State quarter from {:?}!", state);
            25
        }
    }
}
</code></pre>
</div>
</section>
<section id="slide-9-4">
<h3 id="9-4"><span class="section-number-3">9.4.</span> <code>match</code> је исцрпан</h3>
<div class="org-src-container">

<pre><code class="rust" >fn value_in_cents(coin: Coin) -&gt; u8 {
    match coin {
        Coin::Penny =&gt; 1,
        Coin::Nickel =&gt; 5,
        Coin::Dime =&gt; 10,
        Coin::Quarter(UsState::Alabama) | Coin::Quarter(UsState::Alaska) =&gt; 25
    }
}
</code></pre>
</div>

<pre class="example" id="org37b73c3">
$ cargo run
   Compiling match_test v0.1.0 (/home/igor/NTP/match_test)
error[E0004]: non-exhaustive patterns: `Quarter(Arizona)` not covered
  --&gt; src/main.rs:21:11
   |
13 | / enum Coin {
14 | |     Penny,
15 | |     Nickel,
16 | |     Dime,
17 | |     Quarter(UsState),
   | |     ------- not covered
18 | | }
   | |_- `Coin` defined here
...
21 |       match coin {
   |             ^^^^ pattern `Quarter(Arizona)` not covered
   |
   = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms
   = note: the matched value is of type `Coin`
</pre>
</section>
<section id="slide-9-5">
<h3 id="9-5"><span class="section-number-3">9.5.</span> Подударање са <code>Option&lt;T&gt;</code> типом</h3>
<div class="org-src-container">

<pre><code class="rust" >fn plus_one(x: Option&lt;i32&gt;) -&gt; Option&lt;i32&gt; {
    match x {
        None =&gt; None,
        Some(i) =&gt; Some(i + 1),
    }
}

let five = Some(5);
let six = plus_one(five);
let none = plus_one(None);
</code></pre>
</div>

</section>
<section>

<p>
Пошто је <code>match</code> исцрпан не можемо заборавити да обрадимо <code>None</code> случај.
</p>

<div class="org-src-container">

<pre><code class="rust" >fn plus_one(x: Option&lt;i32&gt;) -&gt; Option&lt;i32&gt; {
    match x {
        Some(i) =&gt; Some(i + 1),
    }
}
</code></pre>
</div>

<pre class="example" id="org0f2b1e5">
$ cargo run
   Compiling enums v0.1.0 (file:///projects/enums)
error[E0004]: non-exhaustive patterns: `None` not covered
   --&gt; src/main.rs:3:15
    |
3   |         match x {
    |               ^ pattern `None` not covered
    |
    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms
    = note: the matched value is of type `Option&lt;i32&gt;`

For more information about this error, try `rustc --explain E0004`.
error: could not compile `enums` due to previous error
</pre>

</section>
<section>

<p>
Употреба <code>Option&lt;T&gt;</code> API-ја. <code>map</code> метода. Више речи у поглављу о функционалном програмирању.
</p>

<div class="org-src-container">

<pre><code class="rust" >fn plus_one(x: Option&lt;i32&gt;) -&gt; Option&lt;i32&gt; {
    x.map(|x| x + 1)
}
fn main () {
    let five = Some(5);
    let six = plus_one(five);
    let none = plus_one(None);
    println!("{five:?}, {six:?}, {none:?}")
}
</code></pre>
</div>

<pre class="example">
Some(5), Some(6), None
</pre>
</section>
<section id="slide-9-6">
<h3 id="9-6"><span class="section-number-3">9.6.</span> Подразумевана обрада преосталих случајева</h3>
<ul>
<li>Желимо на специфичан начин обрадимо само неколико случајева док за све остале
радимо подразумевану обраду.</li>

</ul>

<div class="org-src-container">

<pre><code class="rust" >let dice_roll = 9;
match dice_roll {
    3 =&gt; add_fancy_hat(),
    7 =&gt; remove_fancy_hat(),
    other =&gt; move_player(other),
}

fn add_fancy_hat() {}
fn remove_fancy_hat() {}
fn move_player(num_spaces: u8) {}
</code></pre>
</div>

<ul>
<li>Раст ће нас упозорити ако додамо руку после оне која обрађује све случајеве
јер та се рука никада неће употребити.</li>

</ul>

</section>
<section>

<p>
Ако желимо да обрадимо све случајеве али нас вредност не интересује можемо
користити <code>_</code>.
</p>

<div class="org-src-container">

<pre><code class="rust" >let dice_roll = 9;
match dice_roll {
    3 =&gt; add_fancy_hat(),
    7 =&gt; remove_fancy_hat(),
    _ =&gt; reroll(),
}

fn add_fancy_hat() {}
fn remove_fancy_hat() {}
fn reroll() {}
</code></pre>
</div>
</section>
<section id="slide-9-7">
<h3 id="9-7"><span class="section-number-3">9.7.</span> Распакивање (<i>Destructuring</i>)</h3>
<div class="outline-text-3" id="text-9-7">
</div>
</section>
<section id="slide-9-7-1">
<h4 id="9-7-1"><span class="section-number-4">9.7.1.</span> Распакивање торки</h4>
<div class="org-src-container">

<pre><code class="rust" >fn main() {
    let triple = (0, -2, 3);
    // TODO ^ Try different values for `triple`

    println!("Tell me about {:?}", triple);
    // Match can be used to destructure a tuple
    match triple {
        // Destructure the second and third elements
        (0, y, z) =&gt; println!("First is `0`, `y` is {:?}, and `z` is {:?}", y, z),
        (1, ..)  =&gt; println!("First is `1` and the rest doesn't matter"),
        (.., 2)  =&gt; println!("last is `2` and the rest doesn't matter"),
        (3, .., 4)  =&gt; println!("First is `3`, last is `4`, and the rest doesn't matter"),
        // `..` can be used to ignore the rest of the tuple
        _      =&gt; println!("It doesn't matter what they are"),
        // `_` means don't bind the value to a variable
    }
}
</code></pre>
</div>
</section>
<section id="slide-9-7-2">
<h4 id="9-7-2"><span class="section-number-4">9.7.2.</span> Распакивање исечака</h4>
<div class="org-src-container">

<pre><code class="rust" >fn main() {
    let array = [4, -2, 6];

    match array {
        [0, second, third] =&gt;
            println!("array[0] = 0, array[1] = {}, array[2] = {}", second, third),
        [1, _, third] =&gt; println!(
            "array[0] = 1, array[2] = {} and array[1] was ignored",
            third
        ),
        [-1, second, ..] =&gt; println!(
            "array[0] = -1, array[1] = {} and all the other ones were ignored",
            second
        ),
        [3, second, tail @ ..] =&gt; println!(
            "array[0] = 3, array[1] = {} and the other elements were {:?}",
            second, tail
        ),
        [first, middle @ .., last] =&gt; println!(
            "array[0] = {}, middle = {:?}, array[2] = {}",
            first, middle, last
        ),
    }
}
</code></pre>
</div>

<pre class="example">
array[0] = 4, middle = [-2], array[2] = 6
</pre>
</section>
<section id="slide-9-7-3">
<h4 id="9-7-3"><span class="section-number-4">9.7.3.</span> Распакивање енумерација</h4>
<div class="org-src-container">

<pre><code class="rust" >#[allow(dead_code)]
enum Color {
    Red,
    Blue,
    Green,
    RGB(u32, u32, u32),
    HSV(u32, u32, u32),
    HSL(u32, u32, u32),
    CMY(u32, u32, u32),
    CMYK(u32, u32, u32, u32),
}
fn main() {
    let color = Color::RGB(122, 17, 40);
    println!("What color is it?");
    match color {
        Color::Red   =&gt; println!("The color is Red!"),
        Color::Blue  =&gt; println!("The color is Blue!"),
        Color::Green =&gt; println!("The color is Green!"),
        Color::RGB(r, g, b) =&gt;
            println!("Red: {}, green: {}, and blue: {}!", r, g, b),
        Color::HSV(h, s, v) =&gt;
            println!("Hue: {}, saturation: {}, value: {}!", h, s, v),
        Color::HSL(h, s, l) =&gt;
            println!("Hue: {}, saturation: {}, lightness: {}!", h, s, l),
        Color::CMY(c, m, y) =&gt;
            println!("Cyan: {}, magenta: {}, yellow: {}!", c, m, y),
        Color::CMYK(c, m, y, k) =&gt;
            println!("Cyan: {}, magenta: {}, yellow: {}, key (black): {}!", c, m, y, k),
    }
}
</code></pre>
</div>
</section>
<section id="slide-9-7-4">
<h4 id="9-7-4"><span class="section-number-4">9.7.4.</span> Распакивање референци</h4>
<div class="org-src-container">

<pre><code class="rust" >fn main() {
    let reference = &amp;4;

    match reference {
        &amp;val =&gt; println!("Got a value via destructuring: {:?}", val),
    }
    match *reference {
        val =&gt; println!("Got a value via dereferencing: {:?}", val),
    }
    let _not_a_reference = 3;

    let ref _is_a_reference = 3;

    let value = 5;
    let mut mut_value = 6;
    match value {
        ref r =&gt; println!("Got a reference to a value: {:?}", r),
    }
    match mut_value {
        ref mut m =&gt; {
            *m += 10;
            println!("We added 10. `mut_value`: {:?}", m);
        },
    }
}
</code></pre>
</div>

<pre class="example">
Got a value via destructuring: 4
Got a value via dereferencing: 4
Got a reference to a value: 5
We added 10. `mut_value`: 16
</pre>
</section>
<section id="slide-9-7-5">
<h4 id="9-7-5"><span class="section-number-4">9.7.5.</span> Распакивање структура</h4>
<div class="org-src-container">

<pre><code class="rust" >fn main() {
    struct Foo {
        x: (u32, u32),
        y: u32,
    }

    let foo = Foo { x: (1, 2), y: 3 };
    match foo {
        Foo { x: (1, b), y } =&gt; println!("First of x is 1, b = {},  y = {} ", b, y),

        // you can destructure structs and rename the variables,
        // the order is not important
        Foo { y: 2, x: i } =&gt; println!("y is 2, i = {:?}", i),

        // and you can also ignore some variables:
        Foo { y, .. } =&gt; println!("y = {}, we don't care about x", y),
        // this will give an error: pattern does not mention field `x`
        //Foo { y } =&gt; println!("y = {}", y),
    }
}
</code></pre>
</div>
</section>
<section id="slide-9-8">
<h3 id="9-8"><span class="section-number-3">9.8.</span> <code>if let</code> kontrola toka</h3>
<p>
<code>if let</code> нам омогућава комбинацију <code>if</code> и <code>let</code> исказа у мање опширан исказ за обраду
само једног случаја поклапања и игнорисање осталих.
</p>

<div class="org-src-container">

<pre><code class="rust" >let config_max = Some(3u8);
match config_max {
    Some(max) =&gt; println!("The maximum is configured to be {}", max),
    _ =&gt; (),
}
</code></pre>
</div>

<p>
Ово можемо концизније исказати са:
</p>

<div class="org-src-container">

<pre><code class="rust" >let config_max = Some(3u8);
if let Some(max) = config_max {
    println!("The maximum is configured to be {}", max);
}
</code></pre>
</div>

<ul>
<li>Губимо исцрпност <code>match</code> израза.</li>
<li>Синтаксни шећер у ситуацијама када желимо да игноришемо остале могућности.</li>

</ul>
</section>
<section id="slide-9-9">
<h3 id="9-9"><span class="section-number-3">9.9.</span> Поништиви и непоништиви обрасци</h3>
<div class="note" id="org9aca159">
<p>
Обрасци за подударање <a href="https://doc.rust-lang.org/book/ch18-02-refutability.html">могу имати две форме</a>: поништив (<i>refutable</i>) и непоништив
(<i>irrefutable</i>). Образац који увек мора успети (нпр. <code>let x = 5;</code>) је непоништив.
Образац који не мора да успе увек је поништив (нпр. <code>if let Some(x) = a_value</code>
неће успети за <code>a_value==None</code>).
</p>

<p>
Параметри функција, <code>let</code> искази и <code>for</code> петље прихватају само непоништиве обрасце
јер програм не може урадити ништа смислено уколико подударање не успе.
</p>

<p>
<code>if let</code> и <code>while let</code> прихватају и поништиве и непоништиве обрасце али ће нас
компајлер упозорити уколико користимо непоништиве.
</p>

</div>

</section>
<section>

<p>
Можемо користити и <code>else</code> грану. Следеће је еквивалентно.
</p>

<div class="org-src-container">

<pre><code class="rust" >let mut count = 0;
match coin {
    Coin::Quarter(state) =&gt; println!("State quarter from {:?}!", state),
    _ =&gt; count += 1,
}
</code></pre>
</div>

<div class="org-src-container">

<pre><code class="rust" >let mut count = 0;
if let Coin::Quarter(state) = coin {
    println!("State quarter from {:?}!", state);
} else {
    count += 1;
}
</code></pre>
</div>
</section>
<section id="slide-9-10">
<h3 id="9-10"><span class="section-number-3">9.10.</span> <code>let else</code></h3>
<p>
Омогућава употребу поништивих образаца у исказима доделе. Уколико додела не
успева можемо дивергирати са <code>else</code> граном (нпр. <code>break</code>, <code>return</code>, <code>panic!</code>).
</p>

<div class="org-src-container">

<pre><code class="rust" >use std::str::FromStr;

fn get_count_item(s: &amp;str) -&gt; (u64, &amp;str) {
    let mut it = s.split(' ');
    let (Some(count_str), Some(item)) = (it.next(), it.next()) else {
        panic!("Can't segment count item pair: '{s}'");
    };
    let Ok(count) = u64::from_str(count_str) else {
        panic!("Can't parse integer: '{count_str}'");
    };
    (count, item)
}

assert_eq!(get_count_item("3 chairs"), (3, "chairs"));
</code></pre>
</div>
</section>
<section id="slide-9-11">
<h3 id="9-11"><span class="section-number-3">9.11.</span> <code>while let</code></h3>
<p>
Слично као <code>if let</code> и <code>while let</code> чини одређене конструкције са подударањем образаца
језгровитије.
</p>

<p>
На пример, ако имамо нешто попут:
</p>
<div class="org-src-container">

<pre><code class="rust" >// Make `optional` of type `Option&lt;i32&gt;`
let mut optional = Some(0);

// Repeatedly try this test.
loop {
    match optional {
        // If `optional` destructures, evaluate the block.
        Some(i) =&gt; {
            if i &gt; 9 {
                println!("Greater than 9, quit!");
                optional = None;
            } else {
                println!("`i` is `{:?}`. Try again.", i);
                optional = Some(i + 1);
            }
        },
        // Quit the loop when the destructure fails:
        _ =&gt; { break; }
    }
}
</code></pre>
</div>

</section>
<section>

<p>
То можемо написати као:
</p>
<div class="org-src-container">

<pre><code class="rust" >fn main() {
    // Make `optional` of type `Option&lt;i32&gt;`
    let mut optional = Some(0);

    // This reads: "while `let` destructures `optional` into
    // `Some(i)`, evaluate the block (`{}`). Else `break`.
    while let Some(i) = optional {
        if i &gt; 9 {
            println!("Greater than 9, quit!");
            optional = None;
        } else {
            println!("`i` is `{:?}`. Try again.", i);
            optional = Some(i + 1);
        }
    }
}
</code></pre>
</div>
</section>
</section>
<section>
<section id="slide-10">
<h2 id="10"><span class="section-number-2">10.</span> Паметни поинтери (<i>Smart Pointers</i>) - први део</h2>
<div class="outline-text-2" id="text-10">
</div>
</section>
<section id="slide-10-1">
<h3 id="10-1"><span class="section-number-3">10.1.</span> <code>Box&lt;T&gt;</code></h3>
<ul>
<li>Најједноставнији паметни поинтер.</li>
<li>Слично обичној референци али подаци се чувају на хипу.</li>
<li>Перформансе сличне обичним референцама, осим алокације хип меморије. Али
такође нема додатних могућности.</li>

</ul>
</section>
<section id="slide-10-1-1">
<h4 id="10-1-1"><span class="section-number-4">10.1.1.</span> Ситуације у којима се користи <code>Box&lt;T&gt;</code></h4>
<ol>
<li>Када имамо тип чија величина не може да се утврди у време компајлирања а
желимо да га користимо у контексту где се величина мора знати. Нпр. као
локалну варијаблу.</li>
<li>Када имамо тип који чува већу количину података и не желимо да се при
премештању власништва подаци копирају.</li>
<li>Када желимо поседовати тип и није нам битно који је конкретан тип већ само
које особине имплементира.</li>

</ol>
</section>
<section id="slide-10-1-2">
<h4 id="10-1-2"><span class="section-number-4">10.1.2.</span> <code>Box&lt;T&gt;</code> употреба</h4>
<div class="org-src-container">

<pre><code class="rust" >fn main() {
    let b = Box::new(5);
    println!("b = {}", b);
}
</code></pre>
</div>

<pre class="example">
b = 5
</pre>
</section>
<section id="slide-10-1-3">
<h4 id="10-1-3"><span class="section-number-4">10.1.3.</span> Употреба у рекурзивним типовима</h4>
<ul>
<li><p>
<code>Cons</code> листе. Из LISP-a. Креирање листе употребом парова.
</p>
<div class="org-src-container">

<pre><code class="lisp" >  (1, (2, (3, Nil)))
</code></pre>
</div></li>

</ul>
</section>
<section id="slide-10-1-4">
<h4 id="10-1-4"><span class="section-number-4">10.1.4.</span> Покушај креирања</h4>
<div class="org-src-container">

<pre><code class="rust" >enum List {
    Cons(i32, List),
    Nil,
}
use List::{Cons, Nil};

fn main() {
    let list = Cons(1, Cons(2, Cons(3, Nil)));
}
</code></pre>
</div>

</section>
<section>

<div class="org-src-container">

<pre><code class="text" >error[E0072]: recursive type `List` has infinite size
 --&gt; src/main.rs:2:1
  |
2 | enum List {
  | ^^^^^^^^^
3 |     Cons(i32, List),
  |               ---- recursive without indirection
  |
help: insert some indirection (e.g., a `Box`, `Rc`, or `&amp;`) to break the cycle
  |
3 |     Cons(i32, Box&lt;List&gt;),
  |               ++++    +

For more information about this error, try `rustc --explain E0072`.
error: could not compile `cargoXtBWbE` (bin "cargoXtBWbE") due to previous error
</code></pre>
</div>

<ul>
<li>Величина <code>List</code> типа је бесконачна. Компајлер предлаже употребу индирекције кроз <code>Box</code>.</li>

</ul>
</section>
<section id="slide-10-1-5">
<h4 id="10-1-5"><span class="section-number-4">10.1.5.</span> Како компајлер рачуна величину типа?</h4>
<div class="org-src-container">

<pre><code class="rust" >enum Message {
    Quit,
    Move { x: i32, y: i32 },
    Write(String),
    ChangeColor(i32, i32, i32),
}
</code></pre>
</div>

<p>
Величина типа је величина највеће алтернативе.
</p>

</section>
<section>

<p>
Како се рачуна величина <code>List</code> типа?
</p>

<div class="org-src-container">

<pre><code class="rust" >enum List {
    Cons(i32, List),
    Nil,
}
use List::{Cons, Nil};
</code></pre>
</div>


<div id="org663a04a" class="figure">
<p><img src="./images/list-size.svg" alt="list-size.svg" class="org-svg" style="height: 500px;" />
</p>
</div>
</section>
<section id="slide-10-1-6">
<h4 id="10-1-6"><span class="section-number-4">10.1.6.</span> Преправка <code>List</code> типа да користи <code>Box&lt;T&gt;</code></h4>
<div class="org-src-container">

<pre><code class="rust" >enum List {
    Cons(i32, Box&lt;List&gt;),
    Nil,
}

use crate::List::{Cons, Nil};

fn main() {
    let list = Cons(1, Box::new(Cons(2, Box::new(Cons(3, Box::new(Nil))))));
}
</code></pre>
</div>


<div id="org26b9ade" class="figure">
<p><img src="./images/list-size-box.svg" alt="list-size-box.svg" class="org-svg" style="height: 300px;" />
</p>
</div>

<ul>
<li>Величина <code>Box&lt;T&gt;</code> типа је фиксна и позната у време компајлирања. Садржи само
адресу садржаја на хипу.</li>

</ul>
</section>
<section id="slide-10-2">
<h3 id="10-2"><span class="section-number-3">10.2.</span> Употреба паметних поинтера као обичних референци (<i>Deref</i> особина)</h3>
<ul>
<li>Типови који имплементирају <code>Deref</code> редефинишу оператор <code>*</code>.</li>
<li>Имплементацијом ове особине произвољни типови се могу третирати као референце.</li>

</ul>
</section>
<section id="slide-10-2-1">
<h4 id="10-2-1"><span class="section-number-4">10.2.1.</span> Употреба <code>Box&lt;T&gt;</code> као референце</h4>
<div class="org-src-container">

<pre><code class="rust" >fn main() {
    let x = 5;
    let y = Box::new(x);

    assert_eq!(5, x);
    assert_eq!(5, *y);
}
</code></pre>
</div>
</section>
<section id="slide-10-2-2">
<h4 id="10-2-2"><span class="section-number-4">10.2.2.</span> Дефинисање корисничког паметног поинтера</h4>
<div class="org-src-container">

<pre><code class="rust" >struct MyBox&lt;T&gt;(T);

impl&lt;T&gt; MyBox&lt;T&gt; {
    fn new(x: T) -&gt; MyBox&lt;T&gt; {
        MyBox(x)
    }
}
fn main() {
    let x = 5;
    let y = MyBox::new(x);

    assert_eq!(5, x);
    assert_eq!(5, *y);
}
</code></pre>
</div>

</section>
<section>

<div class="org-src-container">

<pre><code class="text" >error[E0614]: type `MyBox&lt;{integer}&gt;` cannot be dereferenced
  --&gt; src/main.rs:14:19
   |
14 |     assert_eq!(5, *y);
   |                   ^^

For more information about this error, try `rustc --explain E0614`.
error: could not compile `cargoEj7N5h` (bin "cargoEj7N5h") due to previous error
</code></pre>
</div>
</section>
<section id="slide-10-2-3">
<h4 id="10-2-3"><span class="section-number-4">10.2.3.</span> Имплементација <code>Deref</code> особине</h4>
<div class="org-src-container">

<pre><code class="rust" >use std::ops::Deref;

impl&lt;T&gt; Deref for MyBox&lt;T&gt; {
    type Target = T;

    fn deref(&amp;self) -&gt; &amp;Self::Target {
        &amp;self.0
    }
}
</code></pre>
</div>

<ul>
<li><code>Target</code> је придружени тип (<i>Associated type</i>) особине <code>Deref</code>.</li>
<li><code>deref</code> враћа референцу на <code>Target</code> тип.</li>
<li><p>
Приликом дереференцирања, вредност није обична референца, позива се <code>deref</code>
уколико тип имплементира <code>Deref</code> и враћена референца се затим дереференцира на
стандардни начин. Компајлер у позадини извршава ово:
</p>
<div class="org-src-container">

<pre><code class="rust" >  *(y.deref())
</code></pre>
</div></li>

</ul>

</section>
<section>

<ul>
<li>Зашто <code>deref</code> враћа референцу на <code>Target</code> тип а не директно вредност?</li>

</ul>

<p class="fragment (roll-in)">
Јер би дошло до премештања вредности из поинтера а то не желимо да се деси.
Желимо вредност само да позајмимо.
</p>
</section>
<section id="slide-10-2-4">
<h4 id="10-2-4"><span class="section-number-4">10.2.4.</span> Имплицитна <code>Deref</code> коерција</h4>
<ul>
<li><code>Deref</code> коерција представља имплицитну конверзију референци на тип који
имплементира <code>Deref</code> у референцу на његов <code>Target</code> тип приликом позива функција и
метода.</li>
<li>Додато у језик да програмери не би морали да пишу превише експлицитних
референцирања и дереференцирања.</li>
<li><p>
На пример, тип <code>&amp;String</code> se имплицитно конвертује у <code>&amp;str</code> jer у стандардној
библиотеци постоји следећа имплементација:
</p>

<div class="org-src-container">

<pre><code class="rust" >  impl ops::Deref for String {
      type Target = str;

      #[inline]
      fn deref(&amp;self) -&gt; &amp;str {
          unsafe { str::from_utf8_unchecked(&amp;self.vec) }
      }
  }
</code></pre>
</div></li>

</ul>
</section>
<section id="slide-10-2-5">
<h4 id="10-2-5"><span class="section-number-4">10.2.5.</span> <code>Deref</code> коерција типа <code>MyBox</code></h4>
<div class="org-src-container">

<pre><code class="rust" >fn hello(name: &amp;str) {
    println!("Hello, {name}!");
}

fn main() {
    let m = MyBox::new(String::from("Rust"));
    hello(&amp;m);
}
</code></pre>
</div>

<ul>
<li>Ово је могуће јер се конвертује <code>&amp;MyBox&lt;String&gt;</code> у <code>&amp;String</code> и затим се конвертује
<code>&amp;String</code> u <code>&amp;str</code> на основу имплементације у стандардној библиотеци.</li>
<li>Раст ће позвати потребан број пута <code>deref</code> ако постоји ланац конверзије који ће
довести до траженог типа.</li>
<li>Због овога је боље користити <code>&amp;str</code> уместо <code>&amp;String</code> у листи параметара функције.
Функција ће моћи да се користи и за <code>&amp;str</code> и за све друге типове који се
имплицитном коерцијом могу превести у <code>&amp;str</code>.</li>

</ul>

</section>
<section>

<p>
Када Раст не би имплементирао имплицитну коерцију морали бисмо ово да пишемо:
</p>

<div class="org-src-container">

<pre><code class="rust" >fn main() {
    let m = MyBox::new(String::from("Rust"));
    hello(&amp;(*m)[..]);
}
</code></pre>
</div>
</section>
<section id="slide-10-3">
<h3 id="10-3"><span class="section-number-3">10.3.</span> Ослобађање ресурса употребом <code>Drop</code> особине</h3>
<ul>
<li><code>Drop</code> је друга особина битна за паметне поинтере.</li>
<li>Ако тип имплементира <code>Drop</code> тада ће компајлер позвати <code>drop</code> методу приликом
изласка вредности из опсега важења.</li>
<li>На пример, <code>Box&lt;T&gt;</code> имплементира <code>Drop</code> да би деалоцирао хип меморију приликом
изласка из опсега важења.</li>

</ul>
</section>
<section id="slide-10-3-1">
<h4 id="10-3-1"><span class="section-number-4">10.3.1.</span> Пример</h4>
<div class="org-src-container">

<pre><code class="rust" >struct CustomSmartPointer {
    data: String,
}

impl Drop for CustomSmartPointer {
    fn drop(&amp;mut self) {
        println!("Dropping CustomSmartPointer with data `{}`!", self.data);
    }
}

fn main() {
    let c = CustomSmartPointer {
        data: String::from("my stuff"),
    };
    let d = CustomSmartPointer {
        data: String::from("other stuff"),
    };
    println!("CustomSmartPointers created.");
}
</code></pre>
</div>

<pre class="example">
CustomSmartPointers created.
Dropping CustomSmartPointer with data `other stuff`!
Dropping CustomSmartPointer with data `my stuff`!
</pre>
</section>
<section id="slide-10-4">
<h3 id="10-4"><span class="section-number-3">10.4.</span> Дељено власништво кроз бројање референци - <code>Rc&lt;T&gt;</code></h3>
<div class="outline-text-3" id="text-10-4">
</div>
</section>
<section id="slide-10-4-1">
<h4 id="10-4-1"><span class="section-number-4">10.4.1.</span> Мотивација</h4>
<ul>
<li>Постоје случајеви када је потребно имати више власника за неку вредност.</li>

</ul>


<div id="orgc94925c" class="figure">
<p><img src="./images/rc-list.svg" alt="rc-list.svg" class="org-svg" style="height: 300px;" />
</p>
</div>
</section>
<section id="slide-10-4-2">
<h4 id="10-4-2"><span class="section-number-4">10.4.2.</span> Покушај креирања дељене листе</h4>
<div class="org-src-container">

<pre><code class="rust" >enum List {
    Cons(i32, Box&lt;List&gt;),
    Nil,
}

use crate::List::{Cons, Nil};

fn main() {
    let a = Cons(5, Box::new(Cons(10, Box::new(Nil))));
    let b = Cons(3, Box::new(a));
    let c = Cons(4, Box::new(a));
}
</code></pre>
</div>

<div class="org-src-container">

<pre><code class="text" >error[E0382]: use of moved value: `a`
  --&gt; src/main.rs:12:30
   |
10 |     let a = Cons(5, Box::new(Cons(10, Box::new(Nil))));
   |         - move occurs because `a` has type `List`, which does not implement the `Copy` trait
11 |     let b = Cons(3, Box::new(a));
   |                              - value moved here
12 |     let c = Cons(4, Box::new(a));
   |                              ^ value used here after move

For more information about this error, try `rustc --explain E0382`.
error: could not compile `cargo1mCqK5` (bin "cargo1mCqK5") due to previous error
</code></pre>
</div>
</section>
<section id="slide-10-4-3">
<h4 id="10-4-3"><span class="section-number-4">10.4.3.</span> Решење - употреба <code>Rc&lt;T&gt;</code> паметног поинтера</h4>
<ul>
<li>Бројање референци - <i>reference counting</i>.</li>
<li>Додавањем новог власника бројач се увећава за један.</li>
<li>Када власник изађе из опсега бројач се умањује за један.</li>
<li>Када бројач постане 0 врши се деалокација вредности са хипа.</li>

</ul>
</section>
<section id="slide-10-4-4">
<h4 id="10-4-4"><span class="section-number-4">10.4.4.</span> Дељене листе употребом <code>Rc&lt;T&gt;</code></h4>
<div class="org-src-container">

<pre><code class="rust" >enum List {
    Cons(i32, Rc&lt;List&gt;),
    Nil,
}

use crate::List::{Cons, Nil};
use std::rc::Rc;

fn main() {
    let a = Rc::new(Cons(5, Rc::new(Cons(10, Rc::new(Nil)))));
    let b = Cons(3, Rc::clone(&amp;a));
    let c = Cons(4, Rc::clone(&amp;a));
}
</code></pre>
</div>

<ul>
<li><code>Rc::clone</code> не клонира вредност већ само увећава бројач.</li>
<li>Могли би писати и <code>a.clone()</code> али је конвенција да се пише <code>Rc::clone(&amp;a)</code> јер
овде не долази заиста до клонирања па је лакше уочити оваква места у коду.</li>

</ul>
</section>
<section id="slide-10-4-5">
<h4 id="10-4-5"><span class="section-number-4">10.4.5.</span> Тестирање бројача</h4>
<div class="org-src-container">

<pre><code class="rust" >enum List {
    Cons(i32, Rc&lt;List&gt;),
    Nil,
}
use std::rc::Rc;
use crate::List::{Cons, Nil};
fn main() {
    let a = Rc::new(Cons(5, Rc::new(Cons(10, Rc::new(Nil)))));
    println!("count after creating a = {}", Rc::strong_count(&amp;a));
    let b = Cons(3, Rc::clone(&amp;a));
    println!("count after creating b = {}", Rc::strong_count(&amp;a));
    {
        let c = Cons(4, Rc::clone(&amp;a));
        println!("count after creating c = {}", Rc::strong_count(&amp;a));
    }
    println!("count after c goes out of scope = {}", Rc::strong_count(&amp;a));
}
</code></pre>
</div>

<pre class="example">
count after creating a = 1
count after creating b = 2
count after creating c = 3
count after c goes out of scope = 2
</pre>
</section>
<section id="slide-10-4-6">
<h4 id="10-4-6"><span class="section-number-4">10.4.6.</span> Финалне напомене</h4>
<ul>
<li><code>Rc&lt;T&gt;</code> није сигуран у контексту нити (<i>not threadsafe</i>). Тип који јесте је
<code>Arc&lt;T&gt;</code> - <i>atomic reference counting</i>.</li>
<li>Овај тип има додатно оптерећење јер мора да ради закључавање. Зато у контексту
једне нити треба увек користити <code>Rc&lt;T&gt;</code>.</li>

</ul>
</section>
</section>
<section>
<section id="slide-11">
<h2 id="11"><span class="section-number-2">11.</span> Колекције</h2>
<div class="outline-text-2" id="text-11">
</div>
</section>
<section id="slide-11-1">
<h3 id="11-1"><span class="section-number-3">11.1.</span> Вектор (<code>Vec&lt;T&gt;</code>)</h3>
<div class="outline-text-3" id="text-11-1">
</div>
</section>
<section id="slide-11-1-1">
<h4 id="11-1-1"><span class="section-number-4">11.1.1.</span> Шта је вектор?</h4>
<ul>
<li>Линеарна структура која омогућава смештање података у суседне локације у меморији.</li>
<li>Хомогена структура. Елементи морају бити истог типа.</li>

</ul>
</section>
<section id="slide-11-1-2">
<h4 id="11-1-2"><span class="section-number-4">11.1.2.</span> Креирање новог вектора</h4>
<div class="org-src-container">

<pre><code class="rust" >let v: Vec&lt;i32&gt; = Vec::new();
</code></pre>
</div>

<ul>
<li>Морали смо додати анотацију типа јер је вектор генерички тип и компајлер не
зна тип елемента које ћемо смештати у вектор.</li>

<li><p>
Ако креирамо вектор са већ постојећим елементима чешће користимо <code>vec!</code> макро:
</p>

<div class="org-src-container">

<pre><code class="rust" >    let v = vec![1, 2, 3];
</code></pre>
</div></li>

</ul>
</section>
<section id="slide-11-1-3">
<h4 id="11-1-3"><span class="section-number-4">11.1.3.</span> Ажурирање вектора</h4>
<div class="org-src-container">

<pre><code class="rust" >let mut v = Vec::new();
v.push(5);
v.push(6);
v.push(7);
v.push(8);
</code></pre>
</div>
</section>
<section id="slide-11-1-4">
<h4 id="11-1-4"><span class="section-number-4">11.1.4.</span> Читање елемената вектора</h4>
<ul>
<li>Индексни приступ или употреба <code>get</code> методе.</li>

</ul>

<div class="org-src-container">

<pre><code class="rust" >let v = vec![1, 2, 3, 4, 5];

let third: &amp;i32 = &amp;v[2];
println!("The third element is {third}");

let third: Option&lt;&amp;i32&gt; = v.get(2);
match third {
    Some(third) =&gt; println!("The third element is {third}"),
    None =&gt; println!("There is no third element."),
}
</code></pre>
</div>

<ul>
<li>Индексни приступ може да доведе до прекида програма уколико индексирамо ван
опсега валидних индекса.</li>
<li><code>get</code> метода увек успева и враћа <code>Option&lt;&amp;T&gt;</code>.</li>

</ul>

</section>
<section>

<div class="org-src-container">

<pre><code class="rust" >let v = vec![1, 2, 3, 4, 5];

let does_not_exist = &amp;v[100];
let does_not_exist = v.get(100);
</code></pre>
</div>

<ul>
<li>Први индексни приступ ће изазвати панику.</li>
<li>Приступ са <code>get</code> би вратио <code>None</code>.</li>

</ul>
</section>
<section id="slide-11-1-5">
<h4 id="11-1-5"><span class="section-number-4">11.1.5.</span> Провера позајмљивања у контексту вектора</h4>
<ul>
<li><a href="#/slide-6-2-1" class="backwardlink">Правила позајмљивања</a> важе и у контексту вектора. Не можемо истовремено имати
промењиву и непромењиву референцу на елемент вектора.</li>

</ul>

<div class="org-src-container">

<pre><code class="rust" >let mut v = vec![1, 2, 3, 4, 5];
let first = &amp;v[0];
v.push(6);
println!("The first element is: {first}");
</code></pre>
</div>

<pre>
$ cargo run
   Compiling collections v0.1.0 (file:///projects/collections)
error[E0502]: cannot borrow `v` as mutable because it is also borrowed as immutable
 --&gt; src/main.rs:6:5
  |
4 |     let first = &amp;v[0];
  |                  - immutable borrow occurs here
5 |
6 |     v.push(6);
  |     ^^^^^^^^^ mutable borrow occurs here
7 |
8 |     println!("The first element is: {first}");
  |                                      ----- immutable borrow later used here

For more information about this error, try `rustc --explain E0502`.
error: could not compile `collections` due to previous error
</pre>

</section>
<section>

<div class="note" id="org2891073">
<p>
Имамо референцу на први елемент вектора а покушавамо промењивом референцом да
додамо на крај. Ово делује као да би било безбедно.
</p>

<p>
<i>Зашто Раст не дозвољава овакве операције?</i>
</p>

<p>
Приликом додавања новог елемента може доћи до попуњавања текуће алоциране зоне и
алоцирања нове зоне уз премештање свих елемената на нову локацију чиме би све
текуће референце постале невалидне. Правило позајмљивања спречава овакве грешке.
</p>

</div>
</section>
<section id="slide-11-1-6">
<h4 id="11-1-6"><span class="section-number-4">11.1.6.</span> Итерација преко елемената вектора</h4>
<div class="org-src-container">

<pre><code class="rust" >let v = vec![100, 32, 57];
for i in &amp;v {
    println!("{i}");
}
</code></pre>
</div>

<pre class="example">
100
32
57
</pre>


<div class="note" id="orgad619c8">
<p>
Пошто итерирамо преко позајмљене вредности <code>&amp;v</code>, тип од <code>i</code> ће бити позајмљен
(<code>&amp;u32</code>). Уколико би итерирали преко поседоване вредности <code>for i in v</code> тада би сви
елементи из вектора били премештени (тј. конзумирани) од стране <code>for</code> петље и не
би могли више да им приступимо.
</p>

</div>

</section>
<section>

<div class="org-src-container">

<pre><code class="rust" >let mut v = vec![100, 32, 57];
for i in &amp;mut v {
    *i += 50;
}
println!("{v:?}");
</code></pre>
</div>

<pre class="example">
[150, 82, 107]
</pre>
</section>
<section id="slide-11-1-7">
<h4 id="11-1-7"><span class="section-number-4">11.1.7.</span> Смештање елемената различитог типа</h4>
<ul>
<li>Вектор може садржати само елементе истог типа.</li>
<li>Уколико желимо да сместимо елементе различитог типа користимо енумерације.</li>

</ul>

<div class="org-src-container">

<pre><code class="rust" >#[derive(Debug)]
enum SpreadsheetCell {
    Int(i32),
    Float(f64),
    Text(String),
}
let row = vec![
    SpreadsheetCell::Int(3),
    SpreadsheetCell::Text(String::from("blue")),
    SpreadsheetCell::Float(10.12),
];
println!("{row:?}");
</code></pre>
</div>

<pre class="example">
[Int(3), Text("blue"), Float(10.12)]
</pre>


<ul>
<li>Употреба енумерација осигурава да ћемо обрадити све могуће случајеве нпр. <code>match</code> изразом.</li>

</ul>
</section>
<section id="slide-11-1-8">
<h4 id="11-1-8"><span class="section-number-4">11.1.8.</span> Ослобађање елемената вектора</h4>
<ul>
<li>Вектор ће деалоцирати своје елементе када власник напусти опсег важења.</li>

</ul>

<div class="org-src-container">

<pre><code class="rust" >{
    let v = vec![1, 2, 3, 4];

    // do stuff with v
} // &lt;- v goes out of scope and is freed here
</code></pre>
</div>
</section>
<section id="slide-11-2">
<h3 id="11-2"><span class="section-number-3">11.2.</span> <code>String</code></h3>
<div class="outline-text-3" id="text-11-2">
</div>
</section>
<section id="slide-11-2-1">
<h4 id="11-2-1"><span class="section-number-4">11.2.1.</span> Шта је стринг?</h4>
<ul>
<li>Раст има само један тип стринга подржан директно од стране језика - <code>str</code> који
се обично користи у позајмљеној форми <code>&amp;str</code> - стринг исечак који представља
референцу на UTF-8 енкодован садржај.</li>
<li>Тип <code>String</code>, дефинисан у Раст стандардној библиотеци, је растући, промењиви,
поседовани UTF-8 енкодовани стринг тип.</li>

</ul>
</section>
<section id="slide-11-2-2">
<h4 id="11-2-2"><span class="section-number-4">11.2.2.</span> Креирање новог стринга</h4>
<ul>
<li>Нова празна <code>String</code> вредност се креира на следећи начин:</li>

</ul>
<div class="org-src-container">

<pre><code class="rust" >let mut s = String::new();
</code></pre>
</div>

<p>
Обично користимо <code>to_string</code> методу типа који имплементира <code>Display</code> особину да би
добили почетну вреност стринга.
</p>

<div class="org-src-container">

<pre><code class="rust" >let data = "initial contents";

let s = data.to_string();

// the method also works on a literal directly:
let s = "initial contents".to_string();
</code></pre>
</div>

<p>
Такође, можемо користити <code>String::from</code>:
</p>
<div class="org-src-container">

<pre><code class="rust" >let s = String::from("initial contents");
</code></pre>
</div>
</section>
<section id="slide-11-2-3">
<h4 id="11-2-3"><span class="section-number-4">11.2.3.</span> Стринг може да садржи произвољну UTF-8 вредност</h4>
<div class="org-src-container">

<pre><code class="rust" >let hello = String::from("السلام عليكم");
let hello = String::from("Dobrý den");
let hello = String::from("Hello");
let hello = String::from("שָׁלוֹם");
let hello = String::from("नमस्ते");
let hello = String::from("こんにちは");
let hello = String::from("안녕하세요");
let hello = String::from("你好");
let hello = String::from("Olá");
let hello = String::from("Здравствуйте");
let hello = String::from("Hola");
</code></pre>
</div>
</section>
<section id="slide-11-2-4">
<h4 id="11-2-4"><span class="section-number-4">11.2.4.</span> Ажурирање стринга</h4>
<div class="org-src-container">

<pre><code class="rust" >let mut s = String::from("foo");
s.push_str("bar");
</code></pre>
</div>

<div class="org-src-container">

<pre><code class="rust" >let mut s1 = String::from("foo");
let s2 = "bar";
s1.push_str(s2);
println!("s2 is {s2}");
</code></pre>
</div>

<p>
<code>s2</code> је позајмљено и може да се користи после додавања.
</p>

</section>
<section>

<ul>
<li><p>
Додавање једног карактера:
</p>
<div class="org-src-container">

<pre><code class="rust" >    let mut s = String::from("lo");
    s.push('l');
</code></pre>
</div></li>

</ul>
</section>
<section id="slide-11-2-5">
<h4 id="11-2-5"><span class="section-number-4">11.2.5.</span> Употреба <code>+</code> оператора</h4>
<div class="org-src-container">

<pre><code class="rust" >let s1 = String::from("Hello, ");
let s2 = String::from("world!");
let s3 = s1 + &amp;s2; // note s1 has been moved here and can no longer be used
</code></pre>
</div>

<p>
<code>+</code> оператор конзумира први операнд тако да у претходном примеру <code>s1</code> варијабла не
важи после задње линије.
</p>

<p>
<code>+</code> оператор интерно користи <code>add</code> методу чија сигнатура је нешто попут:
</p>

<div class="org-src-container">

<pre><code class="rust" >fn add(self, s: &amp;str) -&gt; String {
</code></pre>
</div>

<div class="note" id="org6645f14">
<p>
Обратите пажњу да је други параметар типа <code>&amp;str</code> док је прослеђен тип <code>&amp;String</code>.
Компајлер ово прихвата. Зашто?
</p>

<p>
Користи се техника <a href="https://doc.rust-lang.org/std/ops/trait.Deref.html#more-on-deref-coercion">Deref coercion</a>, јер <code>String</code> имплементира особину <code>Deref&lt;Target=str&gt;</code>.
</p>

</div>
</section>
<section id="slide-11-2-6">
<h4 id="11-2-6"><span class="section-number-4">11.2.6.</span> Употреба <code>format!</code> макроа</h4>
<p>
Уместо:
</p>
<div class="org-src-container">

<pre><code class="rust" >let s1 = String::from("tic");
let s2 = String::from("tac");
let s3 = String::from("toe");

let s = s1 + "-" + &amp;s2 + "-" + &amp;s3;
</code></pre>
</div>

<p>
Можемо писати:
</p>
<div class="org-src-container">

<pre><code class="rust" >let s1 = String::from("tic");
let s2 = String::from("tac");
let s3 = String::from("toe");

let s = format!("{s1}-{s2}-{s3}");
</code></pre>
</div>
</section>
<section id="slide-11-2-7">
<h4 id="11-2-7"><span class="section-number-4">11.2.7.</span> Индексни приступ унутар стринга</h4>
<div class="org-src-container">

<pre><code class="rust" >let s1 = String::from("hello");
let h = s1[0];
</code></pre>
</div>

<pre>
$ cargo run
   Compiling collections v0.1.0 (file:///projects/collections)
error[E0277]: the type `String` cannot be indexed by `{integer}`
 --&gt; src/main.rs:3:13
  |
3 |     let h = s1[0];
  |             ^^^^^ `String` cannot be indexed by `{integer}`
  |
  = help: the trait `Index&lt;{integer}&gt;` is not implemented for `String`
  = help: the following other types implement trait `Index&lt;Idx&gt;`:
            &lt;String as Index&lt;RangeFrom&lt;usize&gt;&gt;&gt;
            &lt;String as Index&lt;RangeFull&gt;&gt;
            &lt;String as Index&lt;RangeInclusive&lt;usize&gt;&gt;&gt;
            &lt;String as Index&lt;RangeTo&lt;usize&gt;&gt;&gt;
            &lt;String as Index&lt;RangeToInclusive&lt;usize&gt;&gt;&gt;
            &lt;String as Index&lt;std::ops::Range&lt;usize&gt;&gt;&gt;

For more information about this error, try `rustc --explain E0277`.
error: could not compile `collections` due to previous error
</pre>

<p>
<i>Зашто?</i>
</p>
</section>
<section id="slide-11-2-8">
<h4 id="11-2-8"><span class="section-number-4">11.2.8.</span> Чување стринга у меморији</h4>
<div class="org-src-container">

<pre><code class="rust" >let hello = String::from("Hola");
println!("{}", hello.len());
</code></pre>
</div>

<pre class="example">
4
</pre>


<div class="org-src-container">

<pre><code class="rust" >let hello = String::from("Здраво");
println!("{}", hello.len());   // Дужина није 6 већ 12!
</code></pre>
</div>

<pre class="example">
12
</pre>


<p>
Шта би требао да врати елемент на одређеном индексу?
</p>
</section>
<section id="slide-11-2-9">
<h4 id="11-2-9"><span class="section-number-4">11.2.9.</span> Различити погледи на стринг</h4>
<p>
Три начина посматрања стринга: низ бајтова, низ скалара и низ графем кластера.
</p>

<p>
На пример, хинди реч "“नम�ते" ће у меморији бити следећи низ бајтова:
</p>
<pre>
[224, 164, 168, 224, 164, 174, 224, 164, 184, 224, 165, 141, 224, 164, 164,
224, 165, 135]
</pre>

<p>
Ако исту реч посматрамо као низ скалара или карактера (Раст <code>char</code> тип) онда имамо
следеће вредности:
</p>

<pre>
['न', 'म', 'स', '◌्', 'त', '◌े ']
</pre>

<p>
Четврти и шести карактер су дијакритици тј. немају смисла сами за себе.
</p>

<p>
Ако посматрамо исти садржај као графем кластере (најприближније концепту слова)
онда видимо следеће:
</p>

<div class="org-src-container">

<pre><code class="rust" >["न", "म", "स्", "ते"]
</code></pre>
</div>
</section>
<section id="slide-11-2-10">
<h4 id="11-2-10"><span class="section-number-4">11.2.10.</span> Сложеност индексног приступа</h4>
<p>
Додатни разлог зашто не треба дозволити индексни приступ код стрингова јесте
чињеница да индексни приступ увак има сложеност <code>O(1)</code> што се код стрингова не
може гарантовати.
</p>
</section>
<section id="slide-11-2-11">
<h4 id="11-2-11"><span class="section-number-4">11.2.11.</span> Креирање исечака</h4>
<p>
Могуће је креирање исечака стрингова с тим да је на програмеру да обезбеди да се
границе исечака налазе на крајевима <code>char</code> типа тј. није могуће да играница исечка
буде унутар карактера.
</p>

<p>
На пример, ово је могуће:
</p>
<div class="org-src-container">

<pre><code class="rust" >let hello = "Здраво";
let s = &amp;hello[0..4];
println!("{s}")
</code></pre>
</div>

<pre class="example">
Зд
</pre>


<p>
Али ово је грешка:
</p>
<div class="org-src-container">

<pre><code class="rust" >let hello = "Здраво";
let s = &amp;hello[0..3];
println!("{s}")
</code></pre>
</div>

<pre>
thread 'main' panicked at 'byte index 3 is not a char boundary; it is inside 'д' (bytes 2..4)
of `Здраво`', src/main.rs:4:10
</pre>
</section>
<section id="slide-11-2-12">
<h4 id="11-2-12"><span class="section-number-4">11.2.12.</span> Итерација преко стрингова</h4>
<p>
Начин да обрадимо све елементе стринга је да итерирамо, при чему имамо две
методе:
</p>

<ul>
<li><p>
<code>chars</code> - ако желимо да обрадимо стринг као низ карактера
</p>
<div class="org-src-container">

<pre><code class="rust" >    for c in "Зд".chars() {
        println!("{c}");
    }
</code></pre>
</div></li>

<li><p>
<code>bytes</code> - ако желимо да обрадимо стринг као низ бајтова
</p>
<div class="org-src-container">

<pre><code class="rust" >    for b in "Зд".bytes() {
        println!("{b}");
    }
</code></pre>
</div></li>

</ul>
</section>
<section id="slide-11-3">
<h3 id="11-3"><span class="section-number-3">11.3.</span> Хеш мапа (<code>HashMap&lt;K, V&gt;</code>)</h3>
<div class="outline-text-3" id="text-11-3">
</div>
</section>
<section id="slide-11-3-1">
<h4 id="11-3-1"><span class="section-number-4">11.3.1.</span> Шта је хеш мапа?</h4>
<ul>
<li>Генеричка, хомогена структура која чува парове кључ-вреност.</li>
<li>У другим језицима се зове још и: хеш табела, речник или асоцијативни низ.</li>
<li>Корисно у ситацијама када је потребно пронаћи везани податак не по индексу већ
по другој вредности.</li>

</ul>
</section>
<section id="slide-11-3-2">
<h4 id="11-3-2"><span class="section-number-4">11.3.2.</span> Креирање хеш мапе</h4>
<div class="org-src-container">

<pre><code class="rust" >use std::collections::HashMap;

let mut scores = HashMap::new();

scores.insert(String::from("Blue"), 10);
scores.insert(String::from("Yellow"), 50);
</code></pre>
</div>
</section>
<section id="slide-11-3-3">
<h4 id="11-3-3"><span class="section-number-4">11.3.3.</span> Приступање елементима хеш мапе</h4>
<div class="org-src-container">

<pre><code class="rust" >use std::collections::HashMap;

let mut scores = HashMap::new();

scores.insert(String::from("Blue"), 10);
scores.insert(String::from("Yellow"), 50);

let team_name = String::from("Blue");
let score = scores.get(&amp;team_name).copied().unwrap_or(0);
</code></pre>
</div>

<ul>
<li><code>get</code> метода враћа тип <code>Option&lt;&amp;T&gt;</code>, дакле <code>None</code> вредност ако за дати кључ не
постоји везана вредност. Позивамо <code>copied</code> да добијемо <code>Option&lt;T&gt;</code> са копираном
вредношћу.</li>

</ul>
</section>
<section id="slide-11-3-4">
<h4 id="11-3-4"><span class="section-number-4">11.3.4.</span> Итерација преко парова кључ-вредност</h4>
<div class="org-src-container">

<pre><code class="rust" >use std::collections::HashMap;

let mut scores = HashMap::new();

scores.insert(String::from("Blue"), 10);
scores.insert(String::from("Yellow"), 50);

for (key, value) in &amp;scores {
    println!("{key}: {value}");
}
</code></pre>
</div>

<pre class="example">
Yellow: 50
Blue: 10
</pre>
</section>
<section id="slide-11-3-5">
<h4 id="11-3-5"><span class="section-number-4">11.3.5.</span> Хеш мапа и власништво</h4>
<ul>
<li>Ако тип имплементира <code>Copy</code> особину биће копиран у мапу, у супротном биће
премештен и хеш мапа постаје власник.</li>

</ul>

<div class="org-src-container">

<pre><code class="rust" >use std::collections::HashMap;

let field_name = String::from("Favorite color");
let field_value = String::from("Blue");

let mut map = HashMap::new();
map.insert(field_name, field_value);
// field_name and field_value are invalid at this point, try using them and
// see what compiler error you get!
</code></pre>
</div>
</section>
<section id="slide-11-3-6">
<h4 id="11-3-6"><span class="section-number-4">11.3.6.</span> Ажурирање хеш мапе - преписивање вредности</h4>
<div class="org-src-container">

<pre><code class="rust" >use std::collections::HashMap;

let mut scores = HashMap::new();

scores.insert(String::from("Blue"), 10);
scores.insert(String::from("Blue"), 25);

println!("{:?}", scores);
</code></pre>
</div>

<pre class="example">
{"Blue": 25}
</pre>
</section>
<section id="slide-11-3-7">
<h4 id="11-3-7"><span class="section-number-4">11.3.7.</span> Ажурирање хеш мапе - додавање уклолико кључ не постоји</h4>
<div class="org-src-container">

<pre><code class="rust" >use std::collections::HashMap;

let mut scores = HashMap::new();
scores.insert(String::from("Blue"), 10);

scores.entry(String::from("Yellow")).or_insert(50);
scores.entry(String::from("Blue")).or_insert(50);

println!("{:?}", scores);
</code></pre>
</div>

<pre class="example">
{"Yellow": 50, "Blue": 10}
</pre>


<p>
Користимо <code>Entry API</code>.
</p>
</section>
<section id="slide-11-3-8">
<h4 id="11-3-8"><span class="section-number-4">11.3.8.</span> Ажурирање хеш мапе - на основу старе вредности</h4>
<div class="org-src-container">

<pre><code class="rust" >use std::collections::HashMap;

let text = "hello world wonderful world";

let mut map = HashMap::new();

for word in text.split_whitespace() {
    let count = map.entry(word).or_insert(0);
    *count += 1;
}

println!("{:?}", map);
</code></pre>
</div>

<pre class="example">
{"wonderful": 1, "hello": 1, "world": 2}
</pre>
</section>
</section>
<section>
<section id="slide-12">
<h2 id="12"><span class="section-number-2">12.</span> Обрада грешака</h2>
<div class="outline-text-2" id="text-12">
</div>
</section>
<section id="slide-12-1">
<h3 id="12-1"><span class="section-number-3">12.1.</span> Категорије грешака у Расту</h3>
<ul>
<li>грешке код којих је могућ опоравак (<i>recoverable</i>)
<ul>
<li>Грешке које очекивано могу да се десе у току рада и које можемо да обрадимо
и наставимо извршавање без нарушавања конзитентности стања програма.</li>

</ul></li>
<li>грешке код којих опоравак није могућ (<i>unrecoverable</i>)
<ul>
<li>Увек су симптом багова у програму, нпр. читање ван опсега низа.</li>
<li>Једини логичан поступак је прекид рада програма.</li>

</ul></li>
<li>Већина језика не прави разлику већ све обрађује на исти начин, најчешће
употребом механизма изузетака.</li>

</ul>
</section>
<section id="slide-12-2">
<h3 id="12-2"><span class="section-number-3">12.2.</span> <code>panic!</code></h3>
<ul>
<li>Макро који доводи до прекида програма. Позивамо га када програм заврши у стању
у коме није могућ опоравак.</li>

</ul>

<div class="org-src-container">

<pre><code class="rust" >fn main() {
    panic!("crash and burn");
}
</code></pre>
</div>

<div class="org-src-container">

<pre><code class="sh" >$ cargo run
   Compiling panic v0.1.0 (file:///projects/panic)
    Finished dev [unoptimized + debuginfo] target(s) in 0.25s
     Running `target/debug/panic`
thread 'main' panicked at 'crash and burn', src/main.rs:2:5
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace
</code></pre>
</div>
</section>
<section id="slide-12-3">
<h3 id="12-3"><span class="section-number-3">12.3.</span> <code>panic!</code> повратни траг (<i>backtrace</i>)</h3>
<div class="org-src-container">

<pre><code class="rust" >fn main() {
    let v = vec![1, 2, 3];

    v[99];
}
</code></pre>
</div>

<div class="org-src-container">

<pre><code class="sh" >$ cargo run
   Compiling panic v0.1.0 (file:///projects/panic)
    Finished dev [unoptimized + debuginfo] target(s) in 0.27s
     Running `target/debug/panic`
thread 'main' panicked at 'index out of bounds: the len is 3 but the index is 99', src/main.rs:4:5
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace
</code></pre>
</div>

</section>
<section>

<ul>
<li>Читамо линије повратног трага од горе до доле и интересује нас да пронађемо
прво место где се помиње наш код. То је локација која је изазвала прекид.</li>

</ul>
<div class="org-src-container">

<pre><code class="sh" >$ RUST_BACKTRACE=1 cargo run
thread 'main' panicked at 'index out of bounds: the len is 3 but the index is 99', src/main.rs:4:5
stack backtrace:
   0: rust_begin_unwind
             at /rustc/e092d0b6b43f2de967af0887873151bb1c0b18d3/library/std/src/panicking.rs:584:5
   1: core::panicking::panic_fmt
             at /rustc/e092d0b6b43f2de967af0887873151bb1c0b18d3/library/core/src/panicking.rs:142:14
   2: core::panicking::panic_bounds_check
             at /rustc/e092d0b6b43f2de967af0887873151bb1c0b18d3/library/core/src/panicking.rs:84:5
   3: &lt;usize as core::slice::index::SliceIndex&lt;[T]&gt;&gt;::index
             at /rustc/e092d0b6b43f2de967af0887873151bb1c0b18d3/library/core/src/slice/index.rs:242:10
   4: core::slice::index::&lt;impl core::ops::index::Index&lt;I&gt; for [T]&gt;::index
             at /rustc/e092d0b6b43f2de967af0887873151bb1c0b18d3/library/core/src/slice/index.rs:18:9
   5: &lt;alloc::vec::Vec&lt;T,A&gt; as core::ops::index::Index&lt;I&gt;&gt;::index
             at /rustc/e092d0b6b43f2de967af0887873151bb1c0b18d3/library/alloc/src/vec/mod.rs:2591:9
   6: panic::main
             at ./src/main.rs:4:5
   7: core::ops::function::FnOnce::call_once
             at /rustc/e092d0b6b43f2de967af0887873151bb1c0b18d3/library/core/src/ops/function.rs:248:5
note: Some details are omitted, run with `RUST_BACKTRACE=full` for a verbose backtrace.
</code></pre>
</div>

</section>
<section>

<div class="note" id="org96053f8">
<p>
У програмском језику Ц, читање ван опсега је недефинисано понашање и компајлер
може да произведе кôд који ради произвољну ствар. Најчешће ће да чита са
локације која се налази иза краја низа што представља грешку <i>buffer overread</i>
која доводи до сигурносних пропуста.
</p>

</div>
</section>
<section id="slide-12-4">
<h3 id="12-4"><span class="section-number-3">12.4.</span> Опоравак од грешке - <code>Result&lt;T,E&gt;</code></h3>
<ul>
<li>Многе грешке су очекиване током нормалног извршавања програма.</li>
<li>На пример, ако покушамо отварање фајла, он можда не постоји тако да би
опоравак од грешке могао бити његово креирање.</li>
<li>Код оваквих грешака Раст користи генерички тип <code>Result&lt;T,E&gt;</code>:</li>

</ul>

<div class="org-src-container">

<pre><code class="rust" >enum Result&lt;T, E&gt; {
    Ok(T),
    Err(E),
}
</code></pre>
</div>
</section>
<section id="slide-12-5">
<h3 id="12-5"><span class="section-number-3">12.5.</span> Отварање фајла</h3>
<p>
Фајл: <code>src/main.rs</code>:
</p>
<div class="org-src-container">

<pre><code class="rust" >use std::fs::File;

fn main() {
    let greeting_file_result = File::open("hello.txt");
}
</code></pre>
</div>

<ul>
<li>Варијабла <code>greeting_file_result</code> ће бити типа <code>Result&lt;std::fs::File,
  std::io::Error&gt;</code>. Уколико је враћена варијанта <code>Ok</code> она ће у себи садржати фајл,
уколико се врати варијанта <code>Err</code>, у њој ће бити грешка типа <code>std::io::Error</code>.</li>

</ul>

</section>
<section>

<ul>
<li>У сваком случају морамо обрадити обе варијанте.</li>

</ul>
<p>
Фајл: <code>src/main.rs</code>:
</p>
<div class="org-src-container">

<pre><code class="rust" >use std::fs::File;

fn main() {
    let greeting_file_result = File::open("hello.txt");

    let greeting_file = match greeting_file_result {
        Ok(file) =&gt; file,
        Err(error) =&gt; panic!("Problem opening the file: {:?}", error),
    };
}
</code></pre>
</div>
</section>
<section id="slide-12-6">
<h3 id="12-6"><span class="section-number-3">12.6.</span> Препознавање различитих грешака</h3>
<ul>
<li>Желимо да креирамо фајл уколико не постоји. Морамо да проверимо коју грешку
смо добили.</li>

</ul>

<div class="org-src-container">

<pre><code class="rust" >use std::fs::File;
use std::io::ErrorKind;

fn main() {
    let greeting_file_result = File::open("hello.txt");

    let greeting_file = match greeting_file_result {
        Ok(file) =&gt; file,
        Err(error) =&gt; match error.kind() {
            ErrorKind::NotFound =&gt; match File::create("hello.txt") {
                Ok(fc) =&gt; fc,
                Err(e) =&gt; panic!("Problem creating the file: {:?}", e),
            },
            other_error =&gt; {
                panic!("Problem opening the file: {:?}", other_error);
            }
        },
    };
}
</code></pre>
</div>

</section>
<section>

<ul>
<li>Алтернативно можемо користити API <code>Result</code> типа:</li>

</ul>

<div class="org-src-container">

<pre><code class="rust" >use std::fs::File;
use std::io::ErrorKind;

fn main() {
    let greeting_file = File::open("hello.txt").unwrap_or_else(|error| {
        if error.kind() == ErrorKind::NotFound {
            File::create("hello.txt").unwrap_or_else(|error| {
                panic!("Problem creating the file: {:?}", error);
            })
        } else {
            panic!("Problem opening the file: {:?}", error);
        }
    });
}
</code></pre>
</div>
</section>
<section id="slide-12-7">
<h3 id="12-7"><span class="section-number-3">12.7.</span> Пречица <code>unwrap</code></h3>
<ul>
<li>С обзиром да је оваква обрада честа, постоји пречица тако да можемо писати
доста краће:</li>

</ul>

<div class="org-src-container">

<pre><code class="rust" >use std::fs::File;

fn main() {
    let greeting_file = File::open("hello.txt").unwrap();
}
</code></pre>
</div>

<pre>
thread 'main' panicked at 'called `Result::unwrap()` on an `Err` value: Os {
code: 2, kind: NotFound, message: "No such file or directory" }',
src/main.rs:4:49
</pre>
</section>
<section id="slide-12-8">
<h3 id="12-8"><span class="section-number-3">12.8.</span> Пречица <code>expect</code></h3>
<ul>
<li>Или, уколико желимо да дамо више информација у случају прекида:</li>

</ul>

<div class="org-src-container">

<pre><code class="rust" >use std::fs::File;

fn main() {
    let greeting_file = File::open("hello.txt")
        .expect("hello.txt should be included in this project");
}
</code></pre>
</div>

<pre>
thread 'main' panicked at 'hello.txt should be included in this project: Os {
code: 2, kind: NotFound, message: "No such file or directory" }',
src/main.rs:5:10
</pre>
</section>
<section id="slide-12-9">
<h3 id="12-9"><span class="section-number-3">12.9.</span> Пропагација грешака</h3>
<div class="org-src-container">

<pre><code class="rust" >use std::fs::File;
use std::io::{self, Read};

fn read_username_from_file() -&gt; Result&lt;String, io::Error&gt; {
    let username_file_result = File::open("hello.txt");

    let mut username_file = match username_file_result {
        Ok(file) =&gt; file,
        Err(e) =&gt; return Err(e),
    };

    let mut username = String::new();

    match username_file.read_to_string(&amp;mut username) {
        Ok(_) =&gt; Ok(username),
        Err(e) =&gt; Err(e),
    }
}
</code></pre>
</div>

<p>
Сада позиваоц може да одлучи како да обради грешку. Нпр. може да:
</p>
<ul>
<li>прекине програм са <code>panic!</code></li>
<li>користи подразумевано корисничко име</li>
<li>пронађе корисничко име на неком другом месту (нпр. из базе података)</li>

</ul>
</section>
<section id="slide-12-10">
<h3 id="12-10"><span class="section-number-3">12.10.</span> Пречица за пропагацију грешака - оператор <code>?</code></h3>
<div class="org-src-container">

<pre><code class="rust" >use std::fs::File;
use std::io::{self, Read};

fn read_username_from_file() -&gt; Result&lt;String, io::Error&gt; {
    let mut username_file = File::open("hello.txt")?;
    let mut username = String::new();
    username_file.read_to_string(&amp;mut username)?;
    Ok(username)
}
</code></pre>
</div>

<ul>
<li>Оператор <code>?</code> елиминише тзв. <i>boilerplate</i> код.</li>
<li>Функција мора да враћа компатибилан тип да би могла да се користи ова пречица.</li>

</ul>

</section>
<section>

<div class="note" id="org22edfd7">
<p>
Постоји значајна разлика између <code>?</code> оператора и <code>match</code> израза. <code>?</code> оператор ће
аутоматски радити конверзију грешака за све грешке које имплементирају <code>From</code>
особину. На пример, ако нека наша грешка <code>OurError</code> имплементира конверзију из
<code>std::io::Error</code> тако што имамо <code>impl From&lt;std::io::Error&gt; for OurError</code> тада можемо
декларисати да наша функција враћа <code>OurError</code> и даље користити пречицу <code>?</code> на
местима која резултују са <code>std::io::Error</code>.
</p>

</div>
</section>
<section id="slide-12-11">
<h3 id="12-11"><span class="section-number-3">12.11.</span> Додатно скраћење кода</h3>
<ul>
<li>Употребом повезаних позива <i>chain call</i> можемо додатно поједноставити код:</li>

</ul>

<div class="org-src-container">

<pre><code class="rust" >use std::fs::File;
use std::io::{self, Read};

fn read_username_from_file() -&gt; Result&lt;String, io::Error&gt; {
    let mut username = String::new();

    File::open("hello.txt")?.read_to_string(&amp;mut username)?;

    Ok(username)
}
</code></pre>
</div>
</section>
<section id="slide-12-12">
<h3 id="12-12"><span class="section-number-3">12.12.</span> Употреба <code>?</code> оператора код <code>Option</code> типа</h3>
<div class="org-src-container">

<pre><code class="rust" >fn last_char_of_first_line(text: &amp;str) -&gt; Option&lt;char&gt; {
    text.lines().next()?.chars().last()
}
</code></pre>
</div>
</section>
<section id="slide-12-13">
<h3 id="12-13"><span class="section-number-3">12.13.</span> Употреба <code>?</code> оператора у функцији <code>main</code></h3>
<div class="org-src-container">

<pre><code class="rust" >use std::error::Error;
use std::fs::File;

fn main() -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
    let greeting_file = File::open("hello.txt")?;

    Ok(())
}
</code></pre>
</div>
</section>
</section>
<section>
<section id="slide-13">
<h2 id="13"><span class="section-number-2">13.</span> Пакети, сандуци и модули</h2>
<div class="outline-text-2" id="text-13">
</div>
</section>
<section id="slide-13-1">
<h3 id="13-1"><span class="section-number-3">13.1.</span> Организација програмског кода</h3>
<ul>
<li>Са порастом величине пројекта расте значај организације кода.</li>
<li>Раст механизми за организацију кода су:
<ul>
<li>Пакети</li>
<li>Сандуци (<i>crates</i>)</li>
<li>Модули и кључна реч <code>use</code></li>
<li>Путање (<i>paths</i>)</li>

</ul></li>

</ul>
</section>
<section id="slide-13-2">
<h3 id="13-2"><span class="section-number-3">13.2.</span> Сандуци (<i>crates</i>)</h3>
<ul>
<li>Сандук представља најмању количину кода коју Раст компајлер обрађује у једном тренутку.</li>
<li>Сандук може бити у форми <i>бинарног сандука</i> и <i>библиотечког сандука</i>.</li>
<li>Бинарни сандук представља програме који могу да се компајлирају и покрену. Ови
сандуци имају функцију <code>main</code> која представља улазну тачку.</li>
<li>Библиотечки сандуци представљају функционалност намењену за дељење са другим пројектима.</li>
<li>Корен сандука представља почетни фајл од кога Раст компајлер креће, односно
представља коренски модул.</li>

</ul>
</section>
<section id="slide-13-3">
<h3 id="13-3"><span class="section-number-3">13.3.</span> Пакети</h3>
<ul>
<li>Пакет представља скуп логички повезаних сандука којима се управља на
јединствен начин.</li>
<li>Пакет мора имати бар један сандук.</li>
<li>Пакет може имати произвољно много бинарних сандука али највише један
библиотечки сандук.</li>

</ul>
</section>
<section id="slide-13-4">
<h3 id="13-4"><span class="section-number-3">13.4.</span> Креирање пакета</h3>
<div class="org-src-container">

<pre><code class="sh" >$ cargo new my-project
     Created binary (application) `my-project` package
$ ls my-project
Cargo.toml
src
$ ls my-project/src
main.rs
</code></pre>
</div>

<ul>
<li>Сваки пакети у корену има <code>Cargo.toml</code> конфигурациони фајл.</li>
<li>Према конвенцији корен бинарног сандука је <code>src/main.rs</code>, док је корен
библиотечког сандука <code>src/lib.rs</code>.</li>
<li>Ако пакет има више бинарних сандука, коренски фајлови се смештају у фолдер <code>src/bin</code>.</li>

</ul>
</section>
<section id="slide-13-5">
<h3 id="13-5"><span class="section-number-3">13.5.</span> Структура пакета</h3>
<div class="org-src-container">

<pre><code class="text" >backyard
├── Cargo.lock
├── Cargo.toml              &lt;- конфигурација пакета
└── src
    ├── garden
    │   └── vegetables.rs   &lt;- модул
    ├── garden.rs           &lt;- модул
    └── main.rs             &lt;- корен бинарног сандука
</code></pre>
</div>
</section>
<section id="slide-13-6">
<h3 id="13-6"><span class="section-number-3">13.6.</span> Груписање повезаног кода у модуле</h3>
<ul>
<li>У циљу читљивости, лакшег проналаска и поновне искористљивости, модули нам омогућавају организацију кода унутар сандука у виду стабла.</li>
<li>Модули, такође, омогућавају дефинисање правила приступа. Сви елементи унутар
модула су подразумевано приватни.</li>

</ul>
</section>
<section id="slide-13-7">
<h3 id="13-7"><span class="section-number-3">13.7.</span> Пример употребе модула</h3>
<div class="org-src-container">

<pre><code class="sh" >cargo new restaurant --lib
</code></pre>
</div>

<p>
Фајл: src/lib.rs
</p>
<div class="org-src-container">

<pre><code class="rust" >mod front_of_house {
    mod hosting {
        fn add_to_waitlist() {}

        fn seat_at_table() {}
    }

    mod serving {
        fn take_order() {}

        fn serve_order() {}

        fn take_payment() {}
    }
}
</code></pre>
</div>

<p>
Модули могу имати друге модуле, структуре, енумерације, константе, особине итд.
</p>
</section>
<section id="slide-13-8">
<h3 id="13-8"><span class="section-number-3">13.8.</span> Стабло модула (<i>module tree</i>)</h3>
<p>
Модули се повезују и чине структуру типа стабла чији корен је корен сандука
(<code>main.rs</code> ili <code>lib.rs</code>).
</p>

<div class="org-src-container">

<pre><code class="text" >crate
 └── front_of_house
     ├── hosting
     │   ├── add_to_waitlist
     │   └── seat_at_table
     └── serving
         ├── take_order
         ├── serve_order
         └── take_payment
</code></pre>
</div>

<p>
Аналогија је систем фајлова и фолдера.
</p>
</section>
<section id="slide-13-9">
<h3 id="13-9"><span class="section-number-3">13.9.</span> Путање унутар стабла модула</h3>
<p>
Елементи Раст кода се могу референцирати путањама које синтаксни елемент за
навигацију над стаблом модула.
</p>

<p>
Постоје две врсте путања:
</p>
<ul>
<li><i>апсолутна путања</i> - пуна путања која почиње од корена сандука. Започиње са
речју <code>crate</code>.</li>
<li><i>релативна путања</i> - путања која се гради релативно од позиције где се наводи.
Може да користи кључне речи <code>self</code> i <code>super</code>.</li>

</ul>
</section>
<section id="slide-13-10">
<h3 id="13-10"><span class="section-number-3">13.10.</span> Пример апсолутне и релативне путање</h3>
<div class="org-src-container">

<pre><code class="rust" >mod front_of_house {
    mod hosting {
        fn add_to_waitlist() {}
    }
}

pub fn eat_at_restaurant() {
    // Absolute path
    crate::front_of_house::hosting::add_to_waitlist();

    // Relative path
    front_of_house::hosting::add_to_waitlist();
}
</code></pre>
</div>
</section>
<section id="slide-13-11">
<h3 id="13-11"><span class="section-number-3">13.11.</span> Видљивост елемената унутар модула</h3>
<ul>
<li>Претходни пример се не компајлира.</li>

</ul>

<div class="org-src-container">

<pre><code class="rust" >$ cargo build
   Compiling restaurant v0.1.0 (file:///projects/restaurant)
error[E0603]: module `hosting` is private
 --&gt; src/lib.rs:9:28
  |
9 |     crate::front_of_house::hosting::add_to_waitlist();
  |                            ^^^^^^^ private module
  |
note: the module `hosting` is defined here
 --&gt; src/lib.rs:2:5
  |
2 |     mod hosting {
  |     ^^^^^^^^^^^

error[E0603]: module `hosting` is private
  --&gt; src/lib.rs:12:21
   |
12 |     front_of_house::hosting::add_to_waitlist();
   |                     ^^^^^^^ private module
   |
note: the module `hosting` is defined here
  --&gt; src/lib.rs:2:5
   |
2  |     mod hosting {
   |     ^^^^^^^^^^^

For more information about this error, try `rustc --explain E0603`.
error: could not compile `restaurant` due to 2 previous errors
</code></pre>
</div>

</section>
<section>

<p>
Ако учинимо модул <code>hosting</code> јавним:
</p>

<div class="org-src-container">

<pre><code class="rust" >mod front_of_house {
    pub mod hosting {
        fn add_to_waitlist() {}
    }
}

pub fn eat_at_restaurant() {
    // Absolute path
    crate::front_of_house::hosting::add_to_waitlist();

    // Relative path
    front_of_house::hosting::add_to_waitlist();
}
</code></pre>
</div>

</section>
<section>

<p>
И даље имамо грешку:
</p>
<div class="org-src-container">

<pre><code class="rust" >$ cargo build
   Compiling restaurant v0.1.0 (file:///projects/restaurant)
error[E0603]: function `add_to_waitlist` is private
 --&gt; src/lib.rs:9:37
  |
9 |     crate::front_of_house::hosting::add_to_waitlist();
  |                                     ^^^^^^^^^^^^^^^ private function
  |
note: the function `add_to_waitlist` is defined here
 --&gt; src/lib.rs:3:9
  |
3 |         fn add_to_waitlist() {}
  |         ^^^^^^^^^^^^^^^^^^^^

error[E0603]: function `add_to_waitlist` is private
  --&gt; src/lib.rs:12:30
   |
12 |     front_of_house::hosting::add_to_waitlist();
   |                              ^^^^^^^^^^^^^^^ private function
   |
note: the function `add_to_waitlist` is defined here
  --&gt; src/lib.rs:3:9
   |
3  |         fn add_to_waitlist() {}
   |         ^^^^^^^^^^^^^^^^^^^^

For more information about this error, try `rustc --explain E0603`.
error: could not compile `restaurant` due to 2 previous errors
</code></pre>
</div>

</section>
<section>

<p>
Морамо учинити и функцију <code>add_to_waitlist</code> јавном јер иако је модул јаван његови
елементи су подразумевано приватни.
</p>

<div class="org-src-container">

<pre><code class="rust" >mod front_of_house {
    pub mod hosting {
        pub fn add_to_waitlist() {}
    }
}

pub fn eat_at_restaurant() {
    // Absolute path
    crate::front_of_house::hosting::add_to_waitlist();

    // Relative path
    front_of_house::hosting::add_to_waitlist();
}
</code></pre>
</div>
</section>
<section id="slide-13-12">
<h3 id="13-12"><span class="section-number-3">13.12.</span> Јавни API</h3>
<p>
Код који је јавно доступан ван библиотечког сандука чини јавни API библиотеке и
представља "уговор" са корисницима библиотеке. Стога је важно поштовати одређена
правила измене ових елемената.
</p>

<p>
Делови кода који нису споља јавно доступни могу слободно да се мењају јер неће
утицати на кориснике.
</p>
</section>
<section id="slide-13-13">
<h3 id="13-13"><span class="section-number-3">13.13.</span> Релативне путање и употреба <code>super</code></h3>
<ul>
<li><code>super</code> се користи у ситуацији када релативну путању креирамо са почетком у
родитељском модулу.</li>

</ul>

<div class="org-src-container">

<pre><code class="rust" >fn deliver_order() {}

mod back_of_house {
    fn fix_incorrect_order() {
        cook_order();
        super::deliver_order();
    }

    fn cook_order() {}
}
</code></pre>
</div>
</section>
<section id="slide-13-14">
<h3 id="13-14"><span class="section-number-3">13.14.</span> Јавни приступ структурама и енумерацијама</h3>
<ul>
<li>Постоји одређена разлика у третирању <code>pub</code> кључне речи када су у питању
структуре и енумерације.</li>
<li>Структуре које имају јавни приступ и даље подразумевано имају приватан приступ пољима.</li>

</ul>
<div class="org-src-container">

<pre><code class="rust" >mod back_of_house {
    pub struct Breakfast {
        pub toast: String,
        seasonal_fruit: String,
    }
    impl Breakfast {
        pub fn summer(toast: &amp;str) -&gt; Breakfast {
            Breakfast {
                toast: String::from(toast),
                seasonal_fruit: String::from("peaches"),
            }
        }
    }
}
pub fn eat_at_restaurant() {
    let mut meal = back_of_house::Breakfast::summer("Rye");

    meal.toast = String::from("Wheat");
    println!("I'd like {} toast please", meal.toast);

    // Следећа линија се не компајлира јер је поље приватно
    // meal.seasonal_fruit = String::from("blueberries");
}
</code></pre>
</div>

</section>
<section>

<p>
Са друге стране, варијанте енумерација су увек јавне:
</p>

<div class="org-src-container">

<pre><code class="rust" >mod back_of_house {
    pub enum Appetizer {
        Soup,
        Salad,
    }
}

pub fn eat_at_restaurant() {
    let order1 = back_of_house::Appetizer::Soup;
    let order2 = back_of_house::Appetizer::Salad;
}
</code></pre>
</div>
</section>
<section id="slide-13-15">
<h3 id="13-15"><span class="section-number-3">13.15.</span> Увођење елемената у опсег - кључна реч <code>use</code></h3>
<ul>
<li>Употреба пуних путања за свако навођење језичког елемента је оптерећујуће и
лоше утиче на читкост кода.</li>
<li>Употребом кључне речи <code>use</code> можемо увести елемент у текући опсег.</li>

</ul>

<div class="org-src-container">

<pre><code class="rust" >mod front_of_house {
    pub mod hosting {
        pub fn add_to_waitlist() {}
    }
}

use crate::front_of_house::hosting;

pub fn eat_at_restaurant() {
    hosting::add_to_waitlist();
}
</code></pre>
</div>

<p>
Аналогно креирању пречица (<i>shortcuts</i>) у фајл систему.
</p>
</section>
<section id="slide-13-16">
<h3 id="13-16"><span class="section-number-3">13.16.</span> <code>use</code> само креира пречицу</h3>
<p>
Следећи пример се не компајлира јер смо поморили функцију <code>eat_at_restaurant</code> у
модул <code>customer</code> и релативна пречица више није валидна.
</p>

<div class="org-src-container">

<pre><code class="rust" >mod front_of_house {
    pub mod hosting {
        pub fn add_to_waitlist() {}
    }
}

use crate::front_of_house::hosting;

mod customer {
    pub fn eat_at_restaurant() {
        hosting::add_to_waitlist();
    }
}
</code></pre>
</div>
</section>
<section id="slide-13-17">
<h3 id="13-17"><span class="section-number-3">13.17.</span> Креирање идиоматских путања</h3>
<ul>
<li>Када уводимо функцију у опсег обично то радимо увођењем родитељског модула
како смо видели на претходном примеру.</li>
<li>Ако уводимо типове (структуре, енумерације) наводимо их директно.</li>
<li>На пример, увођење структуре <code>HashMap</code> из стандардне библиотеке:</li>

</ul>

<div class="org-src-container">

<pre><code class="rust" >use std::collections::HashMap;

fn main() {
    let mut map = HashMap::new();
    map.insert(1, 2);
}
</code></pre>
</div>
</section>
<section id="slide-13-18">
<h3 id="13-18"><span class="section-number-3">13.18.</span> Употреба кључне речи <code>as</code> за промену имена</h3>
<p>
Раст не дозвољава да постоје различити елементи у опсегу са истим именом.
Уколико желимо да уведемо елементе са истим називом можемо:
</p>
<ul>
<li><p>
Увести родитељски модул, као у следећем примеру:
</p>
<div class="org-src-container">

<pre><code class="rust" >    use std::fmt;
    use std::io;
    fn function1() -&gt; fmt::Result {
        // --snip--
    }

    fn function2() -&gt; io::Result&lt;()&gt; {
        // --snip--
    }
</code></pre>
</div></li>

<li><p>
Променити име у текућем опсегу употребом кључне речи <code>as</code>.
</p>
<div class="org-src-container">

<pre><code class="rust" >    use std::fmt::Result;
    use std::io::Result as IoResult;
    fn function1() -&gt; Result {
        // --snip--
    }

    fn function2() -&gt; IoResult&lt;()&gt; {
        // --snip--
    }
</code></pre>
</div></li>

</ul>
</section>
<section id="slide-13-19">
<h3 id="13-19"><span class="section-number-3">13.19.</span> Реекспорт имена са <code>pub use</code></h3>
<ul>
<li>Када уведемо име у опсег са <code>use</code> он је приватан за приступ споља.</li>
<li>Уколико желимо да буде јаван споља можемо користити <code>pub use</code>.</li>

</ul>

<div class="org-src-container">

<pre><code class="rust" >mod front_of_house {
    pub mod hosting {
        pub fn add_to_waitlist() {}
    }
}

pub use crate::front_of_house::hosting;

pub fn eat_at_restaurant() {
    hosting::add_to_waitlist();
}
</code></pre>
</div>

<ul>
<li>Ово се често користи када јавни API библиотеке треба да буде различит од
интерне организације кода.</li>

</ul>
</section>
<section id="slide-13-20">
<h3 id="13-20"><span class="section-number-3">13.20.</span> Употреба екстерних пакета</h3>
<p>
Фајл <code>Cargo.toml</code>:
</p>
<div class="org-src-container">

<pre><code class="rust" >...
[dependencies]
rand = "0.8.5"
...
</code></pre>
</div>

<p>
И затим можемо увести елементе из <code>rand</code> сандука са:
</p>
<div class="org-src-container">

<pre><code class="rust" >use rand::Rng;

fn main() {
    let secret_number = rand::thread_rng().gen_range(1..=100);
}
</code></pre>
</div>

</section>
<section>

<p>
Пакети се подразумевано преузимају са <code>crates.io</code>. <code>std</code> библиотека је сандук, увек
је локално присутан, није потребно посебно га наводити у конфигурацији али је
елементе које користимо потребно увести.
</p>

<div class="org-src-container">

<pre><code class="rust" >use std::collections::HashMap;
</code></pre>
</div>
</section>
<section id="slide-13-21">
<h3 id="13-21"><span class="section-number-3">13.21.</span> Угњеждене путање при увођењу</h3>
<ul>
<li>Ако уводимо више елемената из истог модула можемо користити скраћени угњеждени
запис.</li>

<li><p>
На пример:
</p>
<div class="org-src-container">

<pre><code class="rust" >    // --snip--
    use std::cmp::Ordering;
    use std::io;
    // --snip--
</code></pre>
</div></li>

<li><p>
Можемо писати као:
</p>
<div class="org-src-container">

<pre><code class="rust" >    // --snip--
    use std::{cmp::Ordering, io};
    // --snip--
</code></pre>
</div></li>

</ul>

</section>
<section>

<ul>
<li><p>
Moжемо истовремено увести и модул и неке од његових елемената. На пример,
уместо:
</p>
<div class="org-src-container">

<pre><code class="rust" >    use std::io;
    use std::io::Write;
</code></pre>
</div></li>
<li><p>
Можемо писати:
</p>
<div class="org-src-container">

<pre><code class="rust" >    use std::io::{self, Write};
</code></pre>
</div></li>

</ul>
</section>
<section id="slide-13-22">
<h3 id="13-22"><span class="section-number-3">13.22.</span> <i>Glob</i> оператор</h3>
<ul>
<li><p>
Ако желимо да уведемо све елементе неког модула можемо писати:
</p>
<div class="org-src-container">

<pre><code class="rust" >    use std::collections::*;
</code></pre>
</div></li>

</ul>
</section>
<section id="slide-13-23">
<h3 id="13-23"><span class="section-number-3">13.23.</span> Подела модула у посебне фајлове</h3>
<p>
Модуле често пишемо у посебним фајловима због лакшег приступа и организације.
</p>

<p>
Фајл <code>src/lib.rs</code>:
</p>
<div class="org-src-container">

<pre><code class="rust" >pub mod front_of_house;    // &lt;- наводимо име фајла модула

pub use crate::front_of_house::hosting;

pub fn eat_at_restaurant() {
    hosting::add_to_waitlist();
}
</code></pre>
</div>

<p>
А затим у фајлу <code>src/front_of_house.rs</code>
</p>
<div class="org-src-container">

<pre><code class="rust" >pub mod hosting {
    pub fn add_to_waitlist() {}
}
</code></pre>
</div>

</section>
<section>

<p>
А можемо даље декомпоновати и извући модул <code>hosting</code> из фајла <code>front_of_house.rs</code>:
</p>

<p>
Фајл <code>src/front_of_house.rs</code>:
</p>
<div class="org-src-container">

<pre><code class="rust" >pub mod hosting;
</code></pre>
</div>

<p>
Фајл <code>src/front_of_house/hosting.rs</code>:
</p>
<div class="org-src-container">

<pre><code class="rust" >pub fn add_to_waitlist() {}
</code></pre>
</div>

<div class="note" id="org10786b4">
<p>
<code>mod</code> је потребно навести само једном. Тиме се модул увезује у стабло модула и
могуће га је референцирати путањама из остатка кода. Односно, <code>mod</code> није исто што
и <code>include</code> из других програмских језика.
</p>

</div>
</section>
</section>
<section>
<section id="slide-14">
<h2 id="14"><span class="section-number-2">14.</span> Тестирање</h2>
<div class="outline-text-2" id="text-14">
</div>
</section>
<section id="slide-14-1">
<h3 id="14-1"><span class="section-number-3">14.1.</span> Тестирање</h3>
<blockquote>
<p>
Program testing can be a very effective way to show the presence of bugs, but it
is hopelessly inadequate for showing their absence.
</p>

<p>
&#x2013; Edsger W. Dijkstra, “The Humble Programmer”, 1972
</p>
</blockquote>

</section>
<section>

<ul>
<li>Раст систем типова и провера позајмица спречава појаву шире класе логичких
грешака али не може да предупреди појаву свих грешака. На пример, Раст не може
да провери да ће одређан функција да ради тачно оно што је програмер замислио.</li>
<li>Одређена класа логичких грешака захтева креирање тестова.</li>

</ul>
</section>
<section id="slide-14-2">
<h3 id="14-2"><span class="section-number-3">14.2.</span> Како писати тестове?</h3>
<ol>
<li>Поставити потребно стање и податке.</li>
<li>Извршити код који се тестира са датим улазима.</li>
<li>Потврдити да је резултат извршавања очекиван.</li>

</ol>
</section>
<section id="slide-14-3">
<h3 id="14-3"><span class="section-number-3">14.3.</span> Анатомија тест функције</h3>
<div class="org-src-container">

<pre><code class="rust" >$ cargo new adder --lib
     Created library `adder` project
$ cd adder
</code></pre>
</div>

<p>
Генерисан тест ће бити:
</p>

<p>
Фајл <code>src/lib.rs</code>:
</p>
<div class="org-src-container">

<pre><code class="rust" >#[cfg(test)]
mod tests {
    #[test]
    fn it_works() {
        let result = 2 + 2;
        assert_eq!(result, 4);
    }
}
</code></pre>
</div>
</section>
<section id="slide-14-4">
<h3 id="14-4"><span class="section-number-3">14.4.</span> Покретање теста</h3>
<div class="org-src-container">

<pre><code class="sh" >$ cargo test
   Compiling adder v0.1.0 (file:///projects/adder)
    Finished test [unoptimized + debuginfo] target(s) in 0.57s
     Running unittests src/lib.rs (target/debug/deps/adder-92948b65e88960b4)

running 1 test
test tests::it_works ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

   Doc-tests adder

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s
</code></pre>
</div>
</section>
<section id="slide-14-5">
<h3 id="14-5"><span class="section-number-3">14.5.</span> Пример теста 1</h3>
<div class="org-src-container">

<pre><code class="rust" >#[derive(Debug)]
struct Rectangle {
    width: u32,
    height: u32,
}

impl Rectangle {
    fn can_hold(&amp;self, other: &amp;Rectangle) -&gt; bool {
        self.width &gt; other.width &amp;&amp; self.height &gt; other.height
    }
}
</code></pre>
</div>

</section>
<section>

<div class="org-src-container">

<pre><code class="rust" >#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn larger_can_hold_smaller() {
        let larger = Rectangle {
            width: 8,
            height: 7,
        };
        let smaller = Rectangle {
            width: 5,
            height: 1,
        };

        assert!(larger.can_hold(&amp;smaller));
    }
}
</code></pre>
</div>

</section>
<section>

<div class="org-src-container">

<pre><code class="sh" >$ cargo test
   Compiling rectangle v0.1.0 (file:///projects/rectangle)
    Finished test [unoptimized + debuginfo] target(s) in 0.66s
     Running unittests src/lib.rs (target/debug/deps/rectangle-6584c4561e48942e)

running 1 test
test tests::larger_can_hold_smaller ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

   Doc-tests rectangle

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s
</code></pre>
</div>
</section>
<section id="slide-14-6">
<h3 id="14-6"><span class="section-number-3">14.6.</span> Пример теста 2</h3>
<div class="org-src-container">

<pre><code class="rust" >#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn larger_can_hold_smaller() {
        // --snip--
    }

    #[test]
    fn smaller_cannot_hold_larger() {
        let larger = Rectangle {
            width: 8,
            height: 7,
        };
        let smaller = Rectangle {
            width: 5,
            height: 1,
        };

        assert!(!smaller.can_hold(&amp;larger));
    }
}
</code></pre>
</div>

</section>
<section>

<div class="org-src-container">

<pre><code class="sh" >$ cargo test
   Compiling rectangle v0.1.0 (file:///projects/rectangle)
    Finished test [unoptimized + debuginfo] target(s) in 0.66s
     Running unittests src/lib.rs (target/debug/deps/rectangle-6584c4561e48942e)

running 2 tests
test tests::larger_can_hold_smaller ... ok
test tests::smaller_cannot_hold_larger ... ok

test result: ok. 2 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

   Doc-tests rectangle

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s
</code></pre>
</div>
</section>
<section id="slide-14-7">
<h3 id="14-7"><span class="section-number-3">14.7.</span> Неуспешан тест</h3>
<ul>
<li>Намерно уводимо грешку у код да видимо како излгеда када тест не успева:</li>

</ul>
<div class="org-src-container">

<pre><code class="rust" >// --snip--
impl Rectangle {
    fn can_hold(&amp;self, other: &amp;Rectangle) -&gt; bool {
        self.width &lt; other.width &amp;&amp; self.height &gt; other.height
    }
}
</code></pre>
</div>

</section>
<section>

<div class="org-src-container">

<pre><code class="sh" >$ cargo test
   Compiling rectangle v0.1.0 (file:///projects/rectangle)
    Finished test [unoptimized + debuginfo] target(s) in 0.66s
     Running unittests src/lib.rs (target/debug/deps/rectangle-6584c4561e48942e)

running 2 tests
test tests::larger_can_hold_smaller ... FAILED
test tests::smaller_cannot_hold_larger ... ok

failures:

---- tests::larger_can_hold_smaller stdout ----
thread 'tests::larger_can_hold_smaller' panicked at 'assertion failed: larger.can_hold(&amp;smaller)', src/lib.rs:28:9
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

failures:
    tests::larger_can_hold_smaller

test result: FAILED. 1 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

error: test failed, to rerun pass `--lib`
</code></pre>
</div>
</section>
<section id="slide-14-8">
<h3 id="14-8"><span class="section-number-3">14.8.</span> Тестирање једнакости и неједнакости - <code>assert_eq!</code> и <code>assert_ne!</code></h3>
<div class="org-src-container">

<pre><code class="rust" >pub fn add_two(a: i32) -&gt; i32 {
    a + 2
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn it_adds_two() {
        assert_eq!(4, add_two(2));
    }
}
</code></pre>
</div>

</section>
<section>

<div class="org-src-container">

<pre><code class="sh" >$ cargo test
   Compiling adder v0.1.0 (file:///projects/adder)
    Finished test [unoptimized + debuginfo] target(s) in 0.58s
     Running unittests src/lib.rs (target/debug/deps/adder-92948b65e88960b4)

running 1 test
test tests::it_adds_two ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

   Doc-tests adder

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s
</code></pre>
</div>

</section>
<section>

<p>
Уколико тест не успе:
</p>

<div class="org-src-container">

<pre><code class="rust" >pub fn add_two(a: i32) -&gt; i32 {
    a + 3
}
</code></pre>
</div>

</section>
<section>

<div class="org-src-container">

<pre><code class="sh" >$ cargo test
   Compiling adder v0.1.0 (file:///projects/adder)
    Finished test [unoptimized + debuginfo] target(s) in 0.61s
     Running unittests src/lib.rs (target/debug/deps/adder-92948b65e88960b4)

running 1 test
test tests::it_adds_two ... FAILED

failures:

---- tests::it_adds_two stdout ----
thread 'tests::it_adds_two' panicked at 'assertion failed: `(left == right)`
  left: `4`,
 right: `5`', src/lib.rs:11:9
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace


failures:
    tests::it_adds_two

test result: FAILED. 0 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

error: test failed, to rerun pass `--lib`
</code></pre>
</div>
</section>
<section id="slide-14-9">
<h3 id="14-9"><span class="section-number-3">14.9.</span> Произвољна корисничка порука</h3>
<div class="org-src-container">

<pre><code class="rust" >#[test]
    fn greeting_contains_name() {
        let result = greeting("Carol");
        assert!(
            result.contains("Carol"),
            "Greeting did not contain name, value was `{}`",
            result
        );
    }

</code></pre>
</div>

</section>
<section>

<div class="org-src-container">

<pre><code class="sh" >$ cargo test
   Compiling greeter v0.1.0 (file:///projects/greeter)
    Finished test [unoptimized + debuginfo] target(s) in 0.93s
     Running unittests src/lib.rs (target/debug/deps/greeter-170b942eb5bf5e3a)

running 1 test
test tests::greeting_contains_name ... FAILED

failures:

---- tests::greeting_contains_name stdout ----
thread 'tests::greeting_contains_name'
panicked at 'Greeting did not contain name, value was `Hello!`', src/lib.rs:12:9
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace


failures:
    tests::greeting_contains_name

test result: FAILED. 0 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out;
finished in 0.00s

error: test failed, to rerun pass `--lib`
</code></pre>
</div>
</section>
<section id="slide-14-10">
<h3 id="14-10"><span class="section-number-3">14.10.</span> Провера <code>should_panic</code></h3>
<div class="org-src-container">

<pre><code class="rust" >pub struct Guess {
    value: i32,
}

impl Guess {
    pub fn new(value: i32) -&gt; Guess {
        if value &lt; 1 || value &gt; 100 {
            panic!("Guess value must be between 1 and 100, got {}.", value);
        }

        Guess { value }
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    #[should_panic]
    fn greater_than_100() {
        Guess::new(200);
    }
}
</code></pre>
</div>

</section>
<section>

<div class="org-src-container">

<pre><code class="rust" >impl Guess {
    pub fn new(value: i32) -&gt; Guess {
        if value &lt; 1 {
            panic!(
                "Guess value must be greater than or equal to 1, got {}.",
                value
            );
        } else if value &gt; 100 {
            panic!(
                "Guess value must be less than or equal to 100, got {}.",
                value
            );
        }
        Guess { value }
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    #[test]
    #[should_panic(expected = "less than or equal to 100")]
    fn greater_than_100() {
        Guess::new(200);
    }
}
</code></pre>
</div>
</section>
<section id="slide-14-11">
<h3 id="14-11"><span class="section-number-3">14.11.</span> Филтрирање тестова при покретању</h3>
<div class="org-src-container">

<pre><code class="rust" >pub fn add_two(a: i32) -&gt; i32 {
    a + 2
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn add_two_and_two() {
        assert_eq!(4, add_two(2));
    }

    #[test]
    fn add_three_and_two() {
        assert_eq!(5, add_two(3));
    }

    #[test]
    fn one_hundred() {
        assert_eq!(102, add_two(100));
    }
}
</code></pre>
</div>

</section>
<section>

<div class="org-src-container">

<pre><code class="sh" >$ cargo test one_hundred
   Compiling adder v0.1.0 (file:///projects/adder)
    Finished test [unoptimized + debuginfo] target(s) in 0.69s
     Running unittests src/lib.rs (target/debug/deps/adder-92948b65e88960b4)

running 1 test
test tests::one_hundred ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 2 filtered out; finished in 0.00s
</code></pre>
</div>

</section>
<section>

<div class="org-src-container">

<pre><code class="sh" >$ cargo test add
   Compiling adder v0.1.0 (file:///projects/adder)
    Finished test [unoptimized + debuginfo] target(s) in 0.61s
     Running unittests src/lib.rs (target/debug/deps/adder-92948b65e88960b4)

running 2 tests
test tests::add_three_and_two ... ok
test tests::add_two_and_two ... ok

test result: ok. 2 passed; 0 failed; 0 ignored; 0 measured; 1 filtered out; finished in 0.00s
</code></pre>
</div>
</section>
</section>
<section>
<section id="slide-15">
<h2 id="15"><span class="section-number-2">15.</span> Генерички типови, особине (<i>Traits</i>) и животни век (<i>Lifetimes</i>)</h2>
<div class="outline-text-2" id="text-15">
</div>
</section>
<section id="slide-15-1">
<h3 id="15-1"><span class="section-number-3">15.1.</span> Генерички типови (<i>generics</i>)</h3>
<div class="outline-text-3" id="text-15-1">
</div>
</section>
<section id="slide-15-1-1">
<h4 id="15-1-1"><span class="section-number-4">15.1.1.</span> Генерички типови (<i>generics</i>)</h4>
<ul>
<li>Механизам за елиминацију дуплирања кода.</li>
<li>Генерички типови су апстрактне замене за конкретне типове у друге особине у
време извршавања.</li>
<li>Омогућавају нам да на апстрактан начин искажемо особине типова и њихове везе
са другим типовима без знања о томе који ће се конкретни типови наћи на
њиховом месту у време компајлирања и извршавања кода.</li>
<li>На пример функције могу примити генеричке параметре. Такође, сложени типови
могу бити параметризовани генеричким типовима (пример је <code>Option&lt;T&gt;</code>).</li>

</ul>
</section>
<section id="slide-15-1-2">
<h4 id="15-1-2"><span class="section-number-4">15.1.2.</span> Уклањање дуплог кода употребом функција</h4>
<div class="org-src-container">

<pre><code class="rust" >fn main() {
    let number_list = vec![34, 50, 25, 100, 65];

    let mut largest = number_list[0];

    for number in number_list {
        if number &gt; largest {
            largest = number;
        }
    }

    println!("The largest number is {}", largest);
}
</code></pre>
</div>

</section>
<section>

<div class="org-src-container">

<pre><code class="rust" >fn main() {
    let number_list = vec![34, 50, 25, 100, 65];

    let mut largest = number_list[0];

    for number in number_list {
        if number &gt; largest {
            largest = number;
        }
    }

    println!("The largest number is {}", largest);

    let number_list = vec![102, 34, 6000, 89, 54, 2, 43, 8];

    let mut largest = number_list[0];

    for number in number_list {
        if number &gt; largest {
            largest = number;
        }
    }

    println!("The largest number is {}", largest);
}
</code></pre>
</div>

<p>
Дуплирање кода!
</p>

</section>
<section>

<p>
Елиминишемо дуплирање увођењем функције.
</p>

<div class="org-src-container">

<pre><code class="rust" >fn largest(list: &amp;[i32]) -&gt; i32 {
    let mut largest = list[0];

    for &amp;item in list {
        if item &gt; largest {
            largest = item;
        }
    }

    largest
}

fn main() {
    let number_list = vec![34, 50, 25, 100, 65];

    let result = largest(&amp;number_list);
    println!("The largest number is {}", result);

    let number_list = vec![102, 34, 6000, 89, 54, 2, 43, 8];

    let result = largest(&amp;number_list);
    println!("The largest number is {}", result);
}
</code></pre>
</div>


</section>
<section>

<p>
Поступак елиминације дуплог кода је подразумевао следеће:
</p>

<ol>
<li>Идентификација дуплог кода.</li>
<li>Екстракција кода у функцију, дефинисање параметара и повратне вредности.</li>
<li>Замена инстанци дуплог кода са позивом функције.</li>

</ol>
</section>
<section id="slide-15-1-3">
<h4 id="15-1-3"><span class="section-number-4">15.1.3.</span> Уклањање дуплог кода употребом генеричких функција</h4>
<p>
Имамо функцију за проналажење највећег елемента у листи са различитим типовима.
</p>
<div class="org-src-container">

<pre><code class="rust" >fn largest_i32(list: &amp;[i32]) -&gt; i32 {
    let mut largest = list[0];
    for &amp;item in list {
        if item &gt; largest {
            largest = item;
        }
    }
    largest
}
fn largest_char(list: &amp;[char]) -&gt; char {
    let mut largest = list[0];
    for &amp;item in list {
        if item &gt; largest {
            largest = item;
        }
    }
    largest
}
fn main() {
    let number_list = vec![34, 50, 25, 100, 65];
    let result = largest_i32(&amp;number_list);
    println!("The largest number is {}", result);
    let char_list = vec!['y', 'm', 'a', 'q'];
    let result = largest_char(&amp;char_list);
    println!("The largest char is {}", result);
}
</code></pre>
</div>

</section>
<section>

<p>
Функције су готово идентичне. Разлика је само у типу. Пишемо генеричку функцију
тако што дефинишемо генерички тип унутар <code>&lt;&gt;</code> после назива функције:
</p>

<div class="org-src-container">

<pre><code class="rust" >fn largest&lt;T&gt;(list: &amp;[T]) -&gt; T {
</code></pre>
</div>

<p>
<code>T</code> је генерички тип и у време компајлирања биће замењен са конкретним типом.
</p>

</section>
<section>

<p>
Сада је наш код следећи:
</p>

<div class="org-src-container">

<pre><code class="rust" >fn largest&lt;T&gt;(list: &amp;[T]) -&gt; T {
    let mut largest = list[0];

    for &amp;item in list {
        if item &gt; largest {
            largest = item;
        }
    }

    largest
}

fn main() {
    let number_list = vec![34, 50, 25, 100, 65];

    let result = largest(&amp;number_list);
    println!("The largest number is {}", result);

    let char_list = vec!['y', 'm', 'a', 'q'];

    let result = largest(&amp;char_list);
    println!("The largest char is {}", result);
}
</code></pre>
</div>

</section>
<section>

<p>
Али се не компајлира.
</p>

<div class="org-src-container">

<pre><code class="rust" >$ cargo run
   Compiling chapter10 v0.1.0 (file:///projects/chapter10)
error[E0369]: binary operation `&gt;` cannot be applied to type `T`
 --&gt; src/main.rs:5:17
  |
5 |         if item &gt; largest {
  |            ---- ^ ------- T
  |            |
  |            T
  |
help: consider restricting type parameter `T`
  |
1 | fn largest&lt;T: std::cmp::PartialOrd&gt;(list: &amp;[T]) -&gt; T {
  |             ++++++++++++++++++++++

For more information about this error, try `rustc --explain E0369`.
error: could not compile `chapter10` due to previous error
</code></pre>
</div>

<p>
Тип <code>T</code> може бити било који тип па и тип који не дефинише операцију <code>&gt;</code> која се
користи у коду. Дакле, морамо ограничити који типови су могући.
</p>

<p>
Видећемо како се ово ради у наставку у причи о особинама (<i>Traits</i>).
</p>
</section>
<section id="slide-15-1-4">
<h4 id="15-1-4"><span class="section-number-4">15.1.4.</span> Генерички типови у структурама</h4>
<div class="org-src-container">

<pre><code class="rust" >struct Point&lt;T&gt; {
    x: T,
    y: T,
}

fn main() {
    let integer = Point { x: 5, y: 10 };
    let float = Point { x: 1.0, y: 4.0 };
}
</code></pre>
</div>

</section>
<section>

<p>
Типови оба поља морају бити исти.
</p>

<div class="org-src-container">

<pre><code class="rust" >struct Point&lt;T&gt; {
    x: T,
    y: T,
}

fn main() {
    let wont_work = Point { x: 5, y: 4.0 };
}
</code></pre>
</div>

<pre class="example" id="org6e42472">
$ cargo run
   Compiling chapter10 v0.1.0 (file:///projects/chapter10)
error[E0308]: mismatched types
 --&gt; src/main.rs:7:38
  |
7 |     let wont_work = Point { x: 5, y: 4.0 };
  |                                      ^^^ expected integer, found floating-point number

For more information about this error, try `rustc --explain E0308`.
error: could not compile `chapter10` due to previous error
</pre>

</section>
<section>

<p>
Ако желимо да поља имају различите типове онда морамо имати различите генеричке типове.
</p>

<div class="org-src-container">

<pre><code class="rust" >struct Point&lt;T, U&gt; {
    x: T,
    y: U,
}

fn main() {
    let both_integer = Point { x: 5, y: 10 };
    let both_float = Point { x: 1.0, y: 4.0 };
    let integer_and_float = Point { x: 5, y: 4.0 };
}
</code></pre>
</div>
</section>
<section id="slide-15-1-5">
<h4 id="15-1-5"><span class="section-number-4">15.1.5.</span> Генерички типови у енумерацијама</h4>
<div class="org-src-container">

<pre><code class="rust" >enum Option&lt;T&gt; {
    Some(T),
    None,
}
</code></pre>
</div>

</section>
<section>

<div class="org-src-container">

<pre><code class="rust" >enum Result&lt;T, E&gt; {
    Ok(T),
    Err(E),
}
</code></pre>
</div>
</section>
<section id="slide-15-1-6">
<h4 id="15-1-6"><span class="section-number-4">15.1.6.</span> Дефиниције метода</h4>
<div class="org-src-container">

<pre><code class="rust" >struct Point&lt;T&gt; {
    x: T,
    y: T,
}

impl&lt;T&gt; Point&lt;T&gt; {
    fn x(&amp;self) -&gt; &amp;T {
        &amp;self.x
    }
}

fn main() {
    let p = Point { x: 5, y: 10 };

    println!("p.x = {}", p.x());
}
</code></pre>
</div>

<p>
Пошто смо навели <code>&lt;T&gt;</code> иза кључне речи <code>impl</code> Раст даље зна да је тип <code>T</code> генерички
а не конкретни тип тако да је метода <code>x</code> за <code>Point&lt;T&gt;</code> дефинисана над свим типовима
<code>T</code>.
</p>

</section>
<section>

<p>
Могли смо нпр. методу дефинисати само за одређени <code>Point</code> тип.
</p>

<div class="org-src-container">

<pre><code class="rust" >impl Point&lt;f32&gt; {
    fn distance_from_origin(&amp;self) -&gt; f32 {
        (self.x.powi(2) + self.y.powi(2)).sqrt()
    }
}
</code></pre>
</div>

<p>
Овај <code>impl</code> блок дефинише методу <code>distance_from_origin</code> али само за <code>Point&lt;f32&gt;</code> док
остали <code>Point</code> типови неће имати ову методу.
</p>
</section>
<section id="slide-15-1-7">
<h4 id="15-1-7"><span class="section-number-4">15.1.7.</span> Генерички типови у методама и <code>impl</code> блоковима</h4>
<p>
Генерички типови у структурама и методама не морају бити исти. На пример, можемо
креирати методу <code>mixup</code> која узима две инстанце <code>Point</code> и враћа нови <code>Point</code> тип где
ће прво поље имати исти тип као прва тачка а друго поље као друга тачка.
</p>

<div class="org-src-container">

<pre><code class="rust" >struct Point&lt;X1, Y1&gt; {
    x: X1,
    y: Y1,
}

impl&lt;X1, Y1&gt; Point&lt;X1, Y1&gt; {
    fn mixup&lt;X2, Y2&gt;(self, other: Point&lt;X2, Y2&gt;) -&gt; Point&lt;X1, Y2&gt; {
        Point {
            x: self.x,
            y: other.y,
        }
    }
}

fn main() {
    let p1 = Point { x: 5, y: 10.4 };
    let p2 = Point { x: "Hello", y: 'c' };
    let p3 = p1.mixup(p2);
    println!("p3.x = {}, p3.y = {}", p3.x, p3.y);
}
</code></pre>
</div>

<ul>
<li>Генерички типови <code>X2</code> и <code>Y2</code> су наведени само у методи јер су релевантни само у
њеном контексту.</li>

</ul>
</section>
<section id="slide-15-1-8">
<h4 id="15-1-8"><span class="section-number-4">15.1.8.</span> Перформансе</h4>
<p>
Употреба генеричког кода не доводи до деградације перформанси. Раст користи
технику мономорфизације (<i>Monomorphization</i>) код које ће компајлер инстанцирати
конкретан код за сваки тип посебно.
</p>

<p>
То би значило следеће. Ако имамо код:
</p>

<div class="org-src-container">

<pre><code class="rust" >let integer = Some(5);
let float = Some(5.0)
</code></pre>
</div>

<p>
Компајлер ће произвести код еквивалентан следећем:
</p>
<div class="org-src-container">

<pre><code class="rust" >enum Option_i32 {
    Some(i32),
    None,
}

enum Option_f64 {
    Some(f64),
    None,
}

fn main() {
    let integer = Option_i32::Some(5);
    let float = Option_f64::Some(5.0);
}
</code></pre>
</div>
</section>
<section id="slide-15-2">
<h3 id="15-2"><span class="section-number-3">15.2.</span> Особине (<i>Traits</i>) - дефинисање заједничког понашања</h3>
<div class="outline-text-3" id="text-15-2">
</div>
</section>
<section id="slide-15-2-1">
<h4 id="15-2-1"><span class="section-number-4">15.2.1.</span> Особине (<i>Traits</i>)</h4>
<ul>
<li>Особина дефинише функционалност коју тип може делити са другим типовима.</li>
<li>У другим језицима сличан концепт назива се интерфејс.</li>
<li>Можемо користити <i>ограничења кроз особине</i> (<i>Trait bounds</i>) да дефинишемо да
генерички тип мора задовољити одређена ограничења.</li>

</ul>
</section>
<section id="slide-15-2-2">
<h4 id="15-2-2"><span class="section-number-4">15.2.2.</span> Дефинисање особина</h4>
<ul>
<li>Пример дефинисања <i>media aggregator</i> библиотеке која може да приказе сажетак
података који се може чувати у <code>NewsArticle</code> или <code>Tweet</code> инстанци.</li>
<li>Дефинишемо <code>Summary</code> особину да опишемо ову функционалност.</li>

</ul>

<div class="org-src-container">

<pre><code class="rust" >pub trait Summary {
    fn summarize(&amp;self) -&gt; String;
}
</code></pre>
</div>
</section>
<section id="slide-15-2-3">
<h4 id="15-2-3"><span class="section-number-4">15.2.3.</span> Имплементација особина</h4>
<div class="org-src-container">

<pre><code class="rust" >pub struct NewsArticle {
    pub headline: String,
    pub location: String,
    pub author: String,
    pub content: String,
}

impl Summary for NewsArticle {
    fn summarize(&amp;self) -&gt; String {
        format!("{}, by {} ({})", self.headline, self.author, self.location)
    }
}

pub struct Tweet {
    pub username: String,
    pub content: String,
    pub reply: bool,
    pub retweet: bool,
}

impl Summary for Tweet {
    fn summarize(&amp;self) -&gt; String {
        format!("{}: {}", self.username, self.content)
    }
}
</code></pre>
</div>

</section>
<section>

<p>
Методе особина се позивају као и обичне методе. Једина разлика је у томе што
методе особина морају бити доступне у опсегу (укључити их са <code>use</code>).
</p>

<div class="org-src-container">

<pre><code class="rust" >use aggregator::{Summary, Tweet};

fn main() {
    let tweet = Tweet {
        username: String::from("horse_ebooks"),
        content: String::from(
            "of course, as you probably already know, people",
        ),
        reply: false,
        retweet: false,
    };

    println!("1 new tweet: {}", tweet.summarize());
}
</code></pre>
</div>

</section>
<section>

<div class="note" id="org8716834">
<p>
Ограничење у употреби особина је да можемо имплементирати особину над типом
једино ако је бар једно од њих локално за наш сандук. Ово правило је део скупа
правила који се називају <i>coherence</i>. Конкретно ово правило зове се <i>orphan rule</i> и
спречава некомпатибилне имплементације особина над типовима од стране више
сандука.
</p>

<p>
Без овог правила могло би се десити да два различита сандука имплементирају исту
особину над истим типом на различите начине и компајлер не би знао коју верзију
да користи.
</p>

</div>
</section>
<section id="slide-15-2-4">
<h4 id="15-2-4"><span class="section-number-4">15.2.4.</span> Подразумевана имплементација</h4>
<p>
Особина може имати подразумевану имплементацију метода.
</p>

<div class="org-src-container">

<pre><code class="rust" >pub trait Summary {
    fn summarize(&amp;self) -&gt; String {
        String::from("(Read more...)")
    }
}
</code></pre>
</div>

<p>
Да би користили подразумевану имплементацију можемо навести празно тело у <code>impl</code>
блоку:
</p>

<div class="org-src-container">

<pre><code class="rust" >impl Summary for NewsArticle {}
</code></pre>
</div>

</section>
<section>

<p>
И затим можемо позвати <code>summarize</code> методу:
</p>

<div class="org-src-container">

<pre><code class="rust" >let article = NewsArticle {
        headline: String::from("Penguins win the Stanley Cup Championship!"),
        location: String::from("Pittsburgh, PA, USA"),
        author: String::from("Iceburgh"),
        content: String::from(
            "The Pittsburgh Penguins once again are the best \
             hockey team in the NHL.",
        ),
    };

    println!("New article available! {}", article.summarize());
</code></pre>
</div>

</section>
<section>

<ul>
<li>Подразумевана имплементација може бити редефинисана приликом имплементације.</li>
<li>Такође, подразумеване методе могу позивати друге методе.</li>

</ul>

<div class="org-src-container">

<pre><code class="rust" >pub trait Summary {
    fn summarize_author(&amp;self) -&gt; String;

    fn summarize(&amp;self) -&gt; String {
        format!("(Read more from {}...)", self.summarize_author())
    }
}
</code></pre>
</div>

<p>
Сада је потребно и довољно да приликом имплементације дефинишемо
<code>summarize_author</code> методу:
</p>

<div class="org-src-container">

<pre><code class="rust" >impl Summary for Tweet {
    fn summarize_author(&amp;self) -&gt; String {
        format!("@{}", self.username)
    }
}
</code></pre>
</div>
</section>
<section id="slide-15-2-5">
<h4 id="15-2-5"><span class="section-number-4">15.2.5.</span> Особине као параметри</h4>
<ul>
<li>Сада можемо користити особине да дефинишемо функције које раде над параметрима
различитог типа.</li>

</ul>

<div class="org-src-container">

<pre><code class="rust" >pub fn notify(item: &amp;impl Summary) {
    println!("Breaking news! {}", item.summarize());
}
</code></pre>
</div>

<p>
Функција <code>notify</code> ради над свим типовима који имплементирају <code>Summary</code>.
</p>

</section>
<section>

<p>
Претходна употреба <code>impl</code> код параметра је синтаксни шећер за општи облик
навођења ограничења кроз особине.
</p>

<div class="org-src-container">

<pre><code class="rust" >pub fn notify&lt;T: Summary&gt;(item: &amp;T) {
    println!("Breaking news! {}", item.summarize());
}
</code></pre>
</div>

<p>
Ограничења кроз особине (<i>Trait bounds</i>) стављамо после двотачке код навођења
генеричког типа. Компајлер ће верификовати да све што користимо над вредностима
овог типа унутар функције је заиста дефинисано особинама наведеним у заглављу.
</p>

</section>
<section>

<p>
<code>impl Trait</code> синтаксе је концизнија код једноставних примера али је пуна синтакса
боља код сложенијих примера.
</p>

<p>
На пример:
</p>

<div class="org-src-container">

<pre><code class="rust" >pub fn notify(item1: &amp;impl Summary, item2: &amp;impl Summary) {
</code></pre>
</div>

<p>
би у пуној синтакси било:
</p>

<div class="org-src-container">

<pre><code class="rust" >pub fn notify&lt;T: Summary&gt;(item1: &amp;T, item2: &amp;T) {
</code></pre>
</div>
</section>
<section id="slide-15-2-6">
<h4 id="15-2-6"><span class="section-number-4">15.2.6.</span> Вишеструке особине код ограничења</h4>
<p>
Можемо дефинисати и више ограничења употребом <code>+</code> синтаксе. На пример, ако
параметар мора да имплементира <code>Summary</code> и <code>Display</code>:
</p>
<div class="org-src-container">

<pre><code class="rust" >pub fn notify(item: &amp;(impl Summary + Display)) {
</code></pre>
</div>

<p>
или у пуној синтакси:
</p>

<div class="org-src-container">

<pre><code class="rust" >pub fn notify&lt;T: Summary + Display&gt;(item: &amp;T) {
</code></pre>
</div>
</section>
<section id="slide-15-2-7">
<h4 id="15-2-7"><span class="section-number-4">15.2.7.</span> <code>where</code> клаузула у ограничењима</h4>
<ul>
<li>Уколико имамо више ограничења основна синтакса може да смањи читкост.</li>

</ul>

<div class="org-src-container">

<pre><code class="rust" >fn some_function&lt;T: Display + Clone, U: Clone + Debug&gt;(t: &amp;T, u: &amp;U) -&gt; i32 {
</code></pre>
</div>

<ul>
<li><code>where</code> клаузула измешта дефинисање ограничења после заглавља функције чиме
се постиже боља читкост:</li>

</ul>

<div class="org-src-container">

<pre><code class="rust" >fn some_function&lt;T, U&gt;(t: &amp;T, u: &amp;U) -&gt; i32
    where T: Display + Clone,
          U: Clone + Debug
{
</code></pre>
</div>
</section>
<section id="slide-15-2-8">
<h4 id="15-2-8"><span class="section-number-4">15.2.8.</span> <code>impl Trait</code> као повратна вредност функције</h4>
<div class="org-src-container">

<pre><code class="rust" >fn returns_summarizable() -&gt; impl Summary {
    Tweet {
        username: String::from("horse_ebooks"),
        content: String::from(
            "of course, as you probably already know, people",
        ),
        reply: false,
        retweet: false,
    }
}
</code></pre>
</div>

<p>
Посебно значајно у контексту затворења (<i>closures</i>) и итератора где је конкретан
тип превише сложен за писање или је познат само компајлеру.
</p>

<div class="note" id="org285f516">
<p>
<code>impl Trait</code> синтакса за повратне вредности је могућа само ако функција враћа
један тип који имплементира дату особину. На пример, ова функција неће радити
ако функција може вратити <code>NewsArticle</code> или <code>Tweet</code>.
</p>

</div>
</section>
<section id="slide-15-2-9">
<h4 id="15-2-9"><span class="section-number-4">15.2.9.</span> Поправка <code>largest</code> генеричке функције</h4>
<p>
На претходним сладовима имали смо функцију <code>largest</code>. Сада можемо да завршимо
њену дефиницију.
</p>

<p>
Грешка је била следећа:
</p>
<pre class="example" id="org04c828d">
$ cargo run
   Compiling chapter10 v0.1.0 (file:///projects/chapter10)
error[E0369]: binary operation `&gt;` cannot be applied to type `T`
 --&gt; src/main.rs:5:17
  |
5 |         if item &gt; largest {
  |            ---- ^ ------- T
  |            |
  |            T
  |
help: consider restricting type parameter `T`
  |
1 | fn largest&lt;T: std::cmp::PartialOrd&gt;(list: &amp;[T]) -&gt; T {
  |             ++++++++++++++++++++++

For more information about this error, try `rustc --explain E0369`.
error: could not compile `chapter10` due to previous error
</pre>

</section>
<section>

<p>
Дакле, морамо ограничити типове на оне који подржавају поређење. Ова особина се
у стандардној библиотеци зове <code>std::cmp::PartialOrd</code>, па ћемо преправити заглавље
функције на следећи начин:
</p>

<div class="org-src-container">

<pre><code class="rust" >fn largest&lt;T: PartialOrd&gt;(list: &amp;[T]) -&gt; T {
</code></pre>
</div>

</section>
<section>

<p>
Међутим, сада имамо још једну грешку:
</p>
<pre class="example" id="org9508bc7">
$ cargo run
   Compiling chapter10 v0.1.0 (file:///projects/chapter10)
error[E0508]: cannot move out of type `[T]`, a non-copy slice
 --&gt; src/main.rs:2:23
  |
2 |     let mut largest = list[0];
  |                       ^^^^^^^
  |                       |
  |                       cannot move out of here
  |                       move occurs because `list[_]` has type `T`, which does not implement the `Copy` trait
  |                       help: consider borrowing here: `&amp;list[0]`

error[E0507]: cannot move out of a shared reference
 --&gt; src/main.rs:4:18
  |
4 |     for &amp;item in list {
  |         -----    ^^^^
  |         ||
  |         |data moved here
  |         |move occurs because `item` has type `T`, which does not implement the `Copy` trait
  |         help: consider removing the `&amp;`: `item`

Some errors have detailed explanations: E0507, E0508.
For more information about an error, try `rustc --explain E0507`.
error: could not compile `chapter10` due to 2 previous errors
</pre>

</section>
<section>

<p>
Уводимо додатно ограничење да генерички тип мора бити и <code>Copy</code>. Тако да је пуно
решење следеће:
</p>

<div class="org-src-container">

<pre><code class="rust" >fn largest&lt;T: PartialOrd + Copy&gt;(list: &amp;[T]) -&gt; T {
    let mut largest = list[0];

    for &amp;item in list {
        if item &gt; largest {
            largest = item;
        }
    }

    largest
}

fn main() {
    let number_list = vec![34, 50, 25, 100, 65];

    let result = largest(&amp;number_list);
    println!("The largest number is {}", result);

    let char_list = vec!['y', 'm', 'a', 'q'];

    let result = largest(&amp;char_list);
    println!("The largest char is {}", result);
}
</code></pre>
</div>
</section>
<section id="slide-15-2-10">
<h4 id="15-2-10"><span class="section-number-4">15.2.10.</span> Употреба особина ограничења за условну имплементацију метода</h4>
<p>
Ако желимо да имплементирамо методу само над типовима који имплементирају
одређене особине.
</p>
<div class="org-src-container">

<pre><code class="rust" >use std::fmt::Display;

struct Pair&lt;T&gt; {
    x: T,
    y: T,
}

impl&lt;T&gt; Pair&lt;T&gt; {
    fn new(x: T, y: T) -&gt; Self {
        Self { x, y }
    }
}

impl&lt;T: Display + PartialOrd&gt; Pair&lt;T&gt; {
    fn cmp_display(&amp;self) {
        if self.x &gt;= self.y {
            println!("The largest member is x = {}", self.x);
        } else {
            println!("The largest member is y = {}", self.y);
        }
    }
}
</code></pre>
</div>
</section>
<section id="slide-15-3">
<h3 id="15-3"><span class="section-number-3">15.3.</span> Валидација референци кроз животни век (<i>Lifetimes</i>)</h3>
<div class="outline-text-3" id="text-15-3">
</div>
</section>
<section id="slide-15-3-1">
<h4 id="15-3-1"><span class="section-number-4">15.3.1.</span> Животни век (<i>Lifetime</i>)</h4>
<ul>
<li>Свака референца има животни век, опсег у коме је референца валидна.</li>
<li>У доста ситуација компајлер аутоматски може да закључи који је животни век
референце. Када то није у стању морамо да урадимо ручну анотацију.</li>
<li>Анотацијама животног века доводимо у везу животни век различитих референци.</li>

</ul>
</section>
<section id="slide-15-3-2">
<h4 id="15-3-2"><span class="section-number-4">15.3.2.</span> Спречавање "висећих" референци</h4>
<div class="org-src-container">

<pre><code class="rust" >{
    let r;

    {
        let x = 5;
        r = &amp;x;
    }

    println!("r: {}", r);
}

</code></pre>
</div>

<pre class="example" id="org1a250ed">
 cargo run
   Compiling chapter10 v0.1.0 (file:///projects/chapter10)
error[E0597]: `x` does not live long enough
  --&gt; src/main.rs:7:17
   |
7  |             r = &amp;x;
   |                 ^^ borrowed value does not live long enough
8  |         }
   |         - `x` dropped here while still borrowed
9  |
10 |         println!("r: {}", r);
   |                           - borrow later used here

For more information about this error, try `rustc --explain E0597`.
error: could not compile `chapter10` due to previous error
</pre>
</section>
<section id="slide-15-3-3">
<h4 id="15-3-3"><span class="section-number-4">15.3.3.</span> <i>Borrow Checker</i></h4>
<ul>
<li>Раст компајлер има компоненту <i>borrow checker</i> која проверава да ли су све
позајмице валидне.</li>

</ul>

<div class="org-src-container">

<pre><code class="rust" >{
    let r;                // ---------+-- 'a
                          //          |
    {                     //          |
        let x = 5;        // -+-- 'b  |
        r = &amp;x;           //  |       |
    }                     // -+       |
                          //          |
    println!("r: {}", r); //          |
}                         // ---------+
</code></pre>
</div>

<ul>
<li>Програм је одбачен јер <code>r</code> референцира вредност чији животни век (<code>'b</code>) је краћи
од животног века варијабле <code>r</code> (<code>'a</code>). Уколико би се ово дозволило, <code>r</code> би у једном
делу референцирала невалидну вредност.</li>

</ul>

</section>
<section>

<p>
Варијабле имају животни век који је једнак синтаксном опсегу у коме је
варијабла дефинисана. Животни век имају и референце које позајмљују вредност и
смештају се у варијабле (нпр. <code>r=&amp;x</code> из претходног примера).
</p>

<div class="note" id="orgaf8e5ed">
<p>
Једно од правила је да референца на варијаблу (тј. вредност) не може да живи
дуже од саме варијабле. Односно <i>животни век варијабле мора да садржи животни
век референце позајмљене од те варијабле</i>.
</p>

</div>

<div class="org-src-container">

<pre><code class="rust" >{
    let r;
    {
        let x = 5;
        r = &amp;x;           // -+- &amp;x не може да живи дуже од
    }                     // -+  овог животног века
    println!("r: {}", r);
}
</code></pre>
</div>

</section>
<section>

<p>
Ако сместимо референцу у варијаблу, референца мора бити исправна за цео животни
век варијабле у коју је смештена.
</p>

<div class="note" id="org7bafb36">
<p>
Кажемо да <i>животни век референце мора да садржи животни век варијабле у коју је
смештена</i>.
</p>

</div>

<div class="org-src-container">

<pre><code class="rust" >{
    let r;
    {
        let x = 5;
        r = &amp;x;           // -+- животни век било чега што
    }                     //  |  се смести у r мора да живи
    println!("r: {}", r); // -+  бар оволико
}
</code></pre>
</div>

<p>
Видимо да ово правило није задовољено. <code>&amp;x</code> не живи довољно дуго јер <code>x</code> не живи
довољно дуго.
</p>

</section>
<section>

<p>
Ако претходна два правила објединимо можемо рећи да:
</p>

<div class="note" id="org9441190">
<p>
<i>Животни век варијабле мора да садржи животни век свих варијабли које позајмљују
вредност од посматране варијабле</i>.
</p>

</div>

<p>
Односно, варијабла може отићи из опсега тек када не постоји више ни једна
варијабла која чува позајмљену вредност.
</p>

</section>
<section>

<p>
Следећи код је прихваћен. Референца <code>r</code> не живи дуже од податка који референцира
(<code>x</code>).
</p>

<div class="org-src-container">

<pre><code class="rust" >{
    let x = 5;            // ----------+-- 'b
                          //           |
    let r = &amp;x;           // --+-- 'a  |
                          //   |       |
    println!("r: {}", r); //   |       |
                          // --+       |
}                         // ----------+
</code></pre>
</div>
</section>
<section id="slide-15-3-4">
<h4 id="15-3-4"><span class="section-number-4">15.3.4.</span> Генерички животни векови у функцијама</h4>
<ul>
<li>Креирамо функцију <code>longest</code> која враћа дужи од два прослеђена стринга.
Прослеђујемо референцу на стринг исечак <code>&amp;str</code>.</li>

</ul>

<div class="org-src-container">

<pre><code class="rust" >fn main() {
    let string1 = String::from("abcd");
    let string2 = "xyz";

    let result = longest(string1.as_str(), string2);
    println!("The longest string is {}", result);
}
</code></pre>
</div>

</section>
<section>

<p>
Овај програм није прихваћен.
</p>
<div class="org-src-container">

<pre><code class="rust" >fn longest(x: &amp;str, y: &amp;str) -&gt; &amp;str {
    if x.len() &gt; y.len() {
        x
    } else {
        y
    }
}
</code></pre>
</div>

<pre class="example" id="orgc52899c">
$ cargo run
   Compiling chapter10 v0.1.0 (file:///projects/chapter10)
error[E0106]: missing lifetime specifier
 --&gt; src/main.rs:9:33
  |
9 | fn longest(x: &amp;str, y: &amp;str) -&gt; &amp;str {
  |               ----     ----     ^ expected named lifetime parameter
  |
  = help: this function's return type contains a borrowed value, but the signature does not say
  whether it is borrowed from `x` or `y`
help: consider introducing a named lifetime parameter
  |
9 | fn longest&lt;'a&gt;(x: &amp;'a str, y: &amp;'a str) -&gt; &amp;'a str {
  |           ++++     ++          ++          ++

For more information about this error, try `rustc --explain E0106`.
error: could not compile `chapter10` due to previous error
</pre>

</section>
<section>

<ul>
<li>Зашто програм није прихваћен?</li>
<li><i>Borrow checker</i> није у стању да одреди у којој релацији су референце <code>x</code> и <code>y</code> са
повратном вредношћу која је такође референца.</li>
<li>Тј. повратна вредност мора бити позајмљена однекуд, али компајлер не може да
одреди да ли је позајмљена од <code>x</code> или <code>y</code> или од неке глобалне вредности.</li>
<li>Ова информација је потребна да би се обавила калкулација и провера животног века.</li>

</ul>
</section>
<section id="slide-15-3-5">
<h4 id="15-3-5"><span class="section-number-4">15.3.5.</span> Синтакса за анотацију животног века</h4>
<ul>
<li>Да би помогли компајлеру референце означавамо са животним веком и тиме
доводимо у везу различите референце (нпр. параметре и повратне вредности
функције).</li>
<li>Анотација је облика <code>'a</code>. Иза апострофа се пише име анотације које је најчешће
једно мало слово са почетка алфабета (<code>'a, 'b,...</code>).</li>
<li><b>Важно:</b> анотације животног века не мењају животни век референце већ само
помажу компајлеру у провери.</li>

</ul>

<div class="org-src-container">

<pre><code class="rust" >&amp;i32        // референца
&amp;'a i32     // референца са експлицитним животним веком
&amp;'a mut i32 // промењива референца са експлицитним животним веком
</code></pre>
</div>

<ul>
<li>Једна анотација нема пуно смисла. Функцију имају тек када анотирамо више
референци јер се доводе у везу ако имају исто име.</li>
<li>Уведимо функцију <code>lt</code> која враћа животни век варијабле/вредности и релацију
између животних векова <code>'a≥'b</code> односно <code>'b≤'a</code> која значи да <code>'a</code> обухвата <code>'b</code>
односно <code>'b</code> је садржано у <code>'a</code>.</li>

</ul>
</section>
<section id="slide-15-3-6">
<h4 id="15-3-6"><span class="section-number-4">15.3.6.</span> Анотација животног века у сигнатурама функција</h4>
<ul>
<li>Следећа анотација за функцију <code>longest</code> је исправна јер референца која се враћа
може бити <code>x</code> или <code>y</code> у зависности од дужине стринга. Стога је потребно да имамо
строжији услов да је животни век повратне вредности у вези са животним веком
оба параметра.</li>

</ul>

<div class="org-src-container">

<pre><code class="rust" >fn longest&lt;'a&gt;(x: &amp;'a str, y: &amp;'a str) -&gt; &amp;'a str {
    if x.len() &gt; y.len() {
        x
    } else {
        y
    }
}
</code></pre>
</div>

<ul>
<li>Овим кажемо компајлеру да за неки генерички животни век <code>'a</code>, функција прима две
референце чији животни век вредности обухвата <code>'a</code> и враћа референцу која мора
бити валидна бар колико и животни век <code>'a</code> тј. животни век повратне референце
мора да обухвати <code>'a</code>. Уколико такав животни век постоји код се прихвата.</li>
<li>Сигнатура доводи у везу обе улазне референце са излазном.</li>

</ul>

</section>
<section>

<p>
Посматрајмо код који позива функцију <code>longest</code>:
</p>

<div class="org-src-container">

<pre><code class="rust" >fn main() {
    let string1 = String::from("abcd");
    {
        let string2 = "xyz";
        let result = longest(string1.as_str(), string2);
    }
    println!("The longest string is {}", result);
}
</code></pre>
</div>

<p>
За код мора да постоји <code>'a</code> тако да важи:
</p>

<pre class="example" id="orgfeb72e5">
lt(string1) ≥ 'a     # животни век вредности првог параметара садржи 'a
lt(string2) ≥ 'a     # животни век вредности другог параметара садржи 'a
'a ≥ lt(result)       # 'a мора да садржи животни веку result варијабле
</pre>

<p>
Што не може бити испуњено истовремено, тј. не постоји <code>'a</code> које испуњава ова
ограничења.
</p>

</section>
<section>

<p>
Други начин размишљања је да повратна вредност функције позајмљује од
вредности улазних параметара означених истим именом животног века.
</p>

<div class="org-src-container">

<pre><code class="rust" >fn main() {
    let string1 = String::from("abcd");
    {
        let string2 = "xyz";
        let result = longest(string1.as_str(), string2);
    }
    println!("The longest string is {}", result);
}
</code></pre>
</div>

<p>
Што значи да <code>result</code> позајмљује од <code>string1</code> и <code>string2</code> и та позајмица траје све
време живота варијабле <code>result</code> што не може бити валидно јер варијабла живи дуже
од вредности <code>string2</code>.
</p>

<p>
Иако, можемо видети да ће, због дужине стринга, враћена вредност бити <code>string1</code> и
програм је валидан, компајлер ово не може да закључи.
</p>
</section>
<section id="slide-15-3-7">
<h4 id="15-3-7"><span class="section-number-4">15.3.7.</span> Ментални модел у контексту животног века</h4>
<ul>
<li>Навођење анотације животног века зависи од тога шта функција ради.</li>
<li>На пример:</li>

</ul>

<div class="org-src-container">

<pre><code class="rust" >fn longest&lt;'a&gt;(x: &amp;'a str, y: &amp;str) -&gt; &amp;'a str {
    x
}
</code></pre>
</div>

<ul>
<li>У овом случају враћамо животни век првог параметра чиме саопштавамо компајлеру
да се позајмица врши искључиво од првог параметра.</li>

</ul>

</section>
<section>

<ul>
<li>Ако не позајмимо од улазних параметара морамо вратити референцу на вредност
креирану унутар функције, што није дозвољено.</li>

</ul>

<div class="org-src-container">

<pre><code class="rust" >fn longest&lt;'a&gt;(x: &amp;str, y: &amp;str) -&gt; &amp;'a str {
    let result = String::from("really long string");
    result.as_str()
}
</code></pre>
</div>

<pre>
$ cargo run
   Compiling chapter10 v0.1.0 (file:///projects/chapter10)
error[E0515]: cannot return reference to local variable `result`
  --&gt; src/main.rs:11:5
   |
11 |     result.as_str()
   |     ^^^^^^^^^^^^^^^ returns a reference to data owned by the current function

For more information about this error, try `rustc --explain E0515`.
error: could not compile `chapter10` due to previous error
</pre>

<p>
Немогуће је вратити референцу на локалну промењиву јер би то била висећа
референца. Решење у овом случају је да вратимо поседовану вредност.
</p>

</section>
<section>

<div class="note" id="org2394499">
<p>
Дакле, синтакса за анотацију животних векова доводи у везу животне векове
улазних параметара и повратних вредности. Наводи се само код референци.
</p>

<p>
На основу анотације, Раст је у стању да обави провере и обезбеди операције које
су меморијски сигурне и забрани операције које би могле да доведу до нарушавања
меморијске сигурности.
</p>

<p>
Анотације животног века истовремено представљају и корисне информације
програмерима јер је лако видети у каквој су вези улазни параметри и излазне
вредности.
</p>

</div>
</section>
<section id="slide-15-3-8">
<h4 id="15-3-8"><span class="section-number-4">15.3.8.</span> Анотације животног века у декларацијама структура</h4>
<ul>
<li>Сложени типови који у себи садрже референце морају увести анотације као врсту
генеричког типа.</li>

</ul>

<div class="org-src-container">

<pre><code class="rust" >struct ImportantExcerpt&lt;'a&gt; {
    part: &amp;'a str,
}

fn main() {
    let novel = String::from("Call me Ishmael. Some years ago...");
    let first_sentence = novel.split('.').next().expect("Could not find a '.'");
    let i = ImportantExcerpt {
        part: first_sentence,
    };
}
</code></pre>
</div>
</section>
<section id="slide-15-3-9">
<h4 id="15-3-9"><span class="section-number-4">15.3.9.</span> Елизија животног века</h4>
<ul>
<li>Имали смо претходно пример у коме нисмо дефинисали анотације животног века.</li>

</ul>

<div class="org-src-container">

<pre><code class="rust" >fn first_word(s: &amp;str) -&gt; &amp;str {
    let bytes = s.as_bytes();

    for (i, &amp;item) in bytes.iter().enumerate() {
        if item == b' ' {
            return &amp;s[0..i];
        }
    }

    &amp;s[..]
}
</code></pre>
</div>

<ul>
<li>Постоје одређена правила које називамо <i>правилима елизије животног века</i>
(<i>lifetime elision rules</i>) и која омогућавају да се избегне анотирање животног
века када је анотација очигледна.</li>

</ul>
</section>
<section id="slide-15-3-10">
<h4 id="15-3-10"><span class="section-number-4">15.3.10.</span> Правила елизије животног века</h4>
<ol>
<li>Компајлер креира животни век за сваку референцу у параметрима функције:</li>

</ol>

<div class="org-src-container">

<pre><code class="rust" >fn foo&lt;'a&gt;(x: &amp;'a i32)
fn foo&lt;'a, 'b&gt;(x: &amp;'a i32, y: &amp;'b i32)
итд.
</code></pre>
</div>

</section>
<section>

<ol>
<li>Када имамо тачно један улазни животни век, он је додељен свим референцама у
повратној вредности:</li>

</ol>

<div class="org-src-container">

<pre><code class="rust" >fn foo&lt;'a&gt;(x: &amp;'a i32) -&gt; &amp;'a i32
</code></pre>
</div>

</section>
<section>

<ol>
<li>Ако има више улазних животних векова али је један улазни параметар <code>&amp;self</code> ili
<code>&amp;mut self</code> тада се овај животни век додељује свим излазним референцема.</li>

</ol>
</section>
<section id="slide-15-3-11">
<h4 id="15-3-11"><span class="section-number-4">15.3.11.</span> Пример елизије 1</h4>
<div class="org-src-container">

<pre><code class="rust" >fn first_word(s: &amp;str) -&gt; &amp;str {
</code></pre>
</div>

</section>
<section>

<p>
Правило 1.
</p>

<div class="org-src-container">

<pre><code class="rust" >fn first_word&lt;'a&gt;(s: &amp;'a str) -&gt; &amp;str {
</code></pre>
</div>

</section>
<section>

<p>
Правило 2.
</p>

<div class="org-src-container">

<pre><code class="rust" >fn first_word&lt;'a&gt;(s: &amp;'a str) -&gt; &amp;'a str {
</code></pre>
</div>
</section>
<section id="slide-15-3-12">
<h4 id="15-3-12"><span class="section-number-4">15.3.12.</span> Пример елизије 2</h4>
<div class="org-src-container">

<pre><code class="rust" >fn longest(x: &amp;str, y: &amp;str) -&gt; &amp;str {
</code></pre>
</div>

</section>
<section>

<p>
Правило 1.
</p>

<div class="org-src-container">

<pre><code class="rust" >fn longest&lt;'a, 'b&gt;(x: &amp;'a str, y: &amp;'b str) -&gt; &amp;str {
</code></pre>
</div>

<ul>
<li>Не можемо да применимо ни правило 2 ни правило 3. И даље нам излазни параметар
нема анотацију -&gt; анотација мора ручно да се обави.</li>

</ul>
</section>
<section id="slide-15-3-13">
<h4 id="15-3-13"><span class="section-number-4">15.3.13.</span> Анотација животног века у методама</h4>
<div class="org-src-container">

<pre><code class="rust" >impl&lt;'a&gt; ImportantExcerpt&lt;'a&gt; {
    fn level(&amp;self) -&gt; i32 {
        3
    }
}
</code></pre>
</div>

<ul>
<li>На основу правила 1. не морамо да анотирамо улазну референцу.</li>

</ul>

</section>
<section>

<div class="org-src-container">

<pre><code class="rust" >impl&lt;'a&gt; ImportantExcerpt&lt;'a&gt; {
    fn announce_and_return_part(&amp;self, announcement: &amp;str) -&gt; &amp;str {
        println!("Attention please: {}", announcement);
        self.part
    }
}
</code></pre>
</div>

<ul>
<li>На основу правила 1 не морамо да анотирамо улазне референце а на основу
правила 3 не морамо да анотирамо ни повратну вредност.</li>

</ul>
</section>
<section id="slide-15-3-14">
<h4 id="15-3-14"><span class="section-number-4">15.3.14.</span> Животни век <code>static</code></h4>
<ul>
<li>Специјалан животни век који означавамо са <code>'static</code> означава животни век
целокупног трајања извршавања програма.</li>
<li>Овај животни век имају статичке вредности јер су такве вредности смештене
директно у извршну датотеку тј. нису алоциране у току извршавања програма.</li>

</ul>

<div class="org-src-container">

<pre><code class="rust" >let s: &amp;'static str = "I have a static lifetime.";
</code></pre>
</div>
</section>
<section id="slide-15-3-15">
<h4 id="15-3-15"><span class="section-number-4">15.3.15.</span> Генерички типови, ограничење кроз особине и животни век</h4>
<div class="org-src-container">

<pre><code class="rust" >use std::fmt::Display;

fn longest_with_an_announcement&lt;'a, T&gt;(
    x: &amp;'a str,
    y: &amp;'a str,
    ann: T,
) -&gt; &amp;'a str
where
    T: Display,
{
    println!("Announcement! {}", ann);
    if x.len() &gt; y.len() {
        x
    } else {
        y
    }
}
</code></pre>
</div>
</section>
</section>
<section>
<section id="slide-16">
<h2 id="16"><span class="section-number-2">16.</span> Функционално програмирање, затворења и итератори</h2>
<div class="outline-text-2" id="text-16">
</div>
</section>
<section id="slide-16-1">
<h3 id="16-1"><span class="section-number-3">16.1.</span> Затворења (<i>closures</i>)</h3>
<ul>
<li>Анонимне функције које се могу сачувати у варијабли и проследити другим функцијама.</li>
<li>За разлику од обичних функција, затворења "памте" варијабле из свога окружења.</li>
<li>Често се користе као параметри функција за трансформацију итератора.</li>

</ul>
</section>
<section id="slide-16-1-1">
<h4 id="16-1-1"><span class="section-number-4">16.1.1.</span> Пример</h4>
<ul>
<li>Фирма која врши промоцију периодичним слањем мајци насумично одабраним
клијентима са мејлинг листе.</li>
<li>Ако клијент има омиљену боју подешену у профилу мајица те боје му се шаље. У
супротном, шаље му се мајица у боји које тренутно има највише на стању.</li>

</ul>

<div class="org-src-container">

<pre id="giveaway-types"><code class="rust" >#[derive(Debug, PartialEq, Copy, Clone)]
enum ShirtColor {
    Red,
    Blue,
}

struct Inventory {
    shirts: Vec&lt;ShirtColor&gt;,
}
</code></pre>
</div>

</section>
<section>

<div class="org-src-container">

<pre id="giveaway-inventory"><code class="rust" >impl Inventory {
    fn giveaway(&amp;self, user_preference: Option&lt;ShirtColor&gt;) -&gt; ShirtColor {
        user_preference.unwrap_or_else(|| self.most_stocked())    // &lt;- Затворење
    }

    fn most_stocked(&amp;self) -&gt; ShirtColor {
        let mut num_red = 0;
        let mut num_blue = 0;

        for color in &amp;self.shirts {
            match color {
                ShirtColor::Red =&gt; num_red += 1,
                ShirtColor::Blue =&gt; num_blue += 1,
            }
        }
        if num_red &gt; num_blue {
            ShirtColor::Red
        } else {
            ShirtColor::Blue
        }
    }
}
</code></pre>
</div>

</section>
<section>

<div class="org-src-container">

<pre><code class="rust" >&lt;&lt;giveaway-types&gt;&gt;
&lt;&lt;giveaway-inventory&gt;&gt;
fn main() {
    let store = Inventory {
        shirts: vec![ShirtColor::Blue, ShirtColor::Red, ShirtColor::Blue],
    };

    let user_pref1 = Some(ShirtColor::Red);
    let giveaway1 = store.giveaway(user_pref1);
    println!(
        "The user with preference {:?} gets {:?}",
        user_pref1, giveaway1
    );

    let user_pref2 = None;
    let giveaway2 = store.giveaway(user_pref2);
    println!(
        "The user with preference {:?} gets {:?}",
        user_pref2, giveaway2
    );
}
</code></pre>
</div>

<pre class="example">
The user with preference Some(Red) gets Red
The user with preference None gets Blue
</pre>
</section>
<section id="slide-16-1-2">
<h4 id="16-1-2"><span class="section-number-4">16.1.2.</span> Инференца типова</h4>
<ul>
<li>За разлику од функција, код затворења није неопходна анотација типова
параметара и повратних вредности.</li>
<li>Уколико је анотација потребна то радимо на следећи начин:</li>

</ul>

<div class="org-src-container">

<pre><code class="rust" >let expensive_closure = |num: u32| -&gt; u32 {
        println!("calculating slowly...");
        thread::sleep(Duration::from_secs(2));
        num
    };
</code></pre>
</div>
</section>
<section id="slide-16-1-3">
<h4 id="16-1-3"><span class="section-number-4">16.1.3.</span> Поређење са функцијама</h4>
<div class="org-src-container">

<pre><code class="rust" >fn  add_one_v1   (x: u32) -&gt; u32 { x + 1 }
let add_one_v2 = |x: u32| -&gt; u32 { x + 1 };
let add_one_v3 = |x|             { x + 1 };
let add_one_v4 = |x|               x + 1  ;
</code></pre>
</div>

<ul>
<li>Последње две линије захтевају евалуацију затворења да би компајлер могао да
изведе типове, слично као употреба <code>let v = Vec::new()</code>.</li>

</ul>
</section>
<section id="slide-16-1-4">
<h4 id="16-1-4"><span class="section-number-4">16.1.4.</span> Инференца типова при евалуацији</h4>
<div class="org-src-container">

<pre><code class="rust" >let example_closure = |x| x;

let s = example_closure(String::from("hello"));
let n = example_closure(5);
</code></pre>
</div>

<div class="org-src-container">

<pre><code class="sh" >$ cargo run
   Compiling closure-example v0.1.0 (file:///projects/closure-example)
error[E0308]: mismatched types
 --&gt; src/main.rs:5:29
  |
5 |     let n = example_closure(5);
  |             --------------- ^- help: try using a conversion method: `.to_string()`
  |             |               |
  |             |               expected struct `String`, found integer
  |             arguments to this function are incorrect
  |
note: closure parameter defined here
 --&gt; src/main.rs:2:28
  |
2 |     let example_closure = |x| x;
  |                            ^

For more information about this error, try `rustc --explain E0308`.
error: could not compile `closure-example` due to previous error
</code></pre>
</div>
</section>
<section id="slide-16-1-5">
<h4 id="16-1-5"><span class="section-number-4">16.1.5.</span> Памћење окружења - референце и власништва</h4>
<ul>
<li>Затворење може да запамти варијабле свога окружења на три начина, као и код
преноса параметара функције:
<ol>
<li>непромењива позајмица (дељена референца)</li>
<li>промењива позајмица (јединствена референца)</li>
<li>узимање власништва (премештање)</li>

</ol></li>

</ul>
</section>
<section id="slide-16-1-6">
<h4 id="16-1-6"><span class="section-number-4">16.1.6.</span> Памћење окружења - непромењива позајмица</h4>
<div class="org-src-container">

<pre><code class="rust" >fn main() {
    let list = vec![1, 2, 3];
    println!("Before defining closure: {:?}", list);

    let only_borrows = || println!("From closure: {:?}", list);

    println!("Before calling closure: {:?}", list);
    only_borrows();
    println!("After calling closure: {:?}", list);
}
</code></pre>
</div>

<pre class="example">
Before defining closure: [1, 2, 3]
Before calling closure: [1, 2, 3]
From closure: [1, 2, 3]
After calling closure: [1, 2, 3]
</pre>
</section>
<section id="slide-16-1-7">
<h4 id="16-1-7"><span class="section-number-4">16.1.7.</span> Памћење окружења - промењива позајмица</h4>
<div class="org-src-container">

<pre><code class="rust" >fn main() {
    let mut list = vec![1, 2, 3];
    println!("Before defining closure: {:?}", list);

    let mut borrows_mutably = || list.push(7);

    // println!("Before calling closure: {:?}", list); // &lt;- Ово не може!
    borrows_mutably();
    println!("After calling closure: {:?}", list);
}
</code></pre>
</div>

<pre class="example">
Before defining closure: [1, 2, 3]
After calling closure: [1, 2, 3, 7]
</pre>
</section>
<section id="slide-16-1-8">
<h4 id="16-1-8"><span class="section-number-4">16.1.8.</span> Памћење окружења - узимање власништва</h4>
<ul>
<li>Ако желимо да затворење преузме власништво над вредношћу користимо кључну реч <code>move</code>.</li>
<li>Најчешће користимо у контексту нити.</li>

</ul>

<div class="org-src-container">

<pre><code class="rust" >use std::thread;

fn main() {
    let list = vec![1, 2, 3];
    println!("Before defining closure: {:?}", list);

    thread::spawn(move || println!("From thread: {:?}", list))
        .join()
        .unwrap();
}
</code></pre>
</div>

<pre class="example">
Before defining closure: [1, 2, 3]
From thread: [1, 2, 3]
</pre>


<ul>
<li>Неопходно јер <code>main</code> нит може завршити раније и тиме деалоцирати <code>list</code> вредност
која би још увек била позајмљена од стране креиране нити.</li>

</ul>

</section>
<section>

<ul>
<li>Ако уклонимо кључну реч <code>move</code> добићемо следећу грешку:</li>

</ul>

<div class="org-src-container">

<pre><code class="sh" >error[E0373]: closure may outlive the current function, but it borrows `list`, which
is owned by the current function
 --&gt; src/main.rs:8:19
  |
8 |     thread::spawn(|| println!("From thread: {:?}", list))
  |                   ^^                               ---- `list` is borrowed here
  |                   |
  |                   may outlive borrowed value `list`
  |
note: function requires argument type to outlive `'static`
 --&gt; src/main.rs:8:5
  |
8 |     thread::spawn(|| println!("From thread: {:?}", list))
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
help: to force the closure to take ownership of `list` (and any other referenced variables),
use the `move` keyword
  |
8 |     thread::spawn(move || println!("From thread: {:?}", list))
  |                   ++++

For more information about this error, try `rustc --explain E0373`.
error: could not compile `cargo0sMXjj` due to previous error
</code></pre>
</div>
</section>
<section id="slide-16-1-9">
<h4 id="16-1-9"><span class="section-number-4">16.1.9.</span> Премештање запамћених вредности и <code>Fn</code> особине</h4>
<ul>
<li>Затворење може са запамћеним вредностима да уради нешто од следећег:
<ol>
<li>Врати власништво позиваоцу приликом евалуације.</li>
<li>Измени запамћену вредност.</li>
<li>Само чита запамћену вредности.</li>
<li>или, може и да не запамти ниједну вредност из свог окружења.</li>

</ol></li>

</ul>

</section>
<section>

<ul>
<li>У зависности од тога, затворење ће аутоматски имплементирати једну, две или
све три особине:
<ol>
<li><code>FnOnce</code> - затворења која могу да се позову само једном. Сва затворења
имплементирају бар ову особину, пошто могу да се позову бар једном.
Затворења која предају власништво приликом позива имплементрају само ову
особину пошто се не могу позвати више од једном.</li>
<li><code>FnMut</code> - затворења која не премештају вредности али их могу мењати. Могу се
позвати више од једном.</li>
<li><code>Fn</code> - затворења која нити премештају нити мењају своје окружење, или не
памте ништа из окружења. Могу се позвати више пута.</li>

</ol></li>

</ul>
</section>
<section id="slide-16-1-10">
<h4 id="16-1-10"><span class="section-number-4">16.1.10.</span> Пример - <code>FnOnce</code></h4>
<div class="org-src-container">

<pre><code class="rust" >impl&lt;T&gt; Option&lt;T&gt; {
    pub fn unwrap_or_else&lt;F&gt;(self, f: F) -&gt; T
    where
        F: FnOnce() -&gt; T
    {
        match self {
            Some(x) =&gt; x,
            None =&gt; f(),
        }
    }
}
</code></pre>
</div>

<ul>
<li><code>unwrap_or_else</code> прихвата најопштији облик затворења која имплементирају <code>FnOnce</code>.</li>

</ul>
</section>
<section id="slide-16-1-11">
<h4 id="16-1-11"><span class="section-number-4">16.1.11.</span> Пример - <code>FnMut</code></h4>
<div class="org-src-container">

<pre><code class="rust" >#[derive(Debug)]
struct Rectangle {
    width: u32,
    height: u32,
}

fn main() {
    let mut list = [
        Rectangle { width: 10, height: 1 },
        Rectangle { width: 3, height: 5 },
        Rectangle { width: 7, height: 12 },
    ];

    list.sort_by_key(|r| r.width);
    println!("{:#?}", list);
}
</code></pre>
</div>

<pre class="example" id="orgcec3929">
[
    Rectangle {
        width: 3,
        height: 5,
    },
    Rectangle {
        width: 7,
        height: 12,
    },
    Rectangle {
        width: 10,
        height: 1,
    },
]
</pre>

</section>
<section>

<ul>
<li>Сигнатура за методу <code>sort_by_key</code> над исечком je <code>FnMut</code>. Зашто?</li>

</ul>
<div class="org-src-container">

<pre><code class="rust" >pub fn sort_by_key&lt;K, F&gt;(&amp;mut self, f: F)
where
    F: FnMut(&amp;T) -&gt; K,
    K: Ord,
</code></pre>
</div>

</section>
<section>

<ul>
<li>Затворење се позива за сваки елемент исечка тако да не може бити само <code>FnOnce</code>
већ мора имати додатна ограничења.</li>
<li>Иако затворење у овом случају <code>|r| r.width</code> не модификује својe окружење ипак је
ограничење тако дефинисано да буде најмање рестриктивно. Стога, пошто је
једини захтев да затворење можемо позивати више пута, ограничење које је
следеће најмање рестриктивно после <code>FnOnce</code> је <code>FnMut</code>.</li>
<li>Овим ћемо моћи проследити затворења која су и <code>Fn</code> и <code>FnMut</code> али не и она која су
само <code>FnOnce</code>.</li>

</ul>

</section>
<section>

<ul>
<li>Да видимо шта ће бити ако имамо затворење које ради премештање из окружења и
тиме је само <code>FnOnce</code>.</li>

</ul>

<div class="org-src-container">

<pre><code class="rust" >#[derive(Debug)]
struct Rectangle {
    width: u32,
    height: u32,
}

fn main() {
    let mut list = [
        Rectangle { width: 10, height: 1 },
        Rectangle { width: 3, height: 5 },
        Rectangle { width: 7, height: 12 },
    ];

    let mut sort_operations = vec![];
    let value = String::from("by key called");

    list.sort_by_key(|r| {
        sort_operations.push(value);
        r.width
    });
    println!("{:#?}", list);
}
</code></pre>
</div>

</section>
<section>

<div class="org-src-container">

<pre><code class="sh" >error[E0507]: cannot move out of `value`, a captured variable in an `FnMut` closure
  --&gt; src/main.rs:19:30
   |
16 |     let value = String::from("by key called");
   |         ----- captured outer variable
17 |
18 |     list.sort_by_key(|r| {
   |                      --- captured by this `FnMut` closure
19 |         sort_operations.push(value);
   |                              ^^^^^ move occurs because `value` has type `String`, which
   does not implement the `Copy` trait

For more information about this error, try `rustc --explain E0507`.
error: could not compile `cargoHMNw8k` due to previous error
</code></pre>
</div>

</section>
<section>

<ul>
<li>Али ово ће радити јер је сада затворење <code>FnMut</code>.</li>

</ul>

<div class="org-src-container">

<pre><code class="rust" >#[derive(Debug)]
struct Rectangle {
    width: u32,
    height: u32,
}

fn main() {
    let mut list = [
        Rectangle { width: 10, height: 1 },
        Rectangle { width: 3, height: 5 },
        Rectangle { width: 7, height: 12 },
    ];

    let mut num_sort_operations = 0;
    list.sort_by_key(|r| {
        num_sort_operations += 1;
        r.width
    });
    println!("{:#?}, sorted in {num_sort_operations} operations", list);
}
</code></pre>
</div>
</section>
<section id="slide-16-2">
<h3 id="16-2"><span class="section-number-3">16.2.</span> Итератори</h3>
<ul>
<li>Итератор образац омогућава процесирање елемената секвенци.</li>
<li>Итератори имплементирају логику итерације тј. преузимање елемента редом из
секвенце и логику детекције краја итерације.</li>
<li>Итератори у Расту су "лењи", односно процесирање ће се одложити и обавити тек
онда када је то заиста потребно.</li>

</ul>
</section>
<section id="slide-16-2-1">
<h4 id="16-2-1"><span class="section-number-4">16.2.1.</span> Пример</h4>
<div class="org-src-container">

<pre><code class="rust" >let v1 = vec![1, 2, 3];

let v1_iter = v1.iter();
</code></pre>
</div>

<ul>
<li><code>v1_iter</code> је итератор. Сам по себи не ради ништа док се не конзумира.</li>

</ul>

<div class="org-src-container">

<pre><code class="rust" >let v1 = vec![1, 2, 3];

let v1_iter = v1.iter();

for val in v1_iter {
    println!("Got: {}", val);
}
</code></pre>
</div>

<pre class="example">
Got: 1
Got: 2
Got: 3
</pre>
</section>
<section id="slide-16-2-2">
<h4 id="16-2-2"><span class="section-number-4">16.2.2.</span> <code>Iterator</code> особина и метода <code>next</code></h4>
<div class="org-src-container">

<pre><code class="rust" >pub trait Iterator {
    type Item;

    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt;;

    // methods with default implementations elided
}
</code></pre>
</div>

<ul>
<li>Ова особина има придружени тип (<i>associated type</i>) - <code>type Item</code> односно
<code>Self::Item</code>. Стога, имплементација ове особине над неким типом захтева
дефиницију и придруженог типа који представља тип елемената над којима се врши
итерација.</li>

</ul>
</section>
<section id="slide-16-2-3">
<h4 id="16-2-3"><span class="section-number-4">16.2.3.</span> Демонстрација итерације</h4>
<div class="org-src-container">

<pre><code class="rust" > #[test]
fn iterator_demonstration() {
    let v1 = vec![1, 2, 3];

    let mut v1_iter = v1.iter();

    assert_eq!(v1_iter.next(), Some(&amp;1));
    assert_eq!(v1_iter.next(), Some(&amp;2));
    assert_eq!(v1_iter.next(), Some(&amp;3));
    assert_eq!(v1_iter.next(), None);
}
</code></pre>
</div>

<ul>
<li>Сваки позив методе <code>next</code> врши конзумацију итератора, односно узима се наредни
елемент и ажурира се интерно стање итератора.</li>
<li>У овом случају <code>iter</code> метода производи итератор кроз непромењиве (дељене)
референце над елементима вектора, тако да <code>next</code> враћа непромењиву референцу на
наредни елемент.</li>
<li>Ако нам треба итерација преко промењивих референци користимо методу <code>iter_mut</code>.</li>
<li>Ако нам треба итерација преко власничких вредности користимо методу <code>into_iter</code>.
У том случају итератор постаје власник колекције и враћа премештене вредности
при сваком позиву <code>next</code> методе.</li>

</ul>
</section>
<section id="slide-16-2-4">
<h4 id="16-2-4"><span class="section-number-4">16.2.4.</span> Методе које конзумирају итераторе</h4>
<ul>
<li><code>Iterator</code> особина има богат API.</li>
<li>Неке од ових метода позивају <code>next</code> методу. За такве методе кажемо да су
конзумирајући адаптери јер врше конзумацију итератора.</li>
<li>На пример, <code>sum</code> метода.</li>

</ul>

<div class="org-src-container">

<pre><code class="rust" >let v1 = vec![1, 2, 3];

let v1_iter = v1.iter();

let total: i32 = v1_iter.sum();

// println!("{:?}", v1_iter.next());  // &lt;- Ово не може.

assert_eq!(total, 6);
</code></pre>
</div>

<ul>
<li>Када се позове <code>sum</code> више нисмо у стању да позовемо <code>v1_iter</code> јер смо га
конзумирали.</li>

</ul>
</section>
<section id="slide-16-2-5">
<h4 id="16-2-5"><span class="section-number-4">16.2.5.</span> Методе које производе друге итераторе</h4>
<ul>
<li>Називамо их итератор адаптерима.</li>
<li>Врше конверзију једног итератора у неки други итератор.</li>

</ul>

<div class="org-src-container">

<pre><code class="rust" >let v1: Vec&lt;i32&gt; = vec![1, 2, 3];

v1.iter().map(|x| x + 1);
</code></pre>
</div>

</section>
<section>

<ul>
<li>Претходни код производи упозорење:</li>

</ul>

<div class="org-src-container">

<pre><code class="rust" >$ cargo run
   Compiling iterators v0.1.0 (file:///projects/iterators)
warning: unused `Map` that must be used
 --&gt; src/main.rs:4:5
  |
4 |     v1.iter().map(|x| x + 1);
  |     ^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: iterators are lazy and do nothing unless consumed
  = note: `#[warn(unused_must_use)]` on by default

warning: `iterators` (bin "iterators") generated 1 warning
    Finished dev [unoptimized + debuginfo] target(s) in 0.47s
     Running `target/debug/iterators`
</code></pre>
</div>

<ul>
<li>Итератор адаптери су "лењи". Претходни итератор није конзумиран тако да се
мапирање никада неће извршити.</li>

</ul>

</section>
<section>

<ul>
<li>Дакле, морамо конзумирати итератор. Једна од метода за конзумацију итератора
је <code>collect</code> која ће да конзумира итератор и креира колекцију са елементима које
он враћа.</li>

</ul>

<div class="org-src-container">

<pre><code class="rust" >let v1: Vec&lt;i32&gt; = vec![1, 2, 3];

let v2: Vec&lt;_&gt; = v1.iter().map(|x| x + 1).collect();

assert_eq!(v2, vec![2, 3, 4]);
</code></pre>
</div>

<ul>
<li>Обратите пажњу да је била потребна анотација типа јер је <code>collect</code> генеричка
метода која може да креира различите типове вредности.</li>
<li>Можете позивати више адаптера у низу и сви заједно су лењи тј. морате на крају
позвати методу која конзумира да бисте извршили цео ланац.</li>

</ul>
</section>
<section id="slide-16-2-6">
<h4 id="16-2-6"><span class="section-number-4">16.2.6.</span> Употреба затворења као параметара итератор адаптера</h4>
<ul>
<li>Многи адаптери користе затворења као своје параметре.</li>

</ul>

<div class="org-src-container">

<pre><code class="rust" >#[derive(PartialEq, Debug)]
struct Shoe {
    size: u32,
    style: String,
}

fn shoes_in_size(shoes: Vec&lt;Shoe&gt;, shoe_size: u32) -&gt; Vec&lt;Shoe&gt; {
    shoes.into_iter().filter(|s| s.size == shoe_size).collect()
}
</code></pre>
</div>

</section>
<section>

<div class="org-src-container">

<pre><code class="rust" >let shoes = vec![
    Shoe {
        size: 10,
        style: String::from("sneaker"),
    },
    Shoe {
        size: 13,
        style: String::from("sandal"),
    },
    Shoe {
        size: 10,
        style: String::from("boot"),
    },
];

let in_my_size = shoes_in_size(shoes, 10);

assert_eq!(
    in_my_size,
    vec![
        Shoe {
            size: 10,
            style: String::from("sneaker")
        },
        Shoe {
            size: 10,
            style: String::from("boot")
        },
    ]
);
</code></pre>
</div>
</section>
<section id="slide-16-2-7">
<h4 id="16-2-7"><span class="section-number-4">16.2.7.</span> Употреба итератор адаптера за писање концизнијег кода</h4>
<ul>
<li>Пример претраге са <code>for</code> петљом:</li>

</ul>
<div class="org-src-container">

<pre><code class="rust" >pub fn search&lt;'a&gt;(query: &amp;str, contents: &amp;'a str) -&gt; Vec&lt;&amp;'a str&gt; {
    let mut results = Vec::new();

    for line in contents.lines() {
        if line.contains(query) {
            results.push(line);
        }
    }

    results
}
</code></pre>
</div>

<ul>
<li>Исти алгоритам употребом итератор адаптера:</li>

</ul>

<div class="org-src-container">

<pre><code class="rust" >pub fn search&lt;'a&gt;(query: &amp;str, contents: &amp;'a str) -&gt; Vec&lt;&amp;'a str&gt; {
    contents
        .lines()
        .filter(|line| line.contains(query))
        .collect()
}
</code></pre>
</div>

</section>
<section>

<ul>
<li>Иако интуитивно можемо да помислимо да је код написан на вишем нивоу употребом
итератора спорији, заправо компајлер је у прилици да боље оптимизује овај код
и он је често нешто бржи од еквивалентног кода написаног употребом <code>for</code> петље.</li>

</ul>
</section>
<section id="slide-16-2-8">
<h4 id="16-2-8"><span class="section-number-4">16.2.8.</span> Анализа сложенијих примера</h4>
<div class="org-src-container">

<pre><code class="rust" >let buffer: &amp;mut [i32];
let coefficients: [i64; 12];
let qlp_shift: i16;

for i in 12..buffer.len() {
    let prediction = coefficients.iter()
                                 .zip(&amp;buffer[i - 12..i])
                                 .map(|(&amp;c, &amp;s)| c * s as i64)
                                 .sum::&lt;i64&gt;() &gt;&gt; qlp_shift;
    let delta = buffer[i];
    buffer[i] = prediction as i32 + delta;
}
</code></pre>
</div>

</section>
<section>

<div class="org-src-container">

<pre><code class="rust" >token_recognizers
    .iter()
    .map(|tr| {
        (
            tr.recognize(&amp;context.input[context.position..]),
            tr.token_kind(),
        )
    })
    // Skip unsuccesful recognition
    .skip_while(|(recognized, _)| recognized.is_none())
    // Create tokens
    .map(|(recognized, token_kind)| Token {
        kind: token_kind,
        value: recognized.unwrap(),
        location: recognized.unwrap().location_span(context.location),
    })
    // Take the first token or return None if no tokens are found.
    .next()
</code></pre>
</div>

</section>
<section>

<div class="org-src-container">

<pre><code class="rust" >let max_actions = self
    .table
    .states
    .iter()
    .map(|x| x.actions.iter().filter(|x| !x.is_empty()).count())
    .max()
    .unwrap();
</code></pre>
</div>

</section>
<section>

<div class="org-src-container">

<pre><code class="rust" >let mut terminals = state
    .actions
    .iter()
    .enumerate()
    .filter(|(_, actions)| !actions.is_empty())
    .map(|(idx, _)| TermIndex(idx))
    .collect::&lt;Vec&lt;_&gt;&gt;();
</code></pre>
</div>

</section>
<section>

<div class="org-src-container">

<pre><code class="rust" >fn context_str(&amp;self, position: usize) -&gt; String {
    format!(
        "{:?}",
        self[position - min(15, position)..position]
            .iter()
            .map(|x| format!("{x}"))
            .chain(once("--&gt;".to_string()))
            .chain(self[position..].iter().map(|x| format!("{x}")).take(15))
            .collect::&lt;Vec&lt;_&gt;&gt;()
    )
}
</code></pre>
</div>

</section>
<section>

<div class="org-src-container">

<pre><code class="rust" >let actions = state
    .actions
    .iter()
    .enumerate()
    .filter(|(_, a)| !a.is_empty())
    .flat_map(|(i, a)| repeat(i).zip(a.iter()))
    .map(|(i, a)| {
        (
            self.grammar.terminals[TermIndex(i)].name.clone(),
            match a {
                Action::Shift(s) =&gt; format!("Shift to {s}"),
                Action::Reduce(p, l) =&gt; {
                    format!(
                        "Reduce for len {l} by:   {}",
                        self.grammar.productions[*p]
                            .to_string(self.grammar)
                    )
                }
                Action::Accept =&gt; "Accept".into(),
            },
        )
    })
    .collect::&lt;Vec&lt;_&gt;&gt;();
</code></pre>
</div>
</section>
</section>
<section>
<section id="slide-17">
<h2 id="17"><span class="section-number-2">17.</span> Литература</h2>
<ul>
<li>Steve Klabnik and Carol Nichols: <a href="https://doc.rust-lang.org/book/">The Rust Programming Language</a>, no starch press.</li>
<li><a href="https://doc.rust-lang.org/stable/rust-by-example/index.html">Rust by Example</a></li>
<li><a href="https://github.com/rust-lang/book/issues/3070">Slice is NOT reference</a></li>
<li><a href="https://google.github.io/comprehensive-rust/">Google: Comprehensive Rust</a></li>
<li><a href="https://rust-lang.github.io/rfcs/0505-api-comment-conventions.html">RFC 505: API documentation conventions</a></li>
<li><a href="https://github.com/rust-lang/rustlings">Rustlings: Small exercises to get you used to reading and writing Rust code!</a></li>

</ul>
</section>
</section>
</div>
</div>
<script src="../../../s/reveal.js/js/reveal.js"></script>
<script>
// Full list of configuration options available here:
// https://github.com/hakimel/reveal.js#configuration
Reveal.initialize({

controls: true,
progress: true,
history: false,
center: true,
slideNumber: 'c/t',
rollingLinks: false,
keyboard: true,
mouseWheel: false,
fragmentInURL: true,
hashOneBasedIndex: false,
pdfSeparateFragments: true,
overview: true,
width: 1400,
height: 1000,
minScale: 0.30,
maxScale: 4.00,

theme: Reveal.getQueryHash().theme, // available themes are in /css/theme
transition: Reveal.getQueryHash().transition || 'slide', // see README of reveal.js for options
transitionSpeed: 'default',

// Optional libraries used to extend reveal.js
dependencies: [
{src: '../../../s/reveal.js/../reveal-plugins/menu/menu.js'},
{src: '../../../s/reveal.js/../reveal-plugins/chalkboard/chalkboard.js'},
 { src: '../../../s/reveal.js/plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } },
 { src: '../../../s/reveal.js/plugin/search/search.js', async: true, condition: function() { return !!document.body.classList; } }]

,keyboard: {67: function() { RevealChalkboard.toggleNotesCanvas() },	66: function() { RevealChalkboard.toggleChalkboard() },	46: function() { RevealChalkboard.clear() },	8: function() { RevealChalkboard.reset() },	68: function() { RevealChalkboard.download() },	},});
</script>
</body>
</html>
