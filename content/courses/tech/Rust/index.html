<!DOCTYPE html>
<html lang="sr">
<head>
<meta charset="utf-8"/>
<title>Програмски језик Раст</title>
<meta name="author" content="Игор Дејановић"/>
<style type="text/css">
.underline { text-decoration: underline; }
</style>
<link rel="stylesheet" href="../../../s/reveal.js/css/reveal.css"/>

<link rel="stylesheet" href="../../../s/reveal.js/css/theme/simple.css" id="theme"/>

<link rel="stylesheet" href="../../../s/reveal-slides.css"/>

<link rel="stylesheet" href="../../../s/highlight-styles/docco.css"/>
<link rel="stylesheet" href=""/>

<!-- If the query includes 'print-pdf', include the PDF print sheet -->
<script>
    if( window.location.search.match( /print-pdf/gi ) ) {
        var link = document.createElement( 'link' );
        link.rel = 'stylesheet';
        link.type = 'text/css';
        link.href = '../../../s/reveal.js/css/print/pdf.css';
        document.getElementsByTagName( 'head' )[0].appendChild( link );
    }
</script>
<base target="_blank">
</head>
<body>
<div class="reveal">
<div class="slides">
<section id="sec-title-slide">
<h1 class="title">Програмски језик Раст</h1>
<h2 class="subtitle">Базирано на верзији 1.65.0. У изради.</h2>
<h2 class="author">Проф. др Игор Дејановић (<a href="mailto:igord at uns ac rs">igord at uns ac rs</a>)</h2>
<p class="date">Креирано 2023-04-10 Mon 14:19, притисни ESC за мапу, "м" за мени, Ctrl+Shift+F за претрагу</p>
</section>

<section>
<section id="slide-1">
<h2 id="1"><span class="section-number-2">1.</span> Увод</h2>
<ul>
<li>Језик опште намене, компајлиран и статички типизиран са инференцом типова</li>
<li>Системско програмирање али са особинама вишег нивоа апстракције као што су
функционално програмирање</li>
<li>2010, Graydon Hoare, Mozilla Research</li>
<li>Перформансе и сигурност</li>
<li>Не користи <i>garbage collector</i> али обезбеђује меморијску сигурност кроз <i>borrow
checker</i></li>
<li>Синтаксно сличан C++. Утицај и OCaml-а, Haskell-а и Erlang-а.</li>
<li>Користи се у великим фирмама: Amazon, Facebook, Google, Microsoft&#x2026;</li>
<li>Више година за редом на SO упитнику први у категорији <i>"most loved programming
languages"</i></li>

</ul>

</section>
</section>
<section>
<section id="slide-2">
<h2 id="2"><span class="section-number-2">2.</span> Инсталација и подешавање</h2>
<div class="outline-text-2" id="text-2">
</div>
</section>
<section id="slide-2-1">
<h3 id="2-1"><span class="section-number-3">2.1.</span> Инсталација</h3>
<ul>
<li>Раст стиже са алатом за управљање ланцем алата (енг. <i>toolchain</i>) &#x2013; <code>rustup</code></li>

</ul>

<div class="org-src-container">

<pre><code class="sh" >$ curl --proto '=https' --tlsv1.2 https://sh.rustup.rs -sSf | sh
</code></pre>
</div>

<ul>
<li>Провера инсталације:</li>

</ul>

<div class="org-src-container">

<pre><code class="sh" >~&gt; rustc --version
rustc 1.65.0 (897e37553 2022-11-02)
</code></pre>
</div>

</section>
<section id="slide-2-2">
<h3 id="2-2"><span class="section-number-3">2.2.</span> Преглед инсталације</h3>
<div class="org-src-container">

<pre><code class="sh" >~&gt; rustup show
Default host: x86_64-unknown-linux-gnu
rustup home:  /home/igor/.rustup

installed toolchains
--------------------

stable-x86_64-unknown-linux-gnu (default)
nightly-x86_64-unknown-linux-gnu

active toolchain
----------------

stable-x86_64-unknown-linux-gnu (default)
rustc 1.58.1 (db9d1b20b 2022-01-20)
</code></pre>
</div>

</section>
<section id="slide-2-3">
<h3 id="2-3"><span class="section-number-3">2.3.</span> Ажурирање</h3>
<p>
За ажурирање инсталације на најновију верзију:
</p>

<div class="org-src-container">

<pre><code class="sh" >rustup update
</code></pre>
</div>

</section>
<section id="slide-2-4">
<h3 id="2-4"><span class="section-number-3">2.4.</span> Документација</h3>
<p>
Раст стиже са веома добром документацијом и књигама које су доступне директно из
инсталације:
</p>

<div class="org-src-container">

<pre><code class="sh" >rustup doc
</code></pre>
</div>

</section>
</section>
<section>
<section id="slide-3">
<h2 id="3"><span class="section-number-2">3.</span> Почетак</h2>
<div class="outline-text-2" id="text-3">
</div>
</section>
<section id="slide-3-1">
<h3 id="3-1"><span class="section-number-3">3.1.</span> Hello, World!</h3>
<div class="org-src-container">

<pre><code class="sh" >$ mkdir hello_world
$ cd hello_world
</code></pre>
</div>

<p>
File <code>main.rs</code>:
</p>
<div class="org-src-container">

<pre><code class="rust" >fn main() {
    println!("Hello, world!");
}
</code></pre>
</div>

</section>
<section id="slide-3-2">
<h3 id="3-2"><span class="section-number-3">3.2.</span> Компајлирање и покретање</h3>
<div class="org-src-container">

<pre><code class="sh" >$ rustc main.rs
$ ./main
Hello, world!
</code></pre>
</div>

</section>
<section id="slide-3-3">
<h3 id="3-3"><span class="section-number-3">3.3.</span> Hello, Cargo!</h3>
<ul>
<li>Алат за разрешавање зависности и управљање пројектом.</li>

</ul>

<div class="org-src-container">

<pre><code class="sh" >~&gt; cargo --version
cargo 1.65.0 (4bc8f24d3 2022-10-20)
</code></pre>
</div>

<ul>
<li>Креирање пројекта са <code>cargo</code> алатом:</li>

</ul>

<div class="org-src-container">

<pre><code class="sh" >$ cargo new hello_cargo
$ cd hello_cargo
</code></pre>
</div>

</section>
<section id="slide-3-4">
<h3 id="3-4"><span class="section-number-3">3.4.</span> Садржај креираног пројекта</h3>
<p>
Фајл <code>cargo.toml</code> чува конфигурацију пројекта. Формат је <a href="https://toml.io/en/">TOML</a> (<i>Tom’s Obvious,
Minimal Language</i>):
</p>

<div class="org-src-container">

<pre><code class="toml" >[package]
name = "hello_cargo"
version = "0.1.0"
edition = "2021"

[dependencies]
</code></pre>
</div>

<p>
Fajl <code>src/main.rs</code>:
</p>
<div class="org-src-container">

<pre><code class="rust" >fn main() {
    println!("Hello, world!");
}
</code></pre>
</div>

</section>
<section id="slide-3-5">
<h3 id="3-5"><span class="section-number-3">3.5.</span> Покретање</h3>
<div class="org-src-container">

<pre><code class="rust" >$ cargo build
   Compiling hello_cargo v0.1.0 (file:///projects/hello_cargo)
    Finished dev [unoptimized + debuginfo] target(s) in 2.85 secs
</code></pre>
</div>

<p>
Извршни фајл се може наћи на локацији <code>target/debug/hello_cargo</code>:
</p>

<div class="org-src-container">

<pre><code class="sh" >$ ./target/debug/hello_cargo
Hello, world!
</code></pre>
</div>

<p>
Али <code>cargo</code> омогућава и једноставнији начин покретања:
</p>
<div class="org-src-container">

<pre><code class="sh" >$ cargo run
    Finished dev [unoptimized + debuginfo] target(s) in 0.0 secs
     Running `target/debug/hello_cargo`
Hello, world!
</code></pre>
</div>

</section>
<section id="slide-3-6">
<h3 id="3-6"><span class="section-number-3">3.6.</span> Провера</h3>
<p>
Такође је могуће брзо проверити да ли се код компајлира:
</p>

<div class="org-src-container">

<pre><code class="sh" >$ cargo check
   Checking hello_cargo v0.1.0 (file:///projects/hello_cargo)
    Finished dev [unoptimized + debuginfo] target(s) in 0.32 secs
</code></pre>
</div>

</section>
<section id="slide-3-7">
<h3 id="3-7"><span class="section-number-3">3.7.</span> Изградња финалне верзије</h3>
<ul>
<li>У току развоја користимо изградњу за дебаговање која се брже заврши али
генерисани извршни код није оптималан.</li>

<li><p>
За финалну верзију је потребно изградњу обавити на следећи начин:
</p>

<div class="org-src-container">

<pre><code class="rust" >    cargo build --release
</code></pre>
</div></li>

<li>Ово ће обавити додатне оптимизације које ће дуже трајати али ће крајњи код
бити оптимизован.</li>

</ul>

</section>
<section id="slide-3-8">
<h3 id="3-8"><span class="section-number-3">3.8.</span> <code>cargo</code> као конвенција</h3>
<p>
Практично сви Раст пројекти користе <code>cargo</code> тако да је унификован начин изградње
пројеката. Углавном се своди на:
</p>

<div class="org-src-container">

<pre><code class="sh" >$ git clone example.org/someproject
$ cd someproject
$ cargo build
</code></pre>
</div>
</section>
</section>
<section>
<section id="slide-4">
<h2 id="4"><span class="section-number-2">4.</span> Игра погађања бројева</h2>
<div class="outline-text-2" id="text-4">
</div>
</section>
<section id="slide-4-1">
<h3 id="4-1"><span class="section-number-3">4.1.</span> Подешавање пројекта</h3>
<div class="org-src-container">

<pre><code class="rust" >$ cargo new guessing_game
$ cd guessing_game
</code></pre>
</div>

<p>
Фајл <code>Cargo.toml</code>:
</p>
<div class="org-src-container">

<pre><code class="toml" >[package]
name = "guessing_game"
version = "0.1.0"
edition = "2021"

[dependencies]
</code></pre>
</div>

<p>
Фајл <code>src/main.rs</code>:
</p>
<div class="org-src-container">

<pre><code class="rust" >fn main() {
    println!("Hello, world!");
}
</code></pre>
</div>

</section>
<section>

<div class="org-src-container">

<pre><code class="sh" >$ cargo run
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
    Finished dev [unoptimized + debuginfo] target(s) in 1.50s
     Running `target/debug/guessing_game`
Hello, world!
</code></pre>
</div>

</section>
<section id="slide-4-2">
<h3 id="4-2"><span class="section-number-3">4.2.</span> Преузимање броја са стандардног улаза</h3>
<div class="org-src-container">

<pre><code class="rust" >use std::io;

fn main() {
    println!("Guess the number!");

    println!("Please input your guess.");

    let mut guess = String::new();

    io::stdin()
        .read_line(&amp;mut guess)
        .expect("Failed to read line");

    println!("You guessed: {}", guess);
}
</code></pre>
</div>

</section>
<section id="slide-4-3">
<h3 id="4-3"><span class="section-number-3">4.3.</span> Променљивост (<i>mutability</i>)</h3>
<ul>
<li>Варијабле су подразумевано непромењиве (<i>immutable</i>).</li>
<li><p>
Уколико желимо варијаблу чија вредност може да се мења користимо кључну реч
<code>mut</code>.
</p>

<div class="org-src-container">

<pre><code class="rust" >  let apples = 5; // immutable
  let mut bananas = 5; // mutable
</code></pre>
</div></li>

<li><p>
Исто важи и за параметре и аргументе функција:
</p>

<div class="org-src-container">

<pre><code class="rust" >  io::stdin()
      .read_line(&amp;mut guess)
</code></pre>
</div></li>

</ul>

</section>
<section id="slide-4-4">
<h3 id="4-4"><span class="section-number-3">4.4.</span> Обрада могућих грешака употребом <code>Result</code> типа</h3>
<p>
<code>read_line</code> може да заврши неуспешно. Зато враћа <code>io::Result</code> тип који представља
тип енумерације (<i>enum</i>) и има две могуће вредности: <code>Ok</code> и <code>Err</code>.
</p>

<div class="org-src-container">

<pre><code class="rust" >io::stdin()
    .read_line(&amp;mut guess)
    .expect("Failed to read line");
</code></pre>
</div>

<p>
<code>expect</code> je имплементиран тако да ће у случају <code>Ok</code> варијанте вратити вредност која
је садржана унутар варијанте док ће у случају <code>Err</code> варијанте прекинути извршавање
програма.
</p>

<div class="org-src-container">

<pre><code class="rust" >pub fn expect(self, msg: &amp;str) -&gt; T
    where
        E: fmt::Debug,
    {
        match self {
            Ok(t) =&gt; t,
            Err(e) =&gt; unwrap_failed(msg, &amp;e),
        }
    }
</code></pre>
</div>

</section>
<section id="slide-4-5">
<h3 id="4-5"><span class="section-number-3">4.5.</span> Покретање</h3>
<div class="org-src-container">

<pre><code class="rust" >$ cargo run
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
    Finished dev [unoptimized + debuginfo] target(s) in 6.44s
     Running `target/debug/guessing_game`
Guess the number!
Please input your guess.
6
You guessed: 6
</code></pre>
</div>

</section>
<section id="slide-4-6">
<h3 id="4-6"><span class="section-number-3">4.6.</span> Генерисање случајног броја</h3>
<p>
Користимо <code>rand</code> пакет (сандук - <i>crate</i> у терминологији <i>Cargo</i>-a).
</p>

<p>
Секција <code>[dependencies]</code> у фајлу <code>Cargo.toml</code>:
</p>
<div class="org-src-container">

<pre><code class="toml" >[dependencies]
rand = "0.8.3"
</code></pre>
</div>

<div class="org-src-container">

<pre><code class="sh" >$ cargo build
    Updating crates.io index
  Downloaded rand v0.8.3
  Downloaded libc v0.2.86
  ...
   Compiling rand_chacha v0.3.0
   Compiling rand v0.8.3
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
    Finished dev [unoptimized + debuginfo] target(s) in 2.53s
</code></pre>
</div>

<p>
<i>Cargo</i> користи <a href="https://semver.org/">Semantic Versioning</a>. Раст пакети се преузимају са сајта <a href="https://crates.io/">crates.io</a>
и кеширају локално.
</p>

</section>
<section id="slide-4-7">
<h3 id="4-7"><span class="section-number-3">4.7.</span> Поновљивост изградње - <i>Cargo.lock</i></h3>
<ul>
<li>Свако следеће покретање изградње користи исте верзије.</li>
<li>Први пут када се покрене <code>cargo build</code> креира се фајл <code>Cargo.lock</code> са
информацијама о верзијама свих сандука који су инсталирани.</li>
<li><code>Cargo.lock</code> је потребно чувати у систему контроле верзија (нпр. <code>git</code>) да би се
осигурала поновљивост.</li>

</ul>

</section>
<section id="slide-4-8">
<h3 id="4-8"><span class="section-number-3">4.8.</span> Ажурирање сандука</h3>
<ul>
<li><p>
Ажурирање на нове верзије сандука се обавља са:
</p>

<div class="org-src-container">

<pre><code class="sh" >  $ cargo update
    Updating crates.io index
    Updating rand v0.8.3 -&gt; v0.8.4
</code></pre>
</div></li>
<li>Поштује се семантичко верзионирање тј. аутоматски се ажурира на следећу
верзију која је мања од наредне главне (<i>major</i>) верзије.</li>
<li>Ако прелазимо на нову главну верзију то морамо урадити изменом верзије у
<code>Cargo.toml</code> фајлу.</li>

</ul>

</section>
<section id="slide-4-9">
<h3 id="4-9"><span class="section-number-3">4.9.</span> Генерисање случајног броја</h3>
<p>
Фајл <code>src/main.rs</code>:
</p>
<div class="org-src-container">

<pre><code class="rust" >use std::io;
use rand::Rng;

fn main() {
    println!("Guess the number!");

    let secret_number = rand::thread_rng().gen_range(1..101);

    println!("The secret number is: {}", secret_number);

    println!("Please input your guess.");

    let mut guess = String::new();

    io::stdin()
        .read_line(&amp;mut guess)
        .expect("Failed to read line");

    println!("You guessed: {}", guess);
}
</code></pre>
</div>

<p>
У <code>gen_range</code> користимо израз опсега (<i>range expression</i>). Интервал је затворен на
доњој граници и отворен на горњој. За интервал затворен и од горе можемо
писати <code>1..=100</code>.
</p>

</section>
<section id="slide-4-10">
<h3 id="4-10"><span class="section-number-3">4.10.</span> Документација за локалне сандуке</h3>
<p>
Да би знали које методе и функције су нам доступне можемо користити уграђену
документацију за сандуке пројекта. Документацију добијамо са:
</p>

<div class="org-src-container">

<pre><code class="sh" >cargo doc --open
</code></pre>
</div>

</section>
<section id="slide-4-11">
<h3 id="4-11"><span class="section-number-3">4.11.</span> Покретање програма</h3>
<div class="org-src-container">

<pre><code class="sh" >$ cargo run
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
    Finished dev [unoptimized + debuginfo] target(s) in 2.53s
     Running `target/debug/guessing_game`
Guess the number!
The secret number is: 7
Please input your guess.
4
You guessed: 4
</code></pre>
</div>

</section>
<section id="slide-4-12">
<h3 id="4-12"><span class="section-number-3">4.12.</span> Поређење тајног броја са задатим</h3>
<p>
Фајл <code>src/main.rs</code>
</p>
<div class="org-src-container">

<pre><code class="rust" >use rand::Rng;
use std::cmp::Ordering;
use std::io;

fn main() {
    // --snip--

    println!("You guessed: {}", guess);

    match guess.cmp(&amp;secret_number) {
        Ordering::Less =&gt; println!("Too small!"),
        Ordering::Greater =&gt; println!("Too big!"),
        Ordering::Equal =&gt; println!("You win!"),
    }
}
</code></pre>
</div>
<ul>
<li>Користимо <code>std::cmp::Ordering</code> енумерисани тип који има варијанте <code>Less</code>, <code>Greater</code>
и <code>Equal</code></li>
<li><code>match</code> израз пореди задату вредност са вредностима задатим у телу и извршава
грану која се подудара. Гране <code>match</code> израза се у Раст терминологији зову "руке"
(<i>arms</i>).</li>

</ul>

</section>
<section id="slide-4-13">
<h3 id="4-13"><span class="section-number-3">4.13.</span> Поправка типова</h3>
<p>
Код са претходног слајда није исправан:
</p>
<div class="org-src-container">

<pre><code class="sh" >$ cargo build
   Compiling libc v0.2.86
   ...
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
error[E0308]: mismatched types
  --&gt; src/main.rs:22:21
   |
22 |     match guess.cmp(&amp;secret_number) {
   |                     ^^^^^^^^^^^^^^ expected struct `String`, found integer
   |
   = note: expected reference `&amp;String`
              found reference `&amp;{integer}`

error[E0283]: type annotations needed for `{integer}`
   --&gt; src/main.rs:8:44
    |
8   |     let secret_number = rand::thread_rng().gen_range(1..101);
    |         -------------                      ^^^^^^^^^ cannot infer type for type `{integer}`
    |         |
    |         consider giving `secret_number` a type
    |
    = note: multiple `impl`s satisfying `{integer}: SampleUniform` found in the `rand` crate:
            - impl SampleUniform for i128;
            - impl SampleUniform for i16;
            - impl SampleUniform for i32;
            - impl SampleUniform for i64;
            and 8 more
...
</code></pre>
</div>

</section>
<section>

<p>
Основа грешке је неслагање типова. Са улаза прихватамо <code>String</code> док нам је тајни
број <code>integer</code>.
</p>

</section>
<section id="slide-4-14">
<h3 id="4-14"><span class="section-number-3">4.14.</span> Конверзија стринга у број</h3>
<p>
Проблем решавамо конверзијом стринга са улаза у бројни тип.
</p>

<div class="org-src-container">

<pre><code class="rust" >// --snip--

    let mut guess = String::new();

    io::stdin()
        .read_line(&amp;mut guess)
        .expect("Failed to read line");

    let guess: u32 = guess.trim().parse().expect("Please type a number!");

    println!("You guessed: {}", guess);

    match guess.cmp(&amp;secret_number) {
        Ordering::Less =&gt; println!("Too small!"),
        Ordering::Greater =&gt; println!("Too big!"),
        Ordering::Equal =&gt; println!("You win!"),
    }
</code></pre>
</div>

</section>
<section>

<p>
Сада се програм компајлира.
</p>

<div class="org-src-container">

<pre><code class="sh" >$ cargo run
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
    Finished dev [unoptimized + debuginfo] target(s) in 0.43s
     Running `target/debug/guessing_game`
Guess the number!
The secret number is: 58
Please input your guess.
  76
You guessed: 76
Too big!
</code></pre>
</div>

</section>
<section id="slide-4-15">
<h3 id="4-15"><span class="section-number-3">4.15.</span> Омогућавање вишеструког погађања - употреба петље</h3>
<p>
Фајл <code>src/main.rs</code>:
</p>
<div class="org-src-container">

<pre><code class="rust" >// --snip--

    println!("The secret number is: {}", secret_number);

    loop {
        println!("Please input your guess.");

        // --snip--

        match guess.cmp(&amp;secret_number) {
            Ordering::Less =&gt; println!("Too small!"),
            Ordering::Greater =&gt; println!("Too big!"),
            Ordering::Equal =&gt; println!("You win!"),
        }
    }
}
</code></pre>
</div>

</section>
<section id="slide-4-16">
<h3 id="4-16"><span class="section-number-3">4.16.</span> Прекид рада</h3>
<p>
Проблем је како прекинути програм када корисник погоди број?
</p>

<div class="org-src-container">

<pre><code class="rust" >// --snip--

        match guess.cmp(&amp;secret_number) {
            Ordering::Less =&gt; println!("Too small!"),
            Ordering::Greater =&gt; println!("Too big!"),
            Ordering::Equal =&gt; {
                println!("You win!");
                break;
            }
        }
    }
}
</code></pre>
</div>

</section>
<section id="slide-4-17">
<h3 id="4-17"><span class="section-number-3">4.17.</span> Руковање неисправним улазом</h3>
<div class="org-src-container">

<pre><code class="rust" >// --snip--

        io::stdin()
            .read_line(&amp;mut guess)
            .expect("Failed to read line");

        let guess: u32 = match guess.trim().parse() {
            Ok(num) =&gt; num,
            Err(_) =&gt; continue,
        };

        println!("You guessed: {}", guess);

        // --snip--
</code></pre>
</div>

<p>
Потребно је још обрисати линију која приказује генерисани број.
</p>

</section>
<section id="slide-4-18">
<h3 id="4-18"><span class="section-number-3">4.18.</span> Финални код</h3>
<div class="org-src-container">

<pre><code class="rust" >use rand::Rng;
use std::cmp::Ordering;
use std::io;

fn main() {
    println!("Guess the number!");
    let secret_number = rand::thread_rng().gen_range(1..101);

    loop {
        println!("Please input your guess.");
        let mut guess = String::new();
        io::stdin()
            .read_line(&amp;mut guess)
            .expect("Failed to read line");
        let guess: u32 = match guess.trim().parse() {
            Ok(num) =&gt; num,
            Err(_) =&gt; continue,
        };
        println!("You guessed: {}", guess);
        match guess.cmp(&amp;secret_number) {
            Ordering::Less =&gt; println!("Too small!"),
            Ordering::Greater =&gt; println!("Too big!"),
            Ordering::Equal =&gt; {
                println!("You win!");
                break;
            }
        }
    }
}
</code></pre>
</div>

</section>
</section>
<section>
<section id="slide-5">
<h2 id="5"><span class="section-number-2">5.</span> Основни програмски концепти</h2>
<div class="outline-text-2" id="text-5">
</div>
</section>
<section id="slide-5-1">
<h3 id="5-1"><span class="section-number-3">5.1.</span> Варијабле и променљивост (<i>mutability</i>)</h3>
<div class="outline-text-3" id="text-5-1">
</div>
</section>
<section id="slide-5-1-1">
<h4 id="5-1-1"><span class="section-number-4">5.1.1.</span> Варијабле и променљивост (<i>mutability</i>)</h4>
<ul>
<li>Варијабле су подразумевано непромењиве.</li>
<li><p>
Једном када добију вредност (<i>binding</i>) та вредност се не може променити
</p>

<div class="org-src-container">

<pre><code class="rust" >    fn main() {
        let x = 5;
        println!("The value of x is: {}", x);
        x = 6;     // greška
        println!("The value of x is: {}", x);
    }
</code></pre>
</div>

</section>
<section>

<div class="org-src-container">

<pre><code class="sh" >    $ cargo run
    Compiling variables v0.1.0 (file:///projects/variables)
    error[E0384]: cannot assign twice to immutable variable `x`
    --&gt; src/main.rs:4:5
    |
    2 |     let x = 5;
    |         -
    |         |
    |         first assignment to `x`
    |         help: consider making this binding mutable: `mut x`
    3 |     println!("The value of x is: {}", x);
    4 |     x = 6;
    |     ^^^^^ cannot assign twice to immutable variable

    For more information about this error, try `rustc --explain E0384`.
    error: could not compile `variables` due to previous error
</code></pre>
</div></li>

</ul>
</section>
<section id="slide-5-1-2">
<h4 id="5-1-2"><span class="section-number-4">5.1.2.</span> <code>mut</code> кључна реч</h4>
<div class="org-src-container">

<pre><code class="rust" >fn main() {
    let mut x = 5;
    println!("The value of x is: {}", x);
    x = 6;
    println!("The value of x is: {}", x);
}
</code></pre>
</div>
</section>
<section id="slide-5-2">
<h3 id="5-2"><span class="section-number-3">5.2.</span> Константе - <code>const</code></h3>
<ul>
<li>Слично као непромењиве варијабле са следећим разликама:
<ul>
<li>Увек су непромењиве</li>
<li>Могу се иницијализовати само константним изразом (познатим у време
компајлирања)</li>
<li>Валидне за целокупно време извршавања програма у опсегу важења где су
дефинисане (<i>scope</i>)</li>
<li>Мора се експлицитно дефинисати тип</li>

</ul></li>
<li>Компајлер ће константе "убацити" на месту употребе</li>
<li><p>
По конвенцији имена константи се пишу великим словима
</p>

<div class="org-src-container">

<pre><code class="rust" >    const THREE_HOURS_IN_SECONDS: u32 = 60 * 60 * 3;
</code></pre>
</div></li>

</ul>

</section>
<section id="slide-5-3">
<h3 id="5-3"><span class="section-number-3">5.3.</span> Типови података</h3>
<div class="outline-text-3" id="text-5-3">
</div>
</section>
<section id="slide-5-3-1">
<h4 id="5-3-1"><span class="section-number-4">5.3.1.</span> Типови података</h4>
<ul>
<li>Свака вредност у Расту има тип. Типови морају бити познати у време
компајлирања (<i>статички типизиран језик</i>).</li>
<li><p>
Компајлер ће пробати да одреди типове (<i>type inference</i>). Ако није могуће
захтева се да дефинишемо тип експлицитно.
</p>

<p>
Нпр:
</p>
<div class="org-src-container">

<pre><code class="rust" >    let guess: u32 = "42".parse().expect("Not a number!");
</code></pre>
</div>
<p>
Овде није могуће одредити тип јер <code>str::parse</code> функција може вратити различите
бројне типове (функција је генеричка) а не постоји начин да се тип аутоматски
одреди.
</p>

<p>
Сигнатура је:
</p>
<div class="org-src-container">

<pre><code class="rust" >    pub fn parse&lt;F&gt;(&amp;self) -&gt; Result&lt;F, &lt;F as FromStr&gt;::Err&gt;
    where
        F: FromStr
</code></pre>
</div></li>

</ul>
</section>
<section id="slide-5-3-2">
<h4 id="5-3-2"><span class="section-number-4">5.3.2.</span> <i>Integer</i> типови</h4>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">Дужина</th>
<th scope="col" class="org-left">Signed</th>
<th scope="col" class="org-left">Unsigned</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">8-bit</td>
<td class="org-left">i8</td>
<td class="org-left">u8</td>
</tr>

<tr>
<td class="org-left">16-bit</td>
<td class="org-left">i16</td>
<td class="org-left">u16</td>
</tr>

<tr>
<td class="org-left">32-bit</td>
<td class="org-left">i32</td>
<td class="org-left">u32</td>
</tr>

<tr>
<td class="org-left">64-bit</td>
<td class="org-left">i64</td>
<td class="org-left">u64</td>
</tr>

<tr>
<td class="org-left">128-bit</td>
<td class="org-left">i128</td>
<td class="org-left">u128</td>
</tr>

<tr>
<td class="org-left">arch</td>
<td class="org-left">isize</td>
<td class="org-left">usize</td>
</tr>
</tbody>
</table>

</section>
<section id="slide-5-3-3">
<h4 id="5-3-3"><span class="section-number-4">5.3.3.</span> Литерали бројева</h4>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">Литерали</th>
<th scope="col" class="org-left">Примери</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">Decimal</td>
<td class="org-left">98_222</td>
</tr>

<tr>
<td class="org-left">Hex</td>
<td class="org-left">0xff</td>
</tr>

<tr>
<td class="org-left">Octal</td>
<td class="org-left">0o77</td>
</tr>

<tr>
<td class="org-left">Binary</td>
<td class="org-left">0b1111_0000</td>
</tr>

<tr>
<td class="org-left">Byte (u8 only)</td>
<td class="org-left">b'A'</td>
</tr>
</tbody>
</table>

</section>
<section id="slide-5-3-4">
<h4 id="5-3-4"><span class="section-number-4">5.3.4.</span> <i>Floating-Point</i> типови</h4>
<div class="org-src-container">

<pre><code class="rust" >fn main() {
    let x = 2.0; // f64

    let y: f32 = 3.0; // f32
}
</code></pre>
</div>

<p>
IEEE-754 стандард
</p>

</section>
<section id="slide-5-3-5">
<h4 id="5-3-5"><span class="section-number-4">5.3.5.</span> Операције над бројевима</h4>
<div class="org-src-container">

<pre><code class="rust" >fn main() {
    // addition
    let sum = 5 + 10;

    // subtraction
    let difference = 95.5 - 4.3;

    // multiplication
    let product = 4 * 30;

    // division
    let quotient = 56.7 / 32.2;
    let floored = 2 / 3; // Results in 0

    // remainder
    let remainder = 43 % 5;
}
</code></pre>
</div>

</section>
<section id="slide-5-3-6">
<h4 id="5-3-6"><span class="section-number-4">5.3.6.</span> <i>Boolean</i> тип</h4>
<div class="org-src-container">

<pre><code class="rust" >fn main() {
    let t = true;

    let f: bool = false; // with explicit type annotation
}
</code></pre>
</div>

</section>
<section id="slide-5-3-7">
<h4 id="5-3-7"><span class="section-number-4">5.3.7.</span> Тип карактера</h4>
<div class="org-src-container">

<pre><code class="rust" >fn main() {
    let c = 'z';
    let z = 'ℤ';
    let heart_eyed_cat = '😻';
}
</code></pre>
</div>

</section>
<section id="slide-5-3-8">
<h4 id="5-3-8"><span class="section-number-4">5.3.8.</span> Торке (<i>tuples</i>)</h4>
<div class="org-src-container">

<pre><code class="rust" >fn main() {
    let tup: (i32, f64, u8) = (500, 6.4, 1);
}
</code></pre>
</div>

<ul>
<li>Распакивање торки (<i>destructuring</i>):</li>

</ul>
<div class="org-src-container">

<pre><code class="rust" >fn main() {
    let tup = (500, 6.4, 1);

    let (x, y, z) = tup;

    println!("The value of y is: {}", y);
}
</code></pre>
</div>

</section>
<section>

<p>
Приступ елементима торке:
</p>
<div class="org-src-container">

<pre><code class="rust" >fn main() {
    let x: (i32, f64, u8) = (500, 6.4, 1);

    let five_hundred = x.0;

    let six_point_four = x.1;

    let one = x.2;
}
</code></pre>
</div>

</section>
<section id="slide-5-3-9">
<h4 id="5-3-9"><span class="section-number-4">5.3.9.</span> Низовни тип</h4>
<ul>
<li>Сваки елемент низовног типа мора имати исти тип</li>
<li><p>
Димензија низа је непромењива (алоциран је на стеку)
</p>
<div class="org-src-container">

<pre><code class="rust" >    fn main() {
        let a = [1, 2, 3, 4, 5];
    }
</code></pre>
</div></li>

<li><p>
Тип се може експлицитно дефинисати на следећи начин (низ дужине <code>5</code> типа <code>i32</code>):
</p>
<div class="org-src-container">

<pre><code class="rust" >    let a: [i32; 5] = [1, 2, 3, 4, 5];
</code></pre>
</div></li>

<li><p>
Иницијализација свих елемената на исту вредност се обавља на следећи начин:
</p>
<div class="org-src-container">

<pre><code class="rust" >  let a = [3; 5];
</code></pre>
</div>
<p>
Где је вредност сваког елемента <code>3</code> а дужина низа <code>5</code>.
</p></li>

</ul>

</section>
<section>

<p>
Индексни приступ:
</p>

<div class="org-src-container">

<pre><code class="rust" >fn main() {
    let a = [1, 2, 3, 4, 5];

    let first = a[0];
    let second = a[1];
}
</code></pre>
</div>

</section>
<section id="slide-5-4">
<h3 id="5-4"><span class="section-number-3">5.4.</span> Функције</h3>
<div class="outline-text-3" id="text-5-4">
</div>
</section>
<section id="slide-5-4-1">
<h4 id="5-4-1"><span class="section-number-4">5.4.1.</span> Функције</h4>
<div class="org-src-container">

<pre><code class="rust" >fn main() {
    println!("Hello, world!");

    another_function();
}

fn another_function() {
    println!("Another function.");
}
</code></pre>
</div>
<ul>
<li>За именовање функција као и варијабли користи се <i>snake_case</i>.</li>

</ul>
</section>
<section id="slide-5-4-2">
<h4 id="5-4-2"><span class="section-number-4">5.4.2.</span> Funkcije - parametri</h4>
<div class="org-src-container">

<pre><code class="rust" >fn main() {
    print_labeled_measurement(5, 'h');
}

fn print_labeled_measurement(value: i32, unit_label: char) {
    println!("The measurement is: {}{}", value, unit_label);
}
</code></pre>
</div>

</section>
<section id="slide-5-4-3">
<h4 id="5-4-3"><span class="section-number-4">5.4.3.</span> Искази и изрази</h4>
<ul>
<li>Рaст је језик базиран на изразима (<i>expression-based</i>)</li>
<li>Искази (<i>statements</i>) су језичке конструкције које немају повратну вредност.
Изрази (<i>expressions</i>) се евалуирају у одређени резултат, тј. имају вредност.</li>
<li><p>
Пример: <code>let</code> је исказ тј. нема повратну вредност. Ово можете писати:
</p>
<div class="org-src-container">

<pre><code class="rust" >  let y = 6;
</code></pre>
</div>
<p>
Ali ovo ne:
</p>
<div class="org-src-container">

<pre><code class="rust" >  let x = (let y = 6);
</code></pre>
</div></li>

</ul>

</section>
<section>

<p>
Блок кода је такође израз. Шта је вредност у коју се евалуира?
</p>

<div class="org-src-container">

<pre><code class="rust" >{
    let x = 3;
    x + 1
}
</code></pre>
</div>

<p>
Вредност блока је вредност последњег израза, тј. <code>x+1</code>. Приметите да ту не
користимо <code>;</code> јер терминација овим карактером претвара израз у исказ.
</p>

</section>
<section>

<p>
Због овога је сасвим легално да пишемо:
</p>

<div class="org-src-container">

<pre><code class="rust" >fn main() {
    let y = {
        let x = 3;
        x + 1
    };

    println!("The value of y is: {}", y);
}
</code></pre>
</div>

<pre class="example">
The value of y is: 4
</pre>
</section>
<section id="slide-5-4-4">
<h4 id="5-4-4"><span class="section-number-4">5.4.4.</span> Повратне вредности функција</h4>
<p>
Вредност функције је вредност блока који представља тело функције, дакле
последњег израза унутар тела функције.
</p>

<div class="org-src-container">

<pre><code class="rust" >fn five() -&gt; i32 {
    5
}

fn main() {
    let x = five();

    println!("The value of x is: {}", x);
}
</code></pre>
</div>

<pre class="example">
The value of x is: 5
</pre>


</section>
<section>

<p>
Или на пример:
</p>
<div class="org-src-container">

<pre><code class="rust" >fn main() {
    let x = plus_one(5);

    println!("The value of x is: {}", x);
}

fn plus_one(x: i32) -&gt; i32 {
    x + 1
}
</code></pre>
</div>

<pre class="example">
The value of x is: 6
</pre>


</section>
<section>

<p>
Уколико израз <code>x+1</code> терминирамо са <code>;</code> код се неће компајлирати јер функција
декларише да враћа тип <code>i32</code> док сада враћа <code>()</code> (тзв. <i>unit type</i>) односно нема
повратну вредност јер је последња инструкција исказ.
</p>

<div class="org-src-container">

<pre><code class="rust" >fn main() {
    let x = plus_one(5);

    println!("The value of x is: {}", x);
}

fn plus_one(x: i32) -&gt; i32 {
    x + 1;
}
</code></pre>
</div>

<pre class="example" id="org8e8d30b">
error[E0308]: mismatched types
 --&gt; src/main.rs:8:24
  |
8 | fn plus_one(x: i32) -&gt; i32 {
  |    --------            ^^^ expected `i32`, found `()`
  |    |
  |    implicitly returns `()` as its body has no tail or `return` expression
9 |     x + 1;
  |          - help: consider removing this semicolon

For more information about this error, try `rustc --explain E0308`.
error: could not compile `cargo4UyKF0` due to previous error
</pre>

</section>
<section id="slide-5-5">
<h3 id="5-5"><span class="section-number-3">5.5.</span> Коментари</h3>
<p>
Коментари се пишу после <code>//</code> или у форми блок коментара <code>/*.... */</code> као и у C++-у.
Ово би били валидни коментари:
</p>
<div class="org-src-container">

<pre><code class="rust" >// So we’re doing something complicated here, long enough that we need
// multiple lines of comments to do it! Whew! Hopefully, this comment will
// explain what’s going on.

fn main() {
    let lucky_number = 7; // I’m feeling lucky today
}
...
fn main() {
    // I’m feeling lucky today
    let lucky_number = 7;
    /* this is block comment
       which can span multiple lines.
       Nesting is allowed.
     */
}
</code></pre>
</div>

</section>
<section>

<p>
Постоје и коментари за документацију који представљају посебну синтаксу за
коментаре који су део API документације. Они се пишу после <code>///</code>. На пример:
</p>
<div class="org-src-container">

<pre><code class="rust" >/// Adds one to the number given.
///
/// # Examples
///
/// ```
/// let arg = 5;
/// let answer = my_crate::add_one(arg);
///
/// assert_eq!(6, answer);
/// ```
pub fn add_one(x: i32) -&gt; i32 {
    x + 1
}
</code></pre>
</div>
</section>
<section id="slide-5-6">
<h3 id="5-6"><span class="section-number-3">5.6.</span> Контрола тока</h3>
<div class="outline-text-3" id="text-5-6">
</div>
</section>
<section id="slide-5-6-1">
<h4 id="5-6-1"><span class="section-number-4">5.6.1.</span> <code>if</code> изрази</h4>
<div class="org-src-container">

<pre><code class="rust" >fn main() {
    let number = 3;

    if number &lt; 5 {
        println!("condition was true");
    } else {
        println!("condition was false");
    }
}
</code></pre>
</div>

</section>
<section id="slide-5-6-2">
<h4 id="5-6-2"><span class="section-number-4">5.6.2.</span> <code>if-else</code></h4>
<div class="org-src-container">

<pre><code class="rust" >fn main() {
    let number = 6;

    if number % 4 == 0 {
        println!("number is divisible by 4");
    } else if number % 3 == 0 {
        println!("number is divisible by 3");
    } else if number % 2 == 0 {
        println!("number is divisible by 2");
    } else {
        println!("number is not divisible by 4, 3, or 2");
    }
}
</code></pre>
</div>
</section>
<section id="slide-5-6-3">
<h4 id="5-6-3"><span class="section-number-4">5.6.3.</span> <code>if</code> у <code>let</code> исказима</h4>
<p>
<code>if</code> је израз па се може користити где год можемо писати и било који други израз.
</p>

<div class="org-src-container">

<pre><code class="rust" >fn main() {
    let condition = true;
    let number = if condition { 5 } else { 6 };

    println!("The value of number is: {}", number);
}
</code></pre>
</div>

<pre class="example">
The value of number is: 5
</pre>


</section>
<section>

<p>
Али се гране морају слагати по типу. Ово је погрешно јер је прва грана типа
<code>i32</code> док је <code>else</code> грана типа <code>str</code>.
</p>

<div class="org-src-container">

<pre><code class="rust" >fn main() {
    let condition = true;

    let number = if condition { 5 } else { "six" };

    println!("The value of number is: {}", number);
}
</code></pre>
</div>
</section>
<section id="slide-5-6-4">
<h4 id="5-6-4"><span class="section-number-4">5.6.4.</span> Петље</h4>
<p>
Рaст има три типа петље:
</p>
<ul>
<li><code>loop</code> - за бесконачне петље</li>
<li><code>while</code> - условна петља</li>
<li><code>for</code> - петља за итерацију кроз елементе итерабилних типова</li>

</ul>

</section>
<section id="slide-5-6-5">
<h4 id="5-6-5"><span class="section-number-4">5.6.5.</span> <code>loop</code></h4>
<div class="org-src-container">

<pre><code class="rust" >fn main() {
    loop {
        println!("again!");
    }
}
</code></pre>
</div>

</section>
<section id="slide-5-6-6">
<h4 id="5-6-6"><span class="section-number-4">5.6.6.</span> <code>loop</code> лабеле</h4>
<p>
Уколико имамо угњеждене <code>loop</code> исказе можемо користити лабеле приликом изласка са
<code>break</code> инструкцијом.
</p>

<div class="org-src-container">

<pre><code class="rust" >fn main() {
    let mut count = 0;
    'counting_up: loop {
        println!("count = {}", count);
        let mut remaining = 10;

        loop {
            println!("remaining = {}", remaining);
            if remaining == 9 {
                break;
            }
            if count == 2 {
                break 'counting_up;
            }
            remaining -= 1;
        }

        count += 1;
    }
    println!("End count = {}", count);
}
</code></pre>
</div>

</section>
<section id="slide-5-6-7">
<h4 id="5-6-7"><span class="section-number-4">5.6.7.</span> <code>loop</code> као израз</h4>
<p>
<code>loop</code> може имати повратну вредност. Повратна вредност се дефинише као параметар
<code>break</code> инструкције.
</p>

<div class="org-src-container">

<pre><code class="rust" >fn main() {
    let mut counter = 0;

    let result = loop {
        counter += 1;

        if counter == 10 {
            break counter * 2;
        }
    };

    println!("The result is {}", result);
}
</code></pre>
</div>
</section>
<section id="slide-5-6-8">
<h4 id="5-6-8"><span class="section-number-4">5.6.8.</span> <code>while</code></h4>
<div class="org-src-container">

<pre><code class="rust" >fn main() {
    let mut number = 3;

    while number != 0 {
        println!("{}!", number);

        number -= 1;
    }

    println!("LIFTOFF!!!");
}
</code></pre>
</div>
</section>
<section id="slide-5-6-9">
<h4 id="5-6-9"><span class="section-number-4">5.6.9.</span> <code>for</code></h4>
<p>
Итерацију кроз уређену колекцију, као што је низ, можемо обавити са <code>while</code> петљом.
</p>
<div class="org-src-container">

<pre><code class="rust" >fn main() {
    let a = [10, 20, 30, 40, 50];
    let mut index = 0;

    while index &lt; 5 {
        println!("the value is: {}", a[index]);

        index += 1;
    }
}
</code></pre>
</div>

</section>
<section>
<p>
Али је за ту намену природније и сигурније користити <code>for</code> петљу. Такође ће се
програм брже извршавати.
</p>

<div class="org-src-container">

<pre><code class="rust" >fn main() {
    let a = [10, 20, 30, 40, 50];

    for element in a {
        println!("the value is: {}", element);
    }
}
</code></pre>
</div>

</section>
<section>
<p>
<code>for</code> петље су најчешћи облик петљи у употреби у Расту. Користе се нпр. и у
ситуацији када је потребно извршити петљу одређени број пута.
</p>

<div class="org-src-container">

<pre><code class="rust" >fn main() {
    for number in (1..4).rev() {
        println!("{}!", number);
    }
    println!("LIFTOFF!!!");
}
</code></pre>
</div>

<pre class="example">
3!
2!
1!
LIFTOFF!!!
</pre>
</section>
<section id="slide-5-6-10">
<h4 id="5-6-10"><span class="section-number-4">5.6.10.</span> <code>for</code> и итератори</h4>
<p>
Приликом итерације употребом <code>for</code> исказа имплицитно се позива метода
<code>into_iter()</code> над колекцијом. Ова метода конзумира елементе колекције.
</p>

<div class="org-src-container">

<pre><code class="rust" >fn main() {
    let names = vec!["Bob", "Frank", "Ferris"];

    for name in names.into_iter() {
        match name {
            "Ferris" =&gt; println!("There is a rustacean among us!"),
            _ =&gt; println!("Hello {}", name),
        }
    }

    // println!("names: {:?}", names); -- FIXME: колекција овде није доступна
}
</code></pre>
</div>

</section>
<section>

<div class="org-src-container">

<pre><code class="rust" >fn main() {
    let names = vec!["Bob", "Frank", "Ferris"];

    for name in names.iter() {
        match name {
            &amp;"Ferris" =&gt; println!("There is a rustacean among us!"),
            // TODO ^ Try deleting the &amp; and matching just "Ferris"
            _ =&gt; println!("Hello {}", name),
        }
    }

    println!("names: {:?}", names);
}
</code></pre>
</div>

<pre class="example">
Hello Bob
Hello Frank
There is a rustacean among us!
names: ["Bob", "Frank", "Ferris"]
</pre>


</section>
<section>

<div class="org-src-container">

<pre><code class="rust" >fn main() {
    let mut names = vec!["Bob", "Frank", "Ferris"];

    for name in names.iter_mut() {
        *name = match name {
            &amp;mut "Ferris" =&gt; "There is a rustacean among us!",
            _ =&gt; "Hello",
        }
    }

    println!("names: {:?}", names);
}
</code></pre>
</div>

<pre class="example">
names: ["Hello", "Hello", "There is a rustacean among us!"]
</pre>

</section>
</section>
<section>
<section id="slide-6">
<h2 id="6"><span class="section-number-2">6.</span> Власништво и позајмљивање (<i>Ownership and borrowing</i>)</h2>
<div class="outline-text-2" id="text-6">
</div>
</section>
<section id="slide-6-1">
<h3 id="6-1"><span class="section-number-3">6.1.</span> Власништво</h3>
<div class="outline-text-3" id="text-6-1">
</div>
</section>
<section id="slide-6-1-1">
<h4 id="6-1-1"><span class="section-number-4">6.1.1.</span> Власништво</h4>
<ul>
<li>Један од најважнијих концепата језика.</li>
<li>Скуп правила који омогућавају управљање меморијом.</li>
<li>Гаранције за меморијску сигурност без употребе <i>garbage collector</i>-а</li>
<li>Све провере се обављају у време компајлирања - резултује одличним
перформансама у време извршавања.</li>

</ul>

</section>
<section id="slide-6-1-2">
<h4 id="6-1-2"><span class="section-number-4">6.1.2.</span> Стек и хип (<i>Stack and Heap</i>)</h4>
<ul>
<li>Стек - алокација простора за податке чија је величина позната у време
компајлирања.
<ul>
<li>Бржа алокација и деалокација - једноставан механизам, LIFO структура.</li>
<li>Бржи приступ - локалне варијабле, кеширање приступа.</li>

</ul></li>
<li>Хип - слободна алокација у време извршавања.
<ul>
<li>Спорија алокација и деалокација.</li>
<li>Спорији приступ - произвољна локација.</li>

</ul></li>

</ul>

</section>
<section id="slide-6-1-3">
<h4 id="6-1-3"><span class="section-number-4">6.1.3.</span> Правила власништва</h4>
<ol>
<li>Свака вредност у Расту има варијаблу која се назива <i>власником</i> (<i>owner</i>).</li>
<li>У сваком тренутку постоји само један власник.</li>
<li>Када власник изађе из опсега важења (<i>scope</i>) вредност се деалоцира (<i>drop</i>).</li>

</ol>

</section>
<section id="slide-6-1-4">
<h4 id="6-1-4"><span class="section-number-4">6.1.4.</span> Опсег важења варијабле (<i>Variable Scope</i>)</h4>
<div class="org-src-container">

<pre><code class="rust" >{                      // s није валидно овде јер још није декларисано
    let s = "hello";   // s је валидно од ове позиције

    // користимо s
}   // овде опсег престаје да важи и s више није валидно
</code></pre>
</div>

</section>
<section id="slide-6-1-5">
<h4 id="6-1-5"><span class="section-number-4">6.1.5.</span> <code>String</code> тип</h4>
<ul>
<li><p>
Демонстрација власништва над типом који се алоцира на хипу.
</p>

<div class="org-src-container">

<pre><code class="rust" >  let mut s = String::from("hello");
  s.push_str(", world!"); // push_str() додаје литерал на стринг
  println!("{}", s); // hello, world!`
</code></pre>
</div></li>

<li>Меморија се алоцира са хипа у време извршавања.</li>
<li>Морамо вратити меморију алокатору када нам више није потребна.</li>

</ul>

</section>
<section>

<ul>
<li><p>
Алокација стринга се обавља на линији:
</p>

<div class="org-src-container">

<pre><code class="rust" >  let mut s = String::from("hello");
</code></pre>
</div></li>

<li>Али деалокација је тежа:
<ul>
<li><i>Garbage collector</i></li>
<li><i>Memory waste</i></li>
<li><i>Double-free</i></li>

</ul></li>

</ul>

</section>
<section>

<ul>
<li>Раст компајлер ће додати кôд који ради деалокацију када власник напусти опсег важења.</li>
<li><p>
Позива се функција <code>drop</code> над типом и ова функција је задужена да обави деалокацију.
</p>

<div class="org-src-container">

<pre><code class="rust" >  {
        let s = String::from("hello"); // s постаје валидно

        // користимо s
  }  // &lt;- s излази из опсега и позива се "drop"
</code></pre>
</div></li>

</ul>

</section>
<section id="slide-6-1-6">
<h4 id="6-1-6"><span class="section-number-4">6.1.6.</span> Додела вредности</h4>
<ul>
<li><p>
Копирање вредности <code>x</code> у <code>y</code>. Обе варијабле сада имају вредност <code>5</code>.
</p>

<div class="org-src-container">

<pre><code class="rust" >  let x = 5;
  let y = x;
</code></pre>
</div></li>

<li><p>
Али са <code>String</code> типом дешава се нешто друго.
</p>

<div class="org-src-container">

<pre><code class="rust" >  let s1 = String::from("hello");
</code></pre>
</div></li>

</ul>


<div id="org0cb1d2f" class="figure">
<p><img src="./images/string-type.png" alt="string-type.png" style="height: 400px;" />
</p>
</div>

</section>
<section>

<ul>
<li><p>
Ако би се копирао само садржај са стека имали бисмо следећу ситуацију (тзв.
<i>shallow copy</i>).
</p>

<div class="org-src-container">

<pre><code class="rust" >  let s1 = String::from("hello");
  let s2 = s1;
</code></pre>
</div></li>

</ul>


<div id="orge6a6277" class="figure">
<p><img src="./images/string-type-2.png" alt="string-type-2.png" style="height: 400px;" />
</p>
</div>

<p>
Што је проблематично јер када и <code>s1</code> и <code>s2</code> напусте опсег покушаће се двострука
деалокација исте меморије на хипу (<i>double free</i>).
</p>

</section>
<section>

<p>
Ако би се и хип меморија копирала (tzv. <i>deep copy</i>) имали бисмо валидну ситуацију
али би таква операција била веома "скупа".
</p>


<div id="orge55245f" class="figure">
<p><img src="./images/string-type-3.png" alt="string-type-3.png" style="height: 500px;" />
</p>
</div>

</section>
<section id="slide-6-1-7">
<h4 id="6-1-7"><span class="section-number-4">6.1.7.</span> Премештање (<i>Move</i>)</h4>
<p>
Ако пробамо да компајлирамо следећи код:
</p>

<div class="org-src-container">

<pre><code class="rust" >let s1 = String::from("hello");
let s2 = s1;

println!("{}, world!", s1);
</code></pre>
</div>

<p>
Добићемо грешку:
</p>

<pre class="example" id="orgc2651c3">
$ cargo run
   Compiling ownership v0.1.0 (file:///projects/ownership)
error[E0382]: borrow of moved value: `s1`
 --&gt; src/main.rs:5:28
  |
2 |     let s1 = String::from("hello");
  |         -- move occurs because `s1` has type `String`, which does not implement the `Copy` trait
3 |     let s2 = s1;
  |              -- value moved here
4 |
5 |     println!("{}, world!", s1);
  |                            ^^ value borrowed here after move

For more information about this error, try `rustc --explain E0382`.
error: could not compile `ownership` due to previous error
</pre>

</section>
<section>

<p>
Оно што нам компајлер каже је да се у исказу:
</p>

<div class="org-src-container">

<pre><code class="rust" >let s2 = s1;
</code></pre>
</div>

<p>
променио власник овог стринга. Нови власник је сада <code>s2</code> док је варијабла <code>s1</code>
постала невалидна и није је више могуће користити.
</p>

<p>
Кажемо да се обавило "премештање" (<i>move</i>) вредности из <code>s1</code> у <code>s2</code>.
</p>


<div id="org3c84cdc" class="figure">
<p><img src="./images/string-type-4.png" alt="string-type-4.png" style="height: 400px;" />
</p>
</div>

<p>
Чиме се испуњава прво правило власништва и спречава <i>double free</i> грешка.
</p>

</section>
<section id="slide-6-1-8">
<h4 id="6-1-8"><span class="section-number-4">6.1.8.</span> Клонирање</h4>
<p>
Последица претходног је да Раст никада неће аутоматски обавити дубоко копирање
варијабле јер би то могло да изазове лоше перформансе.
</p>

<p>
Дубоко копирање (стек+хип) радимо са <code>clone</code> методом:
</p>

<div class="org-src-container">

<pre><code class="rust" >let s1 = String::from("hello");
let s2 = s1.clone();

println!("s1 = {}, s2 = {}", s1, s2);
</code></pre>
</div>

<p>
Сада је лако пронаћи у коду сва места где се обавља потенцијално "скупа"
операција дубоког копирања.
</p>

</section>
<section id="slide-6-1-9">
<h4 id="6-1-9"><span class="section-number-4">6.1.9.</span> <i>Copy</i> типови</h4>
<p>
Како онда ради пример који смо видели претходно? Зашто не долази до премештања
и инвалидације <code>y</code> варијабле?
</p>

<div class="org-src-container">

<pre><code class="rust" >let x = 5;
let y = x;

println!("x = {}, y = {}", x, y);
</code></pre>
</div>

<ul>
<li>Код простих типова чија је величина позната у време компајлирања и који могу
у целости стати на стек нема разлике између дубоког и плитког копирања.</li>
<li>Овакви типови су анотирани са <i>Copy</i> особином (<i>Trait</i>). Типови који су на овај
начин анотирани не обављају премештање већ увек копирање.</li>
<li>Импликација је да се варијабла са десне стране доделе може користити и након
доделе.</li>
<li>Раст ће спречити <i>Copy</i> анотацију ако тип имплементира и <i>Drop</i> јер то значи да
ради неку специјалну алокацију па му је потребна и посебна деалокација што
значи да мора да се ради премештање.</li>

</ul>

</section>
<section id="slide-6-1-10">
<h4 id="6-1-10"><span class="section-number-4">6.1.10.</span> Власништво и функције</h4>
<ul>
<li>Семантика преноса параметара код позива функција је слична семантици доделе.</li>

</ul>

<div class="org-src-container">

<pre><code class="rust" >fn main() {
    let s = String::from("hello");  // s постаје валидно

    takes_ownership(s);             // s вредност се премешта у функцију...
                                    // ... тако да s није валидно од ове позиције

    let x = 5;                      // x постаје валидно

    makes_copy(x);                  // x би се преместило у функцију,
                                    // али i32 је Copy, тако да је ok
                                    // да се x користи и после

} // x излази из опсега, затим s. Али пошто је s премештено ништа посебно се
  // не дешава.

fn takes_ownership(some_string: String) { // some_string улази у опсег
    println!("{}", some_string);
} // some_string излази из опсега и позива се `drop`. Меморија са хипа се
  // ослобађа.

fn makes_copy(some_integer: i32) { // some_integer улази у опсег
    println!("{}", some_integer);
} // some_integer излази из опсега. Пошто није 'Drop', ништа посебно се не
  // догађа (осим "скидања" са стека наравно)
</code></pre>
</div>

</section>
<section id="slide-6-1-11">
<h4 id="6-1-11"><span class="section-number-4">6.1.11.</span> Повратне вредности и опсези</h4>
<p>
Приликом враћања вредности из функције такође може доћи до премештања власништва.
</p>

<div class="org-src-container">

<pre><code class="rust" >fn main() {
    let s1 = gives_ownership();         // gives_ownership премешта повратну
                                        // вредност у s1

    let s2 = String::from("hello");     // s2 постаје валидно

    let s3 = takes_and_gives_back(s2);  // s2 се премешта у функцију
                                        // takes_and_gives_back, која премешта
                                        // повратну вредност у s3
} // s3 излази из опсега и позива се `drop`. s2 је премештена па се ништа
  // не дешава. s1 такође излази из опсега и деалоцира се.

fn gives_ownership() -&gt; String {             // gives_ownership ће преместити
                                             // своју повратну вредност у функцију
                                             // која је позива

    let some_string = String::from("yours"); // some_string постаје валидно

    some_string                              // some_string се премешта
                                             // у функцију позиваоца
}

// Ова функција узима власништво над стрингом и враћа га назад
fn takes_and_gives_back(a_string: String) -&gt; String { // a_string постаје валидно

    a_string  // a_string се премешта у функцију позиваоца
}
</code></pre>
</div>

</section>
<section>

<ul>
<li>Често нам је потребно да варијаблу користимо и после слања у функцију.</li>
<li>Могли би је стало враћати заједно са резултатом функције на пример употребом торки.</li>

</ul>

<div class="org-src-container">

<pre><code class="rust" >fn main() {
    let s1 = String::from("hello");

    let (s2, len) = calculate_length(s1);

    println!("The length of '{}' is {}.", s2, len);
}

fn calculate_length(s: String) -&gt; (String, usize) {
    let length = s.len();

    (s, length)
}
</code></pre>
</div>

<p>
Али је то напорно. Постоји концепт у Раст који је намењен оваквим
ситуацијама и базиран је на референцама и позајмљивању вредности.
</p>
</section>
<section id="slide-6-2">
<h3 id="6-2"><span class="section-number-3">6.2.</span> Референце и позајмљивање (<i>References and Borrowing</i>)</h3>
<div class="outline-text-3" id="text-6-2">
</div>
</section>
<section id="slide-6-2-1">
<h4 id="6-2-1"><span class="section-number-4">6.2.1.</span> Референце и позајмљивање (<i>References and Borrowing</i>)</h4>
<ul>
<li>Референца је попут поинтера, садржи адресу вредности коју поседује нека друга
варијабла.</li>
<li>За разлику од поинтера, референце у Расту су гарантовано валидне.</li>

</ul>

<div class="org-src-container">

<pre><code class="rust" >fn main() {
    let s1 = String::from("hello");

    let len = calculate_length(&amp;s1);

    println!("The length of '{}' is {}.", s1, len);
}

fn calculate_length(s: &amp;String) -&gt; usize {
    s.len()
}
</code></pre>
</div>


<div id="org67c8c0b" class="figure">
<p><img src="./images/reference.png" alt="reference.png" style="height: 400px;" />
</p>
</div>

</section>
<section id="slide-6-2-2">
<h4 id="6-2-2"><span class="section-number-4">6.2.2.</span> Референцирање</h4>
<ul>
<li><p>
Примена оператора <code>&amp;</code> над варијаблом називамо <i>референцирање</i>.
</p>

<div class="org-src-container">

<pre><code class="rust" >  let s1 = String::from("hello");
  let len = calculate_length(&amp;s1);
</code></pre>
</div></li>

<li>Синтакса <code>&amp;s1</code> нам омогућава да креирамо референцу на вредност чији власник је
<code>s1</code> без узимања власништва.</li>
<li>Пошто референца није власник не долази до деалокације приликом изласка из
опсега.</li>
<li>Операција обрнута референцирању назива се <i>дереференцирање</i> и врши се <code>*</code>
оператором над референцом (нпр. <code>*s2</code> је вредност на коју референцира <code>s2</code>).</li>
<li>Операцију референцирања називамо позајмљивањем (<i>borrowing</i>).</li>

</ul>

</section>
<section>

<ul>
<li>Параметар функције може бити референца.</li>

</ul>
<div class="org-src-container">

<pre><code class="rust" >fn calculate_length(s: &amp;String) -&gt; usize { // s је референца на String
    s.len()
} // s излази из опсега али пошто нема власништво над вредношћу
  // ништа се не дешава.
</code></pre>
</div>

</section>
<section id="slide-6-2-3">
<h4 id="6-2-3"><span class="section-number-4">6.2.3.</span> Промена позајмљене вредности</h4>
<p>
Шта се дешава уколико покушамо да модификујемо позајмљену вредност?
</p>

<div class="org-src-container">

<pre><code class="rust" >fn main() {
    let s = String::from("hello");
    change(&amp;s);
}

fn change(some_string: &amp;String) {
    some_string.push_str(", world");
}
</code></pre>
</div>

<pre class="example" id="org246df51">
$ cargo run
   Compiling ownership v0.1.0 (file:///projects/ownership)
error[E0596]: cannot borrow `*some_string` as mutable, as it is behind a `&amp;` reference
 --&gt; src/main.rs:8:5
  |
7 | fn change(some_string: &amp;String) {
  |                        ------- help: consider changing this to be a mutable reference: `&amp;mut String`
8 |     some_string.push_str(", world");
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ `some_string` is a `&amp;` reference, so the data it refers
  to cannot be borrowed as mutable

For more information about this error, try `rustc --explain E0596`.
error: could not compile `ownership` due to previous error
</pre>

</section>
<section id="slide-6-2-4">
<h4 id="6-2-4"><span class="section-number-4">6.2.4.</span> Промењиве референце</h4>
<p>
Као и варијабле, и референце су подразумевано непромењива (<i>immutable</i>). Морамо
бити експлицитни уколико нам треба промењива референца.
</p>

<div class="org-src-container">

<pre><code class="rust" >fn main() {
    let mut s = String::from("hello");
    change(&amp;mut s);
}

fn change(some_string: &amp;mut String) {
    some_string.push_str(", world");
}
</code></pre>
</div>

</section>
<section id="slide-6-2-5">
<h4 id="6-2-5"><span class="section-number-4">6.2.5.</span> Више промењивих референци над истом вредношћу</h4>
<p>
Раст не дозвољава да исти податак у једном тренутку има више промењивих
референци.
</p>

<div class="org-src-container">

<pre><code class="rust" >let mut s = String::from("hello");

let r1 = &amp;mut s;
let r2 = &amp;mut s;

println!("{}, {}", r1, r2);
</code></pre>
</div>

<pre class="example" id="orgf7b5036">
$ cargo run
   Compiling ownership v0.1.0 (file:///projects/ownership)
error[E0499]: cannot borrow `s` as mutable more than once at a time
 --&gt; src/main.rs:5:14
  |
4 |     let r1 = &amp;mut s;
  |              ------ first mutable borrow occurs here
5 |     let r2 = &amp;mut s;
  |              ^^^^^^ second mutable borrow occurs here
6 |
7 |     println!("{}, {}", r1, r2);
  |                        -- first borrow later used here

For more information about this error, try `rustc --explain E0499`.
error: could not compile `ownership` due to previous error
</pre>

</section>
<section>

<p>
Овим ограничењем Раст, у време компајлирања, спречава класу грешака које
доводе до недефинисаног понашања и које зовемо <i>data races</i>. Ове грешке се веома
тешко откривају и отклањају и могу настати уколико су задовољени следећи
услови:
</p>

<ul>
<li>Два или више поинтера приступају истим подацима у исто време,</li>
<li>Бар један поинтер се користи за измену податка,</li>
<li>Не постоји механизам за синхронизацију приступа.</li>

</ul>

</section>
<section>

<p>
Више промењивих референци можемо имати али не у истом опсегу:
</p>

<div class="org-src-container">

<pre><code class="rust" >let mut s = String::from("hello");

{
    let r1 = &amp;mut s;
} // r1 овде излази из опсега тако да можемо краирати нове референце

let r2 = &amp;mut s;
</code></pre>
</div>

</section>
<section id="slide-6-2-6">
<h4 id="6-2-6"><span class="section-number-4">6.2.6.</span> Комбинација промењивих и непромењивих референци</h4>
<p>
Слично правило постоји и уколико имамо комбинацију промењивих и непромењивих
референци:
</p>

<div class="org-src-container">

<pre><code class="rust" >let mut s = String::from("hello");

let r1 = &amp;s; // ovo je OK
let r2 = &amp;s; // ovo je OK
let r3 = &amp;mut s; // GREŠKA!

println!("{}, {}, and {}", r1, r2, r3);
</code></pre>
</div>

<pre class="example" id="org3236a05">
$ cargo run
   Compiling ownership v0.1.0 (file:///projects/ownership)
error[E0502]: cannot borrow `s` as mutable because it is also borrowed as immutable
 --&gt; src/main.rs:6:14
  |
4 |     let r1 = &amp;s; // no problem
  |              -- immutable borrow occurs here
5 |     let r2 = &amp;s; // no problem
6 |     let r3 = &amp;mut s; // BIG PROBLEM
  |              ^^^^^^ mutable borrow occurs here
7 |
8 |     println!("{}, {}, and {}", r1, r2, r3);
  |                                -- immutable borrow later used here

For more information about this error, try `rustc --explain E0502`.
error: could not compile `ownership` due to previous error
</pre>

</section>
<section>

<ul>
<li>Не можемо истовремено имати непромењиве и промењиве референце јер корисници
непромењивих референци не очекују да се подаци мењају.</li>
<li>Можемо имати више непромењивих референци јер нико не може да мења податке и
тиме утиче на друге.</li>
<li>Промењиве референце често зовемо и <i>јединствене референце</i> јер када су оне
активне не може постојати друга референца на исту вредност.</li>

</ul>

</section>
<section id="slide-6-2-7">
<h4 id="6-2-7"><span class="section-number-4">6.2.7.</span> Опсег важења референце</h4>
<p>
Опсег важења референце почиње од места где је уведена па до њене последње
употребе. На пример, ово је валидно:
</p>

<div class="org-src-container">

<pre><code class="rust" >let mut s = String::from("hello");

let r1 = &amp;s; // OK
let r2 = &amp;s; // OK
println!("{} and {}", r1, r2);
// варијабле r1 и r2 се не користе у наставку па њихов опсег
// престаје да важи.

let r3 = &amp;mut s; // зато је ово OK
println!("{}", r3);
</code></pre>
</div>

<p>
Ова особина референци се назива <i>Non-Lexical Lifetimes (NLL)</i>.
</p>

</section>
<section id="slide-6-2-8">
<h4 id="6-2-8"><span class="section-number-4">6.2.8.</span> "Висеће" референце</h4>
<ul>
<li>У језицима са поинтерима лако је креирати поинтер на део меморије који је деалоциран.</li>
<li>Раст гарантовано спречава овакве грешке. Референце су увек валидне у Расту.</li>

</ul>

<div class="org-src-container">

<pre><code class="rust" >fn main() {
    let reference_to_nothing = dangle();
}

fn dangle() -&gt; &amp;String {
    let s = String::from("hello");

    &amp;s
}
</code></pre>
</div>

</section>
<section>

<pre class="example" id="orge1207ab">
$ cargo run
   Compiling ownership v0.1.0 (file:///projects/ownership)
error[E0106]: missing lifetime specifier
 --&gt; src/main.rs:5:16
  |
5 | fn dangle() -&gt; &amp;String {
  |                ^ expected named lifetime parameter
  |
  = help: this function's return type contains a borrowed value, but there is no value
  for it to be borrowed from
help: consider using the `'static` lifetime
  |
5 | fn dangle() -&gt; &amp;'static String {
  |                ~~~~~~~~

For more information about this error, try `rustc --explain E0106`.
error: could not compile `ownership` due to previous error
</pre>

<ul>
<li>Механизам који ово спречава назива се "време живота" (<i>lifetime</i>) и биће
детаљније обрађено у наставку.</li>
<li><p>
У преводу Раст нам поручује:
</p>

<blockquote>
<p>
Тип повратне вредности ове функције је позајмљена вредност, али не постоји
улазни параметар од кога може да се позајми.
</p>
</blockquote></li>

</ul>

</section>
<section id="slide-6-2-9">
<h4 id="6-2-9"><span class="section-number-4">6.2.9.</span> Шта се тачно десило?</h4>
<div class="org-src-container">

<pre><code class="rust" >fn dangle() -&gt; &amp;String { // dangle враћа референцу на String

    let s = String::from("hello"); // s је нови String

    &amp;s // Враћамо референцу на String s
} // s излази из опсега и позива се `drop`. Меморија се ослобађа.
  // ОПАСНОСТ! Враћена референца ће бити "висећа".
</code></pre>
</div>

<p>
Како се може решити. Вратићемо поседовану (<i>owned</i>) вредност, тј урадићемо
премештање вредности у функцију позиваоца.
</p>

<div class="org-src-container">

<pre><code class="rust" >fn no_dangle() -&gt; String {
    let s = String::from("hello");

    s
}
</code></pre>
</div>

</section>
<section id="slide-6-2-10">
<h4 id="6-2-10"><span class="section-number-4">6.2.10.</span> Правила референцирања</h4>
<ol>
<li>У сваком тренутку можемо имати или једну промењиву или произвољан број
непромењивих референци.</li>
<li>Референце увек морају бити валидне.</li>

</ol>

</section>
<section id="slide-6-3">
<h3 id="6-3"><span class="section-number-3">6.3.</span> Исечци (<i>Slice</i> тип)</h3>
<div class="outline-text-3" id="text-6-3">
</div>
</section>
<section id="slide-6-3-1">
<h4 id="6-3-1"><span class="section-number-4">6.3.1.</span> <i>Slice</i></h4>
<ul>
<li>Исечци (<i>slices</i>) омогућавају референцирање континуалне секвенце унутар
колекције уместо целе колекције</li>

</ul>

</section>
<section id="slide-6-3-2">
<h4 id="6-3-2"><span class="section-number-4">6.3.2.</span> Пример</h4>
<p>
Функција која за задати стринг враћа прву реч.
</p>

<div class="org-src-container">

<pre><code class="rust" >fn first_word(s: &amp;String) -&gt; usize {
    let bytes = s.as_bytes();

    for (i, &amp;item) in bytes.iter().enumerate() {
        if item == b' ' {
            return i;
        }
    }

    s.len()
}
</code></pre>
</div>

<ul>
<li>Дакле, враћамо индекс краја речи. Позиваоц сада има потребне информације да дође до тражене речи.</li>
<li>Проблем: два податка која су у вези али морамо ту везу ручно да одржавамо јер
немамо гаранцију да ће број који је враћен бити валидан и у будућности (нпр.
стринг може да се промени или да изађе из опсега).</li>

</ul>

</section>
<section>

<div class="org-src-container">

<pre><code class="rust" >fn main() {
    let mut s = String::from("hello world");

    let word = first_word(&amp;s); // word ће добити вредност 5

    s.clear(); // стринг s постаје ""

    // word је и даље 5 иако то више није исправно
}
</code></pre>
</div>

</section>
<section>

<p>
Проблем постаје још озбиљнији ако нпр. напишемо функцију <code>second_word</code> која враћа
другу реч задатог стринга. По аналогији са претходним, требали би да вратимо
почетак и крај друге речи.
</p>

<div class="org-src-container">

<pre><code class="rust" >fn second_word(s: &amp;String) -&gt; (usize, usize) {
</code></pre>
</div>

<p>
Сада имамо три податка о којима морамо да водимо рачуна.
</p>

</section>
<section id="slide-6-3-3">
<h4 id="6-3-3"><span class="section-number-4">6.3.3.</span> Стринг исечак</h4>
<p>
Проблем решавамо употребом исечака.
</p>

<div class="org-src-container">

<pre><code class="rust" >let s = String::from("hello world");

let hello = &amp;s[0..5];
let world = &amp;s[6..11];
</code></pre>
</div>

<div class="column" style="float:left; width: 55%">
<p>
Синтакса <code>s[x..y]</code> креира исечак над секвенцом <code>s</code>. С обзиром да овај тип (<code>[T]</code>) нема
познату величину у време компајлирања, не можемо га алоцирати на стеку, односно
не можемо га доделити локалним варијаблама или прослеђивати као параметар
функције. Зато се у пракси користи референца на исечак (<code>&amp;[T]</code>) (често се зове и
<i>fat pointer</i>).
</p>

<p>
Дакле, у пракси много чешће срећемо синтаксу <code>&amp;s[x..y]</code>.
</p>
</div>

<div class="column" style="float:right; width: 45%">

<div id="orgaa4aed7" class="figure">
<p><img src="./images/slice.png" alt="slice.png" style="height: 500px;" />
</p>
</div>
</div>

<div style="clear: both;">

</section>
<section id="slide-6-3-4">
<h4 id="6-3-4"><span class="section-number-4">6.3.4.</span> Исечци и синтакса опсега (<i>range</i>)</h4>
<div class="org-src-container">

<pre><code class="rust" >let s = String::from("hello");

let slice = &amp;s[0..2];
let slice = &amp;s[..2];
</code></pre>
</div>

<div class="org-src-container">

<pre><code class="rust" >let s = String::from("hello");

let len = s.len();

let slice = &amp;s[3..len];
let slice = &amp;s[3..];
</code></pre>
</div>

<div class="org-src-container">

<pre><code class="rust" >let s = String::from("hello");

let len = s.len();

let slice = &amp;s[0..len];
let slice = &amp;s[..];
</code></pre>
</div>

</section>
<section id="slide-6-3-5">
<h4 id="6-3-5"><span class="section-number-4">6.3.5.</span> Модификација примера да користи стринг исечке</h4>
<div class="org-src-container">

<pre><code class="rust" >fn first_word(s: &amp;String) -&gt; &amp;str {
    let bytes = s.as_bytes();

    for (i, &amp;item) in bytes.iter().enumerate() {
        if item == b' ' {
            return &amp;s[0..i];
        }
    }

    &amp;s[..]
}
</code></pre>
</div>

<p>
Исти API и за <code>second_word</code>.
</p>

<div class="org-src-container">

<pre><code class="rust" >fn second_word(s: &amp;String) -&gt; &amp;str {
</code></pre>
</div>

</section>
<section>

<p>
Сада нам компајлер осигурава да увек имамо валидну референцу на реч.
</p>
<div class="org-src-container">

<pre><code class="rust" >fn main() {
    let mut s = String::from("hello world");

    let word = first_word(&amp;s);

    s.clear(); // ГРЕШКА!

    println!("the first word is: {}", word);
}
</code></pre>
</div>

<pre class="example" id="org7e68ccd">
$ cargo run
   Compiling ownership v0.1.0 (file:///projects/ownership)
error[E0502]: cannot borrow `s` as mutable because it is also borrowed as immutable
  --&gt; src/main.rs:18:5
   |
16 |     let word = first_word(&amp;s);
   |                           -- immutable borrow occurs here
17 |
18 |     s.clear(); // error!
   |     ^^^^^^^^^ mutable borrow occurs here
19 |
20 |     println!("the first word is: {}", word);
   |                                       ---- immutable borrow later used here

For more information about this error, try `rustc --explain E0502`.
error: could not compile `ownership` due to previous error
</pre>

<p>
Не само да је API лакши за употребу већ је читава класа грешака које се тешко
откривају елиминисана у време компајлирања.
</p>

</section>
<section id="slide-6-3-6">
<h4 id="6-3-6"><span class="section-number-4">6.3.6.</span> Стринг литерали су референце на исечке</h4>
<div class="org-src-container">

<pre><code class="rust" >let s = "Hello, world!";
</code></pre>
</div>

<p>
Тип од <code>s</code> је <code>&amp;str</code>. <code>str</code> је стринг исечак.
</p>

</section>
<section id="slide-6-3-7">
<h4 id="6-3-7"><span class="section-number-4">6.3.7.</span> Стринг исечци као параметри функција</h4>
<div class="org-src-container">

<pre><code class="rust" >fn first_word(s: &amp;String) -&gt; &amp;str {
</code></pre>
</div>

<p>
Али ће искусни Раст програмери писати:
</p>

<div class="org-src-container">

<pre><code class="rust" >fn first_word(s: &amp;str) -&gt; &amp;str {
</code></pre>
</div>

<p>
Јер ће ова функција моћи да се користи и за <code>&amp;str</code> и за <code>&amp;String</code>. Овде се
употребљава тзв. <i>Deref Coercion</i> односно могућности типова да се дереференцирају
у други тип. Нпр. <code>&amp;String</code> ће се аутоматски дереференцирати у <code>&amp;str</code> уколико је то
потребно. Операција је ефикасна.
</p>

</section>
<section>

<div class="org-src-container">

<pre><code class="rust" >fn main() {
    let my_string = String::from("hello world");

    // `first_word` works on slices of `String`s, whether partial or whole
    let word = first_word(&amp;my_string[0..6]);
    let word = first_word(&amp;my_string[..]);
    // `first_word` also works on references to `String`s, which are equivalent
    // to whole slices of `String`s
    let word = first_word(&amp;my_string);

    let my_string_literal = "hello world";

    // `first_word` works on slices of string literals, whether partial or whole
    let word = first_word(&amp;my_string_literal[0..6]);
    let word = first_word(&amp;my_string_literal[..]);

    // Because string literals *are* string slices already,
    // this works too, without the slice syntax!
    let word = first_word(my_string_literal);
}
</code></pre>
</div>

</section>
<section id="slide-6-3-8">
<h4 id="6-3-8"><span class="section-number-4">6.3.8.</span> Употреба исечака над другим структурама</h4>
<div class="org-src-container">

<pre><code class="rust" >let a = [1, 2, 3, 4, 5];

let slice = &amp;a[1..3]; // референца на исечак типа &amp;[i32]

assert_eq!(slice, &amp;[2, 3]);
</code></pre>
</div>

</section>
</section>
<section>
<section id="slide-7">
<h2 id="7"><span class="section-number-2">7.</span> Структуре</h2>
</section>
</section>
<section>
<section id="slide-8">
<h2 id="8"><span class="section-number-2">8.</span> Енумерације</h2>
<div class="outline-text-2" id="text-8">
</div>
</section>
<section id="slide-8-1">
<h3 id="8-1"><span class="section-number-3">8.1.</span> <i>Enum</i> тип</h3>
<div class="outline-text-3" id="text-8-1">
</div>
</section>
<section id="slide-8-1-1">
<h4 id="8-1-1"><span class="section-number-4">8.1.1.</span> <i>Enum</i> тип</h4>
<ul>
<li>Дефинисање типа навођењем свих могућих варијанти</li>
<li>Варијанта може да садржи додатне податке</li>
<li>Слично са алгебарским типовима података (<i>algebraic data types</i>) у функционалним
језицима, нпр. F#, OCaml и Haskell-у. Ова врста алгебарског типа је позната и
под називом <i>sum type</i>.</li>

</ul>

</section>
<section id="slide-8-1-2">
<h4 id="8-1-2"><span class="section-number-4">8.1.2.</span> Пример - IP адреса</h4>
<ul>
<li>IP адреса представља идентификацију мрежних интерфејса у уређајима који
комуницирају посредством Интернет протокола (<i>Internet Protocol - IP</i>).</li>
<li>Тренутно имамо у употреби стару верзију 4 и нову верзију 6 која ће временом
заменити верзију 4.</li>
<li>Верзија 4 је дужине 32 бита и наводи се као четири октета у облику нпр.
<code>192.0.2.1</code></li>
<li>Верзија 6 је дужине 128 бита и наводи се као 8 група од по 4 хекса цифре
раздвојене са <code>:</code>, нпр. <code>2001:db8:0:1234:0:567:8:1</code></li>

</ul>

</section>
<section>

<p>
У Расту можемо писати следеће:
</p>

<div class="org-src-container">

<pre><code class="rust" >enum IpAddrKind {
    V4,
    V6,
}
</code></pre>
</div>

<p>
Док вредности можемо креирати са:
</p>
<div class="org-src-container">

<pre><code class="rust" >let four = IpAddrKind::V4;
let six = IpAddrKind::V6;
</code></pre>
</div>

</section>
<section id="slide-8-1-3">
<h4 id="8-1-3"><span class="section-number-4">8.1.3.</span> Пример - IP адреса - функција</h4>
<p>
Сада можемо писати функцију која прима овај тип чиме је могуће проследити било
коју варијанту као аргумент.
</p>

<div class="org-src-container">

<pre><code class="rust" >fn route(ip_kind: IpAddrKind) {}

...

route(IpAddrKind::V4);
route(IpAddrKind::V6);
</code></pre>
</div>

</section>
<section id="slide-8-1-4">
<h4 id="8-1-4"><span class="section-number-4">8.1.4.</span> Пример - IP адреса - вредност</h4>
<ul>
<li>Али како да дефинишемо конкретну вредност IP адресе?</li>
<li>Прва идеја би могла бити да користимо структуру.</li>

</ul>

<div class="org-src-container">

<pre><code class="rust" >enum IpAddrKind {
    V4,
    V6,
}

struct IpAddr {
    kind: IpAddrKind,
    address: String,
}

let home = IpAddr {
    kind: IpAddrKind::V4,
    address: String::from("127.0.0.1"),
};

let loopback = IpAddr {
    kind: IpAddrKind::V6,
    address: String::from("::1"),
};
</code></pre>
</div>

</section>
<section>

<p>
Али, са <code>enum</code> типом можемо то урадити и боље. <code>Enum</code> варијанте могу садржати
додатне податке.
</p>

<div class="org-src-container">

<pre><code class="rust" >enum IpAddr {
    V4(String),
    V6(String),
}

let home = IpAddr::V4(String::from("127.0.0.1"));

let loopback = IpAddr::V6(String::from("::1"));
</code></pre>
</div>

</section>
<section>
<p>
Вредност садржана у варијанти не мора бити иста за све варијанте. На пример,
IPv4 се састоји од 4 октета и можда желимо да вредност наводимо и чувамо у том
облику.
</p>

<div class="org-src-container">

<pre><code class="rust" >enum IpAddr {
    V4(u8, u8, u8, u8),
    V6(String),
}

let home = IpAddr::V4(127, 0, 0, 1);

let loopback = IpAddr::V6(String::from("::1"));
</code></pre>
</div>

</section>
<section id="slide-8-1-5">
<h4 id="8-1-5"><span class="section-number-4">8.1.5.</span> Пример - IP адреса - std библиотека</h4>
<p>
У стандардној библиотеци можемо пронаћи тип <code>IpAddr</code>. Дефинисан је на следећи
начин.
</p>

<div class="org-src-container">

<pre><code class="rust" >struct Ipv4Addr {
    // --snip--
}

struct Ipv6Addr {
    // --snip--
}

enum IpAddr {
    V4(Ipv4Addr),
    V6(Ipv6Addr),
}
</code></pre>
</div>

</section>
<section id="slide-8-1-6">
<h4 id="8-1-6"><span class="section-number-4">8.1.6.</span> Пример  - <i>Message</i></h4>
<div class="org-src-container">

<pre><code class="rust" >enum Message {
    Quit,
    Move { x: i32, y: i32 },
    Write(String),
    ChangeColor(i32, i32, i32),
}
</code></pre>
</div>

</section>
<section>
<p>
Следеће структуре садрже исте податке као претходни <code>enum</code> тип.
</p>

<div class="org-src-container">

<pre><code class="rust" >struct QuitMessage; // unit struct
struct MoveMessage {
    x: i32,
    y: i32,
}
struct WriteMessage(String); // tuple struct
struct ChangeColorMessage(i32, i32, i32); // tuple struct
</code></pre>
</div>

<p>
Али, предност <code>enum</code> типа је што је то јединствен тип па можемо нпр. направити
функцију која прима било коју вредност/варијанту овог типа.
</p>

</section>
<section>
<p>
Над <code>enum</code> типом, као и другим типовима, можемо имплементирати методе употребом
<code>imlp</code> кључне речи.
</p>

<div class="org-src-container">

<pre><code class="rust" >impl Message {
    fn call(&amp;self) {
        // тело методе се овде дефинише
    }
}

let m = Message::Write(String::from("hello"));
m.call();
</code></pre>
</div>

</section>
<section id="slide-8-2">
<h3 id="8-2"><span class="section-number-3">8.2.</span> <code>Option</code> енумерација</h3>
<div class="outline-text-3" id="text-8-2">
</div>
</section>
<section id="slide-8-2-1">
<h4 id="8-2-1"><span class="section-number-4">8.2.1.</span> <code>Option</code> енумерација</h4>
<ul>
<li>Чест случај да вредност може бити нешто или ништа.</li>
<li>Нпр. ако функција враћа први елемент из листе која није празна добићемо први
елемент, међутим ако је листа празна повратна вредност је ништа.</li>
<li>Овај концепт се у различитим језицима различито имплементира. Често се користи
специјална вредност <code>null</code> (или <code>nil</code>, <code>none</code> и сл.) и све варијабле могу бити <code>null</code>
или <code>non-null</code>. Проблем је што програмер не дефинише могућност ове вредности
кроз тип па самим тим компајлер нема могућност да провери да ли код исправно
обрађује ову могућност.</li>

</ul>

</section>
<section>

<p>
У презентацији из 2009 године под називом <i>Null References: The Billion Dollar
Mistake</i> Tony Hoare, који је први увео <code>null</code> вредност као концепт је написао
следеће:
</p>

<blockquote>
<p>
I call it my billion-dollar mistake. At that time, I was designing the first
comprehensive type system for references in an object-oriented language. My goal
was to ensure that all use of references should be absolutely safe, with
checking performed automatically by the compiler. But I couldn’t resist the
temptation to put in a null reference, simply because it was so easy to
implement. This has led to innumerable errors, vulnerabilities, and system
crashes, which have probably caused a billion dollars of pain and damage in the
last forty years.
</p>
</blockquote>

</section>
<section>

<p>
<code>Option</code> је генерички <code>enum</code> тип у Расту.
</p>
<div class="org-src-container">

<pre><code class="rust" >enum Option&lt;T&gt; {
    None,
    Some(T),
}
</code></pre>
</div>

<p>
Примери употребе:
</p>
<div class="org-src-container">

<pre><code class="rust" >let some_number = Some(5);           // тип је Option&lt;i32&gt;
let some_string = Some("a string");  // тип је Option&lt;&amp;str&gt;

let absent_number: Option&lt;i32&gt; = None;    // немогућа инференца
</code></pre>
</div>

</section>
<section id="slide-8-2-2">
<h4 id="8-2-2"><span class="section-number-4">8.2.2.</span> Зашто је <code>Option&lt;T&gt;</code> бољи од <code>null</code>?</h4>
<div class="org-src-container">

<pre><code class="rust" >let x: i8 = 5;
let y: Option&lt;i8&gt; = Some(5);

let sum = x + y;
</code></pre>
</div>

<pre class="example" id="orgc53e941">
$ cargo run
   Compiling enums v0.1.0 (file:///projects/enums)
error[E0277]: cannot add `Option&lt;i8&gt;` to `i8`
 --&gt; src/main.rs:5:17
  |
5 |     let sum = x + y;
  |                 ^ no implementation for `i8 + Option&lt;i8&gt;`
  |
  = help: the trait `Add&lt;Option&lt;i8&gt;&gt;` is not implemented for `i8`

For more information about this error, try `rustc --explain E0277`.
error: could not compile `enums` due to previous error
</pre>

</section>
<section id="slide-8-2-3">
<h4 id="8-2-3"><span class="section-number-4">8.2.3.</span> Како обрађивати <code>Option&lt;T&gt;</code> податке?</h4>
<ul>
<li>Морамо експлицитно обрадити вредност <code>Option&lt;T&gt;</code> и могућност да вредност буде
<code>None</code>.</li>
<li><code>Option&lt;T&gt;</code> тип има <a href="https://doc.rust-lang.org/stable/std/option/enum.Option.html">богат API</a> који је потребно знати јер је овај тип врло често
у употреби.</li>

</ul>

<div class="org-src-container">

<pre><code class="rust" >let x = Some(2);
let y = None;
assert_eq!(x.or(y), Some(2));

let x = None;
let y = Some(100);
assert_eq!(x.or(y), Some(100));
</code></pre>
</div>

<ul>
<li>Често користимо језичке конструкције које омогућавају обраду обе варијанте.</li>

</ul>

</section>
</section>
<section>
<section id="slide-9">
<h2 id="9"><span class="section-number-2">9.</span> Сложена контрола тока и подударање образаца (<i>Pattern Matching</i>)</h2>
<div class="outline-text-2" id="text-9">
</div>
</section>
<section id="slide-9-1">
<h3 id="9-1"><span class="section-number-3">9.1.</span> <code>match</code> израз</h3>
<ul>
<li>Моћан израз контроле тока базиран на подударању образаца (<i>Pattern Matching</i>).</li>
<li>Образац може бити литерал, назив варијабле, џокер (<i>wildcards</i>) итд.</li>
<li><code>match</code> израз ће извршити подударање уз исцрпљивање свих могућност. Уколико
нека могућност није обрађена компајлер ће пријавити грешку.</li>

</ul>

</section>
<section id="slide-9-2">
<h3 id="9-2"><span class="section-number-3">9.2.</span> <code>match</code> као машина за сортирање новчића</h3>
<p>
За почетак можемо <code>match</code> израз посматрати као аутомат за сортирање новчића.
</p>

<div class="org-src-container">

<pre><code class="rust" >enum Coin {
    Penny,
    Nickel,
    Dime,
    Quarter,
}

fn value_in_cents(coin: Coin) -&gt; u8 {
    match coin {
        Coin::Penny =&gt; 1,
        Coin::Nickel =&gt; 5,
        Coin::Dime =&gt; 10,
        Coin::Quarter =&gt; 25,
    }
}
</code></pre>
</div>

<ul>
<li><code>match</code> почиње са изразом произвољног типа.</li>
<li>У телу се налазе "руке" (<i>arms</i>) где свака рука има леву страну која представља
образац за подударање и десну страну (после <code>=&gt;</code>) која представља код који се
евалуира у случају подударања. Руке су раздвојене зарезима.</li>

</ul>

</section>
<section>

<ul>
<li>Руке се подударају у редоследу навођења.</li>
<li>Повратна вредност целог <code>match</code> израза биће вредност евалуираног кода руке чије
је подударање успело</li>

</ul>

</section>
<section>

<p>
Можемо на десној страни користити произвољан израз па и блок кода.
</p>
<div class="org-src-container">

<pre><code class="rust" >fn value_in_cents(coin: Coin) -&gt; u8 {
    match coin {
        Coin::Penny =&gt; {
            println!("Lucky penny!");
            1
        }
        Coin::Nickel =&gt; 5,
        Coin::Dime =&gt; 10,
        Coin::Quarter =&gt; 25,
    }
}
</code></pre>
</div>

</section>
<section id="slide-9-3">
<h3 id="9-3"><span class="section-number-3">9.3.</span> Повезивање имена при подударању (<i>binding</i>)</h3>
<div class="org-src-container">

<pre><code class="rust" >#[derive(Debug)]
enum UsState {
    Alabama,
    Alaska,
    Arizona,
    // --snip--
}

enum Coin {
    Penny,
    Nickel,
    Dime,
    Quarter(UsState),
}

fn value_in_cents(coin: Coin) -&gt; u8 {
    match coin {
        Coin::Penny =&gt; 1,
        Coin::Nickel =&gt; 5,
        Coin::Dime =&gt; 10,
        Coin::Quarter(state) =&gt; {
            println!("State quarter from {:?}!", state);
            25
        }
    }
}
</code></pre>
</div>

</section>
<section id="slide-9-4">
<h3 id="9-4"><span class="section-number-3">9.4.</span> <code>match</code> је исцрпан</h3>
<div class="org-src-container">

<pre><code class="rust" >fn value_in_cents(coin: Coin) -&gt; u8 {
    match coin {
        Coin::Penny =&gt; 1,
        Coin::Nickel =&gt; 5,
        Coin::Dime =&gt; 10,
        Coin::Quarter(UsState::Alabama) | Coin::Quarter(UsState::Alaska) =&gt; 25
    }
}
</code></pre>
</div>

<pre class="example" id="orgb3eb152">
$ cargo run
   Compiling match_test v0.1.0 (/home/igor/NTP/match_test)
error[E0004]: non-exhaustive patterns: `Quarter(Arizona)` not covered
  --&gt; src/main.rs:21:11
   |
13 | / enum Coin {
14 | |     Penny,
15 | |     Nickel,
16 | |     Dime,
17 | |     Quarter(UsState),
   | |     ------- not covered
18 | | }
   | |_- `Coin` defined here
...
21 |       match coin {
   |             ^^^^ pattern `Quarter(Arizona)` not covered
   |
   = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms
   = note: the matched value is of type `Coin`
</pre>

</section>
<section id="slide-9-5">
<h3 id="9-5"><span class="section-number-3">9.5.</span> Подударање са <code>Option&lt;T&gt;</code> типом</h3>
<div class="org-src-container">

<pre><code class="rust" >fn plus_one(x: Option&lt;i32&gt;) -&gt; Option&lt;i32&gt; {
    match x {
        None =&gt; None,
        Some(i) =&gt; Some(i + 1),
    }
}

let five = Some(5);
let six = plus_one(five);
let none = plus_one(None);
</code></pre>
</div>

</section>
<section>

<p>
Пошто је <code>match</code> исцрпан не можемо заборавити да обрадимо <code>None</code> случај.
</p>

<div class="org-src-container">

<pre><code class="rust" >fn plus_one(x: Option&lt;i32&gt;) -&gt; Option&lt;i32&gt; {
    match x {
        Some(i) =&gt; Some(i + 1),
    }
}
</code></pre>
</div>

<pre class="example" id="org3bbb871">
$ cargo run
   Compiling enums v0.1.0 (file:///projects/enums)
error[E0004]: non-exhaustive patterns: `None` not covered
   --&gt; src/main.rs:3:15
    |
3   |         match x {
    |               ^ pattern `None` not covered
    |
    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms
    = note: the matched value is of type `Option&lt;i32&gt;`

For more information about this error, try `rustc --explain E0004`.
error: could not compile `enums` due to previous error
</pre>

</section>
<section id="slide-9-6">
<h3 id="9-6"><span class="section-number-3">9.6.</span> Подразумевана обрада преосталих случајева</h3>
<ul>
<li>Желимо на специфичан начин обрадимо само неколико случајева док за све остале
радимо подразумевану обраду.</li>

</ul>

<div class="org-src-container">

<pre><code class="rust" >let dice_roll = 9;
match dice_roll {
    3 =&gt; add_fancy_hat(),
    7 =&gt; remove_fancy_hat(),
    other =&gt; move_player(other),
}

fn add_fancy_hat() {}
fn remove_fancy_hat() {}
fn move_player(num_spaces: u8) {}
</code></pre>
</div>

<ul>
<li>Раст ће нас упозорити ако додамо руку после оне која обрађује све случајеве
јер та се рука никада неће употребити.</li>

</ul>

</section>
<section>

<p>
Ако желимо да обрадимо све случајеве али нас вредност не интересује можемо
користити <code>_</code>.
</p>

<div class="org-src-container">

<pre><code class="rust" >let dice_roll = 9;
match dice_roll {
    3 =&gt; add_fancy_hat(),
    7 =&gt; remove_fancy_hat(),
    _ =&gt; reroll(),
}

fn add_fancy_hat() {}
fn remove_fancy_hat() {}
fn reroll() {}
</code></pre>
</div>
</section>
<section id="slide-9-7">
<h3 id="9-7"><span class="section-number-3">9.7.</span> Распакивање (<i>Destructuring</i>)</h3>
<div class="outline-text-3" id="text-9-7">
</div>
</section>
<section id="slide-9-7-1">
<h4 id="9-7-1"><span class="section-number-4">9.7.1.</span> Распакивање торки</h4>
<div class="org-src-container">

<pre><code class="rust" >fn main() {
    let triple = (0, -2, 3);
    // TODO ^ Try different values for `triple`

    println!("Tell me about {:?}", triple);
    // Match can be used to destructure a tuple
    match triple {
        // Destructure the second and third elements
        (0, y, z) =&gt; println!("First is `0`, `y` is {:?}, and `z` is {:?}", y, z),
        (1, ..)  =&gt; println!("First is `1` and the rest doesn't matter"),
        (.., 2)  =&gt; println!("last is `2` and the rest doesn't matter"),
        (3, .., 4)  =&gt; println!("First is `3`, last is `4`, and the rest doesn't matter"),
        // `..` can be used to ignore the rest of the tuple
        _      =&gt; println!("It doesn't matter what they are"),
        // `_` means don't bind the value to a variable
    }
}
</code></pre>
</div>

</section>
<section id="slide-9-7-2">
<h4 id="9-7-2"><span class="section-number-4">9.7.2.</span> Распакивање исечака</h4>
<div class="org-src-container">

<pre><code class="rust" >fn main() {
    let array = [4, -2, 6];

    match array {
        [0, second, third] =&gt;
            println!("array[0] = 0, array[1] = {}, array[2] = {}", second, third),
        [1, _, third] =&gt; println!(
            "array[0] = 1, array[2] = {} and array[1] was ignored",
            third
        ),
        [-1, second, ..] =&gt; println!(
            "array[0] = -1, array[1] = {} and all the other ones were ignored",
            second
        ),
        [3, second, tail @ ..] =&gt; println!(
            "array[0] = 3, array[1] = {} and the other elements were {:?}",
            second, tail
        ),
        [first, middle @ .., last] =&gt; println!(
            "array[0] = {}, middle = {:?}, array[2] = {}",
            first, middle, last
        ),
    }
}
</code></pre>
</div>

<pre class="example">
array[0] = 4, middle = [-2], array[2] = 6
</pre>

</section>
<section id="slide-9-7-3">
<h4 id="9-7-3"><span class="section-number-4">9.7.3.</span> Распакивање енумерација</h4>
<div class="org-src-container">

<pre><code class="rust" >#[allow(dead_code)]
enum Color {
    Red,
    Blue,
    Green,
    RGB(u32, u32, u32),
    HSV(u32, u32, u32),
    HSL(u32, u32, u32),
    CMY(u32, u32, u32),
    CMYK(u32, u32, u32, u32),
}
fn main() {
    let color = Color::RGB(122, 17, 40);
    println!("What color is it?");
    match color {
        Color::Red   =&gt; println!("The color is Red!"),
        Color::Blue  =&gt; println!("The color is Blue!"),
        Color::Green =&gt; println!("The color is Green!"),
        Color::RGB(r, g, b) =&gt;
            println!("Red: {}, green: {}, and blue: {}!", r, g, b),
        Color::HSV(h, s, v) =&gt;
            println!("Hue: {}, saturation: {}, value: {}!", h, s, v),
        Color::HSL(h, s, l) =&gt;
            println!("Hue: {}, saturation: {}, lightness: {}!", h, s, l),
        Color::CMY(c, m, y) =&gt;
            println!("Cyan: {}, magenta: {}, yellow: {}!", c, m, y),
        Color::CMYK(c, m, y, k) =&gt;
            println!("Cyan: {}, magenta: {}, yellow: {}, key (black): {}!", c, m, y, k),
    }
}
</code></pre>
</div>

</section>
<section id="slide-9-7-4">
<h4 id="9-7-4"><span class="section-number-4">9.7.4.</span> Распакивање референци</h4>
<div class="org-src-container">

<pre><code class="rust" >fn main() {
    let reference = &amp;4;

    match reference {
        &amp;val =&gt; println!("Got a value via destructuring: {:?}", val),
    }
    match *reference {
        val =&gt; println!("Got a value via dereferencing: {:?}", val),
    }
    let _not_a_reference = 3;

    let ref _is_a_reference = 3;

    let value = 5;
    let mut mut_value = 6;
    match value {
        ref r =&gt; println!("Got a reference to a value: {:?}", r),
    }
    match mut_value {
        ref mut m =&gt; {
            *m += 10;
            println!("We added 10. `mut_value`: {:?}", m);
        },
    }
}
</code></pre>
</div>

<pre class="example">
Got a value via destructuring: 4
Got a value via dereferencing: 4
Got a reference to a value: 5
We added 10. `mut_value`: 16
</pre>

</section>
<section id="slide-9-7-5">
<h4 id="9-7-5"><span class="section-number-4">9.7.5.</span> Распакивање структура</h4>
<div class="org-src-container">

<pre><code class="rust" >fn main() {
    struct Foo {
        x: (u32, u32),
        y: u32,
    }

    let foo = Foo { x: (1, 2), y: 3 };
    match foo {
        Foo { x: (1, b), y } =&gt; println!("First of x is 1, b = {},  y = {} ", b, y),

        // you can destructure structs and rename the variables,
        // the order is not important
        Foo { y: 2, x: i } =&gt; println!("y is 2, i = {:?}", i),

        // and you can also ignore some variables:
        Foo { y, .. } =&gt; println!("y = {}, we don't care about x", y),
        // this will give an error: pattern does not mention field `x`
        //Foo { y } =&gt; println!("y = {}", y),
    }
}
</code></pre>
</div>

</section>
<section id="slide-9-8">
<h3 id="9-8"><span class="section-number-3">9.8.</span> <code>if let</code> kontrola toka</h3>
<p>
<code>if let</code> нам омогућава комбинацију <code>if</code> и <code>let</code> исказа у мање опширан исказ за обраду
само једног случаја поклапања и игнорисање осталих.
</p>

<div class="org-src-container">

<pre><code class="rust" >let config_max = Some(3u8);
match config_max {
    Some(max) =&gt; println!("The maximum is configured to be {}", max),
    _ =&gt; (),
}
</code></pre>
</div>

<p>
Ово можемо концизније исказати са:
</p>

<div class="org-src-container">

<pre><code class="rust" >let config_max = Some(3u8);
if let Some(max) = config_max {
    println!("The maximum is configured to be {}", max);
}
</code></pre>
</div>

<ul>
<li>Губимо исцрпност <code>match</code> израза.</li>
<li>Синтаксни шећер у ситуацијама када желимо да игноришемо остале могућности.</li>

</ul>

</section>
<section>

<div class="note" id="org5ec44e7">
<p>
Обрасци за подударање <a href="https://doc.rust-lang.org/book/ch18-02-refutability.html">могу имати две форме</a>: поништив (<i>refutable</i>) и непоништив
(<i>irrefutable</i>). Образац који увек мора успети (нпр. <code>let x = 5;</code>) је непоништив.
Образац који не мора да успе увек је поништив (нпр. <code>if let Some(x) = a_value</code>
неће успети за <code>a_value==None</code>).
</p>

<p>
Параметри функција, <code>let</code> искази и <code>for</code> петље прихватају само непоништиве обрасце
јер програм не може урадити ништа смислено уколико подударање не успе.
</p>

<p>
<code>if let</code> и <code>while let</code> прихватају и поништиве и непоништиве обрасце али ће нас
компајлер упозорити уколико користимо непоништиве.
</p>

</div>

</section>
<section>
<p>
Можемо користити и <code>else</code> грану. Следеће је еквивалентно.
</p>

<div class="org-src-container">

<pre><code class="rust" >let mut count = 0;
match coin {
    Coin::Quarter(state) =&gt; println!("State quarter from {:?}!", state),
    _ =&gt; count += 1,
}
</code></pre>
</div>

<div class="org-src-container">

<pre><code class="rust" >let mut count = 0;
if let Coin::Quarter(state) = coin {
    println!("State quarter from {:?}!", state);
} else {
    count += 1;
}
</code></pre>
</div>
</section>
<section id="slide-9-9">
<h3 id="9-9"><span class="section-number-3">9.9.</span> <code>let else</code></h3>
</section>
<section id="slide-9-10">
<h3 id="9-10"><span class="section-number-3">9.10.</span> <code>while let</code></h3>
</section>
</section>
<section>
<section id="slide-10">
<h2 id="10"><span class="section-number-2">10.</span> Модули</h2>
</section>
</section>
<section>
<section id="slide-11">
<h2 id="11"><span class="section-number-2">11.</span> Колекције</h2>
</section>
</section>
<section>
<section id="slide-12">
<h2 id="12"><span class="section-number-2">12.</span> Обрада грешака</h2>
</section>
</section>
<section>
<section id="slide-13">
<h2 id="13"><span class="section-number-2">13.</span> Тестирање</h2>
</section>
</section>
<section>
<section id="slide-14">
<h2 id="14"><span class="section-number-2">14.</span> Генерички типови, особине (<i>Traits</i>) и животни век (<i>Lifetimes</i>)</h2>
<div class="outline-text-2" id="text-14">
</div>
</section>
<section id="slide-14-1">
<h3 id="14-1"><span class="section-number-3">14.1.</span> Генерички типови (<i>generics</i>)</h3>
<div class="outline-text-3" id="text-14-1">
</div>
</section>
<section id="slide-14-1-1">
<h4 id="14-1-1"><span class="section-number-4">14.1.1.</span> Генерички типови (<i>generics</i>)</h4>
<ul>
<li>Механизам за елиминацију дуплирања кода.</li>
<li>Генерички типови су апстрактне замене за конкретне типове у друге особине у
време извршавања.</li>
<li>Омогућавају нам да на апстрактан начин искажемо особине типова и њихове везе
са другим типовима без знања о томе који ће се конкретни типови наћи на
њиховом месту у време компајлирања и извршавања кода.</li>
<li>На пример функције могу примити генеричке параметре. Такође, сложени типови
могу бити параметризовани генеричким типовима (пример је <code>Option&lt;T&gt;</code>).</li>

</ul>

</section>
<section id="slide-14-1-2">
<h4 id="14-1-2"><span class="section-number-4">14.1.2.</span> Уклањање дуплог кода употребом функција</h4>
<div class="org-src-container">

<pre><code class="rust" >fn main() {
    let number_list = vec![34, 50, 25, 100, 65];

    let mut largest = number_list[0];

    for number in number_list {
        if number &gt; largest {
            largest = number;
        }
    }

    println!("The largest number is {}", largest);
}
</code></pre>
</div>

</section>
<section>

<div class="org-src-container">

<pre><code class="rust" >fn main() {
    let number_list = vec![34, 50, 25, 100, 65];

    let mut largest = number_list[0];

    for number in number_list {
        if number &gt; largest {
            largest = number;
        }
    }

    println!("The largest number is {}", largest);

    let number_list = vec![102, 34, 6000, 89, 54, 2, 43, 8];

    let mut largest = number_list[0];

    for number in number_list {
        if number &gt; largest {
            largest = number;
        }
    }

    println!("The largest number is {}", largest);
}
</code></pre>
</div>

</section>
<section>

<div class="org-src-container">

<pre><code class="rust" >fn largest(list: &amp;[i32]) -&gt; i32 {
    let mut largest = list[0];

    for &amp;item in list {
        if item &gt; largest {
            largest = item;
        }
    }

    largest
}

fn main() {
    let number_list = vec![34, 50, 25, 100, 65];

    let result = largest(&amp;number_list);
    println!("The largest number is {}", result);

    let number_list = vec![102, 34, 6000, 89, 54, 2, 43, 8];

    let result = largest(&amp;number_list);
    println!("The largest number is {}", result);
}
</code></pre>
</div>


</section>
<section>

<p>
Поступак елиминације дуплог кода је подразумевао следеће:
</p>

<ol>
<li>Идентификација дуплог кода.</li>
<li>Екстракција кода у функцију, дефинисање параметара и повратне вредности.</li>
<li>Замена инстанци дуплог кода са позивом функције.</li>

</ol>

</section>
<section id="slide-14-1-3">
<h4 id="14-1-3"><span class="section-number-4">14.1.3.</span> Уклањање дуплог кода употребом генеричких функција</h4>
<p>
Имамо функцију за проналажење највећег елемента у листи са различитим типовима.
</p>
<div class="org-src-container">

<pre><code class="rust" >fn largest_i32(list: &amp;[i32]) -&gt; i32 {
    let mut largest = list[0];
    for &amp;item in list {
        if item &gt; largest {
            largest = item;
        }
    }
    largest
}
fn largest_char(list: &amp;[char]) -&gt; char {
    let mut largest = list[0];
    for &amp;item in list {
        if item &gt; largest {
            largest = item;
        }
    }
    largest
}
fn main() {
    let number_list = vec![34, 50, 25, 100, 65];
    let result = largest_i32(&amp;number_list);
    println!("The largest number is {}", result);
    let char_list = vec!['y', 'm', 'a', 'q'];
    let result = largest_char(&amp;char_list);
    println!("The largest char is {}", result);
}
</code></pre>
</div>

</section>
<section>

<p>
Функције су готово идентичне. Разлика је само у типу. Пишемо генеричку функцију
тако што дефинишемо генерички тип унутар <code>&lt;&gt;</code> после назива функције:
</p>

<div class="org-src-container">

<pre><code class="rust" >fn largest&lt;T&gt;(list: &amp;[T]) -&gt; T {
</code></pre>
</div>

<p>
<code>T</code> је генерички тип и у време компајлирања биће замењен са конкретним типом.
</p>

</section>
<section>

<p>
Сада је наш код следећи:
</p>

<div class="org-src-container">

<pre><code class="rust" >fn largest&lt;T&gt;(list: &amp;[T]) -&gt; T {
    let mut largest = list[0];

    for &amp;item in list {
        if item &gt; largest {
            largest = item;
        }
    }

    largest
}

fn main() {
    let number_list = vec![34, 50, 25, 100, 65];

    let result = largest(&amp;number_list);
    println!("The largest number is {}", result);

    let char_list = vec!['y', 'm', 'a', 'q'];

    let result = largest(&amp;char_list);
    println!("The largest char is {}", result);
}
</code></pre>
</div>

</section>
<section>

<p>
Али се не компајлира.
</p>

<div class="org-src-container">

<pre><code class="rust" >$ cargo run
   Compiling chapter10 v0.1.0 (file:///projects/chapter10)
error[E0369]: binary operation `&gt;` cannot be applied to type `T`
 --&gt; src/main.rs:5:17
  |
5 |         if item &gt; largest {
  |            ---- ^ ------- T
  |            |
  |            T
  |
help: consider restricting type parameter `T`
  |
1 | fn largest&lt;T: std::cmp::PartialOrd&gt;(list: &amp;[T]) -&gt; T {
  |             ++++++++++++++++++++++

For more information about this error, try `rustc --explain E0369`.
error: could not compile `chapter10` due to previous error
</code></pre>
</div>

<p>
Тип <code>T</code> може бити било који тип па и тип који не дефинише операцију <code>&gt;</code> која се
користи у коду. Дакле, морамо ограничити који типови су могући.
</p>

<p>
Видећемо како се ово ради у наставку у причи о особинама (<i>Traits</i>).
</p>

</section>
<section id="slide-14-1-4">
<h4 id="14-1-4"><span class="section-number-4">14.1.4.</span> Генерички типови у структурама</h4>
<div class="org-src-container">

<pre><code class="rust" >struct Point&lt;T&gt; {
    x: T,
    y: T,
}

fn main() {
    let integer = Point { x: 5, y: 10 };
    let float = Point { x: 1.0, y: 4.0 };
}
</code></pre>
</div>

</section>
<section>

<p>
Типови оба поља морају бити исти.
</p>

<div class="org-src-container">

<pre><code class="rust" >struct Point&lt;T&gt; {
    x: T,
    y: T,
}

fn main() {
    let wont_work = Point { x: 5, y: 4.0 };
}
</code></pre>
</div>

<pre class="example" id="org8cfa28c">
$ cargo run
   Compiling chapter10 v0.1.0 (file:///projects/chapter10)
error[E0308]: mismatched types
 --&gt; src/main.rs:7:38
  |
7 |     let wont_work = Point { x: 5, y: 4.0 };
  |                                      ^^^ expected integer, found floating-point number

For more information about this error, try `rustc --explain E0308`.
error: could not compile `chapter10` due to previous error
</pre>

</section>
<section>

<p>
Ако желимо да поља имају различите типове онда морамо имати различите генеричке типове.
</p>

<div class="org-src-container">

<pre><code class="rust" >struct Point&lt;T, U&gt; {
    x: T,
    y: U,
}

fn main() {
    let both_integer = Point { x: 5, y: 10 };
    let both_float = Point { x: 1.0, y: 4.0 };
    let integer_and_float = Point { x: 5, y: 4.0 };
}
</code></pre>
</div>

</section>
<section id="slide-14-1-5">
<h4 id="14-1-5"><span class="section-number-4">14.1.5.</span> Генерички типови у енумерацијама</h4>
<div class="org-src-container">

<pre><code class="rust" >enum Option&lt;T&gt; {
    Some(T),
    None,
}
</code></pre>
</div>

</section>
<section>

<div class="org-src-container">

<pre><code class="rust" >enum Result&lt;T, E&gt; {
    Ok(T),
    Err(E),
}
</code></pre>
</div>

</section>
<section id="slide-14-1-6">
<h4 id="14-1-6"><span class="section-number-4">14.1.6.</span> Дефиниције метода</h4>
<div class="org-src-container">

<pre><code class="rust" >struct Point&lt;T&gt; {
    x: T,
    y: T,
}

impl&lt;T&gt; Point&lt;T&gt; {
    fn x(&amp;self) -&gt; &amp;T {
        &amp;self.x
    }
}

fn main() {
    let p = Point { x: 5, y: 10 };

    println!("p.x = {}", p.x());
}
</code></pre>
</div>

<p>
Пошто смо навели <code>&lt;T&gt;</code> иза кључне речи <code>impl</code> Раст даље зна да је тип <code>T</code> генерички
а не конкретни тип тако да је метода <code>x</code> за <code>Point&lt;T&gt;</code> дефинисана над свим типовима
<code>T</code>.
</p>

</section>
<section>

<p>
Могли смо нпр. методу дефинисати само за одређени <code>Point</code> тип.
</p>

<div class="org-src-container">

<pre><code class="rust" >impl Point&lt;f32&gt; {
    fn distance_from_origin(&amp;self) -&gt; f32 {
        (self.x.powi(2) + self.y.powi(2)).sqrt()
    }
}
</code></pre>
</div>

<p>
Овај <code>impl</code> блок дефинише методу <code>distance_from_origin</code> али само за <code>Point&lt;f32&gt;</code> док
остали <code>Point</code> типови неће имати ову методу.
</p>

</section>
<section id="slide-14-1-7">
<h4 id="14-1-7"><span class="section-number-4">14.1.7.</span> Генерички типови у методама и <code>impl</code> блоковима</h4>
<p>
Генерички типови у структурама и методама не морају бити исти. На пример, можемо
креирати методу <code>mixup</code> која узима две инстанце <code>Point</code> и враћа нови <code>Point</code> тип где
ће прво поље имати исти тип као прва тачка а друго поље као друга тачка.
</p>

<div class="org-src-container">

<pre><code class="rust" >struct Point&lt;X1, Y1&gt; {
    x: X1,
    y: Y1,
}

impl&lt;X1, Y1&gt; Point&lt;X1, Y1&gt; {
    fn mixup&lt;X2, Y2&gt;(self, other: Point&lt;X2, Y2&gt;) -&gt; Point&lt;X1, Y2&gt; {
        Point {
            x: self.x,
            y: other.y,
        }
    }
}

fn main() {
    let p1 = Point { x: 5, y: 10.4 };
    let p2 = Point { x: "Hello", y: 'c' };
    let p3 = p1.mixup(p2);
    println!("p3.x = {}, p3.y = {}", p3.x, p3.y);
}
</code></pre>
</div>

<ul>
<li>Генерички типови <code>X2</code> и <code>Y2</code> су наведени само у методи јер су релевантни само у
њеном контексту.</li>

</ul>

</section>
<section id="slide-14-1-8">
<h4 id="14-1-8"><span class="section-number-4">14.1.8.</span> Перформансе</h4>
<p>
Употреба генеричког кода не доводи до деградације перформанси. Раст користи
технику мономорфизације (<i>Monomorphization</i>) код које ће компајлер инстанцирати
конкретан код за сваки тип посебно.
</p>

<p>
То би значило следеће. Ако имамо код:
</p>

<div class="org-src-container">

<pre><code class="rust" >let integer = Some(5);
let float = Some(5.0)
</code></pre>
</div>

<p>
Компајлер ће произвести код еквивалентан следећем:
</p>
<div class="org-src-container">

<pre><code class="rust" >enum Option_i32 {
    Some(i32),
    None,
}

enum Option_f64 {
    Some(f64),
    None,
}

fn main() {
    let integer = Option_i32::Some(5);
    let float = Option_f64::Some(5.0);
}
</code></pre>
</div>
</section>
<section id="slide-14-2">
<h3 id="14-2"><span class="section-number-3">14.2.</span> Особине (<i>Traits</i>) - дефинисање заједничког понашања</h3>
<div class="outline-text-3" id="text-14-2">
</div>
</section>
<section id="slide-14-2-1">
<h4 id="14-2-1"><span class="section-number-4">14.2.1.</span> <i>Traits</i></h4>
<ul>
<li><i>Trait</i> дефинише функционалност коју тип може делити са другим типовима.</li>
<li>У другим језицима сличан концепт назива се интерфејс.</li>
<li>Можемо користити <i>ограничења кроз особине</i> (<i>Trait bounds</i>) да дефинишемо да
генерички тип мора задовољити одређена ограничења.</li>

</ul>

</section>
<section id="slide-14-2-2">
<h4 id="14-2-2"><span class="section-number-4">14.2.2.</span> Дефинисање особина</h4>
<ul>
<li>Пример дефинисања медиа агрегатор библиотеке која може да приказе сажетак
података који се може чувати у <code>NewsArticle</code> или <code>Tweet</code> инстанци.</li>
<li>Дефинишемо <code>Summary</code> особину да опишемо ову функционалност.</li>

</ul>

<div class="org-src-container">

<pre><code class="rust" >pub trait Summary {
    fn summarize(&amp;self) -&gt; String;
}
</code></pre>
</div>

</section>
<section id="slide-14-2-3">
<h4 id="14-2-3"><span class="section-number-4">14.2.3.</span> Имплементација особина</h4>
<div class="org-src-container">

<pre><code class="rust" >pub struct NewsArticle {
    pub headline: String,
    pub location: String,
    pub author: String,
    pub content: String,
}

impl Summary for NewsArticle {
    fn summarize(&amp;self) -&gt; String {
        format!("{}, by {} ({})", self.headline, self.author, self.location)
    }
}

pub struct Tweet {
    pub username: String,
    pub content: String,
    pub reply: bool,
    pub retweet: bool,
}

impl Summary for Tweet {
    fn summarize(&amp;self) -&gt; String {
        format!("{}: {}", self.username, self.content)
    }
}
</code></pre>
</div>

</section>
<section>

<p>
Методе особина се позивају као и обичне методе. Једина разлика је у томе што
методе особина морају бити доступне у опсегу (укључити их са <code>use</code>).
</p>

<div class="org-src-container">

<pre><code class="rust" >use aggregator::{Summary, Tweet};

fn main() {
    let tweet = Tweet {
        username: String::from("horse_ebooks"),
        content: String::from(
            "of course, as you probably already know, people",
        ),
        reply: false,
        retweet: false,
    };

    println!("1 new tweet: {}", tweet.summarize());
}
</code></pre>
</div>

</section>
<section>

<div class="note" id="org6297212">
<p>
Ограничење у употреби особина је да можемо имплементирати особину над типом
једино ако је бар једно од њих локално за наш сандук. Ово правило је део скупа
правила који се називају <i>coherence</i>. Конкретно ово правило зове се <i>orphan rule</i> и
спречава некомпатибилне имплементације особина над типовима од стране више
сандука.
</p>

<p>
Без овог правила могло би се десити да два различита сандука имплементирају исту
особину над истим типом на различите начине и компајлер не би знао коју верзију
да користи.
</p>

</div>
</section>
<section id="slide-14-2-4">
<h4 id="14-2-4"><span class="section-number-4">14.2.4.</span> Подразумевана имплементација</h4>
<p>
Особина може имати подразумевану имплементацију метода.
</p>

<div class="org-src-container">

<pre><code class="rust" >pub trait Summary {
    fn summarize(&amp;self) -&gt; String {
        String::from("(Read more...)")
    }
}
</code></pre>
</div>

<p>
Да би користили подразумевану имплементацију можемо навести празно тело у <code>impl</code>
блоку:
</p>

<div class="org-src-container">

<pre><code class="rust" >impl Summary for NewsArticle {}
</code></pre>
</div>

</section>
<section>

<p>
И затим можемо позвати <code>summarize</code> методу:
</p>

<div class="org-src-container">

<pre><code class="rust" >let article = NewsArticle {
        headline: String::from("Penguins win the Stanley Cup Championship!"),
        location: String::from("Pittsburgh, PA, USA"),
        author: String::from("Iceburgh"),
        content: String::from(
            "The Pittsburgh Penguins once again are the best \
             hockey team in the NHL.",
        ),
    };

    println!("New article available! {}", article.summarize());
</code></pre>
</div>

</section>
<section>

<ul>
<li>Подразумевана имплементација може бити редефинисана приликом имплементације.</li>
<li>Такође, подразумеване методе могу позивати друге методе.</li>

</ul>

<div class="org-src-container">

<pre><code class="rust" >pub trait Summary {
    fn summarize_author(&amp;self) -&gt; String;

    fn summarize(&amp;self) -&gt; String {
        format!("(Read more from {}...)", self.summarize_author())
    }
}
</code></pre>
</div>

<p>
Сада је потребно и довољно да приликом имплементације дефинишемо
<code>summarize_author</code> методу:
</p>

<div class="org-src-container">

<pre><code class="rust" >impl Summary for Tweet {
    fn summarize_author(&amp;self) -&gt; String {
        format!("@{}", self.username)
    }
}
</code></pre>
</div>
</section>
<section id="slide-14-2-5">
<h4 id="14-2-5"><span class="section-number-4">14.2.5.</span> Osobine kao parametri</h4>
<ul>
<li>Сада можемо користити особине да дефинишемо функције које раде над параметрима
различитог типа.</li>

</ul>

<div class="org-src-container">

<pre><code class="rust" >pub fn notify(item: &amp;impl Summary) {
    println!("Breaking news! {}", item.summarize());
}
</code></pre>
</div>

<p>
Сада функција <code>notify</code> ради над свим типовима који имплементирају <code>Summary</code>
</p>

</section>
<section>

<p>
Претходна употреба <code>impl</code> код параметра је синтаксни шећер за општи облик
навођења ограничења кроз особине.
</p>

<div class="org-src-container">

<pre><code class="rust" >pub fn notify&lt;T: Summary&gt;(item: &amp;T) {
    println!("Breaking news! {}", item.summarize());
}
</code></pre>
</div>

<p>
Ограничења кроз особине (<i>Trait bounds</i>) стављамо после двотачке код навођења
генеричког типа. Компајлер ће верификовати да све што користимо над вредностима
овог типа унутар функције је заиста дефинисано особинама наведеним у заглављу.
</p>

</section>
<section>

<p>
<code>impl Trait</code> синтаксе је концизнија код једноставних примера али је пуна синтакса
боља код сложенијих примера.
</p>

<p>
На пример:
</p>

<div class="org-src-container">

<pre><code class="rust" >pub fn notify(item1: &amp;impl Summary, item2: &amp;impl Summary) {
</code></pre>
</div>

<p>
би у пуној синтакси било:
</p>

<div class="org-src-container">

<pre><code class="rust" >pub fn notify&lt;T: Summary&gt;(item1: &amp;T, item2: &amp;T) {
</code></pre>
</div>

</section>
<section id="slide-14-2-6">
<h4 id="14-2-6"><span class="section-number-4">14.2.6.</span> Вишеструке особине код ограничења</h4>
<p>
Можемо дефинисати и више ограничења употребом <code>+</code> синтаксе. На пример, ако
параметар мора да имплементира <code>Summary</code> и <code>Display</code>:
</p>
<div class="org-src-container">

<pre><code class="rust" >pub fn notify(item: &amp;(impl Summary + Display)) {
</code></pre>
</div>

<p>
или у пуној синтакси:
</p>

<div class="org-src-container">

<pre><code class="rust" >pub fn notify&lt;T: Summary + Display&gt;(item: &amp;T) {
</code></pre>
</div>

</section>
<section id="slide-14-2-7">
<h4 id="14-2-7"><span class="section-number-4">14.2.7.</span> <code>where</code> клаузула у ограничењима</h4>
<ul>
<li>Уколико имамо више ограничења основна синтакса може да смањи читкост.</li>

</ul>

<div class="org-src-container">

<pre><code class="rust" >fn some_function&lt;T: Display + Clone, U: Clone + Debug&gt;(t: &amp;T, u: &amp;U) -&gt; i32 {
</code></pre>
</div>

<ul>
<li><code>where</code> клаузула измешта дефинисање ограничења после заглавља функције чиме
се постиже боља читкост:</li>

</ul>

<div class="org-src-container">

<pre><code class="rust" >fn some_function&lt;T, U&gt;(t: &amp;T, u: &amp;U) -&gt; i32
    where T: Display + Clone,
          U: Clone + Debug
{
</code></pre>
</div>

</section>
<section id="slide-14-2-8">
<h4 id="14-2-8"><span class="section-number-4">14.2.8.</span> <code>impl Trait</code> као повратна вредност функције</h4>
<div class="org-src-container">

<pre><code class="rust" >fn returns_summarizable() -&gt; impl Summary {
    Tweet {
        username: String::from("horse_ebooks"),
        content: String::from(
            "of course, as you probably already know, people",
        ),
        reply: false,
        retweet: false,
    }
}
</code></pre>
</div>

<p>
Посебно значајно у контексту затворења (<i>closures</i>) и итератора где је конкретан
тип превише сложен за писање или је познат само компајлеру.
</p>

<div class="note" id="org685cbd9">
<p>
<code>impl Trait</code> синтакса за повратне вредности је могућа само ако функција враћа
један тип који имплементира дату особину. На пример, ова функција неће радити
ако функција може вратити <code>NewsArticle</code> или <code>Tweet</code>.
</p>

</div>

</section>
<section id="slide-14-2-9">
<h4 id="14-2-9"><span class="section-number-4">14.2.9.</span> Поправка <code>largest</code> генеричке функције</h4>
<p>
На претходним сладовима имали смо функцију <code>largest</code>. Сада можемо да завршимо
њену дефиницију.
</p>

<p>
Грешка је била следећа:
</p>
<pre class="example" id="org3fe3431">
$ cargo run
   Compiling chapter10 v0.1.0 (file:///projects/chapter10)
error[E0369]: binary operation `&gt;` cannot be applied to type `T`
 --&gt; src/main.rs:5:17
  |
5 |         if item &gt; largest {
  |            ---- ^ ------- T
  |            |
  |            T
  |
help: consider restricting type parameter `T`
  |
1 | fn largest&lt;T: std::cmp::PartialOrd&gt;(list: &amp;[T]) -&gt; T {
  |             ++++++++++++++++++++++

For more information about this error, try `rustc --explain E0369`.
error: could not compile `chapter10` due to previous error
</pre>

</section>
<section>

<p>
Дакле, морамо ограничити типове на оне који подржавају поређње. Ова особина се
у стандардној библиотеци зове <code>std::cmp::PartialOrd</code>, па ћемо преправити заглавље
функције на следећи начин:
</p>

<div class="org-src-container">

<pre><code class="rust" >fn largest&lt;T: PartialOrd&gt;(list: &amp;[T]) -&gt; T {
</code></pre>
</div>

</section>
<section>

<p>
Међутим, сада имамо још једну грешку:
</p>
<pre class="example" id="org3ca8296">
$ cargo run
   Compiling chapter10 v0.1.0 (file:///projects/chapter10)
error[E0508]: cannot move out of type `[T]`, a non-copy slice
 --&gt; src/main.rs:2:23
  |
2 |     let mut largest = list[0];
  |                       ^^^^^^^
  |                       |
  |                       cannot move out of here
  |                       move occurs because `list[_]` has type `T`, which does not implement the `Copy` trait
  |                       help: consider borrowing here: `&amp;list[0]`

error[E0507]: cannot move out of a shared reference
 --&gt; src/main.rs:4:18
  |
4 |     for &amp;item in list {
  |         -----    ^^^^
  |         ||
  |         |data moved here
  |         |move occurs because `item` has type `T`, which does not implement the `Copy` trait
  |         help: consider removing the `&amp;`: `item`

Some errors have detailed explanations: E0507, E0508.
For more information about an error, try `rustc --explain E0507`.
error: could not compile `chapter10` due to 2 previous errors
</pre>

</section>
<section>

<p>
Уводимо додатно ограничење да генерички тип мора бити и <code>Copy</code>. Тако да је пуно
решење следеће:
</p>

<div class="org-src-container">

<pre><code class="rust" >fn largest&lt;T: PartialOrd + Copy&gt;(list: &amp;[T]) -&gt; T {
    let mut largest = list[0];

    for &amp;item in list {
        if item &gt; largest {
            largest = item;
        }
    }

    largest
}

fn main() {
    let number_list = vec![34, 50, 25, 100, 65];

    let result = largest(&amp;number_list);
    println!("The largest number is {}", result);

    let char_list = vec!['y', 'm', 'a', 'q'];

    let result = largest(&amp;char_list);
    println!("The largest char is {}", result);
}
</code></pre>
</div>

</section>
<section id="slide-14-2-10">
<h4 id="14-2-10"><span class="section-number-4">14.2.10.</span> Употреба особина ограничења за условну имплементацију метода</h4>
<p>
Ако желимо да имплементирамо методу само над типовима који имплементирају
одређене особине.
</p>
<div class="org-src-container">

<pre><code class="rust" >use std::fmt::Display;

struct Pair&lt;T&gt; {
    x: T,
    y: T,
}

impl&lt;T&gt; Pair&lt;T&gt; {
    fn new(x: T, y: T) -&gt; Self {
        Self { x, y }
    }
}

impl&lt;T: Display + PartialOrd&gt; Pair&lt;T&gt; {
    fn cmp_display(&amp;self) {
        if self.x &gt;= self.y {
            println!("The largest member is x = {}", self.x);
        } else {
            println!("The largest member is y = {}", self.y);
        }
    }
}
</code></pre>
</div>

</section>
<section id="slide-14-3">
<h3 id="14-3"><span class="section-number-3">14.3.</span> Валидација референци кроз животни век (<i>Lifetimes</i>)</h3>
<div class="outline-text-3" id="text-14-3">
</div>
</section>
<section id="slide-14-3-1">
<h4 id="14-3-1"><span class="section-number-4">14.3.1.</span> Животни век (<i>Lifetime</i>)</h4>
<ul>
<li>Свака референца има животни век, опсег у коме је референца валидна.</li>
<li>У доста ситуација компајлер аутоматски може да закључи који је животни век
референце. Када то није у стању морамо да урадимо ручну анотацију.</li>
<li>Анотацијама животног века доводимо у везу животни век различитих референци.</li>

</ul>

</section>
<section id="slide-14-3-2">
<h4 id="14-3-2"><span class="section-number-4">14.3.2.</span> Спречавање "висећих" референци</h4>
<div class="org-src-container">

<pre><code class="rust" >{
        let r;

        {
            let x = 5;
            r = &amp;x;
        }

        println!("r: {}", r);
    }

</code></pre>
</div>

<pre class="example" id="orgb13cb0b">
 cargo run
   Compiling chapter10 v0.1.0 (file:///projects/chapter10)
error[E0597]: `x` does not live long enough
  --&gt; src/main.rs:7:17
   |
7  |             r = &amp;x;
   |                 ^^ borrowed value does not live long enough
8  |         }
   |         - `x` dropped here while still borrowed
9  |
10 |         println!("r: {}", r);
   |                           - borrow later used here

For more information about this error, try `rustc --explain E0597`.
error: could not compile `chapter10` due to previous error
</pre>

</section>
<section id="slide-14-3-3">
<h4 id="14-3-3"><span class="section-number-4">14.3.3.</span> <i>Borrow Checker</i></h4>
<ul>
<li>Раст компајлер има компоненту <i>borrow checker</i> која проверава да ли су све
позајмице валидне.</li>

</ul>

<div class="org-src-container">

<pre><code class="rust" >{
    let r;                // ---------+-- 'a
                          //          |
    {                     //          |
        let x = 5;        // -+-- 'b  |
        r = &amp;x;           //  |       |
    }                     // -+       |
                          //          |
    println!("r: {}", r); //          |
}                         // ---------+
</code></pre>
</div>

<ul>
<li>Програм је одбачен јер <code>r</code> референцира вредност чији животни век (<code>'b</code>) је краћи
од животног века варијабле <code>r</code> (<code>'a</code>). Уколико би се ово дозволило, <code>r</code> би у једном
делу референцирала невалидну вредност.</li>

</ul>

</section>
<section>

<p>
Варијабле имају животни век који је једнак синстаксном опсегу у коме је
варијабла дефинисана. Животни век имају и референце које позајмљују вредност и
смештају се у варијабле (нпр. <code>r=&amp;x</code> из претходног примера).
</p>

<div class="note" id="org1cd432b">
<p>
Једно од правила је да референца на варијаблу (тј. вредност) не може да живи
дуже од саме варијабле. Односно <i>животни век варијабле мора да садржи животни
век референце позајмљене од те варијабле</i>.
</p>

</div>

<div class="org-src-container">

<pre><code class="rust" >{
    let r;
    {
        let x = 5;
        r = &amp;x;           // -+- &amp;x не може да живи дуже од
    }                     // -+  овог животног века
    println!("r: {}", r);
}
</code></pre>
</div>

</section>
<section>

<p>
Ако сместимо референцу у варијаблу, референца мора бити исправна за цео животни
век варијабле у коју је смештена.
</p>

<div class="note" id="orgce324d6">
<p>
Кажемо да <i>животни век референце мора да садржи животни век варијабле у коју је
смештена</i>.
</p>

</div>

<div class="org-src-container">

<pre><code class="rust" >{
    let r;
    {
        let x = 5;
        r = &amp;x;           // -+- животни век било чега што
    }                     //  |  се смести у r мора да живи
    println!("r: {}", r); // -+  бар оволико
}
</code></pre>
</div>

<p>
Видимо да ово правило није задовољено. <code>&amp;x</code> не живи довољно дуго јер <code>x</code> не живи
довољно дуго.
</p>

</section>
<section>

<p>
Ако претходна два правила објединимо можемо рећи да:
</p>

<div class="note" id="org8a8297e">
<p>
<i>Животни век варијабле мора да садржи животни век свих варијабли које позајмљују
вредност од посматране варијабле</i>.
</p>

</div>

<p>
Односно, варијабла може отићи из опсега тек када не постоји више ни једна
варијабла која чува позајмљену вредност.
</p>

</section>
<section>

<p>
Следећи код је прихваћен. Референца <code>r</code> не живи дуже од податка који референцира
(<code>x</code>).
</p>

<div class="org-src-container">

<pre><code class="rust" >{
    let x = 5;            // ----------+-- 'b
                          //           |
    let r = &amp;x;           // --+-- 'a  |
                          //   |       |
    println!("r: {}", r); //   |       |
                          // --+       |
}                         // ----------+
</code></pre>
</div>

</section>
<section id="slide-14-3-4">
<h4 id="14-3-4"><span class="section-number-4">14.3.4.</span> Генерички животни векови у функцијама</h4>
<ul>
<li>Креирамо функцију <code>longest</code> која враћа дужи од два прослеђена стринга.
Прослеђујемо референцу на стринг исечак <code>&amp;str</code>.</li>

</ul>

<div class="org-src-container">

<pre><code class="rust" >fn main() {
    let string1 = String::from("abcd");
    let string2 = "xyz";

    let result = longest(string1.as_str(), string2);
    println!("The longest string is {}", result);
}
</code></pre>
</div>

</section>
<section>

<p>
Овај програм није прихваћен.
</p>
<div class="org-src-container">

<pre><code class="rust" >fn longest(x: &amp;str, y: &amp;str) -&gt; &amp;str {
    if x.len() &gt; y.len() {
        x
    } else {
        y
    }
}
</code></pre>
</div>

<pre class="example" id="orgccb663f">
$ cargo run
   Compiling chapter10 v0.1.0 (file:///projects/chapter10)
error[E0106]: missing lifetime specifier
 --&gt; src/main.rs:9:33
  |
9 | fn longest(x: &amp;str, y: &amp;str) -&gt; &amp;str {
  |               ----     ----     ^ expected named lifetime parameter
  |
  = help: this function's return type contains a borrowed value, but the signature does not say
  whether it is borrowed from `x` or `y`
help: consider introducing a named lifetime parameter
  |
9 | fn longest&lt;'a&gt;(x: &amp;'a str, y: &amp;'a str) -&gt; &amp;'a str {
  |           ++++     ++          ++          ++

For more information about this error, try `rustc --explain E0106`.
error: could not compile `chapter10` due to previous error
</pre>

</section>
<section>

<ul>
<li>Зашто програм није прихваћен?</li>
<li><i>Borrow checker</i> није у стању да одреди у којој релацији су референце <code>x</code> и <code>y</code> са
повратном вредношћу која је такође референца.</li>
<li>Тј. повратна вредност мора бити позајмљена од некуд, али компајлер не може да
одреди да ли је позамљена од <code>x</code> или <code>y</code> или од неке глобалне вредности.</li>
<li>Ова информација је потребна да би се обавила калкулација и провера животног века.</li>

</ul>

</section>
<section id="slide-14-3-5">
<h4 id="14-3-5"><span class="section-number-4">14.3.5.</span> Синтакса за анотацију животног века</h4>
<ul>
<li>Да би помогли компајлеру референце означавамо са животним веком и тиме
доводимо у везу различите референце (нпр. параметре и повратне вредности
функције).</li>
<li>Анотација је облика <code>'a</code>. Иза апострофа се пише име анотације које је најчешће
једно мало слово са почетка алфабета (<code>'a, 'b,...</code>).</li>
<li><b>Важно:</b> анотације животног века не мењају животни век референце већ само
помажу компајлеру у провери.</li>

</ul>

<div class="org-src-container">

<pre><code class="rust" >&amp;i32        // референца
&amp;'a i32     // референца са експлицитним животним веком
&amp;'a mut i32 // промењива референца са експлицитним животним веком
</code></pre>
</div>

<ul>
<li>Једна анотација нема пуно смисла. Функцију имају тек када анотирамо више
референци јер се доводе у везу ако имају исто име.</li>
<li>Уведимо функцију <code>lt</code> која враћа животни век варијабле/вредности и релацију
између животних векова <code>'a≥'b</code> односно <code>'b≤'a</code> која значи да <code>'a</code> обухвата <code>'b</code>
односно <code>'b</code> је садржано у <code>'a</code>.</li>

</ul>

</section>
<section id="slide-14-3-6">
<h4 id="14-3-6"><span class="section-number-4">14.3.6.</span> Анотација животног века у сигнатурама функција</h4>
<ul>
<li>Следећа анотација за функцију <code>longest</code> је исправна јер референца која се враћа
може бити <code>x</code> или <code>y</code> у зависности од дужине стринга. Стога је потребно да имамо
строжији услов да је животни век повратне вредности у вези са животним веком
оба параметра.</li>

</ul>

<div class="org-src-container">

<pre><code class="rust" >fn longest&lt;'a&gt;(x: &amp;'a str, y: &amp;'a str) -&gt; &amp;'a str {
    if x.len() &gt; y.len() {
        x
    } else {
        y
    }
}
</code></pre>
</div>

<ul>
<li>Овим кажемо компајлеру да за неки генерички животни век <code>'a</code>, функција прима две
референце чији животни век вредности обухвата <code>'a</code> и враћа референцу која мора
бити валидна бар колико и животни век <code>'a</code> тј. животни век повратне референце
мора да обувати <code>'a</code>. Уколико такав животни век постоји код се прихвата.</li>
<li>Сигнатура доводи у везу обе улазне референце са излазном.</li>

</ul>

</section>
<section>

<p>
Посматрајмо код који позива функцију <code>longest</code>:
</p>

<div class="org-src-container">

<pre><code class="rust" >fn main() {
    let string1 = String::from("abcd");
    {
        let string2 = "xyz";
        let result = longest(string1.as_str(), string2);
    }
    println!("The longest string is {}", result);
}
</code></pre>
</div>

<p>
За код мора да постоји <code>'a</code> тако да важи:
</p>

<pre class="example" id="orgd188805">
lt(string1) ≥ 'a     # животни век вредности првог параметара садржи 'a
lt(string2) ≥ 'a     # животни век вредности другог параметара садржи 'a
'a ≥ lt(result)       # 'a мора да садржи животни веку ресулт варијабле
</pre>

<p>
Што не може бити испуњено истовремено, тј. не постоји <code>'a</code> које испуњава ова
ограничења.
</p>

</section>
<section>

<p>
Други начин размишљања је да повратна вредност функције позајмљује од
вредности улазних параметара означених истим именом животног века.
</p>

<div class="org-src-container">

<pre><code class="rust" >fn main() {
    let string1 = String::from("abcd");
    {
        let string2 = "xyz";
        let result = longest(string1.as_str(), string2);
    }
    println!("The longest string is {}", result);
}
</code></pre>
</div>

<p>
Што значи да <code>result</code> позајмљује од <code>string1</code> и <code>string2</code> и та позајмица траје све
време живота варијабле <code>result</code> што не може бити валидно јер варијабла живи дуже
од вредности <code>string2</code>.
</p>

<p>
Иако, можемо видети да ће, због дужине стринга, враћена вредност бити <code>string1</code> и
програм је валидан, компајлер ово не може да закључи.
</p>
</section>
</section>
<section>
<section id="slide-15">
<h2 id="15"><span class="section-number-2">15.</span> Макрои</h2>
</section>
</section>
<section>
<section id="slide-16">
<h2 id="16"><span class="section-number-2">16.</span> Функционално програмирање, затворења и итератори</h2>
</section>
</section>
<section>
<section id="slide-17">
<h2 id="17"><span class="section-number-2">17.</span> ООП, паметни поинтери, конкурентно програмирање</h2>
</section>
</section>
<section>
<section id="slide-18">
<h2 id="18"><span class="section-number-2">18.</span> Литература</h2>
<ul>
<li>Steve Klabnik and Carol Nichols: <a href="https://doc.rust-lang.org/book/">The Rust Programming Language</a>, no starch press.</li>
<li>Rust by Example, <a href="https://doc.rust-lang.org/stable/rust-by-example/index.html">https://doc.rust-lang.org/stable/rust-by-example/index.html</a></li>
<li>Slice is NOT reference, <a href="https://github.com/rust-lang/book/issues/3070">https://github.com/rust-lang/book/issues/3070</a></li>
<li>Google: Comprehensive Rust, <a href="https://google.github.io/comprehensive-rust/">https://google.github.io/comprehensive-rust/</a></li>
<li><a href="https://rust-lang.github.io/rfcs/0505-api-comment-conventions.html">RFC 505: API documentation conventions</a></li>

</ul>
</section>
</section>
</div>
</div>
<script src="../../../s/reveal.js/js/reveal.js"></script>
<script>
// Full list of configuration options available here:
// https://github.com/hakimel/reveal.js#configuration
Reveal.initialize({

controls: true,
progress: true,
history: false,
center: true,
slideNumber: 'c/t',
rollingLinks: false,
keyboard: true,
mouseWheel: false,
fragmentInURL: true,
hashOneBasedIndex: false,
pdfSeparateFragments: true,
overview: true,
width: 1400,
height: 1000,
minScale: 0.30,
maxScale: 4.00,

theme: Reveal.getQueryHash().theme, // available themes are in /css/theme
transition: Reveal.getQueryHash().transition || 'slide', // see README of reveal.js for options
transitionSpeed: 'default',

// Optional libraries used to extend reveal.js
dependencies: [
{src: '../../../s/reveal.js/../reveal-plugins/menu/menu.js'},
{src: '../../../s/reveal.js/../reveal-plugins/chalkboard/chalkboard.js'},
 { src: '../../../s/reveal.js/plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } },
 { src: '../../../s/reveal.js/plugin/search/search.js', async: true, condition: function() { return !!document.body.classList; } }]

,keyboard: {67: function() { RevealChalkboard.toggleNotesCanvas() },	66: function() { RevealChalkboard.toggleChalkboard() },	46: function() { RevealChalkboard.clear() },	8: function() { RevealChalkboard.reset() },	68: function() { RevealChalkboard.download() },	},});
</script>
</body>
</html>
