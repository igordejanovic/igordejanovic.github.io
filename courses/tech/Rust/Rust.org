#+TITLE: Programski jezik Rust
#+SUBTITLE: Bazirano na verziji 1.58.1. U izradi.
#+EXPORT_FILE_NAME: index.html
#+EXPORT_REVEAL_HLEVEL: 10
#+SETUPFILE: ../../courses-startup.org

* Uvod
- Jezik opšte namene, kompajliran i statički tipiziran sa inferencom tipova
- Sistemsko programiranje ali sa osobinama višeg nivoa apstrakcije kao što su
  funkcionalno programiranje
- 2010, Graydon Hoare, Mozilla Research
- Performanse i sigurnost
- Ne koristi /garbage collector/ ali obezbeđuje memorijsku sigurnost kroz /borrow
  checker/
- Sintaksno sličan C++. Uticaj i OCaml-a, Haskell-a i Erlang-a.
- Koristi se u velikim firmama: Amazon, Facebook, Google, Microsoft...
- Od 2016 godine na SO upitniku konstantno prvi u kategoriji /"most loved
  programming languages"/
* Instalacija i podešavanje
** Instalacija
- Rust stiže sa alatom za upravljanje lanca alata =rustup=

#+begin_src sh
$ curl --proto '=https' --tlsv1.2 https://sh.rustup.rs -sSf | sh
#+end_src

- Provera instalacije

#+begin_src sh
~> rustc --version
rustc 1.58.1 (db9d1b20b 2022-01-20)
#+end_src

** Pregled instalacije
#+begin_src sh
~> rustup show
Default host: x86_64-unknown-linux-gnu
rustup home:  /home/igor/.rustup

installed toolchains
--------------------

stable-x86_64-unknown-linux-gnu (default)
nightly-x86_64-unknown-linux-gnu

active toolchain
----------------

stable-x86_64-unknown-linux-gnu (default)
rustc 1.58.1 (db9d1b20b 2022-01-20)
#+end_src

** Ažuriranje
Za ažuriranje instalacije na najnoviju verziju

#+begin_src sh
rustup update
#+end_src

** Dokumentacija

Rust stiže sa veoma dobrom dokumentacijom i knjigama koje su dostupne direktno
iz instalacije.

#+begin_src sh
rustup doc
#+end_src

* Početak
** Hello, World!

#+begin_src sh
$ mkdir hello_world
$ cd hello_world
#+end_src

File =main.rs=:
#+begin_src rust
fn main() {
    println!("Hello, world!");
}
#+end_src

** Kompajliranje i pokretanje

#+begin_src sh
$ rustc main.rs
$ ./main
Hello, world!
#+end_src
** Hello, Cargo!
- Alat za razrešavanje zavisnosti i upravljanje projektom.

#+begin_src sh
~> cargo --version
cargo 1.58.0 (f01b232bc 2022-01-19)
#+end_src

- Kreiranje projekta sa =cargo= alatom:

#+begin_src sh
$ cargo new hello_cargo
$ cd hello_cargo
#+end_src

** Sadržaj kreiranog projekta
Fajl =cargo.toml= čuva konfiguraciju projekta. Format je [[https://toml.io/en/][TOML]] (/Tom’s Obvious,
Minimal Language/):

#+begin_src toml
[package]
name = "hello_cargo"
version = "0.1.0"
edition = "2021"

[dependencies]
#+end_src

Fajl =src/main.rs=:
#+begin_src rust
fn main() {
    println!("Hello, world!");
}
#+end_src
** Pokretanje

#+begin_src rust
$ cargo build
   Compiling hello_cargo v0.1.0 (file:///projects/hello_cargo)
    Finished dev [unoptimized + debuginfo] target(s) in 2.85 secs
#+end_src

Izvršni fajl se može naći na lokaciji =target/debug/hello_cargo=:

#+begin_src sh
$ ./target/debug/hello_cargo
Hello, world!
#+end_src

Ali =cargo= omgućava i jednostavniji način pokretanja:
#+begin_src sh
$ cargo run
    Finished dev [unoptimized + debuginfo] target(s) in 0.0 secs
     Running `target/debug/hello_cargo`
Hello, world!
#+end_src

** Provera
Takođe je moguće brzo proveriti da li se kod kompajlira:

#+begin_src sh
$ cargo check
   Checking hello_cargo v0.1.0 (file:///projects/hello_cargo)
    Finished dev [unoptimized + debuginfo] target(s) in 0.32 secs
#+end_src

** Izgradnja finalne verzije
- U toku razvoja koristimo izgradnju za degabovanje koja se brže završi ali je
  izvršni kod neoptimalan.

- Za finalnu verziju je potrebno izgradnju obaviti na sledeći način:

    #+begin_src rust
    cargo build --release
    #+end_src

- Ovo će obaviti dodatne optimizacije koje će duže trajati ali će krajnji kod
  biti optimizovan.

** Cargo kao konvencija

Praktično svi Rust projekti koriste Cargo tako da je unifikovan način izgradnje
projekata. Uglavnom se svodi na:

#+begin_src sh
$ git clone example.org/someproject
$ cd someproject
$ cargo build
#+end_src

* Igra pogađanja brojeva
** Podešavanje projekta
#+begin_src rust
$ cargo new guessing_game
$ cd guessing_game
#+end_src

Fajl =Cargo.toml=:
#+begin_src toml
[package]
name = "guessing_game"
version = "0.1.0"
edition = "2021"

[dependencies]
#+end_src

Fajl =src/main.rs=:
#+begin_src rust
fn main() {
    println!("Hello, world!");
}
#+end_src

#+REVEAL: split

#+begin_src sh
$ cargo run
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
    Finished dev [unoptimized + debuginfo] target(s) in 1.50s
     Running `target/debug/guessing_game`
Hello, world!
#+end_src

** Preuzimanje broja sa standardnog ulaza

#+begin_src rust
use std::io;

fn main() {
    println!("Guess the number!");

    println!("Please input your guess.");

    let mut guess = String::new();

    io::stdin()
        .read_line(&mut guess)
        .expect("Failed to read line");

    println!("You guessed: {}", guess);
}
#+end_src

** Promenjivost (/mutability/)

- Varijable su podrazumevano nepromenjive (/immutable/).
- Ukoliko želimo varijablu čija vrednost može da se menja koristimo ključnu reč
  =mut=.

  #+begin_src rust
  let apples = 5; // immutable
  let mut bananas = 5; // mutable
  #+end_src

- Isto važi i za parametre funkcija:

  #+begin_src rust
  io::stdin()
      .read_line(&mut guess)
  #+end_src

** Obrada mogućih grešaka upotrebom =Result= tipa

=read_line= može da završi neuspešno. Zato vraća =io::Result= tip koji predstavlja
enumeraciju (/enum/) tip i ima dve vrednosti: =Ok= i =Err=.

#+begin_src rust
io::stdin()
    .read_line(&mut guess)
    .expect("Failed to read line");
#+end_src

=expect= implementiran na =Ok= varijanti će vratiti vrednost koja je sadržana unutar
varijante dok implementacija nad =Err= varijanti prekida izvršavanje programa.

** Pokretanje

#+begin_src rust
$ cargo run
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
    Finished dev [unoptimized + debuginfo] target(s) in 6.44s
     Running `target/debug/guessing_game`
Guess the number!
Please input your guess.
6
You guessed: 6
#+end_src

** Generisanje slučajnog broja
Koristimo =rand= paket (sanduk - /crate/ u terminologiji Cargo-a).

Sekcija =[dependencies]= u fajlu =Cargo.toml=:
#+begin_src toml
[dependencies]
rand = "0.8.3"
#+end_src

#+begin_src sh
$ cargo build
    Updating crates.io index
  Downloaded rand v0.8.3
  Downloaded libc v0.2.86
  ...
   Compiling rand_chacha v0.3.0
   Compiling rand v0.8.3
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
    Finished dev [unoptimized + debuginfo] target(s) in 2.53s
#+end_src

Cargo koristi [[https://semver.org/][Semantic Versioning]]. Rust paketi se preuzimaju sa sajta [[https://crates.io/][crates.io]]
i keširaju lokalno.

** Ponovljivost izgradnje - /Cargo.lock/
- Prvi put kada se pokrene =cargo build= kreira se fajl =Cargo.lock= sa
  informacijama o verzijama svih sanduka koji su instalirani.
- Svako sledeće pokretanje izgradnje koristi iste verzije.
- =Cargo.lock= je potrebno čuvati u sistemu kontrole verzija (npr. =git=) da bi se
  osigurala ponovljivost.

** Ažuriranje sanduka
- Ažuriranje na nove verzije sanduka se obavlja sa:

  #+begin_src sh
  $ cargo update
    Updating crates.io index
    Updating rand v0.8.3 -> v0.8.4
  #+end_src
- Poštuje se semantičko verzioniranje tj. automatski se ažurira na sledeću
  verziju koja je manja od naredne glavne (/major/) verzije.
- Ako prelazimo na novu glavnu verziju to moramo uraditi izmenom verzije u
  =Cargo.toml= fajlu.

** Generisanje slučajnog broja

Fajl =src/main.rs=:
#+begin_src rust
use std::io;
use rand::Rng;

fn main() {
    println!("Guess the number!");

    let secret_number = rand::thread_rng().gen_range(1..101);

    println!("The secret number is: {}", secret_number);

    println!("Please input your guess.");

    let mut guess = String::new();

    io::stdin()
        .read_line(&mut guess)
        .expect("Failed to read line");

    println!("You guessed: {}", guess);
}
#+end_src

U =gen_range= koristimo izraz opsega (/range expression/). Interval je zatvoren na
donjoj granici i otvoren na gornjoj. Za interval zatvoren i od gore možemo
pisati ~1..=100~.

** Dokumentacija za lokalne sanduke

Da bi znali koje metode i funkcije su nam dostupne možemo koristiti ugrađenu
dokumentaciju za sanduke projekta. Dokumentaciju dobijamo sa:

#+begin_src sh
cargo doc --open
#+end_src


** Pokretanje programa

#+begin_src sh
$ cargo run
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
    Finished dev [unoptimized + debuginfo] target(s) in 2.53s
     Running `target/debug/guessing_game`
Guess the number!
The secret number is: 7
Please input your guess.
4
You guessed: 4
#+end_src

** Poređenje tajnog broja sa zadatim

Fajl =src/main.rs=
#+begin_src rust
use rand::Rng;
use std::cmp::Ordering;
use std::io;

fn main() {
    // --snip--

    println!("You guessed: {}", guess);

    match guess.cmp(&secret_number) {
        Ordering::Less => println!("Too small!"),
        Ordering::Greater => println!("Too big!"),
        Ordering::Equal => println!("You win!"),
    }
}
#+end_src
- Koristimo =std::cmp::Ordering= enum koji ima varijante =Less=, =Greater= i =Equal=
- =match= izraz poredi zadatu vrednost sa vrednostima zadatim u telu i izvršava
  granu koja se podudara. Grane =match= izraza se u Rust terminologiji zovu "ruke" (/arms/).

** Popravka tipova
Kod sa prethodnog slajda nije ispravan:
#+begin_src sh
$ cargo build
   Compiling libc v0.2.86
   ...
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
error[E0308]: mismatched types
  --> src/main.rs:22:21
   |
22 |     match guess.cmp(&secret_number) {
   |                     ^^^^^^^^^^^^^^ expected struct `String`, found integer
   |
   = note: expected reference `&String`
              found reference `&{integer}`

error[E0283]: type annotations needed for `{integer}`
   --> src/main.rs:8:44
    |
8   |     let secret_number = rand::thread_rng().gen_range(1..101);
    |         -------------                      ^^^^^^^^^ cannot infer type for type `{integer}`
    |         |
    |         consider giving `secret_number` a type
    |
    = note: multiple `impl`s satisfying `{integer}: SampleUniform` found in the `rand` crate:
            - impl SampleUniform for i128;
            - impl SampleUniform for i16;
            - impl SampleUniform for i32;
            - impl SampleUniform for i64;
            and 8 more
...
#+end_src

#+REVEAL: split

Osnova greške je neslaganje tipova. Sa ulaza prihvatamo =String= dok nam je tajni
broj =integer=.

** Konverzija stringa u broj

Problem rešavamo konverzijom stringa sa ulaza u brojni tip.

#+begin_src rust
// --snip--

    let mut guess = String::new();

    io::stdin()
        .read_line(&mut guess)
        .expect("Failed to read line");

    let guess: u32 = guess.trim().parse().expect("Please type a number!");

    println!("You guessed: {}", guess);

    match guess.cmp(&secret_number) {
        Ordering::Less => println!("Too small!"),
        Ordering::Greater => println!("Too big!"),
        Ordering::Equal => println!("You win!"),
    }
#+end_src

#+REVEAL: split

Sada se program komapajlira.

#+begin_src sh
$ cargo run
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
    Finished dev [unoptimized + debuginfo] target(s) in 0.43s
     Running `target/debug/guessing_game`
Guess the number!
The secret number is: 58
Please input your guess.
  76
You guessed: 76
Too big!
#+end_src

** Omogućavanje višestrukog pogađanja - upotreba petlje

Fajl =src/main.rs=:
#+begin_src rust
// --snip--

    println!("The secret number is: {}", secret_number);

    loop {
        println!("Please input your guess.");

        // --snip--

        match guess.cmp(&secret_number) {
            Ordering::Less => println!("Too small!"),
            Ordering::Greater => println!("Too big!"),
            Ordering::Equal => println!("You win!"),
        }
    }
}
#+end_src


** Prekid rada

Problem je kako prekinuti program kada korisnik pogodi broj?

#+begin_src rust
// --snip--

        match guess.cmp(&secret_number) {
            Ordering::Less => println!("Too small!"),
            Ordering::Greater => println!("Too big!"),
            Ordering::Equal => {
                println!("You win!");
                break;
            }
        }
    }
}
#+end_src

** Rukovanje neispravnim ulazom

#+begin_src rust
// --snip--

        io::stdin()
            .read_line(&mut guess)
            .expect("Failed to read line");

        let guess: u32 = match guess.trim().parse() {
            Ok(num) => num,
            Err(_) => continue,
        };

        println!("You guessed: {}", guess);

        // --snip--
#+end_src

Potrebno je još obrisati liniju koja prikazuje generisani broj.

** Finalni kod

#+begin_src rust
use rand::Rng;
use std::cmp::Ordering;
use std::io;

fn main() {
    println!("Guess the number!");
    let secret_number = rand::thread_rng().gen_range(1..101);

    loop {
        println!("Please input your guess.");
        let mut guess = String::new();
        io::stdin()
            .read_line(&mut guess)
            .expect("Failed to read line");
        let guess: u32 = match guess.trim().parse() {
            Ok(num) => num,
            Err(_) => continue,
        };
        println!("You guessed: {}", guess);
        match guess.cmp(&secret_number) {
            Ordering::Less => println!("Too small!"),
            Ordering::Greater => println!("Too big!"),
            Ordering::Equal => {
                println!("You win!");
                break;
            }
        }
    }
}
#+end_src

* Osnovni programski koncepti
** Varijable i promenjivost (/mutability/)
*** Varijable i promenjivost (/mutability/)
- Varijable su podrazumevano nepromenjive.
- Jednom kada dobiju vrednost (/binding/) ta vrednost se ne može promeniti

  #+begin_src rust
    fn main() {
        let x = 5;
        println!("The value of x is: {}", x);
        x = 6;     // greška
        println!("The value of x is: {}", x);
    }
  #+end_src

  #+REVEAL: split

  #+begin_src sh
    $ cargo run
    Compiling variables v0.1.0 (file:///projects/variables)
    error[E0384]: cannot assign twice to immutable variable `x`
    --> src/main.rs:4:5
    |
    2 |     let x = 5;
    |         -
    |         |
    |         first assignment to `x`
    |         help: consider making this binding mutable: `mut x`
    3 |     println!("The value of x is: {}", x);
    4 |     x = 6;
    |     ^^^^^ cannot assign twice to immutable variable

    For more information about this error, try `rustc --explain E0384`.
    error: could not compile `variables` due to previous error
  #+end_src
*** =mut= ključna reč

#+begin_src rust
fn main() {
    let mut x = 5;
    println!("The value of x is: {}", x);
    x = 6;
    println!("The value of x is: {}", x);
}
#+end_src
** Konstante - =const=
- Slično kao nepromenjive varijable sa sledećim razlikama:
  - Uvek su nepromenjive
  - Mogu se inicijalizovati samo konstantnim izrazom (poznatim u vreme kompajliranja)
  - Validne za celokupno vreme izvršavanja programa u opsegu važenja gde su
    definisane (/scope/)
  - Mora se eksplicitno definisati tip
- Kompajler će konstante "ubaciti" na mestu upotrebe
- Po konvenciji imena konstanti se pišu velikim slovima

  #+begin_src rust
    const THREE_HOURS_IN_SECONDS: u32 = 60 * 60 * 3;
  #+end_src

** Tipovi podataka
*** Tipovi podataka
- Svaka vrednost u Rust-u ima tip. Tipovi moraju biti poznati u vreme
  kompajliranja (statički tipiziran jezik).
- Kompajler će probati da odredi tipove (/type inference/). Ako nije moguće
  zahteva se da definišemo tip eksplicitno.

  Npr:
  #+begin_src rust
    let guess: u32 = "42".parse().expect("Not a number!");
  #+end_src
  Ovde nije moguće odrediti tip jer =str::parse= funkcija može vratiti različite
  brojne tipove (funkcija je generička) a ne postoji način da se tip automatski
  odredi.

  Signatura je:
  #+begin_src rust
    pub fn parse<F>(&self) -> Result<F, <F as FromStr>::Err>
    where
        F: FromStr
  #+end_src
*** /Integer/ tipovi

| Dužina  | Signed | Unsigned |
|---------+--------+----------|
| 8-bit   | i8     | u8       |
| 16-bit  | i16    | u16      |
| 32-bit  | i32    | u32      |
| 64-bit  | i64    | u64      |
| 128-bit | i128   | u128     |
| arch    | isize  | usize    |

*** Literali brojeva

| Literali       | Primeri     |
|----------------+-------------|
| Decimal        | 98_222      |
| Hex            | 0xff        |
| Octal          | 0o77        |
| Binary         | 0b1111_0000 |
| Byte (u8 only) | b'A'        |

*** /Floating-Point/ tipovi

#+begin_src rust
fn main() {
    let x = 2.0; // f64

    let y: f32 = 3.0; // f32
}
#+end_src

IEEE-754 standard

*** Operacije nad brojevima

#+begin_src rust
fn main() {
    // addition
    let sum = 5 + 10;

    // subtraction
    let difference = 95.5 - 4.3;

    // multiplication
    let product = 4 * 30;

    // division
    let quotient = 56.7 / 32.2;
    let floored = 2 / 3; // Results in 0

    // remainder
    let remainder = 43 % 5;
}
#+end_src

*** /Boolean/ tip
#+begin_src rust
fn main() {
    let t = true;

    let f: bool = false; // with explicit type annotation
}
#+end_src

*** Tip karaktera

#+begin_src rust
fn main() {
    let c = 'z';
    let z = 'ℤ';
    let heart_eyed_cat = '😻';
}
#+end_src

*** Torke (/tuples/)
#+begin_src rust
fn main() {
    let tup: (i32, f64, u8) = (500, 6.4, 1);
}
#+end_src

- Raspakivanje torki (/destructuring/):
#+begin_src rust
fn main() {
    let tup = (500, 6.4, 1);

    let (x, y, z) = tup;

    println!("The value of y is: {}", y);
}
#+end_src

#+REVEAL: split

Pristup elementima torke:
#+begin_src rust
fn main() {
    let x: (i32, f64, u8) = (500, 6.4, 1);

    let five_hundred = x.0;

    let six_point_four = x.1;

    let one = x.2;
}
#+end_src

*** Nizovni tip
- Svaki element nizovnog tipa mora imati isti tip
- Dimenzija niza je nepromenjiva (alociran je na steku)
    #+begin_src rust
    fn main() {
        let a = [1, 2, 3, 4, 5];
    }
    #+end_src

- Tip se može eksplitino definisati na sledeći način (niz dužine =5= tipa =i32=):
    #+begin_src rust
    let a: [i32; 5] = [1, 2, 3, 4, 5];
    #+end_src

- Inicijalizacija svih elemenata na istu vrednost se obavlja na sledeći način:
  #+begin_src rust
  let a = [3; 5];
  #+end_src
  Gde je vrednost svakog elementa =3= a dužina niza =5=.

#+REVEAL: split

Indeksni pristup:

#+begin_src rust
fn main() {
    let a = [1, 2, 3, 4, 5];

    let first = a[0];
    let second = a[1];
}
#+end_src

** Funkcije
*** Funkcije
#+begin_src rust
fn main() {
    println!("Hello, world!");

    another_function();
}

fn another_function() {
    println!("Another function.");
}
#+end_src
- Za imenovanje funkcija kao i varijabli koristi se /snake_case/.
*** Funkcije - parametri
#+begin_src rust
fn main() {
    print_labeled_measurement(5, 'h');
}

fn print_labeled_measurement(value: i32, unit_label: char) {
    println!("The measurement is: {}{}", value, unit_label);
}
#+end_src

*** Iskazi i izrazi
- Rust je jezik baziran na izrazima (/expression-based/)
- Iskazi (/statements/) su jezičke konstrukcije koje nemaju povratnu vrednost.
  Izrazi (/expressions/) se evaluiraju u određeni rezultat, tj. imaju vrednost.
- Primer: =let= je iskaz tj. nema povratnu vrednost. Ovo možete pisati:
  #+begin_src rust
  let y = 6;
  #+end_src
  Ali ovo ne:
  #+begin_src rust
  let x = (let y = 6);
  #+end_src

#+REVEAL: split

Blok koda je takođe izraz. Šta je vrednost u koju se evaluira?

#+begin_src rust
{
    let x = 3;
    x + 1
}
#+end_src

Vrednost bloka je vrednost poslednjeg izraza, tj. =x+1=. Primetite da tu ne
koristimo =;= jer terminacija ovim karakterom pretvara izraz u iskaz.

#+REVEAL: split

Zbog ovoga je sasvim legalno da pišemo:

#+begin_src rust
fn main() {
    let y = {
        let x = 3;
        x + 1
    };

    println!("The value of y is: {}", y);
}
#+end_src

#+RESULTS:
: The value of y is: 4
*** Povratne vrednosti funkcija
Vrednost funkcije je vrednost bloka koji predstavlja telo funkcije, dakle
poslednjeg izraza unutar tela funkcije.

#+begin_src rust
fn five() -> i32 {
    5
}

fn main() {
    let x = five();

    println!("The value of x is: {}", x);
}
#+end_src

#+RESULTS:
: The value of x is: 5

#+REVEAL: split

Ili na primer:
#+begin_src rust
fn main() {
    let x = plus_one(5);

    println!("The value of x is: {}", x);
}

fn plus_one(x: i32) -> i32 {
    x + 1
}
#+end_src

#+RESULTS:
: The value of x is: 6

#+REVEAL: split

Ukoliko izraz =x+1= terminiramo sa =;= kod se neće kompajlirati jer funkcija
deklariše da vraća tip =i32= dok sada vraća =()= (tzv. /unit type/) odnosno nema
povratnu vrednost jer je poslednja instrukcija iskaz.

#+begin_src rust
fn main() {
    let x = plus_one(5);

    println!("The value of x is: {}", x);
}

fn plus_one(x: i32) -> i32 {
    x + 1;
}
#+end_src

#+begin_example
error[E0308]: mismatched types
 --> src/main.rs:8:24
  |
8 | fn plus_one(x: i32) -> i32 {
  |    --------            ^^^ expected `i32`, found `()`
  |    |
  |    implicitly returns `()` as its body has no tail or `return` expression
9 |     x + 1;
  |          - help: consider removing this semicolon

For more information about this error, try `rustc --explain E0308`.
error: could not compile `cargo4UyKF0` due to previous error
#+end_example



** Komentari
Komentari se pišu posle =//=. Ne postoji sintaksa za blok komentar kao npr. u
C/C++. Ovo bi bili validni komentari:
#+begin_src rust
// So we’re doing something complicated here, long enough that we need
// multiple lines of comments to do it! Whew! Hopefully, this comment will
// explain what’s going on.

fn main() {
    let lucky_number = 7; // I’m feeling lucky today
}
...
fn main() {
    // I’m feeling lucky today
    let lucky_number = 7;
}
#+end_src

#+REVEAL: split

Postoje i komentari za dokumentaciju koji predstavljaju posebnu sintaksu za
komentare koji su deo API dokumentacije. Oni se pišu posle =///=. Na primer:
#+begin_src rust
/// Adds one to the number given.
///
/// # Examples
///
/// ```
/// let arg = 5;
/// let answer = my_crate::add_one(arg);
///
/// assert_eq!(6, answer);
/// ```
pub fn add_one(x: i32) -> i32 {
    x + 1
}
#+end_src
** Kontrola toka
*** =if= izrazi
#+begin_src rust
fn main() {
    let number = 3;

    if number < 5 {
        println!("condition was true");
    } else {
        println!("condition was false");
    }
}
#+end_src

*** =if-else=
#+begin_src rust
fn main() {
    let number = 6;

    if number % 4 == 0 {
        println!("number is divisible by 4");
    } else if number % 3 == 0 {
        println!("number is divisible by 3");
    } else if number % 2 == 0 {
        println!("number is divisible by 2");
    } else {
        println!("number is not divisible by 4, 3, or 2");
    }
}
#+end_src
*** =if= u =let= iskazima
=if= je izraz pa se može koristiti gde god možemo pisati i bilo koji drugi izraz.

#+begin_src rust
fn main() {
    let condition = true;
    let number = if condition { 5 } else { 6 };

    println!("The value of number is: {}", number);
}
#+end_src

#+RESULTS:
: The value of number is: 5

#+REVEAL: split

Ali se grane moraju slagati po tipu. Ovo je pogrešno jer je prva grana tipa
=i32= dok je =else= grana tipa =str=.

#+begin_src rust
fn main() {
    let condition = true;

    let number = if condition { 5 } else { "six" };

    println!("The value of number is: {}", number);
}
#+end_src
*** Petlje
Rust ima tri tipa petlje:
- =loop= - za beskontačne petlje
- =while= - uslovna petlja
- =for= - petlja za iteraciju kroz iteratore

*** =loop=

#+begin_src rust
fn main() {
    loop {
        println!("again!");
    }
}
#+end_src

*** =loop= labele
Ukoliko imamo ugnježdene =loop= iskaze možemo koristiti labele prilikom izlaska sa
=break= instrukcijom.

#+begin_src rust
fn main() {
    let mut count = 0;
    'counting_up: loop {
        println!("count = {}", count);
        let mut remaining = 10;

        loop {
            println!("remaining = {}", remaining);
            if remaining == 9 {
                break;
            }
            if count == 2 {
                break 'counting_up;
            }
            remaining -= 1;
        }

        count += 1;
    }
    println!("End count = {}", count);
}
#+end_src

*** =loop= kao izraz
=loop= može imati povratnu vrednost. Povratna vrednost se definiše kao parametar
=break= instrukcije.

#+begin_src rust
fn main() {
    let mut counter = 0;

    let result = loop {
        counter += 1;

        if counter == 10 {
            break counter * 2;
        }
    };

    println!("The result is {}", result);
}
#+end_src
*** =while=
#+begin_src rust
fn main() {
    let mut number = 3;

    while number != 0 {
        println!("{}!", number);

        number -= 1;
    }

    println!("LIFTOFF!!!");
}
#+end_src
*** =for=
Iteraciju kroz uređenu kolekciju, kao što je niz, možemo obaviti sa =while= petljom.
#+begin_src rust
fn main() {
    let a = [10, 20, 30, 40, 50];
    let mut index = 0;

    while index < 5 {
        println!("the value is: {}", a[index]);

        index += 1;
    }
}
#+end_src

#+REVEAL: split
Ali je za tu namenu prirodnije i sigurnije koristiti =for= petlju. Takođe će se
program brže izvršavati.

#+begin_src rust
fn main() {
    let a = [10, 20, 30, 40, 50];

    for element in a {
        println!("the value is: {}", element);
    }
}
#+end_src

#+REVEAL: split
=for= petlje su najčešći oblik petlji u upotrebi u Rust-u. Koriste se npr. i u
situaciji kada je potrebno izvršiti petlju određeni broj puta.

#+begin_src rust
fn main() {
    for number in (1..4).rev() {
        println!("{}!", number);
    }
    println!("LIFTOFF!!!");
}
#+end_src

#+RESULTS:
: 3!
: 2!
: 1!
: LIFTOFF!!!

* Vlasništvo i pozamljivanje (/Ownership and borrowing/)
* Strukture
* Enumeracije i podudaranje obrazaca (/Pattern Matching/)
* Moduli
* Kolekcije
* Obrada grešaka
* Generički tipovi, osobine (/Traits/) i životni vek (/Lifetimes/)
* Literatura
- Steve Klabnik and Carol Nichols: [[https://doc.rust-lang.org/book/][The Rust Programming Language]], no starch press.
