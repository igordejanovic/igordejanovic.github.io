<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<title>Programski jezik Rust</title>
<meta name="author" content="Igor Dejanović"/>
<style type="text/css">
.underline { text-decoration: underline; }
</style>
<link rel="stylesheet" href="../../reveal.js/css/reveal.css"/>

<link rel="stylesheet" href="../../reveal.js/css/theme/simple.css" id="theme"/>

<link rel="stylesheet" href="../../reveal-slides.css"/>

<link rel="stylesheet" href="../../highlight-styles/docco.css"/>
<link rel="stylesheet" href=""/>

<!-- If the query includes 'print-pdf', include the PDF print sheet -->
<script>
    if( window.location.search.match( /print-pdf/gi ) ) {
        var link = document.createElement( 'link' );
        link.rel = 'stylesheet';
        link.type = 'text/css';
        link.href = '../../reveal.js/css/print/pdf.css';
        document.getElementsByTagName( 'head' )[0].appendChild( link );
    }
</script>
<base target="_blank">
</head>
<body>
<div class="reveal">
<div class="slides">
<section id="sec-title-slide">
<h1 class="title">Programski jezik Rust</h1>
<h2 class="subtitle">Bazirano na verziji 1.58.1. U izradi.</h2>
<h2 class="author">Prof. dr Igor Dejanović (<a href="mailto:igord at uns ac rs">igord at uns ac rs</a>)</h2>
<p class="date">Kreirano 2022-05-23 Mon 18:11, pritisni ESC za mapu, m za meni, Ctrl+Shift+F za pretragu</p>
</section>

<section>
<section id="slide-1">
<h2 id="1"><span class="section-number-2">1.</span> Uvod</h2>
<ul>
<li>Jezik opšte namene, kompajliran i statički tipiziran sa inferencom tipova</li>
<li>Sistemsko programiranje ali sa osobinama višeg nivoa apstrakcije kao što su
funkcionalno programiranje</li>
<li>2010, Graydon Hoare, Mozilla Research</li>
<li>Performanse i sigurnost</li>
<li>Ne koristi <i>garbage collector</i> ali obezbeđuje memorijsku sigurnost kroz <i>borrow
checker</i></li>
<li>Sintaksno sličan C++. Uticaj i OCaml-a, Haskell-a i Erlang-a.</li>
<li>Koristi se u velikim firmama: Amazon, Facebook, Google, Microsoft&#x2026;</li>
<li>Od 2016 godine na SO upitniku konstantno prvi u kategoriji <i>&ldquo;most loved
programming languages&rdquo;</i></li>

</ul>
</section>
</section>
<section>
<section id="slide-2">
<h2 id="2"><span class="section-number-2">2.</span> Instalacija i podešavanje</h2>
<div class="outline-text-2" id="text-2">
</div>
</section>
<section id="slide-2-1">
<h3 id="2-1"><span class="section-number-3">2.1.</span> Instalacija</h3>
<ul>
<li>Rust stiže sa alatom za upravljanje lanca alata <code>rustup</code></li>

</ul>

<div class="org-src-container">

<pre><code class="sh" >$ curl --proto '=https' --tlsv1.2 https://sh.rustup.rs -sSf | sh
</code></pre>
</div>

<ul>
<li>Provera instalacije</li>

</ul>

<div class="org-src-container">

<pre><code class="sh" >~&gt; rustc --version
rustc 1.58.1 (db9d1b20b 2022-01-20)
</code></pre>
</div>

</section>
<section id="slide-2-2">
<h3 id="2-2"><span class="section-number-3">2.2.</span> Pregled instalacije</h3>
<div class="org-src-container">

<pre><code class="sh" >~&gt; rustup show
Default host: x86_64-unknown-linux-gnu
rustup home:  /home/igor/.rustup

installed toolchains
--------------------

stable-x86_64-unknown-linux-gnu (default)
nightly-x86_64-unknown-linux-gnu

active toolchain
----------------

stable-x86_64-unknown-linux-gnu (default)
rustc 1.58.1 (db9d1b20b 2022-01-20)
</code></pre>
</div>

</section>
<section id="slide-2-3">
<h3 id="2-3"><span class="section-number-3">2.3.</span> Ažuriranje</h3>
<p>
Za ažuriranje instalacije na najnoviju verziju
</p>

<div class="org-src-container">

<pre><code class="sh" >rustup update
</code></pre>
</div>

</section>
<section id="slide-2-4">
<h3 id="2-4"><span class="section-number-3">2.4.</span> Dokumentacija</h3>
<p>
Rust stiže sa veoma dobrom dokumentacijom i knjigama koje su dostupne direktno
iz instalacije.
</p>

<div class="org-src-container">

<pre><code class="sh" >rustup doc
</code></pre>
</div>

</section>
</section>
<section>
<section id="slide-3">
<h2 id="3"><span class="section-number-2">3.</span> Početak</h2>
<div class="outline-text-2" id="text-3">
</div>
</section>
<section id="slide-3-1">
<h3 id="3-1"><span class="section-number-3">3.1.</span> Hello, World!</h3>
<div class="org-src-container">

<pre><code class="sh" >$ mkdir hello_world
$ cd hello_world
</code></pre>
</div>

<p>
File <code>main.rs</code>:
</p>
<div class="org-src-container">

<pre><code class="rust" >fn main() {
    println!("Hello, world!");
}
</code></pre>
</div>

</section>
<section id="slide-3-2">
<h3 id="3-2"><span class="section-number-3">3.2.</span> Kompajliranje i pokretanje</h3>
<div class="org-src-container">

<pre><code class="sh" >$ rustc main.rs
$ ./main
Hello, world!
</code></pre>
</div>
</section>
<section id="slide-3-3">
<h3 id="3-3"><span class="section-number-3">3.3.</span> Hello, Cargo!</h3>
<ul>
<li>Alat za razrešavanje zavisnosti i upravljanje projektom.</li>

</ul>

<div class="org-src-container">

<pre><code class="sh" >~&gt; cargo --version
cargo 1.58.0 (f01b232bc 2022-01-19)
</code></pre>
</div>

<ul>
<li>Kreiranje projekta sa <code>cargo</code> alatom:</li>

</ul>

<div class="org-src-container">

<pre><code class="sh" >$ cargo new hello_cargo
$ cd hello_cargo
</code></pre>
</div>

</section>
<section id="slide-3-4">
<h3 id="3-4"><span class="section-number-3">3.4.</span> Sadržaj kreiranog projekta</h3>
<p>
Fajl <code>cargo.toml</code> čuva konfiguraciju projekta. Format je <a href="https://toml.io/en/">TOML</a> (<i>Tom’s Obvious,
Minimal Language</i>):
</p>

<div class="org-src-container">

<pre><code class="toml" >[package]
name = "hello_cargo"
version = "0.1.0"
edition = "2021"

[dependencies]
</code></pre>
</div>

<p>
Fajl <code>src/main.rs</code>:
</p>
<div class="org-src-container">

<pre><code class="rust" >fn main() {
    println!("Hello, world!");
}
</code></pre>
</div>
</section>
<section id="slide-3-5">
<h3 id="3-5"><span class="section-number-3">3.5.</span> Pokretanje</h3>
<div class="org-src-container">

<pre><code class="rust" >$ cargo build
   Compiling hello_cargo v0.1.0 (file:///projects/hello_cargo)
    Finished dev [unoptimized + debuginfo] target(s) in 2.85 secs
</code></pre>
</div>

<p>
Izvršni fajl se može naći na lokaciji <code>target/debug/hello_cargo</code>:
</p>

<div class="org-src-container">

<pre><code class="sh" >$ ./target/debug/hello_cargo
Hello, world!
</code></pre>
</div>

<p>
Ali <code>cargo</code> omgućava i jednostavniji način pokretanja:
</p>
<div class="org-src-container">

<pre><code class="sh" >$ cargo run
    Finished dev [unoptimized + debuginfo] target(s) in 0.0 secs
     Running `target/debug/hello_cargo`
Hello, world!
</code></pre>
</div>

</section>
<section id="slide-3-6">
<h3 id="3-6"><span class="section-number-3">3.6.</span> Provera</h3>
<p>
Takođe je moguće brzo proveriti da li se kod kompajlira:
</p>

<div class="org-src-container">

<pre><code class="sh" >$ cargo check
   Checking hello_cargo v0.1.0 (file:///projects/hello_cargo)
    Finished dev [unoptimized + debuginfo] target(s) in 0.32 secs
</code></pre>
</div>

</section>
<section id="slide-3-7">
<h3 id="3-7"><span class="section-number-3">3.7.</span> Izgradnja finalne verzije</h3>
<ul>
<li>U toku razvoja koristimo izgradnju za degabovanje koja se brže završi ali je
izvršni kod neoptimalan.</li>

<li><p>
Za finalnu verziju je potrebno izgradnju obaviti na sledeći način:
</p>

<div class="org-src-container">

<pre><code class="rust" >    cargo build --release
</code></pre>
</div></li>

<li>Ovo će obaviti dodatne optimizacije koje će duže trajati ali će krajnji kod
biti optimizovan.</li>

</ul>

</section>
<section id="slide-3-8">
<h3 id="3-8"><span class="section-number-3">3.8.</span> Cargo kao konvencija</h3>
<p>
Praktično svi Rust projekti koriste Cargo tako da je unifikovan način izgradnje
projekata. Uglavnom se svodi na:
</p>

<div class="org-src-container">

<pre><code class="sh" >$ git clone example.org/someproject
$ cd someproject
$ cargo build
</code></pre>
</div>

</section>
</section>
<section>
<section id="slide-4">
<h2 id="4"><span class="section-number-2">4.</span> Igra pogađanja brojeva</h2>
<div class="outline-text-2" id="text-4">
</div>
</section>
<section id="slide-4-1">
<h3 id="4-1"><span class="section-number-3">4.1.</span> Podešavanje projekta</h3>
<div class="org-src-container">

<pre><code class="rust" >$ cargo new guessing_game
$ cd guessing_game
</code></pre>
</div>

<p>
Fajl <code>Cargo.toml</code>:
</p>
<div class="org-src-container">

<pre><code class="toml" >[package]
name = "guessing_game"
version = "0.1.0"
edition = "2021"

[dependencies]
</code></pre>
</div>

<p>
Fajl <code>src/main.rs</code>:
</p>
<div class="org-src-container">

<pre><code class="rust" >fn main() {
    println!("Hello, world!");
}
</code></pre>
</div>

</section>
<section>

<div class="org-src-container">

<pre><code class="sh" >$ cargo run
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
    Finished dev [unoptimized + debuginfo] target(s) in 1.50s
     Running `target/debug/guessing_game`
Hello, world!
</code></pre>
</div>

</section>
<section id="slide-4-2">
<h3 id="4-2"><span class="section-number-3">4.2.</span> Preuzimanje broja sa standardnog ulaza</h3>
<div class="org-src-container">

<pre><code class="rust" >use std::io;

fn main() {
    println!("Guess the number!");

    println!("Please input your guess.");

    let mut guess = String::new();

    io::stdin()
        .read_line(&amp;mut guess)
        .expect("Failed to read line");

    println!("You guessed: {}", guess);
}
</code></pre>
</div>

</section>
<section id="slide-4-3">
<h3 id="4-3"><span class="section-number-3">4.3.</span> Promenjivost (<i>mutability</i>)</h3>
<ul>
<li>Varijable su podrazumevano nepromenjive (<i>immutable</i>).</li>
<li><p>
Ukoliko želimo varijablu čija vrednost može da se menja koristimo ključnu reč
<code>mut</code>.
</p>

<div class="org-src-container">

<pre><code class="rust" >  let apples = 5; // immutable
  let mut bananas = 5; // mutable
</code></pre>
</div></li>

<li><p>
Isto važi i za parametre funkcija:
</p>

<div class="org-src-container">

<pre><code class="rust" >  io::stdin()
      .read_line(&amp;mut guess)
</code></pre>
</div></li>

</ul>

</section>
<section id="slide-4-4">
<h3 id="4-4"><span class="section-number-3">4.4.</span> Obrada mogućih grešaka upotrebom <code>Result</code> tipa</h3>
<p>
<code>read_line</code> može da završi neuspešno. Zato vraća <code>io::Result</code> tip koji predstavlja
enumeraciju (<i>enum</i>) tip i ima dve vrednosti: <code>Ok</code> i <code>Err</code>.
</p>

<div class="org-src-container">

<pre><code class="rust" >io::stdin()
    .read_line(&amp;mut guess)
    .expect("Failed to read line");
</code></pre>
</div>

<p>
<code>expect</code> implementiran na <code>Ok</code> varijanti će vratiti vrednost koja je sadržana unutar
varijante dok implementacija nad <code>Err</code> varijanti prekida izvršavanje programa.
</p>

</section>
<section id="slide-4-5">
<h3 id="4-5"><span class="section-number-3">4.5.</span> Pokretanje</h3>
<div class="org-src-container">

<pre><code class="rust" >$ cargo run
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
    Finished dev [unoptimized + debuginfo] target(s) in 6.44s
     Running `target/debug/guessing_game`
Guess the number!
Please input your guess.
6
You guessed: 6
</code></pre>
</div>

</section>
<section id="slide-4-6">
<h3 id="4-6"><span class="section-number-3">4.6.</span> Generisanje slučajnog broja</h3>
<p>
Koristimo <code>rand</code> paket (sanduk - <i>crate</i> u terminologiji Cargo-a).
</p>

<p>
Sekcija <code>[dependencies]</code> u fajlu <code>Cargo.toml</code>:
</p>
<div class="org-src-container">

<pre><code class="toml" >[dependencies]
rand = "0.8.3"
</code></pre>
</div>

<div class="org-src-container">

<pre><code class="sh" >$ cargo build
    Updating crates.io index
  Downloaded rand v0.8.3
  Downloaded libc v0.2.86
  ...
   Compiling rand_chacha v0.3.0
   Compiling rand v0.8.3
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
    Finished dev [unoptimized + debuginfo] target(s) in 2.53s
</code></pre>
</div>

<p>
Cargo koristi <a href="https://semver.org/">Semantic Versioning</a>. Rust paketi se preuzimaju sa sajta <a href="https://crates.io/">crates.io</a>
i keširaju lokalno.
</p>

</section>
<section id="slide-4-7">
<h3 id="4-7"><span class="section-number-3">4.7.</span> Ponovljivost izgradnje - <i>Cargo.lock</i></h3>
<ul>
<li>Prvi put kada se pokrene <code>cargo build</code> kreira se fajl <code>Cargo.lock</code> sa
informacijama o verzijama svih sanduka koji su instalirani.</li>
<li>Svako sledeće pokretanje izgradnje koristi iste verzije.</li>
<li><code>Cargo.lock</code> je potrebno čuvati u sistemu kontrole verzija (npr. <code>git</code>) da bi se
osigurala ponovljivost.</li>

</ul>

</section>
<section id="slide-4-8">
<h3 id="4-8"><span class="section-number-3">4.8.</span> Ažuriranje sanduka</h3>
<ul>
<li><p>
Ažuriranje na nove verzije sanduka se obavlja sa:
</p>

<div class="org-src-container">

<pre><code class="sh" >  $ cargo update
    Updating crates.io index
    Updating rand v0.8.3 -&gt; v0.8.4
</code></pre>
</div></li>
<li>Poštuje se semantičko verzioniranje tj. automatski se ažurira na sledeću
verziju koja je manja od naredne glavne (<i>major</i>) verzije.</li>
<li>Ako prelazimo na novu glavnu verziju to moramo uraditi izmenom verzije u
<code>Cargo.toml</code> fajlu.</li>

</ul>

</section>
<section id="slide-4-9">
<h3 id="4-9"><span class="section-number-3">4.9.</span> Generisanje slučajnog broja</h3>
<p>
Fajl <code>src/main.rs</code>:
</p>
<div class="org-src-container">

<pre><code class="rust" >use std::io;
use rand::Rng;

fn main() {
    println!("Guess the number!");

    let secret_number = rand::thread_rng().gen_range(1..101);

    println!("The secret number is: {}", secret_number);

    println!("Please input your guess.");

    let mut guess = String::new();

    io::stdin()
        .read_line(&amp;mut guess)
        .expect("Failed to read line");

    println!("You guessed: {}", guess);
}
</code></pre>
</div>

<p>
U <code>gen_range</code> koristimo izraz opsega (<i>range expression</i>). Interval je zatvoren na
donjoj granici i otvoren na gornjoj. Za interval zatvoren i od gore možemo
pisati <code>1..=100</code>.
</p>

</section>
<section id="slide-4-10">
<h3 id="4-10"><span class="section-number-3">4.10.</span> Dokumentacija za lokalne sanduke</h3>
<p>
Da bi znali koje metode i funkcije su nam dostupne možemo koristiti ugrađenu
dokumentaciju za sanduke projekta. Dokumentaciju dobijamo sa:
</p>

<div class="org-src-container">

<pre><code class="sh" >cargo doc --open
</code></pre>
</div>


</section>
<section id="slide-4-11">
<h3 id="4-11"><span class="section-number-3">4.11.</span> Pokretanje programa</h3>
<div class="org-src-container">

<pre><code class="sh" >$ cargo run
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
    Finished dev [unoptimized + debuginfo] target(s) in 2.53s
     Running `target/debug/guessing_game`
Guess the number!
The secret number is: 7
Please input your guess.
4
You guessed: 4
</code></pre>
</div>

</section>
<section id="slide-4-12">
<h3 id="4-12"><span class="section-number-3">4.12.</span> Poređenje tajnog broja sa zadatim</h3>
<p>
Fajl <code>src/main.rs</code>
</p>
<div class="org-src-container">

<pre><code class="rust" >use rand::Rng;
use std::cmp::Ordering;
use std::io;

fn main() {
    // --snip--

    println!("You guessed: {}", guess);

    match guess.cmp(&amp;secret_number) {
        Ordering::Less =&gt; println!("Too small!"),
        Ordering::Greater =&gt; println!("Too big!"),
        Ordering::Equal =&gt; println!("You win!"),
    }
}
</code></pre>
</div>
<ul>
<li>Koristimo <code>std::cmp::Ordering</code> enum koji ima varijante <code>Less</code>, <code>Greater</code> i <code>Equal</code></li>
<li><code>match</code> izraz poredi zadatu vrednost sa vrednostima zadatim u telu i izvršava
granu koja se podudara. Grane <code>match</code> izraza se u Rust terminologiji zovu &ldquo;ruke&rdquo; (<i>arms</i>).</li>

</ul>

</section>
<section id="slide-4-13">
<h3 id="4-13"><span class="section-number-3">4.13.</span> Popravka tipova</h3>
<p>
Kod sa prethodnog slajda nije ispravan:
</p>
<div class="org-src-container">

<pre><code class="sh" >$ cargo build
   Compiling libc v0.2.86
   ...
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
error[E0308]: mismatched types
  --&gt; src/main.rs:22:21
   |
22 |     match guess.cmp(&amp;secret_number) {
   |                     ^^^^^^^^^^^^^^ expected struct `String`, found integer
   |
   = note: expected reference `&amp;String`
              found reference `&amp;{integer}`

error[E0283]: type annotations needed for `{integer}`
   --&gt; src/main.rs:8:44
    |
8   |     let secret_number = rand::thread_rng().gen_range(1..101);
    |         -------------                      ^^^^^^^^^ cannot infer type for type `{integer}`
    |         |
    |         consider giving `secret_number` a type
    |
    = note: multiple `impl`s satisfying `{integer}: SampleUniform` found in the `rand` crate:
            - impl SampleUniform for i128;
            - impl SampleUniform for i16;
            - impl SampleUniform for i32;
            - impl SampleUniform for i64;
            and 8 more
...
</code></pre>
</div>

</section>
<section>

<p>
Osnova greške je neslaganje tipova. Sa ulaza prihvatamo <code>String</code> dok nam je tajni
broj <code>integer</code>.
</p>

</section>
<section id="slide-4-14">
<h3 id="4-14"><span class="section-number-3">4.14.</span> Konverzija stringa u broj</h3>
<p>
Problem rešavamo konverzijom stringa sa ulaza u brojni tip.
</p>

<div class="org-src-container">

<pre><code class="rust" >// --snip--

    let mut guess = String::new();

    io::stdin()
        .read_line(&amp;mut guess)
        .expect("Failed to read line");

    let guess: u32 = guess.trim().parse().expect("Please type a number!");

    println!("You guessed: {}", guess);

    match guess.cmp(&amp;secret_number) {
        Ordering::Less =&gt; println!("Too small!"),
        Ordering::Greater =&gt; println!("Too big!"),
        Ordering::Equal =&gt; println!("You win!"),
    }
</code></pre>
</div>

</section>
<section>

<p>
Sada se program komapajlira.
</p>

<div class="org-src-container">

<pre><code class="sh" >$ cargo run
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
    Finished dev [unoptimized + debuginfo] target(s) in 0.43s
     Running `target/debug/guessing_game`
Guess the number!
The secret number is: 58
Please input your guess.
  76
You guessed: 76
Too big!
</code></pre>
</div>

</section>
<section id="slide-4-15">
<h3 id="4-15"><span class="section-number-3">4.15.</span> Omogućavanje višestrukog pogađanja - upotreba petlje</h3>
<p>
Fajl <code>src/main.rs</code>:
</p>
<div class="org-src-container">

<pre><code class="rust" >// --snip--

    println!("The secret number is: {}", secret_number);

    loop {
        println!("Please input your guess.");

        // --snip--

        match guess.cmp(&amp;secret_number) {
            Ordering::Less =&gt; println!("Too small!"),
            Ordering::Greater =&gt; println!("Too big!"),
            Ordering::Equal =&gt; println!("You win!"),
        }
    }
}
</code></pre>
</div>


</section>
<section id="slide-4-16">
<h3 id="4-16"><span class="section-number-3">4.16.</span> Prekid rada</h3>
<p>
Problem je kako prekinuti program kada korisnik pogodi broj?
</p>

<div class="org-src-container">

<pre><code class="rust" >// --snip--

        match guess.cmp(&amp;secret_number) {
            Ordering::Less =&gt; println!("Too small!"),
            Ordering::Greater =&gt; println!("Too big!"),
            Ordering::Equal =&gt; {
                println!("You win!");
                break;
            }
        }
    }
}
</code></pre>
</div>

</section>
<section id="slide-4-17">
<h3 id="4-17"><span class="section-number-3">4.17.</span> Rukovanje neispravnim ulazom</h3>
<div class="org-src-container">

<pre><code class="rust" >// --snip--

        io::stdin()
            .read_line(&amp;mut guess)
            .expect("Failed to read line");

        let guess: u32 = match guess.trim().parse() {
            Ok(num) =&gt; num,
            Err(_) =&gt; continue,
        };

        println!("You guessed: {}", guess);

        // --snip--
</code></pre>
</div>

<p>
Potrebno je još obrisati liniju koja prikazuje generisani broj.
</p>

</section>
<section id="slide-4-18">
<h3 id="4-18"><span class="section-number-3">4.18.</span> Finalni kod</h3>
<div class="org-src-container">

<pre><code class="rust" >use rand::Rng;
use std::cmp::Ordering;
use std::io;

fn main() {
    println!("Guess the number!");
    let secret_number = rand::thread_rng().gen_range(1..101);

    loop {
        println!("Please input your guess.");
        let mut guess = String::new();
        io::stdin()
            .read_line(&amp;mut guess)
            .expect("Failed to read line");
        let guess: u32 = match guess.trim().parse() {
            Ok(num) =&gt; num,
            Err(_) =&gt; continue,
        };
        println!("You guessed: {}", guess);
        match guess.cmp(&amp;secret_number) {
            Ordering::Less =&gt; println!("Too small!"),
            Ordering::Greater =&gt; println!("Too big!"),
            Ordering::Equal =&gt; {
                println!("You win!");
                break;
            }
        }
    }
}
</code></pre>
</div>

</section>
</section>
<section>
<section id="slide-5">
<h2 id="5"><span class="section-number-2">5.</span> Osnovni programski koncepti</h2>
<div class="outline-text-2" id="text-5">
</div>
</section>
<section id="slide-5-1">
<h3 id="5-1"><span class="section-number-3">5.1.</span> Varijable i promenjivost (<i>mutability</i>)</h3>
<div class="outline-text-3" id="text-5-1">
</div>
</section>
<section id="slide-5-1-1">
<h4 id="5-1-1"><span class="section-number-4">5.1.1.</span> Varijable i promenjivost (<i>mutability</i>)</h4>
<ul>
<li>Varijable su podrazumevano nepromenjive.</li>
<li><p>
Jednom kada dobiju vrednost (<i>binding</i>) ta vrednost se ne može promeniti
</p>

<div class="org-src-container">

<pre><code class="rust" >    fn main() {
        let x = 5;
        println!("The value of x is: {}", x);
        x = 6;     // greška
        println!("The value of x is: {}", x);
    }
</code></pre>
</div>

</section>
<section>

<div class="org-src-container">

<pre><code class="sh" >    $ cargo run
    Compiling variables v0.1.0 (file:///projects/variables)
    error[E0384]: cannot assign twice to immutable variable `x`
    --&gt; src/main.rs:4:5
    |
    2 |     let x = 5;
    |         -
    |         |
    |         first assignment to `x`
    |         help: consider making this binding mutable: `mut x`
    3 |     println!("The value of x is: {}", x);
    4 |     x = 6;
    |     ^^^^^ cannot assign twice to immutable variable

    For more information about this error, try `rustc --explain E0384`.
    error: could not compile `variables` due to previous error
</code></pre>
</div></li>

</ul>
</section>
<section id="slide-5-1-2">
<h4 id="5-1-2"><span class="section-number-4">5.1.2.</span> <code>mut</code> ključna reč</h4>
<div class="org-src-container">

<pre><code class="rust" >fn main() {
    let mut x = 5;
    println!("The value of x is: {}", x);
    x = 6;
    println!("The value of x is: {}", x);
}
</code></pre>
</div>
</section>
<section id="slide-5-2">
<h3 id="5-2"><span class="section-number-3">5.2.</span> Konstante - <code>const</code></h3>
<ul>
<li>Slično kao nepromenjive varijable sa sledećim razlikama:
<ul>
<li>Uvek su nepromenjive</li>
<li>Mogu se inicijalizovati samo konstantnim izrazom (poznatim u vreme kompajliranja)</li>
<li>Validne za celokupno vreme izvršavanja programa u opsegu važenja gde su
definisane (<i>scope</i>)</li>
<li>Mora se eksplicitno definisati tip</li>

</ul></li>
<li>Kompajler će konstante &ldquo;ubaciti&rdquo; na mestu upotrebe</li>
<li><p>
Po konvenciji imena konstanti se pišu velikim slovima
</p>

<div class="org-src-container">

<pre><code class="rust" >    const THREE_HOURS_IN_SECONDS: u32 = 60 * 60 * 3;
</code></pre>
</div></li>

</ul>

</section>
<section id="slide-5-3">
<h3 id="5-3"><span class="section-number-3">5.3.</span> Tipovi podataka</h3>
<div class="outline-text-3" id="text-5-3">
</div>
</section>
<section id="slide-5-3-1">
<h4 id="5-3-1"><span class="section-number-4">5.3.1.</span> Tipovi podataka</h4>
<ul>
<li>Svaka vrednost u Rust-u ima tip. Tipovi moraju biti poznati u vreme
kompajliranja (statički tipiziran jezik).</li>
<li><p>
Kompajler će probati da odredi tipove (<i>type inference</i>). Ako nije moguće
zahteva se da definišemo tip eksplicitno.
</p>

<p>
Npr:
</p>
<div class="org-src-container">

<pre><code class="rust" >    let guess: u32 = "42".parse().expect("Not a number!");
</code></pre>
</div>
<p>
Ovde nije moguće odrediti tip jer <code>str::parse</code> funkcija može vratiti različite
brojne tipove (funkcija je generička) a ne postoji način da se tip automatski
odredi.
</p>

<p>
Signatura je:
</p>
<div class="org-src-container">

<pre><code class="rust" >    pub fn parse&lt;F&gt;(&amp;self) -&gt; Result&lt;F, &lt;F as FromStr&gt;::Err&gt;
    where
        F: FromStr
</code></pre>
</div></li>

</ul>
</section>
<section id="slide-5-3-2">
<h4 id="5-3-2"><span class="section-number-4">5.3.2.</span> <i>Integer</i> tipovi</h4>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">Dužina</th>
<th scope="col" class="org-left">Signed</th>
<th scope="col" class="org-left">Unsigned</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">8-bit</td>
<td class="org-left">i8</td>
<td class="org-left">u8</td>
</tr>

<tr>
<td class="org-left">16-bit</td>
<td class="org-left">i16</td>
<td class="org-left">u16</td>
</tr>

<tr>
<td class="org-left">32-bit</td>
<td class="org-left">i32</td>
<td class="org-left">u32</td>
</tr>

<tr>
<td class="org-left">64-bit</td>
<td class="org-left">i64</td>
<td class="org-left">u64</td>
</tr>

<tr>
<td class="org-left">128-bit</td>
<td class="org-left">i128</td>
<td class="org-left">u128</td>
</tr>

<tr>
<td class="org-left">arch</td>
<td class="org-left">isize</td>
<td class="org-left">usize</td>
</tr>
</tbody>
</table>

</section>
<section id="slide-5-3-3">
<h4 id="5-3-3"><span class="section-number-4">5.3.3.</span> Literali brojeva</h4>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">Literali</th>
<th scope="col" class="org-left">Primeri</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">Decimal</td>
<td class="org-left">98_222</td>
</tr>

<tr>
<td class="org-left">Hex</td>
<td class="org-left">0xff</td>
</tr>

<tr>
<td class="org-left">Octal</td>
<td class="org-left">0o77</td>
</tr>

<tr>
<td class="org-left">Binary</td>
<td class="org-left">0b1111_0000</td>
</tr>

<tr>
<td class="org-left">Byte (u8 only)</td>
<td class="org-left">b&rsquo;A&rsquo;</td>
</tr>
</tbody>
</table>

</section>
<section id="slide-5-3-4">
<h4 id="5-3-4"><span class="section-number-4">5.3.4.</span> <i>Floating-Point</i> tipovi</h4>
<div class="org-src-container">

<pre><code class="rust" >fn main() {
    let x = 2.0; // f64

    let y: f32 = 3.0; // f32
}
</code></pre>
</div>

<p>
IEEE-754 standard
</p>

</section>
<section id="slide-5-3-5">
<h4 id="5-3-5"><span class="section-number-4">5.3.5.</span> Operacije nad brojevima</h4>
<div class="org-src-container">

<pre><code class="rust" >fn main() {
    // addition
    let sum = 5 + 10;

    // subtraction
    let difference = 95.5 - 4.3;

    // multiplication
    let product = 4 * 30;

    // division
    let quotient = 56.7 / 32.2;
    let floored = 2 / 3; // Results in 0

    // remainder
    let remainder = 43 % 5;
}
</code></pre>
</div>

</section>
<section id="slide-5-3-6">
<h4 id="5-3-6"><span class="section-number-4">5.3.6.</span> <i>Boolean</i> tip</h4>
<div class="org-src-container">

<pre><code class="rust" >fn main() {
    let t = true;

    let f: bool = false; // with explicit type annotation
}
</code></pre>
</div>

</section>
<section id="slide-5-3-7">
<h4 id="5-3-7"><span class="section-number-4">5.3.7.</span> Tip karaktera</h4>
<div class="org-src-container">

<pre><code class="rust" >fn main() {
    let c = 'z';
    let z = 'ℤ';
    let heart_eyed_cat = '😻';
}
</code></pre>
</div>

</section>
<section id="slide-5-3-8">
<h4 id="5-3-8"><span class="section-number-4">5.3.8.</span> Torke (<i>tuples</i>)</h4>
<div class="org-src-container">

<pre><code class="rust" >fn main() {
    let tup: (i32, f64, u8) = (500, 6.4, 1);
}
</code></pre>
</div>

<ul>
<li>Raspakivanje torki (<i>destructuring</i>):</li>

</ul>
<div class="org-src-container">

<pre><code class="rust" >fn main() {
    let tup = (500, 6.4, 1);

    let (x, y, z) = tup;

    println!("The value of y is: {}", y);
}
</code></pre>
</div>

</section>
<section>

<p>
Pristup elementima torke:
</p>
<div class="org-src-container">

<pre><code class="rust" >fn main() {
    let x: (i32, f64, u8) = (500, 6.4, 1);

    let five_hundred = x.0;

    let six_point_four = x.1;

    let one = x.2;
}
</code></pre>
</div>

</section>
<section id="slide-5-3-9">
<h4 id="5-3-9"><span class="section-number-4">5.3.9.</span> Nizovni tip</h4>
<ul>
<li>Svaki element nizovnog tipa mora imati isti tip</li>
<li><p>
Dimenzija niza je nepromenjiva (alociran je na steku)
</p>
<div class="org-src-container">

<pre><code class="rust" >    fn main() {
        let a = [1, 2, 3, 4, 5];
    }
</code></pre>
</div></li>

<li><p>
Tip se može eksplitino definisati na sledeći način (niz dužine <code>5</code> tipa <code>i32</code>):
</p>
<div class="org-src-container">

<pre><code class="rust" >    let a: [i32; 5] = [1, 2, 3, 4, 5];
</code></pre>
</div></li>

<li><p>
Inicijalizacija svih elemenata na istu vrednost se obavlja na sledeći način:
</p>
<div class="org-src-container">

<pre><code class="rust" >  let a = [3; 5];
</code></pre>
</div>
<p>
Gde je vrednost svakog elementa <code>3</code> a dužina niza <code>5</code>.
</p></li>

</ul>

</section>
<section>

<p>
Indeksni pristup:
</p>

<div class="org-src-container">

<pre><code class="rust" >fn main() {
    let a = [1, 2, 3, 4, 5];

    let first = a[0];
    let second = a[1];
}
</code></pre>
</div>

</section>
<section id="slide-5-4">
<h3 id="5-4"><span class="section-number-3">5.4.</span> Funkcije</h3>
<div class="outline-text-3" id="text-5-4">
</div>
</section>
<section id="slide-5-4-1">
<h4 id="5-4-1"><span class="section-number-4">5.4.1.</span> Funkcije</h4>
<div class="org-src-container">

<pre><code class="rust" >fn main() {
    println!("Hello, world!");

    another_function();
}

fn another_function() {
    println!("Another function.");
}
</code></pre>
</div>
<ul>
<li>Za imenovanje funkcija kao i varijabli koristi se <i>snake_case</i>.</li>

</ul>
</section>
<section id="slide-5-4-2">
<h4 id="5-4-2"><span class="section-number-4">5.4.2.</span> Funkcije - parametri</h4>
<div class="org-src-container">

<pre><code class="rust" >fn main() {
    print_labeled_measurement(5, 'h');
}

fn print_labeled_measurement(value: i32, unit_label: char) {
    println!("The measurement is: {}{}", value, unit_label);
}
</code></pre>
</div>

</section>
<section id="slide-5-4-3">
<h4 id="5-4-3"><span class="section-number-4">5.4.3.</span> Iskazi i izrazi</h4>
<ul>
<li>Rust je jezik baziran na izrazima (<i>expression-based</i>)</li>
<li>Iskazi (<i>statements</i>) su jezičke konstrukcije koje nemaju povratnu vrednost.
Izrazi (<i>expressions</i>) se evaluiraju u određeni rezultat, tj. imaju vrednost.</li>
<li><p>
Primer: <code>let</code> je iskaz tj. nema povratnu vrednost. Ovo možete pisati:
</p>
<div class="org-src-container">

<pre><code class="rust" >  let y = 6;
</code></pre>
</div>
<p>
Ali ovo ne:
</p>
<div class="org-src-container">

<pre><code class="rust" >  let x = (let y = 6);
</code></pre>
</div></li>

</ul>

</section>
<section>

<p>
Blok koda je takođe izraz. Šta je vrednost u koju se evaluira?
</p>

<div class="org-src-container">

<pre><code class="rust" >{
    let x = 3;
    x + 1
}
</code></pre>
</div>

<p>
Vrednost bloka je vrednost poslednjeg izraza, tj. <code>x+1</code>. Primetite da tu ne
koristimo <code>;</code> jer terminacija ovim karakterom pretvara izraz u iskaz.
</p>

</section>
<section>

<p>
Zbog ovoga je sasvim legalno da pišemo:
</p>

<div class="org-src-container">

<pre><code class="rust" >fn main() {
    let y = {
        let x = 3;
        x + 1
    };

    println!("The value of y is: {}", y);
}
</code></pre>
</div>

<pre class="example">
The value of y is: 4
</pre>
</section>
<section id="slide-5-4-4">
<h4 id="5-4-4"><span class="section-number-4">5.4.4.</span> Povratne vrednosti funkcija</h4>
<p>
Vrednost funkcije je vrednost bloka koji predstavlja telo funkcije, dakle
poslednjeg izraza unutar tela funkcije.
</p>

<div class="org-src-container">

<pre><code class="rust" >fn five() -&gt; i32 {
    5
}

fn main() {
    let x = five();

    println!("The value of x is: {}", x);
}
</code></pre>
</div>

<pre class="example">
The value of x is: 5
</pre>


</section>
<section>

<p>
Ili na primer:
</p>
<div class="org-src-container">

<pre><code class="rust" >fn main() {
    let x = plus_one(5);

    println!("The value of x is: {}", x);
}

fn plus_one(x: i32) -&gt; i32 {
    x + 1
}
</code></pre>
</div>

<pre class="example">
The value of x is: 6
</pre>


</section>
<section>

<p>
Ukoliko izraz <code>x+1</code> terminiramo sa <code>;</code> kod se neće kompajlirati jer funkcija
deklariše da vraća tip <code>i32</code> dok sada vraća <code>()</code> (tzv. <i>unit type</i>) odnosno nema
povratnu vrednost jer je poslednja instrukcija iskaz.
</p>

<div class="org-src-container">

<pre><code class="rust" >fn main() {
    let x = plus_one(5);

    println!("The value of x is: {}", x);
}

fn plus_one(x: i32) -&gt; i32 {
    x + 1;
}
</code></pre>
</div>

<pre class="example" id="org4c22bf6">
error[E0308]: mismatched types
 --&gt; src/main.rs:8:24
  |
8 | fn plus_one(x: i32) -&gt; i32 {
  |    --------            ^^^ expected `i32`, found `()`
  |    |
  |    implicitly returns `()` as its body has no tail or `return` expression
9 |     x + 1;
  |          - help: consider removing this semicolon

For more information about this error, try `rustc --explain E0308`.
error: could not compile `cargo4UyKF0` due to previous error
</pre>

</section>
<section id="slide-5-5">
<h3 id="5-5"><span class="section-number-3">5.5.</span> Komentari</h3>
<p>
Komentari se pišu posle <code>//</code>. Ne postoji sintaksa za blok komentar kao npr. u
C/C++. Ovo bi bili validni komentari:
</p>
<div class="org-src-container">

<pre><code class="rust" >// So we’re doing something complicated here, long enough that we need
// multiple lines of comments to do it! Whew! Hopefully, this comment will
// explain what’s going on.

fn main() {
    let lucky_number = 7; // I’m feeling lucky today
}
...
fn main() {
    // I’m feeling lucky today
    let lucky_number = 7;
}
</code></pre>
</div>

</section>
<section>

<p>
Postoje i komentari za dokumentaciju koji predstavljaju posebnu sintaksu za
komentare koji su deo API dokumentacije. Oni se pišu posle <code>///</code>. Na primer:
</p>
<div class="org-src-container">

<pre><code class="rust" >/// Adds one to the number given.
///
/// # Examples
///
/// ```
/// let arg = 5;
/// let answer = my_crate::add_one(arg);
///
/// assert_eq!(6, answer);
/// ```
pub fn add_one(x: i32) -&gt; i32 {
    x + 1
}
</code></pre>
</div>
</section>
<section id="slide-5-6">
<h3 id="5-6"><span class="section-number-3">5.6.</span> Kontrola toka</h3>
<div class="outline-text-3" id="text-5-6">
</div>
</section>
<section id="slide-5-6-1">
<h4 id="5-6-1"><span class="section-number-4">5.6.1.</span> <code>if</code> izrazi</h4>
<div class="org-src-container">

<pre><code class="rust" >fn main() {
    let number = 3;

    if number &lt; 5 {
        println!("condition was true");
    } else {
        println!("condition was false");
    }
}
</code></pre>
</div>

</section>
<section id="slide-5-6-2">
<h4 id="5-6-2"><span class="section-number-4">5.6.2.</span> <code>if-else</code></h4>
<div class="org-src-container">

<pre><code class="rust" >fn main() {
    let number = 6;

    if number % 4 == 0 {
        println!("number is divisible by 4");
    } else if number % 3 == 0 {
        println!("number is divisible by 3");
    } else if number % 2 == 0 {
        println!("number is divisible by 2");
    } else {
        println!("number is not divisible by 4, 3, or 2");
    }
}
</code></pre>
</div>
</section>
<section id="slide-5-6-3">
<h4 id="5-6-3"><span class="section-number-4">5.6.3.</span> <code>if</code> u <code>let</code> iskazima</h4>
<p>
<code>if</code> je izraz pa se može koristiti gde god možemo pisati i bilo koji drugi izraz.
</p>

<div class="org-src-container">

<pre><code class="rust" >fn main() {
    let condition = true;
    let number = if condition { 5 } else { 6 };

    println!("The value of number is: {}", number);
}
</code></pre>
</div>

<pre class="example">
The value of number is: 5
</pre>


</section>
<section>

<p>
Ali se grane moraju slagati po tipu. Ovo je pogrešno jer je prva grana tipa
<code>i32</code> dok je <code>else</code> grana tipa <code>str</code>.
</p>

<div class="org-src-container">

<pre><code class="rust" >fn main() {
    let condition = true;

    let number = if condition { 5 } else { "six" };

    println!("The value of number is: {}", number);
}
</code></pre>
</div>
</section>
<section id="slide-5-6-4">
<h4 id="5-6-4"><span class="section-number-4">5.6.4.</span> Petlje</h4>
<p>
Rust ima tri tipa petlje:
</p>
<ul>
<li><code>loop</code> - za beskontačne petlje</li>
<li><code>while</code> - uslovna petlja</li>
<li><code>for</code> - petlja za iteraciju kroz iteratore</li>

</ul>

</section>
<section id="slide-5-6-5">
<h4 id="5-6-5"><span class="section-number-4">5.6.5.</span> <code>loop</code></h4>
<div class="org-src-container">

<pre><code class="rust" >fn main() {
    loop {
        println!("again!");
    }
}
</code></pre>
</div>

</section>
<section id="slide-5-6-6">
<h4 id="5-6-6"><span class="section-number-4">5.6.6.</span> <code>loop</code> labele</h4>
<p>
Ukoliko imamo ugnježdene <code>loop</code> iskaze možemo koristiti labele prilikom izlaska sa
<code>break</code> instrukcijom.
</p>

<div class="org-src-container">

<pre><code class="rust" >fn main() {
    let mut count = 0;
    'counting_up: loop {
        println!("count = {}", count);
        let mut remaining = 10;

        loop {
            println!("remaining = {}", remaining);
            if remaining == 9 {
                break;
            }
            if count == 2 {
                break 'counting_up;
            }
            remaining -= 1;
        }

        count += 1;
    }
    println!("End count = {}", count);
}
</code></pre>
</div>

</section>
<section id="slide-5-6-7">
<h4 id="5-6-7"><span class="section-number-4">5.6.7.</span> <code>loop</code> kao izraz</h4>
<p>
<code>loop</code> može imati povratnu vrednost. Povratna vrednost se definiše kao parametar
<code>break</code> instrukcije.
</p>

<div class="org-src-container">

<pre><code class="rust" >fn main() {
    let mut counter = 0;

    let result = loop {
        counter += 1;

        if counter == 10 {
            break counter * 2;
        }
    };

    println!("The result is {}", result);
}
</code></pre>
</div>
</section>
<section id="slide-5-6-8">
<h4 id="5-6-8"><span class="section-number-4">5.6.8.</span> <code>while</code></h4>
<div class="org-src-container">

<pre><code class="rust" >fn main() {
    let mut number = 3;

    while number != 0 {
        println!("{}!", number);

        number -= 1;
    }

    println!("LIFTOFF!!!");
}
</code></pre>
</div>
</section>
<section id="slide-5-6-9">
<h4 id="5-6-9"><span class="section-number-4">5.6.9.</span> <code>for</code></h4>
<p>
Iteraciju kroz uređenu kolekciju, kao što je niz, možemo obaviti sa <code>while</code> petljom.
</p>
<div class="org-src-container">

<pre><code class="rust" >fn main() {
    let a = [10, 20, 30, 40, 50];
    let mut index = 0;

    while index &lt; 5 {
        println!("the value is: {}", a[index]);

        index += 1;
    }
}
</code></pre>
</div>

</section>
<section>
<p>
Ali je za tu namenu prirodnije i sigurnije koristiti <code>for</code> petlju. Takođe će se
program brže izvršavati.
</p>

<div class="org-src-container">

<pre><code class="rust" >fn main() {
    let a = [10, 20, 30, 40, 50];

    for element in a {
        println!("the value is: {}", element);
    }
}
</code></pre>
</div>

</section>
<section>
<p>
<code>for</code> petlje su najčešći oblik petlji u upotrebi u Rust-u. Koriste se npr. i u
situaciji kada je potrebno izvršiti petlju određeni broj puta.
</p>

<div class="org-src-container">

<pre><code class="rust" >fn main() {
    for number in (1..4).rev() {
        println!("{}!", number);
    }
    println!("LIFTOFF!!!");
}
</code></pre>
</div>

<pre class="example">
3!
2!
1!
LIFTOFF!!!
</pre>

</section>
</section>
<section>
<section id="slide-6">
<h2 id="6"><span class="section-number-2">6.</span> Vlasništvo i pozajmljivanje (<i>Ownership and borrowing</i>)</h2>
<div class="outline-text-2" id="text-6">
</div>
</section>
<section id="slide-6-1">
<h3 id="6-1"><span class="section-number-3">6.1.</span> Vlasništvo</h3>
<ul>
<li>Jedan od najvažnijih koncepata jezika.</li>
<li>Skup pravila koji omogućavaju upravljanje memorijom.</li>
<li>Garancije za memorijsku sigurnost bez upotrebe <i>garbage collector</i>-a</li>
<li>Sve provere se obavljaju u vreme kompajliranja - rezultuje odličnim
performansama u vreme izvršavanja.</li>

</ul>

</section>
<section id="slide-6-2">
<h3 id="6-2"><span class="section-number-3">6.2.</span> Stek i hip (<i>Stack and Heap</i>)</h3>
<ul>
<li>Stek - alokacija prostora za podatke čija je veličina poznata u vreme
kompajliranja.
<ul>
<li>Brža alokacija i dealokacija - jednostavan mehanizam, LIFO struktura.</li>
<li>Brži pristup - lokalne varijable, keširanje pristupa.</li>

</ul></li>
<li>Hip - slobodna alokacija u vreme izvršavanja.
<ul>
<li>Sporija alokacija i dealokacija.</li>
<li>Sporiji pristup - proizvoljna lokacija.</li>

</ul></li>

</ul>

</section>
<section id="slide-6-3">
<h3 id="6-3"><span class="section-number-3">6.3.</span> Pravila vlasništva</h3>
<ol>
<li>Svaka vrednost u Rust-u ima varijablu koja se naziva <i>vlasnikom</i> (<i>owner</i>).</li>
<li>U svakom trenutku postoji samo jedan vlasnik.</li>
<li>Kada vlasnik izađe iz opsega važenja (<i>scope</i>) vrednost se dealocira (<i>drop</i>).</li>

</ol>

</section>
<section id="slide-6-4">
<h3 id="6-4"><span class="section-number-3">6.4.</span> Opseg važenja varijable (<i>Variable Scope</i>)</h3>
<div class="org-src-container">

<pre><code class="rust" >{                      // s nije validno ovde jer još nije deklarisano
    let s = "hello";   // s je validno od ove pozicije

    // koristimo s
}   // ovde opseg prestaje da važi i s više nije validno
</code></pre>
</div>

</section>
<section id="slide-6-5">
<h3 id="6-5"><span class="section-number-3">6.5.</span> <code>String</code> tip</h3>
<ul>
<li><p>
Demonstracija vlasništva nad tipom koji se alocira na hipu.
</p>

<div class="org-src-container">

<pre><code class="rust" >  let mut s = String::from("hello");
  s.push_str(", world!"); // push_str() dodaje literal na string
  println!("{}", s); // hello, world!`
</code></pre>
</div></li>

<li>Memorija se alocira sa hipa u vreme izvršavanja.</li>
<li>Moramo vratiti memoriju alokatoru kada nam više nije potrebna.</li>

</ul>

</section>
<section>

<ul>
<li><p>
Alokacija stringa se obavlja na liniji:
</p>

<div class="org-src-container">

<pre><code class="rust" >  let mut s = String::from("hello");
</code></pre>
</div></li>

<li>Ali dealokacija je teža:
<ul>
<li><i>Garbage collector</i></li>
<li><i>Memory waste</i></li>
<li><i>Double-free</i></li>

</ul></li>

</ul>

</section>
<section>

<ul>
<li>Rust kompajler će dodati kod koji radi dealokaciju kada vlasnik napusti opseg važenja.</li>
<li><p>
Poziva se funkcija <code>drop</code> nad tipom i ova funkcija je zadužena da obavi dealokaciju.
</p>

<div class="org-src-container">

<pre><code class="rust" >  {
        let s = String::from("hello"); // s postaje validno

        // koristimo s
  }  // &lt;- s izlazi iz opsega i poziva se "drop"
</code></pre>
</div></li>

</ul>

</section>
<section id="slide-6-6">
<h3 id="6-6"><span class="section-number-3">6.6.</span> Dodela vrednosti</h3>
<ul>
<li><p>
Kopiranje vrednosti <code>x</code> u <code>y</code>. Obe varijable sada imaju vrednost <code>5</code>.
</p>

<div class="org-src-container">

<pre><code class="rust" >  let x = 5;
  let y = x;
</code></pre>
</div></li>

<li><p>
Ali sa <code>String</code> tipom dešava se nešto drugo.
</p>

<div class="org-src-container">

<pre><code class="rust" >  let s1 = String::from("hello");
</code></pre>
</div></li>

</ul>


<div id="org8f9f59e" class="figure">
<p><img src="./images/string-type.png" alt="string-type.png" style="height: 400px;" />
</p>
</div>

</section>
<section>

<ul>
<li><p>
Ako bi se kopirao samo sadržaj sa steka bez imali bismo sledeću situaciju
(tzv. <i>shallow copy</i>).
</p>

<div class="org-src-container">

<pre><code class="rust" >  let s1 = String::from("hello");
  let s2 = s1;
</code></pre>
</div></li>

</ul>


<div id="orgde98ea9" class="figure">
<p><img src="./images/string-type-2.png" alt="string-type-2.png" style="height: 400px;" />
</p>
</div>

<p>
Što je problematično jer kada i <code>s1</code> i <code>s2</code> napuste opseg pokušaće se dvostruka
dealokacija iste memorije na hipu (<i>double free</i>).
</p>

</section>
<section>

<p>
Ako bi se i hip memorija kopirala (tzv. <i>deep copy</i>) imali bismo validnu situaciju
ali bi takva operacija bila veoma &ldquo;skupa&rdquo;.
</p>


<div id="org650f4ec" class="figure">
<p><img src="./images/string-type-3.png" alt="string-type-3.png" style="height: 500px;" />
</p>
</div>

</section>
<section id="slide-6-7">
<h3 id="6-7"><span class="section-number-3">6.7.</span> Premeštanje (<i>Move</i>)</h3>
<p>
Ako probamo da kompajliramo sledeći kod:
</p>

<div class="org-src-container">

<pre><code class="rust" >let s1 = String::from("hello");
let s2 = s1;

println!("{}, world!", s1);
</code></pre>
</div>

<p>
Dobićemo grešku:
</p>

<pre class="example" id="orge50e94b">
$ cargo run
   Compiling ownership v0.1.0 (file:///projects/ownership)
error[E0382]: borrow of moved value: `s1`
 --&gt; src/main.rs:5:28
  |
2 |     let s1 = String::from("hello");
  |         -- move occurs because `s1` has type `String`, which does not implement the `Copy` trait
3 |     let s2 = s1;
  |              -- value moved here
4 |
5 |     println!("{}, world!", s1);
  |                            ^^ value borrowed here after move

For more information about this error, try `rustc --explain E0382`.
error: could not compile `ownership` due to previous error
</pre>

</section>
<section>

<p>
Ono što nam kompajler kaže je da se u iskazu:
</p>

<div class="org-src-container">

<pre><code class="rust" >let s2 = s1;
</code></pre>
</div>

<p>
promenio vlasnik ovog stringa. Novi vlasnik je sada <code>s2</code> dok je varijabla <code>s1</code>
postala nevalidna i nije je više moguće koristiti.
</p>

<p>
Kažemo da se obavilo &ldquo;premeštanje&rdquo; (<i>move</i>) vrednosti iz <code>s1</code> u <code>s2</code>.
</p>


<div id="org2db72f6" class="figure">
<p><img src="./images/string-type-4.png" alt="string-type-4.png" style="height: 400px;" />
</p>
</div>

<p>
Čime se ispunjava prvo pravilo vlasništva i sprečava <i>double free</i> greška.
</p>

</section>
<section id="slide-6-8">
<h3 id="6-8"><span class="section-number-3">6.8.</span> Kloniranje</h3>
<p>
Posledica prethodnog je da Rust nikada neće automatski obaviti duboko kopiranje
varijable jer bi to moglo da izazove loše performanse.
</p>

<p>
Duboko kopiranje (stek+hip) radimo sa <code>clone</code> metodom:
</p>

<div class="org-src-container">

<pre><code class="rust" >let s1 = String::from("hello");
let s2 = s1.clone();

println!("s1 = {}, s2 = {}", s1, s2);
</code></pre>
</div>

<p>
Sada je lako pronaći u kodu sva mesta gde se obavlja potencijalno &ldquo;skupa&rdquo;
operacija dubokog kopiranja.
</p>

</section>
<section id="slide-6-9">
<h3 id="6-9"><span class="section-number-3">6.9.</span> <i>Copy</i> tipovi</h3>
<p>
Kako onda radi primer koji smo videli prethodno? Zašto ne dolazi do premeštanja
i invalidacije <code>y</code> varijable?
</p>

<div class="org-src-container">

<pre><code class="rust" >let x = 5;
let y = x;

println!("x = {}, y = {}", x, y);
</code></pre>
</div>

<ul>
<li>Kod prostih tipova čija je veličina poznata u vreme kompajliranja i koji mogu
u celosti stati na stek nema razlike između dubokog i plitkog kopiranja.</li>
<li>Ovakvi tipovi su anotirani sa <i>Copy</i> trejtom (<i>Trait</i>). Tipovi koji su na ovaj
način anotirani ne obavljaju premeštanje već uvek kopiranje.</li>
<li>Implikacija je da se varijabla sa desne strane dodele može koristiti i nakon
dodele.</li>
<li>Rust će sprečiti <i>Copy</i> anotaciju ako tip implementira i <i>Drop</i> jer to znači da
radi neku specijalnu alokaciju pa mu je potrebna i posebna dealokacija što
znači da mora da se radi premeštanje.</li>

</ul>

</section>
<section id="slide-6-10">
<h3 id="6-10"><span class="section-number-3">6.10.</span> Vlasništvo i funkcije</h3>
<ul>
<li>Semantika prenosa parametara kod poziva funkcija je slična semantici dodele.</li>

</ul>

<div class="org-src-container">

<pre><code class="rust" >fn main() {
    let s = String::from("hello");  // s postaje validno

    takes_ownership(s);             // s vrednost se premešta u funkciju...
                                    // ... tako da s nije validno od ove pozicije

    let x = 5;                      // x postaje validno

    makes_copy(x);                  // x bi se premestilo u funkciju,
                                    // ali i32 je Copy, tako da je ok
                                    // da se x koristi i posle

} // x izlazi iz opsega, zatim s. Ali pošto je s premešteno ništa posebno se
  // ne dešava.

fn takes_ownership(some_string: String) { // some_string ulazi u opseg
    println!("{}", some_string);
} // some_string izlazi iz opsega i poziva se `drop`. Memorija sa hipa se
  // oslobađa.

fn makes_copy(some_integer: i32) { // some_integer ulazi u opseg
    println!("{}", some_integer);
} // some_integer izlazi iz opsega. Pošto nije 'Drop', ništa posebno se ne
  // događa (osim "skidanja" sa steka naravno)
</code></pre>
</div>

</section>
<section id="slide-6-11">
<h3 id="6-11"><span class="section-number-3">6.11.</span> Povratne vrednosti i opsezi</h3>
<p>
Prilikom vraćanja vrednosti iz funkcije takođe može doći do premeštanja vlasništva.
</p>

<div class="org-src-container">

<pre><code class="rust" >fn main() {
    let s1 = gives_ownership();         // gives_ownership premešta povratnu
                                        // vrednost u s1

    let s2 = String::from("hello");     // s2 postaje validno

    let s3 = takes_and_gives_back(s2);  // s2 se premešta u funkciju
                                        // takes_and_gives_back, koja premešta
                                        // povratnu vrednost u s3
} // s3 izlazi iz opsega i poziva se `drop`. s2 je premeštena pa se ništa
  // ne dešava. s1 takođe izlazi iz opsega i dealocira se.

fn gives_ownership() -&gt; String {             // gives_ownership će premestiti
                                             // svoju povratnu vrednost u funkciju
                                             // koja je poziva

    let some_string = String::from("yours"); // some_string postaje validno

    some_string                              // some_string se premešta
                                             // u funkciju pozivaoca
}

// Ova funkcija uzima vlasništvo nad stringom i vraća ga nazad
fn takes_and_gives_back(a_string: String) -&gt; String { // a_string postaje validno

    a_string  // a_string se premešta u funkciju pozivaoca
}
</code></pre>
</div>

</section>
<section>

<ul>
<li>Često nam je potrebno da varijablu koristimo i posle slanja u funkciju.</li>
<li>Mogli bi je stalo vraćati zajedno sa rezultatom funkcije na primer upotrebom torki.</li>

</ul>

<div class="org-src-container">

<pre><code class="rust" >fn main() {
    let s1 = String::from("hello");

    let (s2, len) = calculate_length(s1);

    println!("The length of '{}' is {}.", s2, len);
}

fn calculate_length(s: String) -&gt; (String, usize) {
    let length = s.len();

    (s, length)
}
</code></pre>
</div>

<p>
Ali je to naporno. Postoji koncept u Rust-u koji je namenjen u ovakvim
situacijama i baziran je na referencama i pozajmljivanju vrednosti.
</p>
</section>
<section id="slide-6-12">
<h3 id="6-12"><span class="section-number-3">6.12.</span> Reference i pozajmljivanje (<i>References and Borrowing</i>)</h3>
<ul>
<li>Referenca je poput pointera, sadrži adresu vrednosti koju poseduje neka druga
varijabla.</li>
<li>Za razliku od pointera, reference u Rust-u su garantovano validne.</li>

</ul>

<div class="org-src-container">

<pre><code class="rust" >fn main() {
    let s1 = String::from("hello");

    let len = calculate_length(&amp;s1);

    println!("The length of '{}' is {}.", s1, len);
}

fn calculate_length(s: &amp;String) -&gt; usize {
    s.len()
}
</code></pre>
</div>


<div id="org3d59b56" class="figure">
<p><img src="./images/reference.png" alt="reference.png" style="height: 400px;" />
</p>
</div>

</section>
<section id="slide-6-13">
<h3 id="6-13"><span class="section-number-3">6.13.</span> Referenciranje</h3>
<ul>
<li><p>
Primena operatora <code>&amp;</code> nad varijablom nazivamo <i>referenciranje</i>.
</p>

<div class="org-src-container">

<pre><code class="rust" >  let s1 = String::from("hello");
  let len = calculate_length(&amp;s1);
</code></pre>
</div></li>

<li>Sintaksa <code>&amp;s1</code> nam omogućava da kreiramo referencu na vrednost čiji vlasnik je
<code>s1</code> bez uzimanja vlasništva.</li>
<li>Pošto referenca nije vlasnik ne dolazi do dealokacije prilikom izlaska iz
opsega.</li>
<li>Operacija obrnuta referenciranju naziva se <i>dereferenciranje</i> i vrši se <code>*</code>
operatorom nad referencom (npr. <code>*s2</code> je vrednost na koju referencira <code>s2</code>).</li>
<li>Operaciju referenciranja nazivamo pozajmljivanjem (<i>borrowing</i>).</li>

</ul>

</section>
<section>

<ul>
<li>Takođe, parametar funkcije može biti referenca.</li>

</ul>
<div class="org-src-container">

<pre><code class="rust" >fn calculate_length(s: &amp;String) -&gt; usize { // s je referenca na String
    s.len()
} // s izlazi iz opsega ali pošto nema vlasništvo nad vrednošću
  // ništa se ne dešava.
</code></pre>
</div>

</section>
<section id="slide-6-14">
<h3 id="6-14"><span class="section-number-3">6.14.</span> Promena pozajmljene vrednosti</h3>
<p>
Šta se dešava ukoliko pokušamo da modifikujemo pozajmljenu vrednost?
</p>

<div class="org-src-container">

<pre><code class="rust" >fn main() {
    let s = String::from("hello");
    change(&amp;s);
}

fn change(some_string: &amp;String) {
    some_string.push_str(", world");
}
</code></pre>
</div>

<pre class="example" id="orgd8a5dd7">
$ cargo run
   Compiling ownership v0.1.0 (file:///projects/ownership)
error[E0596]: cannot borrow `*some_string` as mutable, as it is behind a `&amp;` reference
 --&gt; src/main.rs:8:5
  |
7 | fn change(some_string: &amp;String) {
  |                        ------- help: consider changing this to be a mutable reference: `&amp;mut String`
8 |     some_string.push_str(", world");
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ `some_string` is a `&amp;` reference, so the data it refers
  to cannot be borrowed as mutable

For more information about this error, try `rustc --explain E0596`.
error: could not compile `ownership` due to previous error
</pre>

</section>
<section id="slide-6-15">
<h3 id="6-15"><span class="section-number-3">6.15.</span> Promenjive reference</h3>
<p>
Kao i varijable, i reference su podrazumevano nepromenjiva (<i>immutable</i>). Moramo
biti eksplicitni ukoliko nam treba promenjiva referenca.
</p>

<div class="org-src-container">

<pre><code class="rust" >fn main() {
    let mut s = String::from("hello");
    change(&amp;mut s);
}

fn change(some_string: &amp;mut String) {
    some_string.push_str(", world");
}
</code></pre>
</div>

</section>
<section id="slide-6-16">
<h3 id="6-16"><span class="section-number-3">6.16.</span> Više promenjivih referenci nad istom vrednošću</h3>
<p>
Rust ne dozvoljava da isti podatak u jednom trenutku ima više promenjivih
referenci.
</p>

<div class="org-src-container">

<pre><code class="rust" >let mut s = String::from("hello");

let r1 = &amp;mut s;
let r2 = &amp;mut s;

println!("{}, {}", r1, r2);
</code></pre>
</div>

<pre class="example" id="orgfc9cd09">
$ cargo run
   Compiling ownership v0.1.0 (file:///projects/ownership)
error[E0499]: cannot borrow `s` as mutable more than once at a time
 --&gt; src/main.rs:5:14
  |
4 |     let r1 = &amp;mut s;
  |              ------ first mutable borrow occurs here
5 |     let r2 = &amp;mut s;
  |              ^^^^^^ second mutable borrow occurs here
6 |
7 |     println!("{}, {}", r1, r2);
  |                        -- first borrow later used here

For more information about this error, try `rustc --explain E0499`.
error: could not compile `ownership` due to previous error
</pre>

</section>
<section>

<p>
Ovim ograničenjem Rust, u vreme kompajliranja, sprečava klasu grešaka koje
dovode do nedefinisanog ponašanja i koje zovemo <i>data races</i>. Ove greške se veoma
teško otkrivaju i otklanjaju i mogu nastati ukoliko su zadovoljeni sledeći
uslovi:
</p>

<ul>
<li>Dva ili više pointera pristupaju istim podacima u isto vreme,</li>
<li>Bar jedan pointer se koristi za izmenu podatka,</li>
<li>Ne postoji mehanizam za sinhronizaciju pristupa.</li>

</ul>

</section>
<section>

<p>
Više promenjivih referenci možemo imati ali ne u istom opsegu:
</p>

<div class="org-src-container">

<pre><code class="rust" >let mut s = String::from("hello");

{
    let r1 = &amp;mut s;
} // r1 ovde izlazi iz opsega tako da možemo krairati nove reference

let r2 = &amp;mut s;
</code></pre>
</div>

</section>
<section id="slide-6-17">
<h3 id="6-17"><span class="section-number-3">6.17.</span> Kombinacija promenjivih i nepromenjivih referenci</h3>
<p>
Slično pravilo postoji i ukoliko imamo kombinaciju promenjivih i nepromenjivih
referenci:
</p>

<div class="org-src-container">

<pre><code class="rust" >let mut s = String::from("hello");

let r1 = &amp;s; // ovo je OK
let r2 = &amp;s; // ovo je OK
let r3 = &amp;mut s; // GREŠKA!

println!("{}, {}, and {}", r1, r2, r3);
</code></pre>
</div>

<pre class="example" id="orgc446dc8">
$ cargo run
   Compiling ownership v0.1.0 (file:///projects/ownership)
error[E0502]: cannot borrow `s` as mutable because it is also borrowed as immutable
 --&gt; src/main.rs:6:14
  |
4 |     let r1 = &amp;s; // no problem
  |              -- immutable borrow occurs here
5 |     let r2 = &amp;s; // no problem
6 |     let r3 = &amp;mut s; // BIG PROBLEM
  |              ^^^^^^ mutable borrow occurs here
7 |
8 |     println!("{}, {}, and {}", r1, r2, r3);
  |                                -- immutable borrow later used here

For more information about this error, try `rustc --explain E0502`.
error: could not compile `ownership` due to previous error
</pre>

</section>
<section>

<ul>
<li>Ne možemo istovremeno imati nepromenjive i promenjive reference jer korisnici
nepromenjivih referenci ne očekuju da se podaci menjaju.</li>
<li>Možemo imati više nepromenjivih referenci jer niko ne može da menja podatke i
time utiče na druge.</li>

</ul>

</section>
<section id="slide-6-18">
<h3 id="6-18"><span class="section-number-3">6.18.</span> Opseg važenja reference</h3>
<p>
Opseg važenja reference počinje od mesta gde je uvedena pa do njene poslednje
upotrebe. Na primer, ovo je validno:
</p>

<div class="org-src-container">

<pre><code class="rust" >let mut s = String::from("hello");

let r1 = &amp;s; // OK
let r2 = &amp;s; // OK
println!("{} and {}", r1, r2);
// varijable r1 i r2 se ne koriste u nastavku pa njihov opseg
// prestaje da važi.

let r3 = &amp;mut s; // zato je ovo OK
println!("{}", r3);
</code></pre>
</div>

<p>
Ova osobina referenci se naziva <i>Non-Lexical Lifetimes (NLL)</i>.
</p>

</section>
<section id="slide-6-19">
<h3 id="6-19"><span class="section-number-3">6.19.</span> &ldquo;Viseće&rdquo; reference</h3>
<ul>
<li>U jezicima sa pointerima lako je kreirati pointer na deo memorije koji je dealociran.</li>
<li>Rust garantovano sprečava ovakve greške. Reference su uvek validne u Rust-u.</li>

</ul>

<div class="org-src-container">

<pre><code class="rust" >fn main() {
    let reference_to_nothing = dangle();
}

fn dangle() -&gt; &amp;String {
    let s = String::from("hello");

    &amp;s
}
</code></pre>
</div>

</section>
<section>

<pre class="example" id="org13453b0">
$ cargo run
   Compiling ownership v0.1.0 (file:///projects/ownership)
error[E0106]: missing lifetime specifier
 --&gt; src/main.rs:5:16
  |
5 | fn dangle() -&gt; &amp;String {
  |                ^ expected named lifetime parameter
  |
  = help: this function's return type contains a borrowed value, but there is no value
  for it to be borrowed from
help: consider using the `'static` lifetime
  |
5 | fn dangle() -&gt; &amp;'static String {
  |                ~~~~~~~~

For more information about this error, try `rustc --explain E0106`.
error: could not compile `ownership` due to previous error
</pre>

<ul>
<li>Mehanizam koji ovo sprečava naziva se &ldquo;vreme života&rdquo; (<i>lifetime</i>) i biće
detaljnije obrađeno u nastavku.</li>
<li><p>
U prevodu Rust nam poručuje:
</p>

<blockquote>
<p>
Tip povratne vrednosti ove funkcije je pozajmljena vrednost, ali vrednost koja
je pozajmljena posle povratka više ne postoji.
</p>
</blockquote></li>

</ul>

</section>
<section id="slide-6-20">
<h3 id="6-20"><span class="section-number-3">6.20.</span> Šta se tačno desilo</h3>
<div class="org-src-container">

<pre><code class="rust" >fn dangle() -&gt; &amp;String { // dangle vraća referencu na String

    let s = String::from("hello"); // s je novi String

    &amp;s // Vraćamo referencu na String s
} // s izlazi iz opsega i poziva se `drop`. Memorija se oslobađa.
  // OPASNOST! Vraćena referenca će biti "viseća".
</code></pre>
</div>

<p>
Kako se može rešiti. Vratićemo posedovanu (<i>owned</i>) vrednost, tj uradićemo
premeštanje vrednosti u funkciju pozivaoca.
</p>

<div class="org-src-container">

<pre><code class="rust" >fn no_dangle() -&gt; String {
    let s = String::from("hello");

    s
}
</code></pre>
</div>

</section>
<section id="slide-6-21">
<h3 id="6-21"><span class="section-number-3">6.21.</span> Pravila referenciranja</h3>
<ol>
<li>U svakom trenutku možemo imati ili jednu promenjivu ili proizvoljan broj
nepromenjivih referenci.</li>
<li>Reference uvek moraju biti validne.</li>

</ol>

</section>
</section>
<section>
<section id="slide-7">
<h2 id="7"><span class="section-number-2">7.</span> Strukture</h2>
</section>
</section>
<section>
<section id="slide-8">
<h2 id="8"><span class="section-number-2">8.</span> Enumeracije i podudaranje obrazaca (<i>Pattern Matching</i>)</h2>
</section>
</section>
<section>
<section id="slide-9">
<h2 id="9"><span class="section-number-2">9.</span> Moduli</h2>
</section>
</section>
<section>
<section id="slide-10">
<h2 id="10"><span class="section-number-2">10.</span> Kolekcije</h2>
</section>
</section>
<section>
<section id="slide-11">
<h2 id="11"><span class="section-number-2">11.</span> Obrada grešaka</h2>
</section>
</section>
<section>
<section id="slide-12">
<h2 id="12"><span class="section-number-2">12.</span> Generički tipovi, osobine (<i>Traits</i>) i životni vek (<i>Lifetimes</i>)</h2>
</section>
</section>
<section>
<section id="slide-13">
<h2 id="13"><span class="section-number-2">13.</span> Literatura</h2>
<ul>
<li>Steve Klabnik and Carol Nichols: <a href="https://doc.rust-lang.org/book/">The Rust Programming Language</a>, no starch press.</li>

</ul>
</section>
</section>
</div>
</div>
<script src="../../reveal.js/js/reveal.js"></script>
<script>
// Full list of configuration options available here:
// https://github.com/hakimel/reveal.js#configuration
Reveal.initialize({

controls: true,
progress: true,
history: false,
center: true,
slideNumber: 'c/t',
rollingLinks: false,
keyboard: true,
mouseWheel: false,
fragmentInURL: true,
hashOneBasedIndex: false,
pdfSeparateFragments: true,
overview: true,
width: 1400,
height: 1000,
minScale: 0.30,
maxScale: 4.00,

theme: Reveal.getQueryHash().theme, // available themes are in /css/theme
transition: Reveal.getQueryHash().transition || 'slide', // see README of reveal.js for options
transitionSpeed: 'default',

// Optional libraries used to extend reveal.js
dependencies: [
{src: '../../reveal.js/../reveal-plugins/menu/menu.js'},
{src: '../../reveal.js/../reveal-plugins/chalkboard/chalkboard.js'},
 { src: '../../reveal.js/plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } },
 { src: '../../reveal.js/plugin/search/search.js', async: true, condition: function() { return !!document.body.classList; } }]

,keyboard: {67: function() { RevealChalkboard.toggleNotesCanvas() },	66: function() { RevealChalkboard.toggleChalkboard() },	46: function() { RevealChalkboard.clear() },	8: function() { RevealChalkboard.reset() },	68: function() { RevealChalkboard.download() },	},});
</script>
</body>
</html>
