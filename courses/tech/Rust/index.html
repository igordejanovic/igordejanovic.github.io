<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<title>Programski jezik Rust</title>
<meta name="author" content="Igor Dejanoviƒá"/>
<style type="text/css">
.underline { text-decoration: underline; }
</style>
<link rel="stylesheet" href="../../reveal.js/css/reveal.css"/>

<link rel="stylesheet" href="../../reveal.js/css/theme/simple.css" id="theme"/>

<link rel="stylesheet" href="../../reveal-slides.css"/>

<link rel="stylesheet" href="../../highlight-styles/docco.css"/>
<link rel="stylesheet" href=""/>

<!-- If the query includes 'print-pdf', include the PDF print sheet -->
<script>
    if( window.location.search.match( /print-pdf/gi ) ) {
        var link = document.createElement( 'link' );
        link.rel = 'stylesheet';
        link.type = 'text/css';
        link.href = '../../reveal.js/css/print/pdf.css';
        document.getElementsByTagName( 'head' )[0].appendChild( link );
    }
</script>
<base target="_blank">
</head>
<body>
<div class="reveal">
<div class="slides">
<section id="sec-title-slide">
<h1 class="title">Programski jezik Rust</h1>
<h2 class="subtitle">Bazirano na verziji 1.58.1. U izradi.</h2>
<h2 class="author">Prof. dr Igor Dejanoviƒá (<a href="mailto:igord at uns ac rs">igord at uns ac rs</a>)</h2>
<p class="date">Kreirano 2022-05-29 Sun 19:22, pritisni ESC za mapu, m za meni, Ctrl+Shift+F za pretragu</p>
</section>

<section>
<section id="slide-1">
<h2 id="1"><span class="section-number-2">1.</span> Uvod</h2>
<ul>
<li>Jezik op≈°te namene, kompajliran i statiƒçki tipiziran sa inferencom tipova</li>
<li>Sistemsko programiranje ali sa osobinama vi≈°eg nivoa apstrakcije kao ≈°to su
funkcionalno programiranje</li>
<li>2010, Graydon Hoare, Mozilla Research</li>
<li>Performanse i sigurnost</li>
<li>Ne koristi <i>garbage collector</i> ali obezbeƒëuje memorijsku sigurnost kroz <i>borrow
checker</i></li>
<li>Sintaksno sliƒçan C++. Uticaj i OCaml-a, Haskell-a i Erlang-a.</li>
<li>Koristi se u velikim firmama: Amazon, Facebook, Google, Microsoft&#x2026;</li>
<li>Od 2016 godine na SO upitniku konstantno prvi u kategoriji <i>&ldquo;most loved
programming languages&rdquo;</i></li>

</ul>
</section>
</section>
<section>
<section id="slide-2">
<h2 id="2"><span class="section-number-2">2.</span> Instalacija i pode≈°avanje</h2>
<div class="outline-text-2" id="text-2">
</div>
</section>
<section id="slide-2-1">
<h3 id="2-1"><span class="section-number-3">2.1.</span> Instalacija</h3>
<ul>
<li>Rust sti≈æe sa alatom za upravljanje lanca alata <code>rustup</code></li>

</ul>

<div class="org-src-container">

<pre><code class="sh" >$ curl --proto '=https' --tlsv1.2 https://sh.rustup.rs -sSf | sh
</code></pre>
</div>

<ul>
<li>Provera instalacije</li>

</ul>

<div class="org-src-container">

<pre><code class="sh" >~&gt; rustc --version
rustc 1.58.1 (db9d1b20b 2022-01-20)
</code></pre>
</div>

</section>
<section id="slide-2-2">
<h3 id="2-2"><span class="section-number-3">2.2.</span> Pregled instalacije</h3>
<div class="org-src-container">

<pre><code class="sh" >~&gt; rustup show
Default host: x86_64-unknown-linux-gnu
rustup home:  /home/igor/.rustup

installed toolchains
--------------------

stable-x86_64-unknown-linux-gnu (default)
nightly-x86_64-unknown-linux-gnu

active toolchain
----------------

stable-x86_64-unknown-linux-gnu (default)
rustc 1.58.1 (db9d1b20b 2022-01-20)
</code></pre>
</div>

</section>
<section id="slide-2-3">
<h3 id="2-3"><span class="section-number-3">2.3.</span> A≈æuriranje</h3>
<p>
Za a≈æuriranje instalacije na najnoviju verziju
</p>

<div class="org-src-container">

<pre><code class="sh" >rustup update
</code></pre>
</div>

</section>
<section id="slide-2-4">
<h3 id="2-4"><span class="section-number-3">2.4.</span> Dokumentacija</h3>
<p>
Rust sti≈æe sa veoma dobrom dokumentacijom i knjigama koje su dostupne direktno
iz instalacije.
</p>

<div class="org-src-container">

<pre><code class="sh" >rustup doc
</code></pre>
</div>

</section>
</section>
<section>
<section id="slide-3">
<h2 id="3"><span class="section-number-2">3.</span> Poƒçetak</h2>
<div class="outline-text-2" id="text-3">
</div>
</section>
<section id="slide-3-1">
<h3 id="3-1"><span class="section-number-3">3.1.</span> Hello, World!</h3>
<div class="org-src-container">

<pre><code class="sh" >$ mkdir hello_world
$ cd hello_world
</code></pre>
</div>

<p>
File <code>main.rs</code>:
</p>
<div class="org-src-container">

<pre><code class="rust" >fn main() {
    println!("Hello, world!");
}
</code></pre>
</div>

</section>
<section id="slide-3-2">
<h3 id="3-2"><span class="section-number-3">3.2.</span> Kompajliranje i pokretanje</h3>
<div class="org-src-container">

<pre><code class="sh" >$ rustc main.rs
$ ./main
Hello, world!
</code></pre>
</div>
</section>
<section id="slide-3-3">
<h3 id="3-3"><span class="section-number-3">3.3.</span> Hello, Cargo!</h3>
<ul>
<li>Alat za razre≈°avanje zavisnosti i upravljanje projektom.</li>

</ul>

<div class="org-src-container">

<pre><code class="sh" >~&gt; cargo --version
cargo 1.58.0 (f01b232bc 2022-01-19)
</code></pre>
</div>

<ul>
<li>Kreiranje projekta sa <code>cargo</code> alatom:</li>

</ul>

<div class="org-src-container">

<pre><code class="sh" >$ cargo new hello_cargo
$ cd hello_cargo
</code></pre>
</div>

</section>
<section id="slide-3-4">
<h3 id="3-4"><span class="section-number-3">3.4.</span> Sadr≈æaj kreiranog projekta</h3>
<p>
Fajl <code>cargo.toml</code> ƒçuva konfiguraciju projekta. Format je <a href="https://toml.io/en/">TOML</a> (<i>Tom‚Äôs Obvious,
Minimal Language</i>):
</p>

<div class="org-src-container">

<pre><code class="toml" >[package]
name = "hello_cargo"
version = "0.1.0"
edition = "2021"

[dependencies]
</code></pre>
</div>

<p>
Fajl <code>src/main.rs</code>:
</p>
<div class="org-src-container">

<pre><code class="rust" >fn main() {
    println!("Hello, world!");
}
</code></pre>
</div>
</section>
<section id="slide-3-5">
<h3 id="3-5"><span class="section-number-3">3.5.</span> Pokretanje</h3>
<div class="org-src-container">

<pre><code class="rust" >$ cargo build
   Compiling hello_cargo v0.1.0 (file:///projects/hello_cargo)
    Finished dev [unoptimized + debuginfo] target(s) in 2.85 secs
</code></pre>
</div>

<p>
Izvr≈°ni fajl se mo≈æe naƒái na lokaciji <code>target/debug/hello_cargo</code>:
</p>

<div class="org-src-container">

<pre><code class="sh" >$ ./target/debug/hello_cargo
Hello, world!
</code></pre>
</div>

<p>
Ali <code>cargo</code> omguƒáava i jednostavniji naƒçin pokretanja:
</p>
<div class="org-src-container">

<pre><code class="sh" >$ cargo run
    Finished dev [unoptimized + debuginfo] target(s) in 0.0 secs
     Running `target/debug/hello_cargo`
Hello, world!
</code></pre>
</div>

</section>
<section id="slide-3-6">
<h3 id="3-6"><span class="section-number-3">3.6.</span> Provera</h3>
<p>
Takoƒëe je moguƒáe brzo proveriti da li se kod kompajlira:
</p>

<div class="org-src-container">

<pre><code class="sh" >$ cargo check
   Checking hello_cargo v0.1.0 (file:///projects/hello_cargo)
    Finished dev [unoptimized + debuginfo] target(s) in 0.32 secs
</code></pre>
</div>

</section>
<section id="slide-3-7">
<h3 id="3-7"><span class="section-number-3">3.7.</span> Izgradnja finalne verzije</h3>
<ul>
<li>U toku razvoja koristimo izgradnju za degabovanje koja se br≈æe zavr≈°i ali je
izvr≈°ni kod neoptimalan.</li>

<li><p>
Za finalnu verziju je potrebno izgradnju obaviti na sledeƒái naƒçin:
</p>

<div class="org-src-container">

<pre><code class="rust" >    cargo build --release
</code></pre>
</div></li>

<li>Ovo ƒáe obaviti dodatne optimizacije koje ƒáe du≈æe trajati ali ƒáe krajnji kod
biti optimizovan.</li>

</ul>

</section>
<section id="slide-3-8">
<h3 id="3-8"><span class="section-number-3">3.8.</span> Cargo kao konvencija</h3>
<p>
Praktiƒçno svi Rust projekti koriste Cargo tako da je unifikovan naƒçin izgradnje
projekata. Uglavnom se svodi na:
</p>

<div class="org-src-container">

<pre><code class="sh" >$ git clone example.org/someproject
$ cd someproject
$ cargo build
</code></pre>
</div>

</section>
</section>
<section>
<section id="slide-4">
<h2 id="4"><span class="section-number-2">4.</span> Igra pogaƒëanja brojeva</h2>
<div class="outline-text-2" id="text-4">
</div>
</section>
<section id="slide-4-1">
<h3 id="4-1"><span class="section-number-3">4.1.</span> Pode≈°avanje projekta</h3>
<div class="org-src-container">

<pre><code class="rust" >$ cargo new guessing_game
$ cd guessing_game
</code></pre>
</div>

<p>
Fajl <code>Cargo.toml</code>:
</p>
<div class="org-src-container">

<pre><code class="toml" >[package]
name = "guessing_game"
version = "0.1.0"
edition = "2021"

[dependencies]
</code></pre>
</div>

<p>
Fajl <code>src/main.rs</code>:
</p>
<div class="org-src-container">

<pre><code class="rust" >fn main() {
    println!("Hello, world!");
}
</code></pre>
</div>

</section>
<section>

<div class="org-src-container">

<pre><code class="sh" >$ cargo run
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
    Finished dev [unoptimized + debuginfo] target(s) in 1.50s
     Running `target/debug/guessing_game`
Hello, world!
</code></pre>
</div>

</section>
<section id="slide-4-2">
<h3 id="4-2"><span class="section-number-3">4.2.</span> Preuzimanje broja sa standardnog ulaza</h3>
<div class="org-src-container">

<pre><code class="rust" >use std::io;

fn main() {
    println!("Guess the number!");

    println!("Please input your guess.");

    let mut guess = String::new();

    io::stdin()
        .read_line(&amp;mut guess)
        .expect("Failed to read line");

    println!("You guessed: {}", guess);
}
</code></pre>
</div>

</section>
<section id="slide-4-3">
<h3 id="4-3"><span class="section-number-3">4.3.</span> Promenjivost (<i>mutability</i>)</h3>
<ul>
<li>Varijable su podrazumevano nepromenjive (<i>immutable</i>).</li>
<li><p>
Ukoliko ≈æelimo varijablu ƒçija vrednost mo≈æe da se menja koristimo kljuƒçnu reƒç
<code>mut</code>.
</p>

<div class="org-src-container">

<pre><code class="rust" >  let apples = 5; // immutable
  let mut bananas = 5; // mutable
</code></pre>
</div></li>

<li><p>
Isto va≈æi i za parametre funkcija:
</p>

<div class="org-src-container">

<pre><code class="rust" >  io::stdin()
      .read_line(&amp;mut guess)
</code></pre>
</div></li>

</ul>

</section>
<section id="slide-4-4">
<h3 id="4-4"><span class="section-number-3">4.4.</span> Obrada moguƒáih gre≈°aka upotrebom <code>Result</code> tipa</h3>
<p>
<code>read_line</code> mo≈æe da zavr≈°i neuspe≈°no. Zato vraƒáa <code>io::Result</code> tip koji predstavlja
enumeraciju (<i>enum</i>) tip i ima dve vrednosti: <code>Ok</code> i <code>Err</code>.
</p>

<div class="org-src-container">

<pre><code class="rust" >io::stdin()
    .read_line(&amp;mut guess)
    .expect("Failed to read line");
</code></pre>
</div>

<p>
<code>expect</code> implementiran na <code>Ok</code> varijanti ƒáe vratiti vrednost koja je sadr≈æana unutar
varijante dok implementacija nad <code>Err</code> varijanti prekida izvr≈°avanje programa.
</p>

</section>
<section id="slide-4-5">
<h3 id="4-5"><span class="section-number-3">4.5.</span> Pokretanje</h3>
<div class="org-src-container">

<pre><code class="rust" >$ cargo run
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
    Finished dev [unoptimized + debuginfo] target(s) in 6.44s
     Running `target/debug/guessing_game`
Guess the number!
Please input your guess.
6
You guessed: 6
</code></pre>
</div>

</section>
<section id="slide-4-6">
<h3 id="4-6"><span class="section-number-3">4.6.</span> Generisanje sluƒçajnog broja</h3>
<p>
Koristimo <code>rand</code> paket (sanduk - <i>crate</i> u terminologiji Cargo-a).
</p>

<p>
Sekcija <code>[dependencies]</code> u fajlu <code>Cargo.toml</code>:
</p>
<div class="org-src-container">

<pre><code class="toml" >[dependencies]
rand = "0.8.3"
</code></pre>
</div>

<div class="org-src-container">

<pre><code class="sh" >$ cargo build
    Updating crates.io index
  Downloaded rand v0.8.3
  Downloaded libc v0.2.86
  ...
   Compiling rand_chacha v0.3.0
   Compiling rand v0.8.3
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
    Finished dev [unoptimized + debuginfo] target(s) in 2.53s
</code></pre>
</div>

<p>
Cargo koristi <a href="https://semver.org/">Semantic Versioning</a>. Rust paketi se preuzimaju sa sajta <a href="https://crates.io/">crates.io</a>
i ke≈°iraju lokalno.
</p>

</section>
<section id="slide-4-7">
<h3 id="4-7"><span class="section-number-3">4.7.</span> Ponovljivost izgradnje - <i>Cargo.lock</i></h3>
<ul>
<li>Prvi put kada se pokrene <code>cargo build</code> kreira se fajl <code>Cargo.lock</code> sa
informacijama o verzijama svih sanduka koji su instalirani.</li>
<li>Svako sledeƒáe pokretanje izgradnje koristi iste verzije.</li>
<li><code>Cargo.lock</code> je potrebno ƒçuvati u sistemu kontrole verzija (npr. <code>git</code>) da bi se
osigurala ponovljivost.</li>

</ul>

</section>
<section id="slide-4-8">
<h3 id="4-8"><span class="section-number-3">4.8.</span> A≈æuriranje sanduka</h3>
<ul>
<li><p>
A≈æuriranje na nove verzije sanduka se obavlja sa:
</p>

<div class="org-src-container">

<pre><code class="sh" >  $ cargo update
    Updating crates.io index
    Updating rand v0.8.3 -&gt; v0.8.4
</code></pre>
</div></li>
<li>Po≈°tuje se semantiƒçko verzioniranje tj. automatski se a≈æurira na sledeƒáu
verziju koja je manja od naredne glavne (<i>major</i>) verzije.</li>
<li>Ako prelazimo na novu glavnu verziju to moramo uraditi izmenom verzije u
<code>Cargo.toml</code> fajlu.</li>

</ul>

</section>
<section id="slide-4-9">
<h3 id="4-9"><span class="section-number-3">4.9.</span> Generisanje sluƒçajnog broja</h3>
<p>
Fajl <code>src/main.rs</code>:
</p>
<div class="org-src-container">

<pre><code class="rust" >use std::io;
use rand::Rng;

fn main() {
    println!("Guess the number!");

    let secret_number = rand::thread_rng().gen_range(1..101);

    println!("The secret number is: {}", secret_number);

    println!("Please input your guess.");

    let mut guess = String::new();

    io::stdin()
        .read_line(&amp;mut guess)
        .expect("Failed to read line");

    println!("You guessed: {}", guess);
}
</code></pre>
</div>

<p>
U <code>gen_range</code> koristimo izraz opsega (<i>range expression</i>). Interval je zatvoren na
donjoj granici i otvoren na gornjoj. Za interval zatvoren i od gore mo≈æemo
pisati <code>1..=100</code>.
</p>

</section>
<section id="slide-4-10">
<h3 id="4-10"><span class="section-number-3">4.10.</span> Dokumentacija za lokalne sanduke</h3>
<p>
Da bi znali koje metode i funkcije su nam dostupne mo≈æemo koristiti ugraƒëenu
dokumentaciju za sanduke projekta. Dokumentaciju dobijamo sa:
</p>

<div class="org-src-container">

<pre><code class="sh" >cargo doc --open
</code></pre>
</div>

</section>
<section id="slide-4-11">
<h3 id="4-11"><span class="section-number-3">4.11.</span> Pokretanje programa</h3>
<div class="org-src-container">

<pre><code class="sh" >$ cargo run
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
    Finished dev [unoptimized + debuginfo] target(s) in 2.53s
     Running `target/debug/guessing_game`
Guess the number!
The secret number is: 7
Please input your guess.
4
You guessed: 4
</code></pre>
</div>

</section>
<section id="slide-4-12">
<h3 id="4-12"><span class="section-number-3">4.12.</span> Poreƒëenje tajnog broja sa zadatim</h3>
<p>
Fajl <code>src/main.rs</code>
</p>
<div class="org-src-container">

<pre><code class="rust" >use rand::Rng;
use std::cmp::Ordering;
use std::io;

fn main() {
    // --snip--

    println!("You guessed: {}", guess);

    match guess.cmp(&amp;secret_number) {
        Ordering::Less =&gt; println!("Too small!"),
        Ordering::Greater =&gt; println!("Too big!"),
        Ordering::Equal =&gt; println!("You win!"),
    }
}
</code></pre>
</div>
<ul>
<li>Koristimo <code>std::cmp::Ordering</code> enum koji ima varijante <code>Less</code>, <code>Greater</code> i <code>Equal</code></li>
<li><code>match</code> izraz poredi zadatu vrednost sa vrednostima zadatim u telu i izvr≈°ava
granu koja se podudara. Grane <code>match</code> izraza se u Rust terminologiji zovu &ldquo;ruke&rdquo; (<i>arms</i>).</li>

</ul>

</section>
<section id="slide-4-13">
<h3 id="4-13"><span class="section-number-3">4.13.</span> Popravka tipova</h3>
<p>
Kod sa prethodnog slajda nije ispravan:
</p>
<div class="org-src-container">

<pre><code class="sh" >$ cargo build
   Compiling libc v0.2.86
   ...
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
error[E0308]: mismatched types
  --&gt; src/main.rs:22:21
   |
22 |     match guess.cmp(&amp;secret_number) {
   |                     ^^^^^^^^^^^^^^ expected struct `String`, found integer
   |
   = note: expected reference `&amp;String`
              found reference `&amp;{integer}`

error[E0283]: type annotations needed for `{integer}`
   --&gt; src/main.rs:8:44
    |
8   |     let secret_number = rand::thread_rng().gen_range(1..101);
    |         -------------                      ^^^^^^^^^ cannot infer type for type `{integer}`
    |         |
    |         consider giving `secret_number` a type
    |
    = note: multiple `impl`s satisfying `{integer}: SampleUniform` found in the `rand` crate:
            - impl SampleUniform for i128;
            - impl SampleUniform for i16;
            - impl SampleUniform for i32;
            - impl SampleUniform for i64;
            and 8 more
...
</code></pre>
</div>

</section>
<section>

<p>
Osnova gre≈°ke je neslaganje tipova. Sa ulaza prihvatamo <code>String</code> dok nam je tajni
broj <code>integer</code>.
</p>

</section>
<section id="slide-4-14">
<h3 id="4-14"><span class="section-number-3">4.14.</span> Konverzija stringa u broj</h3>
<p>
Problem re≈°avamo konverzijom stringa sa ulaza u brojni tip.
</p>

<div class="org-src-container">

<pre><code class="rust" >// --snip--

    let mut guess = String::new();

    io::stdin()
        .read_line(&amp;mut guess)
        .expect("Failed to read line");

    let guess: u32 = guess.trim().parse().expect("Please type a number!");

    println!("You guessed: {}", guess);

    match guess.cmp(&amp;secret_number) {
        Ordering::Less =&gt; println!("Too small!"),
        Ordering::Greater =&gt; println!("Too big!"),
        Ordering::Equal =&gt; println!("You win!"),
    }
</code></pre>
</div>

</section>
<section>

<p>
Sada se program komapajlira.
</p>

<div class="org-src-container">

<pre><code class="sh" >$ cargo run
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
    Finished dev [unoptimized + debuginfo] target(s) in 0.43s
     Running `target/debug/guessing_game`
Guess the number!
The secret number is: 58
Please input your guess.
  76
You guessed: 76
Too big!
</code></pre>
</div>

</section>
<section id="slide-4-15">
<h3 id="4-15"><span class="section-number-3">4.15.</span> Omoguƒáavanje vi≈°estrukog pogaƒëanja - upotreba petlje</h3>
<p>
Fajl <code>src/main.rs</code>:
</p>
<div class="org-src-container">

<pre><code class="rust" >// --snip--

    println!("The secret number is: {}", secret_number);

    loop {
        println!("Please input your guess.");

        // --snip--

        match guess.cmp(&amp;secret_number) {
            Ordering::Less =&gt; println!("Too small!"),
            Ordering::Greater =&gt; println!("Too big!"),
            Ordering::Equal =&gt; println!("You win!"),
        }
    }
}
</code></pre>
</div>

</section>
<section id="slide-4-16">
<h3 id="4-16"><span class="section-number-3">4.16.</span> Prekid rada</h3>
<p>
Problem je kako prekinuti program kada korisnik pogodi broj?
</p>

<div class="org-src-container">

<pre><code class="rust" >// --snip--

        match guess.cmp(&amp;secret_number) {
            Ordering::Less =&gt; println!("Too small!"),
            Ordering::Greater =&gt; println!("Too big!"),
            Ordering::Equal =&gt; {
                println!("You win!");
                break;
            }
        }
    }
}
</code></pre>
</div>

</section>
<section id="slide-4-17">
<h3 id="4-17"><span class="section-number-3">4.17.</span> Rukovanje neispravnim ulazom</h3>
<div class="org-src-container">

<pre><code class="rust" >// --snip--

        io::stdin()
            .read_line(&amp;mut guess)
            .expect("Failed to read line");

        let guess: u32 = match guess.trim().parse() {
            Ok(num) =&gt; num,
            Err(_) =&gt; continue,
        };

        println!("You guessed: {}", guess);

        // --snip--
</code></pre>
</div>

<p>
Potrebno je jo≈° obrisati liniju koja prikazuje generisani broj.
</p>

</section>
<section id="slide-4-18">
<h3 id="4-18"><span class="section-number-3">4.18.</span> Finalni kod</h3>
<div class="org-src-container">

<pre><code class="rust" >use rand::Rng;
use std::cmp::Ordering;
use std::io;

fn main() {
    println!("Guess the number!");
    let secret_number = rand::thread_rng().gen_range(1..101);

    loop {
        println!("Please input your guess.");
        let mut guess = String::new();
        io::stdin()
            .read_line(&amp;mut guess)
            .expect("Failed to read line");
        let guess: u32 = match guess.trim().parse() {
            Ok(num) =&gt; num,
            Err(_) =&gt; continue,
        };
        println!("You guessed: {}", guess);
        match guess.cmp(&amp;secret_number) {
            Ordering::Less =&gt; println!("Too small!"),
            Ordering::Greater =&gt; println!("Too big!"),
            Ordering::Equal =&gt; {
                println!("You win!");
                break;
            }
        }
    }
}
</code></pre>
</div>

</section>
</section>
<section>
<section id="slide-5">
<h2 id="5"><span class="section-number-2">5.</span> Osnovni programski koncepti</h2>
<div class="outline-text-2" id="text-5">
</div>
</section>
<section id="slide-5-1">
<h3 id="5-1"><span class="section-number-3">5.1.</span> Varijable i promenjivost (<i>mutability</i>)</h3>
<div class="outline-text-3" id="text-5-1">
</div>
</section>
<section id="slide-5-1-1">
<h4 id="5-1-1"><span class="section-number-4">5.1.1.</span> Varijable i promenjivost (<i>mutability</i>)</h4>
<ul>
<li>Varijable su podrazumevano nepromenjive.</li>
<li><p>
Jednom kada dobiju vrednost (<i>binding</i>) ta vrednost se ne mo≈æe promeniti
</p>

<div class="org-src-container">

<pre><code class="rust" >    fn main() {
        let x = 5;
        println!("The value of x is: {}", x);
        x = 6;     // gre≈°ka
        println!("The value of x is: {}", x);
    }
</code></pre>
</div>

</section>
<section>

<div class="org-src-container">

<pre><code class="sh" >    $ cargo run
    Compiling variables v0.1.0 (file:///projects/variables)
    error[E0384]: cannot assign twice to immutable variable `x`
    --&gt; src/main.rs:4:5
    |
    2 |     let x = 5;
    |         -
    |         |
    |         first assignment to `x`
    |         help: consider making this binding mutable: `mut x`
    3 |     println!("The value of x is: {}", x);
    4 |     x = 6;
    |     ^^^^^ cannot assign twice to immutable variable

    For more information about this error, try `rustc --explain E0384`.
    error: could not compile `variables` due to previous error
</code></pre>
</div></li>

</ul>
</section>
<section id="slide-5-1-2">
<h4 id="5-1-2"><span class="section-number-4">5.1.2.</span> <code>mut</code> kljuƒçna reƒç</h4>
<div class="org-src-container">

<pre><code class="rust" >fn main() {
    let mut x = 5;
    println!("The value of x is: {}", x);
    x = 6;
    println!("The value of x is: {}", x);
}
</code></pre>
</div>
</section>
<section id="slide-5-2">
<h3 id="5-2"><span class="section-number-3">5.2.</span> Konstante - <code>const</code></h3>
<ul>
<li>Sliƒçno kao nepromenjive varijable sa sledeƒáim razlikama:
<ul>
<li>Uvek su nepromenjive</li>
<li>Mogu se inicijalizovati samo konstantnim izrazom (poznatim u vreme kompajliranja)</li>
<li>Validne za celokupno vreme izvr≈°avanja programa u opsegu va≈æenja gde su
definisane (<i>scope</i>)</li>
<li>Mora se eksplicitno definisati tip</li>

</ul></li>
<li>Kompajler ƒáe konstante &ldquo;ubaciti&rdquo; na mestu upotrebe</li>
<li><p>
Po konvenciji imena konstanti se pi≈°u velikim slovima
</p>

<div class="org-src-container">

<pre><code class="rust" >    const THREE_HOURS_IN_SECONDS: u32 = 60 * 60 * 3;
</code></pre>
</div></li>

</ul>

</section>
<section id="slide-5-3">
<h3 id="5-3"><span class="section-number-3">5.3.</span> Tipovi podataka</h3>
<div class="outline-text-3" id="text-5-3">
</div>
</section>
<section id="slide-5-3-1">
<h4 id="5-3-1"><span class="section-number-4">5.3.1.</span> Tipovi podataka</h4>
<ul>
<li>Svaka vrednost u Rust-u ima tip. Tipovi moraju biti poznati u vreme
kompajliranja (statiƒçki tipiziran jezik).</li>
<li><p>
Kompajler ƒáe probati da odredi tipove (<i>type inference</i>). Ako nije moguƒáe
zahteva se da defini≈°emo tip eksplicitno.
</p>

<p>
Npr:
</p>
<div class="org-src-container">

<pre><code class="rust" >    let guess: u32 = "42".parse().expect("Not a number!");
</code></pre>
</div>
<p>
Ovde nije moguƒáe odrediti tip jer <code>str::parse</code> funkcija mo≈æe vratiti razliƒçite
brojne tipove (funkcija je generiƒçka) a ne postoji naƒçin da se tip automatski
odredi.
</p>

<p>
Signatura je:
</p>
<div class="org-src-container">

<pre><code class="rust" >    pub fn parse&lt;F&gt;(&amp;self) -&gt; Result&lt;F, &lt;F as FromStr&gt;::Err&gt;
    where
        F: FromStr
</code></pre>
</div></li>

</ul>
</section>
<section id="slide-5-3-2">
<h4 id="5-3-2"><span class="section-number-4">5.3.2.</span> <i>Integer</i> tipovi</h4>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">Du≈æina</th>
<th scope="col" class="org-left">Signed</th>
<th scope="col" class="org-left">Unsigned</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">8-bit</td>
<td class="org-left">i8</td>
<td class="org-left">u8</td>
</tr>

<tr>
<td class="org-left">16-bit</td>
<td class="org-left">i16</td>
<td class="org-left">u16</td>
</tr>

<tr>
<td class="org-left">32-bit</td>
<td class="org-left">i32</td>
<td class="org-left">u32</td>
</tr>

<tr>
<td class="org-left">64-bit</td>
<td class="org-left">i64</td>
<td class="org-left">u64</td>
</tr>

<tr>
<td class="org-left">128-bit</td>
<td class="org-left">i128</td>
<td class="org-left">u128</td>
</tr>

<tr>
<td class="org-left">arch</td>
<td class="org-left">isize</td>
<td class="org-left">usize</td>
</tr>
</tbody>
</table>

</section>
<section id="slide-5-3-3">
<h4 id="5-3-3"><span class="section-number-4">5.3.3.</span> Literali brojeva</h4>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">Literali</th>
<th scope="col" class="org-left">Primeri</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">Decimal</td>
<td class="org-left">98_222</td>
</tr>

<tr>
<td class="org-left">Hex</td>
<td class="org-left">0xff</td>
</tr>

<tr>
<td class="org-left">Octal</td>
<td class="org-left">0o77</td>
</tr>

<tr>
<td class="org-left">Binary</td>
<td class="org-left">0b1111_0000</td>
</tr>

<tr>
<td class="org-left">Byte (u8 only)</td>
<td class="org-left">b&rsquo;A&rsquo;</td>
</tr>
</tbody>
</table>

</section>
<section id="slide-5-3-4">
<h4 id="5-3-4"><span class="section-number-4">5.3.4.</span> <i>Floating-Point</i> tipovi</h4>
<div class="org-src-container">

<pre><code class="rust" >fn main() {
    let x = 2.0; // f64

    let y: f32 = 3.0; // f32
}
</code></pre>
</div>

<p>
IEEE-754 standard
</p>

</section>
<section id="slide-5-3-5">
<h4 id="5-3-5"><span class="section-number-4">5.3.5.</span> Operacije nad brojevima</h4>
<div class="org-src-container">

<pre><code class="rust" >fn main() {
    // addition
    let sum = 5 + 10;

    // subtraction
    let difference = 95.5 - 4.3;

    // multiplication
    let product = 4 * 30;

    // division
    let quotient = 56.7 / 32.2;
    let floored = 2 / 3; // Results in 0

    // remainder
    let remainder = 43 % 5;
}
</code></pre>
</div>

</section>
<section id="slide-5-3-6">
<h4 id="5-3-6"><span class="section-number-4">5.3.6.</span> <i>Boolean</i> tip</h4>
<div class="org-src-container">

<pre><code class="rust" >fn main() {
    let t = true;

    let f: bool = false; // with explicit type annotation
}
</code></pre>
</div>

</section>
<section id="slide-5-3-7">
<h4 id="5-3-7"><span class="section-number-4">5.3.7.</span> Tip karaktera</h4>
<div class="org-src-container">

<pre><code class="rust" >fn main() {
    let c = 'z';
    let z = '‚Ñ§';
    let heart_eyed_cat = 'üòª';
}
</code></pre>
</div>

</section>
<section id="slide-5-3-8">
<h4 id="5-3-8"><span class="section-number-4">5.3.8.</span> Torke (<i>tuples</i>)</h4>
<div class="org-src-container">

<pre><code class="rust" >fn main() {
    let tup: (i32, f64, u8) = (500, 6.4, 1);
}
</code></pre>
</div>

<ul>
<li>Raspakivanje torki (<i>destructuring</i>):</li>

</ul>
<div class="org-src-container">

<pre><code class="rust" >fn main() {
    let tup = (500, 6.4, 1);

    let (x, y, z) = tup;

    println!("The value of y is: {}", y);
}
</code></pre>
</div>

</section>
<section>

<p>
Pristup elementima torke:
</p>
<div class="org-src-container">

<pre><code class="rust" >fn main() {
    let x: (i32, f64, u8) = (500, 6.4, 1);

    let five_hundred = x.0;

    let six_point_four = x.1;

    let one = x.2;
}
</code></pre>
</div>

</section>
<section id="slide-5-3-9">
<h4 id="5-3-9"><span class="section-number-4">5.3.9.</span> Nizovni tip</h4>
<ul>
<li>Svaki element nizovnog tipa mora imati isti tip</li>
<li><p>
Dimenzija niza je nepromenjiva (alociran je na steku)
</p>
<div class="org-src-container">

<pre><code class="rust" >    fn main() {
        let a = [1, 2, 3, 4, 5];
    }
</code></pre>
</div></li>

<li><p>
Tip se mo≈æe eksplitino definisati na sledeƒái naƒçin (niz du≈æine <code>5</code> tipa <code>i32</code>):
</p>
<div class="org-src-container">

<pre><code class="rust" >    let a: [i32; 5] = [1, 2, 3, 4, 5];
</code></pre>
</div></li>

<li><p>
Inicijalizacija svih elemenata na istu vrednost se obavlja na sledeƒái naƒçin:
</p>
<div class="org-src-container">

<pre><code class="rust" >  let a = [3; 5];
</code></pre>
</div>
<p>
Gde je vrednost svakog elementa <code>3</code> a du≈æina niza <code>5</code>.
</p></li>

</ul>

</section>
<section>

<p>
Indeksni pristup:
</p>

<div class="org-src-container">

<pre><code class="rust" >fn main() {
    let a = [1, 2, 3, 4, 5];

    let first = a[0];
    let second = a[1];
}
</code></pre>
</div>

</section>
<section id="slide-5-4">
<h3 id="5-4"><span class="section-number-3">5.4.</span> Funkcije</h3>
<div class="outline-text-3" id="text-5-4">
</div>
</section>
<section id="slide-5-4-1">
<h4 id="5-4-1"><span class="section-number-4">5.4.1.</span> Funkcije</h4>
<div class="org-src-container">

<pre><code class="rust" >fn main() {
    println!("Hello, world!");

    another_function();
}

fn another_function() {
    println!("Another function.");
}
</code></pre>
</div>
<ul>
<li>Za imenovanje funkcija kao i varijabli koristi se <i>snake_case</i>.</li>

</ul>
</section>
<section id="slide-5-4-2">
<h4 id="5-4-2"><span class="section-number-4">5.4.2.</span> Funkcije - parametri</h4>
<div class="org-src-container">

<pre><code class="rust" >fn main() {
    print_labeled_measurement(5, 'h');
}

fn print_labeled_measurement(value: i32, unit_label: char) {
    println!("The measurement is: {}{}", value, unit_label);
}
</code></pre>
</div>

</section>
<section id="slide-5-4-3">
<h4 id="5-4-3"><span class="section-number-4">5.4.3.</span> Iskazi i izrazi</h4>
<ul>
<li>Rust je jezik baziran na izrazima (<i>expression-based</i>)</li>
<li>Iskazi (<i>statements</i>) su jeziƒçke konstrukcije koje nemaju povratnu vrednost.
Izrazi (<i>expressions</i>) se evaluiraju u odreƒëeni rezultat, tj. imaju vrednost.</li>
<li><p>
Primer: <code>let</code> je iskaz tj. nema povratnu vrednost. Ovo mo≈æete pisati:
</p>
<div class="org-src-container">

<pre><code class="rust" >  let y = 6;
</code></pre>
</div>
<p>
Ali ovo ne:
</p>
<div class="org-src-container">

<pre><code class="rust" >  let x = (let y = 6);
</code></pre>
</div></li>

</ul>

</section>
<section>

<p>
Blok koda je takoƒëe izraz. ≈†ta je vrednost u koju se evaluira?
</p>

<div class="org-src-container">

<pre><code class="rust" >{
    let x = 3;
    x + 1
}
</code></pre>
</div>

<p>
Vrednost bloka je vrednost poslednjeg izraza, tj. <code>x+1</code>. Primetite da tu ne
koristimo <code>;</code> jer terminacija ovim karakterom pretvara izraz u iskaz.
</p>

</section>
<section>

<p>
Zbog ovoga je sasvim legalno da pi≈°emo:
</p>

<div class="org-src-container">

<pre><code class="rust" >fn main() {
    let y = {
        let x = 3;
        x + 1
    };

    println!("The value of y is: {}", y);
}
</code></pre>
</div>

<pre class="example">
The value of y is: 4
</pre>
</section>
<section id="slide-5-4-4">
<h4 id="5-4-4"><span class="section-number-4">5.4.4.</span> Povratne vrednosti funkcija</h4>
<p>
Vrednost funkcije je vrednost bloka koji predstavlja telo funkcije, dakle
poslednjeg izraza unutar tela funkcije.
</p>

<div class="org-src-container">

<pre><code class="rust" >fn five() -&gt; i32 {
    5
}

fn main() {
    let x = five();

    println!("The value of x is: {}", x);
}
</code></pre>
</div>

<pre class="example">
The value of x is: 5
</pre>


</section>
<section>

<p>
Ili na primer:
</p>
<div class="org-src-container">

<pre><code class="rust" >fn main() {
    let x = plus_one(5);

    println!("The value of x is: {}", x);
}

fn plus_one(x: i32) -&gt; i32 {
    x + 1
}
</code></pre>
</div>

<pre class="example">
The value of x is: 6
</pre>


</section>
<section>

<p>
Ukoliko izraz <code>x+1</code> terminiramo sa <code>;</code> kod se neƒáe kompajlirati jer funkcija
deklari≈°e da vraƒáa tip <code>i32</code> dok sada vraƒáa <code>()</code> (tzv. <i>unit type</i>) odnosno nema
povratnu vrednost jer je poslednja instrukcija iskaz.
</p>

<div class="org-src-container">

<pre><code class="rust" >fn main() {
    let x = plus_one(5);

    println!("The value of x is: {}", x);
}

fn plus_one(x: i32) -&gt; i32 {
    x + 1;
}
</code></pre>
</div>

<pre class="example" id="org73176e9">
error[E0308]: mismatched types
 --&gt; src/main.rs:8:24
  |
8 | fn plus_one(x: i32) -&gt; i32 {
  |    --------            ^^^ expected `i32`, found `()`
  |    |
  |    implicitly returns `()` as its body has no tail or `return` expression
9 |     x + 1;
  |          - help: consider removing this semicolon

For more information about this error, try `rustc --explain E0308`.
error: could not compile `cargo4UyKF0` due to previous error
</pre>

</section>
<section id="slide-5-5">
<h3 id="5-5"><span class="section-number-3">5.5.</span> Komentari</h3>
<p>
Komentari se pi≈°u posle <code>//</code> ili u formi blok komentara <code>/*.... */</code> kao i u C++-u.
Ovo bi bili validni komentari:
</p>
<div class="org-src-container">

<pre><code class="rust" >// So we‚Äôre doing something complicated here, long enough that we need
// multiple lines of comments to do it! Whew! Hopefully, this comment will
// explain what‚Äôs going on.

fn main() {
    let lucky_number = 7; // I‚Äôm feeling lucky today
}
...
fn main() {
    // I‚Äôm feeling lucky today
    let lucky_number = 7;
    /* this is block comment
       which can span multiple lines.
       Nesting is allowed.
     */
}
</code></pre>
</div>

</section>
<section>

<p>
Postoje i komentari za dokumentaciju koji predstavljaju posebnu sintaksu za
komentare koji su deo API dokumentacije. Oni se pi≈°u posle <code>///</code>. Na primer:
</p>
<div class="org-src-container">

<pre><code class="rust" >/// Adds one to the number given.
///
/// # Examples
///
/// ```
/// let arg = 5;
/// let answer = my_crate::add_one(arg);
///
/// assert_eq!(6, answer);
/// ```
pub fn add_one(x: i32) -&gt; i32 {
    x + 1
}
</code></pre>
</div>
</section>
<section id="slide-5-6">
<h3 id="5-6"><span class="section-number-3">5.6.</span> Kontrola toka</h3>
<div class="outline-text-3" id="text-5-6">
</div>
</section>
<section id="slide-5-6-1">
<h4 id="5-6-1"><span class="section-number-4">5.6.1.</span> <code>if</code> izrazi</h4>
<div class="org-src-container">

<pre><code class="rust" >fn main() {
    let number = 3;

    if number &lt; 5 {
        println!("condition was true");
    } else {
        println!("condition was false");
    }
}
</code></pre>
</div>

</section>
<section id="slide-5-6-2">
<h4 id="5-6-2"><span class="section-number-4">5.6.2.</span> <code>if-else</code></h4>
<div class="org-src-container">

<pre><code class="rust" >fn main() {
    let number = 6;

    if number % 4 == 0 {
        println!("number is divisible by 4");
    } else if number % 3 == 0 {
        println!("number is divisible by 3");
    } else if number % 2 == 0 {
        println!("number is divisible by 2");
    } else {
        println!("number is not divisible by 4, 3, or 2");
    }
}
</code></pre>
</div>
</section>
<section id="slide-5-6-3">
<h4 id="5-6-3"><span class="section-number-4">5.6.3.</span> <code>if</code> u <code>let</code> iskazima</h4>
<p>
<code>if</code> je izraz pa se mo≈æe koristiti gde god mo≈æemo pisati i bilo koji drugi izraz.
</p>

<div class="org-src-container">

<pre><code class="rust" >fn main() {
    let condition = true;
    let number = if condition { 5 } else { 6 };

    println!("The value of number is: {}", number);
}
</code></pre>
</div>

<pre class="example">
The value of number is: 5
</pre>


</section>
<section>

<p>
Ali se grane moraju slagati po tipu. Ovo je pogre≈°no jer je prva grana tipa
<code>i32</code> dok je <code>else</code> grana tipa <code>str</code>.
</p>

<div class="org-src-container">

<pre><code class="rust" >fn main() {
    let condition = true;

    let number = if condition { 5 } else { "six" };

    println!("The value of number is: {}", number);
}
</code></pre>
</div>
</section>
<section id="slide-5-6-4">
<h4 id="5-6-4"><span class="section-number-4">5.6.4.</span> Petlje</h4>
<p>
Rust ima tri tipa petlje:
</p>
<ul>
<li><code>loop</code> - za beskontaƒçne petlje</li>
<li><code>while</code> - uslovna petlja</li>
<li><code>for</code> - petlja za iteraciju kroz iteratore</li>

</ul>

</section>
<section id="slide-5-6-5">
<h4 id="5-6-5"><span class="section-number-4">5.6.5.</span> <code>loop</code></h4>
<div class="org-src-container">

<pre><code class="rust" >fn main() {
    loop {
        println!("again!");
    }
}
</code></pre>
</div>

</section>
<section id="slide-5-6-6">
<h4 id="5-6-6"><span class="section-number-4">5.6.6.</span> <code>loop</code> labele</h4>
<p>
Ukoliko imamo ugnje≈ædene <code>loop</code> iskaze mo≈æemo koristiti labele prilikom izlaska sa
<code>break</code> instrukcijom.
</p>

<div class="org-src-container">

<pre><code class="rust" >fn main() {
    let mut count = 0;
    'counting_up: loop {
        println!("count = {}", count);
        let mut remaining = 10;

        loop {
            println!("remaining = {}", remaining);
            if remaining == 9 {
                break;
            }
            if count == 2 {
                break 'counting_up;
            }
            remaining -= 1;
        }

        count += 1;
    }
    println!("End count = {}", count);
}
</code></pre>
</div>

</section>
<section id="slide-5-6-7">
<h4 id="5-6-7"><span class="section-number-4">5.6.7.</span> <code>loop</code> kao izraz</h4>
<p>
<code>loop</code> mo≈æe imati povratnu vrednost. Povratna vrednost se defini≈°e kao parametar
<code>break</code> instrukcije.
</p>

<div class="org-src-container">

<pre><code class="rust" >fn main() {
    let mut counter = 0;

    let result = loop {
        counter += 1;

        if counter == 10 {
            break counter * 2;
        }
    };

    println!("The result is {}", result);
}
</code></pre>
</div>
</section>
<section id="slide-5-6-8">
<h4 id="5-6-8"><span class="section-number-4">5.6.8.</span> <code>while</code></h4>
<div class="org-src-container">

<pre><code class="rust" >fn main() {
    let mut number = 3;

    while number != 0 {
        println!("{}!", number);

        number -= 1;
    }

    println!("LIFTOFF!!!");
}
</code></pre>
</div>
</section>
<section id="slide-5-6-9">
<h4 id="5-6-9"><span class="section-number-4">5.6.9.</span> <code>for</code></h4>
<p>
Iteraciju kroz ureƒëenu kolekciju, kao ≈°to je niz, mo≈æemo obaviti sa <code>while</code> petljom.
</p>
<div class="org-src-container">

<pre><code class="rust" >fn main() {
    let a = [10, 20, 30, 40, 50];
    let mut index = 0;

    while index &lt; 5 {
        println!("the value is: {}", a[index]);

        index += 1;
    }
}
</code></pre>
</div>

</section>
<section>
<p>
Ali je za tu namenu prirodnije i sigurnije koristiti <code>for</code> petlju. Takoƒëe ƒáe se
program br≈æe izvr≈°avati.
</p>

<div class="org-src-container">

<pre><code class="rust" >fn main() {
    let a = [10, 20, 30, 40, 50];

    for element in a {
        println!("the value is: {}", element);
    }
}
</code></pre>
</div>

</section>
<section>
<p>
<code>for</code> petlje su najƒçe≈°ƒái oblik petlji u upotrebi u Rust-u. Koriste se npr. i u
situaciji kada je potrebno izvr≈°iti petlju odreƒëeni broj puta.
</p>

<div class="org-src-container">

<pre><code class="rust" >fn main() {
    for number in (1..4).rev() {
        println!("{}!", number);
    }
    println!("LIFTOFF!!!");
}
</code></pre>
</div>

<pre class="example">
3!
2!
1!
LIFTOFF!!!
</pre>

</section>
</section>
<section>
<section id="slide-6">
<h2 id="6"><span class="section-number-2">6.</span> Vlasni≈°tvo i pozajmljivanje (<i>Ownership and borrowing</i>)</h2>
<div class="outline-text-2" id="text-6">
</div>
</section>
<section id="slide-6-1">
<h3 id="6-1"><span class="section-number-3">6.1.</span> Vlasni≈°tvo</h3>
<div class="outline-text-3" id="text-6-1">
</div>
</section>
<section id="slide-6-1-1">
<h4 id="6-1-1"><span class="section-number-4">6.1.1.</span> Vlasni≈°tvo</h4>
<ul>
<li>Jedan od najva≈ænijih koncepata jezika.</li>
<li>Skup pravila koji omoguƒáavaju upravljanje memorijom.</li>
<li>Garancije za memorijsku sigurnost bez upotrebe <i>garbage collector</i>-a</li>
<li>Sve provere se obavljaju u vreme kompajliranja - rezultuje odliƒçnim
performansama u vreme izvr≈°avanja.</li>

</ul>

</section>
<section id="slide-6-1-2">
<h4 id="6-1-2"><span class="section-number-4">6.1.2.</span> Stek i hip (<i>Stack and Heap</i>)</h4>
<ul>
<li>Stek - alokacija prostora za podatke ƒçija je veliƒçina poznata u vreme
kompajliranja.
<ul>
<li>Br≈æa alokacija i dealokacija - jednostavan mehanizam, LIFO struktura.</li>
<li>Br≈æi pristup - lokalne varijable, ke≈°iranje pristupa.</li>

</ul></li>
<li>Hip - slobodna alokacija u vreme izvr≈°avanja.
<ul>
<li>Sporija alokacija i dealokacija.</li>
<li>Sporiji pristup - proizvoljna lokacija.</li>

</ul></li>

</ul>

</section>
<section id="slide-6-1-3">
<h4 id="6-1-3"><span class="section-number-4">6.1.3.</span> Pravila vlasni≈°tva</h4>
<ol>
<li>Svaka vrednost u Rust-u ima varijablu koja se naziva <i>vlasnikom</i> (<i>owner</i>).</li>
<li>U svakom trenutku postoji samo jedan vlasnik.</li>
<li>Kada vlasnik izaƒëe iz opsega va≈æenja (<i>scope</i>) vrednost se dealocira (<i>drop</i>).</li>

</ol>

</section>
<section id="slide-6-1-4">
<h4 id="6-1-4"><span class="section-number-4">6.1.4.</span> Opseg va≈æenja varijable (<i>Variable Scope</i>)</h4>
<div class="org-src-container">

<pre><code class="rust" >{                      // s nije validno ovde jer jo≈° nije deklarisano
    let s = "hello";   // s je validno od ove pozicije

    // koristimo s
}   // ovde opseg prestaje da va≈æi i s vi≈°e nije validno
</code></pre>
</div>

</section>
<section id="slide-6-1-5">
<h4 id="6-1-5"><span class="section-number-4">6.1.5.</span> <code>String</code> tip</h4>
<ul>
<li><p>
Demonstracija vlasni≈°tva nad tipom koji se alocira na hipu.
</p>

<div class="org-src-container">

<pre><code class="rust" >  let mut s = String::from("hello");
  s.push_str(", world!"); // push_str() dodaje literal na string
  println!("{}", s); // hello, world!`
</code></pre>
</div></li>

<li>Memorija se alocira sa hipa u vreme izvr≈°avanja.</li>
<li>Moramo vratiti memoriju alokatoru kada nam vi≈°e nije potrebna.</li>

</ul>

</section>
<section>

<ul>
<li><p>
Alokacija stringa se obavlja na liniji:
</p>

<div class="org-src-container">

<pre><code class="rust" >  let mut s = String::from("hello");
</code></pre>
</div></li>

<li>Ali dealokacija je te≈æa:
<ul>
<li><i>Garbage collector</i></li>
<li><i>Memory waste</i></li>
<li><i>Double-free</i></li>

</ul></li>

</ul>

</section>
<section>

<ul>
<li>Rust kompajler ƒáe dodati kod koji radi dealokaciju kada vlasnik napusti opseg va≈æenja.</li>
<li><p>
Poziva se funkcija <code>drop</code> nad tipom i ova funkcija je zadu≈æena da obavi dealokaciju.
</p>

<div class="org-src-container">

<pre><code class="rust" >  {
        let s = String::from("hello"); // s postaje validno

        // koristimo s
  }  // &lt;- s izlazi iz opsega i poziva se "drop"
</code></pre>
</div></li>

</ul>

</section>
<section id="slide-6-1-6">
<h4 id="6-1-6"><span class="section-number-4">6.1.6.</span> Dodela vrednosti</h4>
<ul>
<li><p>
Kopiranje vrednosti <code>x</code> u <code>y</code>. Obe varijable sada imaju vrednost <code>5</code>.
</p>

<div class="org-src-container">

<pre><code class="rust" >  let x = 5;
  let y = x;
</code></pre>
</div></li>

<li><p>
Ali sa <code>String</code> tipom de≈°ava se ne≈°to drugo.
</p>

<div class="org-src-container">

<pre><code class="rust" >  let s1 = String::from("hello");
</code></pre>
</div></li>

</ul>


<div id="orgb8b5671" class="figure">
<p><img src="./images/string-type.png" alt="string-type.png" style="height: 400px;" />
</p>
</div>

</section>
<section>

<ul>
<li><p>
Ako bi se kopirao samo sadr≈æaj sa steka bez imali bismo sledeƒáu situaciju
(tzv. <i>shallow copy</i>).
</p>

<div class="org-src-container">

<pre><code class="rust" >  let s1 = String::from("hello");
  let s2 = s1;
</code></pre>
</div></li>

</ul>


<div id="org2a4cac0" class="figure">
<p><img src="./images/string-type-2.png" alt="string-type-2.png" style="height: 400px;" />
</p>
</div>

<p>
≈†to je problematiƒçno jer kada i <code>s1</code> i <code>s2</code> napuste opseg poku≈°aƒáe se dvostruka
dealokacija iste memorije na hipu (<i>double free</i>).
</p>

</section>
<section>

<p>
Ako bi se i hip memorija kopirala (tzv. <i>deep copy</i>) imali bismo validnu situaciju
ali bi takva operacija bila veoma &ldquo;skupa&rdquo;.
</p>


<div id="org856aa3b" class="figure">
<p><img src="./images/string-type-3.png" alt="string-type-3.png" style="height: 500px;" />
</p>
</div>

</section>
<section id="slide-6-1-7">
<h4 id="6-1-7"><span class="section-number-4">6.1.7.</span> Preme≈°tanje (<i>Move</i>)</h4>
<p>
Ako probamo da kompajliramo sledeƒái kod:
</p>

<div class="org-src-container">

<pre><code class="rust" >let s1 = String::from("hello");
let s2 = s1;

println!("{}, world!", s1);
</code></pre>
</div>

<p>
Dobiƒáemo gre≈°ku:
</p>

<pre class="example" id="orgdc1cb2b">
$ cargo run
   Compiling ownership v0.1.0 (file:///projects/ownership)
error[E0382]: borrow of moved value: `s1`
 --&gt; src/main.rs:5:28
  |
2 |     let s1 = String::from("hello");
  |         -- move occurs because `s1` has type `String`, which does not implement the `Copy` trait
3 |     let s2 = s1;
  |              -- value moved here
4 |
5 |     println!("{}, world!", s1);
  |                            ^^ value borrowed here after move

For more information about this error, try `rustc --explain E0382`.
error: could not compile `ownership` due to previous error
</pre>

</section>
<section>

<p>
Ono ≈°to nam kompajler ka≈æe je da se u iskazu:
</p>

<div class="org-src-container">

<pre><code class="rust" >let s2 = s1;
</code></pre>
</div>

<p>
promenio vlasnik ovog stringa. Novi vlasnik je sada <code>s2</code> dok je varijabla <code>s1</code>
postala nevalidna i nije je vi≈°e moguƒáe koristiti.
</p>

<p>
Ka≈æemo da se obavilo &ldquo;preme≈°tanje&rdquo; (<i>move</i>) vrednosti iz <code>s1</code> u <code>s2</code>.
</p>


<div id="orgf1aa15a" class="figure">
<p><img src="./images/string-type-4.png" alt="string-type-4.png" style="height: 400px;" />
</p>
</div>

<p>
ƒåime se ispunjava prvo pravilo vlasni≈°tva i spreƒçava <i>double free</i> gre≈°ka.
</p>

</section>
<section id="slide-6-1-8">
<h4 id="6-1-8"><span class="section-number-4">6.1.8.</span> Kloniranje</h4>
<p>
Posledica prethodnog je da Rust nikada neƒáe automatski obaviti duboko kopiranje
varijable jer bi to moglo da izazove lo≈°e performanse.
</p>

<p>
Duboko kopiranje (stek+hip) radimo sa <code>clone</code> metodom:
</p>

<div class="org-src-container">

<pre><code class="rust" >let s1 = String::from("hello");
let s2 = s1.clone();

println!("s1 = {}, s2 = {}", s1, s2);
</code></pre>
</div>

<p>
Sada je lako pronaƒái u kodu sva mesta gde se obavlja potencijalno &ldquo;skupa&rdquo;
operacija dubokog kopiranja.
</p>

</section>
<section id="slide-6-1-9">
<h4 id="6-1-9"><span class="section-number-4">6.1.9.</span> <i>Copy</i> tipovi</h4>
<p>
Kako onda radi primer koji smo videli prethodno? Za≈°to ne dolazi do preme≈°tanja
i invalidacije <code>y</code> varijable?
</p>

<div class="org-src-container">

<pre><code class="rust" >let x = 5;
let y = x;

println!("x = {}, y = {}", x, y);
</code></pre>
</div>

<ul>
<li>Kod prostih tipova ƒçija je veliƒçina poznata u vreme kompajliranja i koji mogu
u celosti stati na stek nema razlike izmeƒëu dubokog i plitkog kopiranja.</li>
<li>Ovakvi tipovi su anotirani sa <i>Copy</i> trejtom (<i>Trait</i>). Tipovi koji su na ovaj
naƒçin anotirani ne obavljaju preme≈°tanje veƒá uvek kopiranje.</li>
<li>Implikacija je da se varijabla sa desne strane dodele mo≈æe koristiti i nakon
dodele.</li>
<li>Rust ƒáe spreƒçiti <i>Copy</i> anotaciju ako tip implementira i <i>Drop</i> jer to znaƒçi da
radi neku specijalnu alokaciju pa mu je potrebna i posebna dealokacija ≈°to
znaƒçi da mora da se radi preme≈°tanje.</li>

</ul>

</section>
<section id="slide-6-1-10">
<h4 id="6-1-10"><span class="section-number-4">6.1.10.</span> Vlasni≈°tvo i funkcije</h4>
<ul>
<li>Semantika prenosa parametara kod poziva funkcija je sliƒçna semantici dodele.</li>

</ul>

<div class="org-src-container">

<pre><code class="rust" >fn main() {
    let s = String::from("hello");  // s postaje validno

    takes_ownership(s);             // s vrednost se preme≈°ta u funkciju...
                                    // ... tako da s nije validno od ove pozicije

    let x = 5;                      // x postaje validno

    makes_copy(x);                  // x bi se premestilo u funkciju,
                                    // ali i32 je Copy, tako da je ok
                                    // da se x koristi i posle

} // x izlazi iz opsega, zatim s. Ali po≈°to je s preme≈°teno ni≈°ta posebno se
  // ne de≈°ava.

fn takes_ownership(some_string: String) { // some_string ulazi u opseg
    println!("{}", some_string);
} // some_string izlazi iz opsega i poziva se `drop`. Memorija sa hipa se
  // oslobaƒëa.

fn makes_copy(some_integer: i32) { // some_integer ulazi u opseg
    println!("{}", some_integer);
} // some_integer izlazi iz opsega. Po≈°to nije 'Drop', ni≈°ta posebno se ne
  // dogaƒëa (osim "skidanja" sa steka naravno)
</code></pre>
</div>

</section>
<section id="slide-6-1-11">
<h4 id="6-1-11"><span class="section-number-4">6.1.11.</span> Povratne vrednosti i opsezi</h4>
<p>
Prilikom vraƒáanja vrednosti iz funkcije takoƒëe mo≈æe doƒái do preme≈°tanja vlasni≈°tva.
</p>

<div class="org-src-container">

<pre><code class="rust" >fn main() {
    let s1 = gives_ownership();         // gives_ownership preme≈°ta povratnu
                                        // vrednost u s1

    let s2 = String::from("hello");     // s2 postaje validno

    let s3 = takes_and_gives_back(s2);  // s2 se preme≈°ta u funkciju
                                        // takes_and_gives_back, koja preme≈°ta
                                        // povratnu vrednost u s3
} // s3 izlazi iz opsega i poziva se `drop`. s2 je preme≈°tena pa se ni≈°ta
  // ne de≈°ava. s1 takoƒëe izlazi iz opsega i dealocira se.

fn gives_ownership() -&gt; String {             // gives_ownership ƒáe premestiti
                                             // svoju povratnu vrednost u funkciju
                                             // koja je poziva

    let some_string = String::from("yours"); // some_string postaje validno

    some_string                              // some_string se preme≈°ta
                                             // u funkciju pozivaoca
}

// Ova funkcija uzima vlasni≈°tvo nad stringom i vraƒáa ga nazad
fn takes_and_gives_back(a_string: String) -&gt; String { // a_string postaje validno

    a_string  // a_string se preme≈°ta u funkciju pozivaoca
}
</code></pre>
</div>

</section>
<section>

<ul>
<li>ƒåesto nam je potrebno da varijablu koristimo i posle slanja u funkciju.</li>
<li>Mogli bi je stalo vraƒáati zajedno sa rezultatom funkcije na primer upotrebom torki.</li>

</ul>

<div class="org-src-container">

<pre><code class="rust" >fn main() {
    let s1 = String::from("hello");

    let (s2, len) = calculate_length(s1);

    println!("The length of '{}' is {}.", s2, len);
}

fn calculate_length(s: String) -&gt; (String, usize) {
    let length = s.len();

    (s, length)
}
</code></pre>
</div>

<p>
Ali je to naporno. Postoji koncept u Rust-u koji je namenjen u ovakvim
situacijama i baziran je na referencama i pozajmljivanju vrednosti.
</p>
</section>
<section id="slide-6-2">
<h3 id="6-2"><span class="section-number-3">6.2.</span> Reference i pozajmljivanje (<i>References and Borrowing</i>)</h3>
<div class="outline-text-3" id="text-6-2">
</div>
</section>
<section id="slide-6-2-1">
<h4 id="6-2-1"><span class="section-number-4">6.2.1.</span> Reference i pozajmljivanje (<i>References and Borrowing</i>)</h4>
<ul>
<li>Referenca je poput pointera, sadr≈æi adresu vrednosti koju poseduje neka druga
varijabla.</li>
<li>Za razliku od pointera, reference u Rust-u su garantovano validne.</li>

</ul>

<div class="org-src-container">

<pre><code class="rust" >fn main() {
    let s1 = String::from("hello");

    let len = calculate_length(&amp;s1);

    println!("The length of '{}' is {}.", s1, len);
}

fn calculate_length(s: &amp;String) -&gt; usize {
    s.len()
}
</code></pre>
</div>


<div id="org680ece4" class="figure">
<p><img src="./images/reference.png" alt="reference.png" style="height: 400px;" />
</p>
</div>

</section>
<section id="slide-6-2-2">
<h4 id="6-2-2"><span class="section-number-4">6.2.2.</span> Referenciranje</h4>
<ul>
<li><p>
Primena operatora <code>&amp;</code> nad varijablom nazivamo <i>referenciranje</i>.
</p>

<div class="org-src-container">

<pre><code class="rust" >  let s1 = String::from("hello");
  let len = calculate_length(&amp;s1);
</code></pre>
</div></li>

<li>Sintaksa <code>&amp;s1</code> nam omoguƒáava da kreiramo referencu na vrednost ƒçiji vlasnik je
<code>s1</code> bez uzimanja vlasni≈°tva.</li>
<li>Po≈°to referenca nije vlasnik ne dolazi do dealokacije prilikom izlaska iz
opsega.</li>
<li>Operacija obrnuta referenciranju naziva se <i>dereferenciranje</i> i vr≈°i se <code>*</code>
operatorom nad referencom (npr. <code>*s2</code> je vrednost na koju referencira <code>s2</code>).</li>
<li>Operaciju referenciranja nazivamo pozajmljivanjem (<i>borrowing</i>).</li>

</ul>

</section>
<section>

<ul>
<li>Takoƒëe, parametar funkcije mo≈æe biti referenca.</li>

</ul>
<div class="org-src-container">

<pre><code class="rust" >fn calculate_length(s: &amp;String) -&gt; usize { // s je referenca na String
    s.len()
} // s izlazi iz opsega ali po≈°to nema vlasni≈°tvo nad vredno≈°ƒáu
  // ni≈°ta se ne de≈°ava.
</code></pre>
</div>

</section>
<section id="slide-6-2-3">
<h4 id="6-2-3"><span class="section-number-4">6.2.3.</span> Promena pozajmljene vrednosti</h4>
<p>
≈†ta se de≈°ava ukoliko poku≈°amo da modifikujemo pozajmljenu vrednost?
</p>

<div class="org-src-container">

<pre><code class="rust" >fn main() {
    let s = String::from("hello");
    change(&amp;s);
}

fn change(some_string: &amp;String) {
    some_string.push_str(", world");
}
</code></pre>
</div>

<pre class="example" id="org1e4393b">
$ cargo run
   Compiling ownership v0.1.0 (file:///projects/ownership)
error[E0596]: cannot borrow `*some_string` as mutable, as it is behind a `&amp;` reference
 --&gt; src/main.rs:8:5
  |
7 | fn change(some_string: &amp;String) {
  |                        ------- help: consider changing this to be a mutable reference: `&amp;mut String`
8 |     some_string.push_str(", world");
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ `some_string` is a `&amp;` reference, so the data it refers
  to cannot be borrowed as mutable

For more information about this error, try `rustc --explain E0596`.
error: could not compile `ownership` due to previous error
</pre>

</section>
<section id="slide-6-2-4">
<h4 id="6-2-4"><span class="section-number-4">6.2.4.</span> Promenjive reference</h4>
<p>
Kao i varijable, i reference su podrazumevano nepromenjiva (<i>immutable</i>). Moramo
biti eksplicitni ukoliko nam treba promenjiva referenca.
</p>

<div class="org-src-container">

<pre><code class="rust" >fn main() {
    let mut s = String::from("hello");
    change(&amp;mut s);
}

fn change(some_string: &amp;mut String) {
    some_string.push_str(", world");
}
</code></pre>
</div>

</section>
<section id="slide-6-2-5">
<h4 id="6-2-5"><span class="section-number-4">6.2.5.</span> Vi≈°e promenjivih referenci nad istom vredno≈°ƒáu</h4>
<p>
Rust ne dozvoljava da isti podatak u jednom trenutku ima vi≈°e promenjivih
referenci.
</p>

<div class="org-src-container">

<pre><code class="rust" >let mut s = String::from("hello");

let r1 = &amp;mut s;
let r2 = &amp;mut s;

println!("{}, {}", r1, r2);
</code></pre>
</div>

<pre class="example" id="org08490c2">
$ cargo run
   Compiling ownership v0.1.0 (file:///projects/ownership)
error[E0499]: cannot borrow `s` as mutable more than once at a time
 --&gt; src/main.rs:5:14
  |
4 |     let r1 = &amp;mut s;
  |              ------ first mutable borrow occurs here
5 |     let r2 = &amp;mut s;
  |              ^^^^^^ second mutable borrow occurs here
6 |
7 |     println!("{}, {}", r1, r2);
  |                        -- first borrow later used here

For more information about this error, try `rustc --explain E0499`.
error: could not compile `ownership` due to previous error
</pre>

</section>
<section>

<p>
Ovim ograniƒçenjem Rust, u vreme kompajliranja, spreƒçava klasu gre≈°aka koje
dovode do nedefinisanog pona≈°anja i koje zovemo <i>data races</i>. Ove gre≈°ke se veoma
te≈°ko otkrivaju i otklanjaju i mogu nastati ukoliko su zadovoljeni sledeƒái
uslovi:
</p>

<ul>
<li>Dva ili vi≈°e pointera pristupaju istim podacima u isto vreme,</li>
<li>Bar jedan pointer se koristi za izmenu podatka,</li>
<li>Ne postoji mehanizam za sinhronizaciju pristupa.</li>

</ul>

</section>
<section>

<p>
Vi≈°e promenjivih referenci mo≈æemo imati ali ne u istom opsegu:
</p>

<div class="org-src-container">

<pre><code class="rust" >let mut s = String::from("hello");

{
    let r1 = &amp;mut s;
} // r1 ovde izlazi iz opsega tako da mo≈æemo krairati nove reference

let r2 = &amp;mut s;
</code></pre>
</div>

</section>
<section id="slide-6-2-6">
<h4 id="6-2-6"><span class="section-number-4">6.2.6.</span> Kombinacija promenjivih i nepromenjivih referenci</h4>
<p>
Sliƒçno pravilo postoji i ukoliko imamo kombinaciju promenjivih i nepromenjivih
referenci:
</p>

<div class="org-src-container">

<pre><code class="rust" >let mut s = String::from("hello");

let r1 = &amp;s; // ovo je OK
let r2 = &amp;s; // ovo je OK
let r3 = &amp;mut s; // GRE≈†KA!

println!("{}, {}, and {}", r1, r2, r3);
</code></pre>
</div>

<pre class="example" id="org7d082d7">
$ cargo run
   Compiling ownership v0.1.0 (file:///projects/ownership)
error[E0502]: cannot borrow `s` as mutable because it is also borrowed as immutable
 --&gt; src/main.rs:6:14
  |
4 |     let r1 = &amp;s; // no problem
  |              -- immutable borrow occurs here
5 |     let r2 = &amp;s; // no problem
6 |     let r3 = &amp;mut s; // BIG PROBLEM
  |              ^^^^^^ mutable borrow occurs here
7 |
8 |     println!("{}, {}, and {}", r1, r2, r3);
  |                                -- immutable borrow later used here

For more information about this error, try `rustc --explain E0502`.
error: could not compile `ownership` due to previous error
</pre>

</section>
<section>

<ul>
<li>Ne mo≈æemo istovremeno imati nepromenjive i promenjive reference jer korisnici
nepromenjivih referenci ne oƒçekuju da se podaci menjaju.</li>
<li>Mo≈æemo imati vi≈°e nepromenjivih referenci jer niko ne mo≈æe da menja podatke i
time utiƒçe na druge.</li>

</ul>

</section>
<section id="slide-6-2-7">
<h4 id="6-2-7"><span class="section-number-4">6.2.7.</span> Opseg va≈æenja reference</h4>
<p>
Opseg va≈æenja reference poƒçinje od mesta gde je uvedena pa do njene poslednje
upotrebe. Na primer, ovo je validno:
</p>

<div class="org-src-container">

<pre><code class="rust" >let mut s = String::from("hello");

let r1 = &amp;s; // OK
let r2 = &amp;s; // OK
println!("{} and {}", r1, r2);
// varijable r1 i r2 se ne koriste u nastavku pa njihov opseg
// prestaje da va≈æi.

let r3 = &amp;mut s; // zato je ovo OK
println!("{}", r3);
</code></pre>
</div>

<p>
Ova osobina referenci se naziva <i>Non-Lexical Lifetimes (NLL)</i>.
</p>

</section>
<section id="slide-6-2-8">
<h4 id="6-2-8"><span class="section-number-4">6.2.8.</span> &ldquo;Viseƒáe&rdquo; reference</h4>
<ul>
<li>U jezicima sa pointerima lako je kreirati pointer na deo memorije koji je dealociran.</li>
<li>Rust garantovano spreƒçava ovakve gre≈°ke. Reference su uvek validne u Rust-u.</li>

</ul>

<div class="org-src-container">

<pre><code class="rust" >fn main() {
    let reference_to_nothing = dangle();
}

fn dangle() -&gt; &amp;String {
    let s = String::from("hello");

    &amp;s
}
</code></pre>
</div>

</section>
<section>

<pre class="example" id="org948fa38">
$ cargo run
   Compiling ownership v0.1.0 (file:///projects/ownership)
error[E0106]: missing lifetime specifier
 --&gt; src/main.rs:5:16
  |
5 | fn dangle() -&gt; &amp;String {
  |                ^ expected named lifetime parameter
  |
  = help: this function's return type contains a borrowed value, but there is no value
  for it to be borrowed from
help: consider using the `'static` lifetime
  |
5 | fn dangle() -&gt; &amp;'static String {
  |                ~~~~~~~~

For more information about this error, try `rustc --explain E0106`.
error: could not compile `ownership` due to previous error
</pre>

<ul>
<li>Mehanizam koji ovo spreƒçava naziva se &ldquo;vreme ≈æivota&rdquo; (<i>lifetime</i>) i biƒáe
detaljnije obraƒëeno u nastavku.</li>
<li><p>
U prevodu Rust nam poruƒçuje:
</p>

<blockquote>
<p>
Tip povratne vrednosti ove funkcije je pozajmljena vrednost, ali vrednost koja
je pozajmljena posle povratka vi≈°e ne postoji.
</p>
</blockquote></li>

</ul>

</section>
<section id="slide-6-2-9">
<h4 id="6-2-9"><span class="section-number-4">6.2.9.</span> ≈†ta se taƒçno desilo</h4>
<div class="org-src-container">

<pre><code class="rust" >fn dangle() -&gt; &amp;String { // dangle vraƒáa referencu na String

    let s = String::from("hello"); // s je novi String

    &amp;s // Vraƒáamo referencu na String s
} // s izlazi iz opsega i poziva se `drop`. Memorija se oslobaƒëa.
  // OPASNOST! Vraƒáena referenca ƒáe biti "viseƒáa".
</code></pre>
</div>

<p>
Kako se mo≈æe re≈°iti. Vratiƒáemo posedovanu (<i>owned</i>) vrednost, tj uradiƒáemo
preme≈°tanje vrednosti u funkciju pozivaoca.
</p>

<div class="org-src-container">

<pre><code class="rust" >fn no_dangle() -&gt; String {
    let s = String::from("hello");

    s
}
</code></pre>
</div>

</section>
<section id="slide-6-2-10">
<h4 id="6-2-10"><span class="section-number-4">6.2.10.</span> Pravila referenciranja</h4>
<ol>
<li>U svakom trenutku mo≈æemo imati ili jednu promenjivu ili proizvoljan broj
nepromenjivih referenci.</li>
<li>Reference uvek moraju biti validne.</li>

</ol>
</section>
<section id="slide-6-3">
<h3 id="6-3"><span class="section-number-3">6.3.</span> Iseƒçci (<i>Slice</i> tip)</h3>
<div class="outline-text-3" id="text-6-3">
</div>
</section>
<section id="slide-6-3-1">
<h4 id="6-3-1"><span class="section-number-4">6.3.1.</span> <i>Slice</i></h4>
<ul>
<li>Iseƒçci (<i>slices</i>) omoguƒáavaju referenciranje kontinualne sekvence unutar
kolekcije umesto cele kolekcije</li>

</ul>

</section>
<section id="slide-6-3-2">
<h4 id="6-3-2"><span class="section-number-4">6.3.2.</span> Primer</h4>
<p>
Funkcija koja za zadati string vraƒáa prvu reƒç.
</p>

<div class="org-src-container">

<pre><code class="rust" >fn first_word(s: &amp;String) -&gt; usize {
    let bytes = s.as_bytes();

    for (i, &amp;item) in bytes.iter().enumerate() {
        if item == b' ' {
            return i;
        }
    }

    s.len()
}
</code></pre>
</div>

<ul>
<li>Dakle, vraƒáamo indeks kraja reƒçi. Pozivaoc sada ima potrebne informacije da doƒëe do tra≈æene reƒçi.</li>
<li>Problem: dva podatka koja su u vezi ali moramo tu vezu ruƒçno da odr≈æavamo jer
nemamo garanciju da ƒáe broj koji je vraƒáen biti validan i u buduƒánosti (npr.
string mo≈æe da se promeni ili da izaƒëe iz opsega).</li>

</ul>

</section>
<section>

<div class="org-src-container">

<pre><code class="rust" >fn main() {
    let mut s = String::from("hello world");

    let word = first_word(&amp;s); // word ƒáe dobiti vrednost 5

    s.clear(); // string s postaje ""

    // word je i dalje 5 iako to vi≈°e nije ispravno
}
</code></pre>
</div>

</section>
<section>

<p>
Problem postaje jo≈° ozbiljniji ako npr. napi≈°emo funkciju <code>second_word</code> koja vraƒáa
drugu reƒç zadatog stringa. Po analogiji sa prethodnim, trebali bi da vratimo
poƒçetak i kraj druge reƒçi.
</p>

<div class="org-src-container">

<pre><code class="rust" >fn second_word(s: &amp;String) -&gt; (usize, usize) {
</code></pre>
</div>

<p>
Sada imamo tri podatka o kojima moramo da vodimo raƒçuna.
</p>

</section>
<section id="slide-6-3-3">
<h4 id="6-3-3"><span class="section-number-4">6.3.3.</span> String iseƒçak</h4>
<p>
Problem re≈°avamo upotrebom iseƒçaka.
</p>

<div class="org-src-container">

<pre><code class="rust" >let s = String::from("hello world");

let hello = &amp;s[0..5];
let world = &amp;s[6..11];
</code></pre>
</div>

<div class="column" style="float:left; width: 50%">
<p>
Sintaksa <code>s[x..y]</code> kreira iseƒçak nad sekvencom <code>s</code>. S obzirom da ovaj tip (<code>[T]</code>) nema
poznatu veliƒçinu u vreme kompajliranja, ne mo≈æemo ga alocirati na steku, odnosno
ne mo≈æemo ga dodeliti lokalnim varijablama ili prosleƒëivati kao parametar
funkcije. Zato se u praksi koristi referenca na iseƒçak (<code>&amp;[T]</code>) (ƒçesto se zove i
<i>fat pointer</i>).
</p>

<p>
Dakle, u praksi mnogo ƒçe≈°ƒáe sreƒáemo sintaksu <code>&amp;s[x..y]</code>.
</p>
</div>

<div class="column" style="float:right; width: 50%">

<div id="org9e1b9ca" class="figure">
<p><img src="./images/slice.png" alt="slice.png" style="height: 600px;" />
</p>
</div>
</div>

<div style="clear: both;">
</section>
<section id="slide-6-3-4">
<h4 id="6-3-4"><span class="section-number-4">6.3.4.</span> Iseƒçci i sintaksa opsega (<i>range</i>)</h4>
<div class="org-src-container">

<pre><code class="rust" >let s = String::from("hello");

let slice = &amp;s[0..2];
let slice = &amp;s[..2];
</code></pre>
</div>

<div class="org-src-container">

<pre><code class="rust" >let s = String::from("hello");

let len = s.len();

let slice = &amp;s[3..len];
let slice = &amp;s[3..];
</code></pre>
</div>

<div class="org-src-container">

<pre><code class="rust" >let s = String::from("hello");

let len = s.len();

let slice = &amp;s[0..len];
let slice = &amp;s[..];
</code></pre>
</div>

</section>
<section id="slide-6-3-5">
<h4 id="6-3-5"><span class="section-number-4">6.3.5.</span> Modifikacija primera da koristi string iseƒçke</h4>
<div class="org-src-container">

<pre><code class="rust" >fn first_word(s: &amp;String) -&gt; &amp;str {
    let bytes = s.as_bytes();

    for (i, &amp;item) in bytes.iter().enumerate() {
        if item == b' ' {
            return &amp;s[0..i];
        }
    }

    &amp;s[..]
}
</code></pre>
</div>

<p>
Isti API i za <code>second_word</code>.
</p>

<div class="org-src-container">

<pre><code class="rust" >fn second_word(s: &amp;String) -&gt; &amp;str {
</code></pre>
</div>

</section>
<section>

<p>
Sada nam kompajler osigurava da uvek imamo validnu referencu na reƒç.
</p>
<div class="org-src-container">

<pre><code class="rust" >fn main() {
    let mut s = String::from("hello world");

    let word = first_word(&amp;s);

    s.clear(); // GRE≈†KA!

    println!("the first word is: {}", word);
}
</code></pre>
</div>

<pre class="example" id="orgd5c332d">
$ cargo run
   Compiling ownership v0.1.0 (file:///projects/ownership)
error[E0502]: cannot borrow `s` as mutable because it is also borrowed as immutable
  --&gt; src/main.rs:18:5
   |
16 |     let word = first_word(&amp;s);
   |                           -- immutable borrow occurs here
17 |
18 |     s.clear(); // error!
   |     ^^^^^^^^^ mutable borrow occurs here
19 |
20 |     println!("the first word is: {}", word);
   |                                       ---- immutable borrow later used here

For more information about this error, try `rustc --explain E0502`.
error: could not compile `ownership` due to previous error
</pre>

<p>
Ne samo da je API lak≈°i za upotrebu veƒá je ƒçitava klasa gre≈°aka koje se te≈°ko
otkrivaju eliminisana u vreme kompajliranja.
</p>

</section>
<section id="slide-6-3-6">
<h4 id="6-3-6"><span class="section-number-4">6.3.6.</span> String literali su reference na iseƒçke</h4>
<div class="org-src-container">

<pre><code class="rust" >let s = "Hello, world!";
</code></pre>
</div>

<p>
Tip od <code>s</code> je <code>&amp;str</code>. <code>str</code> je string iseƒçak.
</p>

</section>
<section id="slide-6-3-7">
<h4 id="6-3-7"><span class="section-number-4">6.3.7.</span> String iseƒçci kao parametri funkcija</h4>
<div class="org-src-container">

<pre><code class="rust" >fn first_word(s: &amp;String) -&gt; &amp;str {
</code></pre>
</div>

<p>
Ali ƒáe iskusni Rust programeri pisati:
</p>

<div class="org-src-container">

<pre><code class="rust" >fn first_word(s: &amp;str) -&gt; &amp;str {
</code></pre>
</div>

<p>
Jer ƒáe ova funkcija moƒái da se koristi i za <code>&amp;str</code> i za <code>&amp;String</code>. Ovde se
upotrebljava tzv. <i>Deref Coercion</i> odnosno moguƒánosti tipova da se dereferenciraju
u drugi tip. Npr. <code>&amp;String</code> ƒáe se automatski dereferencirati u <code>&amp;str</code> ukoliko je to
potrebno. Operacija je efikasna.
</p>

</section>
<section>

<div class="org-src-container">

<pre><code class="rust" >fn main() {
    let my_string = String::from("hello world");

    // `first_word` works on slices of `String`s, whether partial or whole
    let word = first_word(&amp;my_string[0..6]);
    let word = first_word(&amp;my_string[..]);
    // `first_word` also works on references to `String`s, which are equivalent
    // to whole slices of `String`s
    let word = first_word(&amp;my_string);

    let my_string_literal = "hello world";

    // `first_word` works on slices of string literals, whether partial or whole
    let word = first_word(&amp;my_string_literal[0..6]);
    let word = first_word(&amp;my_string_literal[..]);

    // Because string literals *are* string slices already,
    // this works too, without the slice syntax!
    let word = first_word(my_string_literal);
}
</code></pre>
</div>

</section>
<section id="slide-6-3-8">
<h4 id="6-3-8"><span class="section-number-4">6.3.8.</span> Upotreba iseƒçaka nad drugim strukturama</h4>
<div class="org-src-container">

<pre><code class="rust" >let a = [1, 2, 3, 4, 5];

let slice = &amp;a[1..3]; // referenca na iseƒçak tipa &amp;[i32]

assert_eq!(slice, &amp;[2, 3]);
</code></pre>
</div>

</section>
</section>
<section>
<section id="slide-7">
<h2 id="7"><span class="section-number-2">7.</span> Strukture</h2>
</section>
</section>
<section>
<section id="slide-8">
<h2 id="8"><span class="section-number-2">8.</span> Enumeracije i podudaranje obrazaca (<i>Pattern Matching</i>)</h2>
<div class="outline-text-2" id="text-8">
</div>
</section>
<section id="slide-8-1">
<h3 id="8-1"><span class="section-number-3">8.1.</span> <i>Enum</i> tip</h3>
<div class="outline-text-3" id="text-8-1">
</div>
</section>
<section id="slide-8-1-1">
<h4 id="8-1-1"><span class="section-number-4">8.1.1.</span> <i>Enum</i> tip</h4>
<ul>
<li>Definisanje tipa navoƒëenjem svih moguƒáih varijanti</li>
<li>Varijanta mo≈æe da sadr≈æi dodatne podatke</li>
<li>Sliƒçno sa algebarskim tipovima podataka (<i>algebraic data types</i>) u funkcionalnim
jezicima, npr. F#, OCaml i Haskell-u. Ova vrsta algebarskog tipa je poznata i
pod nazivom <i>sum type</i>.</li>

</ul>

</section>
<section id="slide-8-1-2">
<h4 id="8-1-2"><span class="section-number-4">8.1.2.</span> Primer - IP adresa</h4>
<ul>
<li>IP adresa predstavlja identifikaciju mre≈ænih interfejsa u ureƒëajima koji
komuniciraju posredstvom Internet protokola (<i>Internet Protocol - IP</i>).</li>
<li>Trenutno imamo u upotrebi staru verziju 4 i novu verziju 6 koja ƒáe vremenom
zameniti verziju 4.</li>
<li>Verzija 4 je du≈æine 32 bita i navodi se kao ƒçetiri okteta u obliku npr.
<code>192.0.2.1</code></li>
<li>Verzija 6 je du≈æine 128 bita i navodi se kao 8 grupa od po 4 heksa cifre
razdvojene sa <code>:</code>, npr. <code>2001:db8:0:1234:0:567:8:1</code></li>

</ul>

</section>
<section>

<p>
U Rust-u mo≈æemo pisati sledeƒáe:
</p>

<div class="org-src-container">

<pre><code class="rust" >enum IpAddrKind {
    V4,
    V6,
}
</code></pre>
</div>

<p>
Dok vrednosti mo≈æemo kreirati sa:
</p>
<div class="org-src-container">

<pre><code class="rust" >let four = IpAddrKind::V4;
let six = IpAddrKind::V6;
</code></pre>
</div>

</section>
<section id="slide-8-1-3">
<h4 id="8-1-3"><span class="section-number-4">8.1.3.</span> Primer - IP adresa - funkcija</h4>
<p>
Sada mo≈æemo pisati funkciju koja prima ovaj tip ƒçime je moguƒáe proslediti bilo
koju varijantu kao argument.
</p>

<div class="org-src-container">

<pre><code class="rust" >fn route(ip_kind: IpAddrKind) {}

...

route(IpAddrKind::V4);
route(IpAddrKind::V6);
</code></pre>
</div>

</section>
<section id="slide-8-1-4">
<h4 id="8-1-4"><span class="section-number-4">8.1.4.</span> Primer - IP adresa - vrednost</h4>
<ul>
<li>Ali kako da defini≈°emo konkretnu vrednost IP adrese?</li>
<li>Prva ideja bi mogla biti da koristimo strukturu.</li>

</ul>

<div class="org-src-container">

<pre><code class="rust" >enum IpAddrKind {
    V4,
    V6,
}

struct IpAddr {
    kind: IpAddrKind,
    address: String,
}

let home = IpAddr {
    kind: IpAddrKind::V4,
    address: String::from("127.0.0.1"),
};

let loopback = IpAddr {
    kind: IpAddrKind::V6,
    address: String::from("::1"),
};
</code></pre>
</div>

</section>
<section>

<p>
Ali, sa <code>enum</code> tipom mo≈æemo to uraditi i bolje. <code>Enum</code> varijante mogu sadr≈æati
dodatne podatke.
</p>

<div class="org-src-container">

<pre><code class="rust" >enum IpAddr {
    V4(String),
    V6(String),
}

let home = IpAddr::V4(String::from("127.0.0.1"));

let loopback = IpAddr::V6(String::from("::1"));
</code></pre>
</div>

</section>
<section>
<p>
Vrednost sadr≈æana u varijanti ne mora biti ista za sve varijante. Na primer,
IPv4 se sastoji od 4 okteta i mo≈æda ≈æelimo da vrednost navodimo i ƒçuvamo u tom
obliku.
</p>

<div class="org-src-container">

<pre><code class="rust" >enum IpAddr {
    V4(u8, u8, u8, u8),
    V6(String),
}

let home = IpAddr::V4(127, 0, 0, 1);

let loopback = IpAddr::V6(String::from("::1"));
</code></pre>
</div>

</section>
<section id="slide-8-1-5">
<h4 id="8-1-5"><span class="section-number-4">8.1.5.</span> Primer - IP adresa - std biblioteka</h4>
<p>
U standardnoj biblioteci mo≈æemo pronaƒái tip <code>IpAddr</code>. Definisan je na sledeƒái
naƒçin.
</p>

<div class="org-src-container">

<pre><code class="rust" >struct Ipv4Addr {
    // --snip--
}

struct Ipv6Addr {
    // --snip--
}

enum IpAddr {
    V4(Ipv4Addr),
    V6(Ipv6Addr),
}
</code></pre>
</div>

</section>
<section id="slide-8-1-6">
<h4 id="8-1-6"><span class="section-number-4">8.1.6.</span> Primer  - <i>Message</i></h4>
<div class="org-src-container">

<pre><code class="rust" >enum Message {
    Quit,
    Move { x: i32, y: i32 },
    Write(String),
    ChangeColor(i32, i32, i32),
}
</code></pre>
</div>

</section>
<section>
<p>
Sledeƒáe strukture sadr≈æe iste podatke kao prethodni <code>enum</code> tip.
</p>

<div class="org-src-container">

<pre><code class="rust" >struct QuitMessage; // unit struct
struct MoveMessage {
    x: i32,
    y: i32,
}
struct WriteMessage(String); // tuple struct
struct ChangeColorMessage(i32, i32, i32); // tuple struct
</code></pre>
</div>

<p>
Ali, prednost <code>enum</code> tipa je ≈°to je to jedinstven tip pa mo≈æemo npr. napraviti
funkciju koja prima bilo koju vrednost/varijantu ovog tipa.
</p>

</section>
<section>
<p>
Nad <code>enum</code> tipom, kao i drugim tipovima, mo≈æemo implementirati metode upotrebom
<code>imlp</code> kljuƒçne reƒçi.
</p>

<div class="org-src-container">

<pre><code class="rust" >impl Message {
    fn call(&amp;self) {
        // telo metode se ovde defini≈°e
    }
}

let m = Message::Write(String::from("hello"));
m.call();
</code></pre>
</div>

</section>
<section id="slide-8-2">
<h3 id="8-2"><span class="section-number-3">8.2.</span> <code>Option</code> enumeracija</h3>
<div class="outline-text-3" id="text-8-2">
</div>
</section>
<section id="slide-8-2-1">
<h4 id="8-2-1"><span class="section-number-4">8.2.1.</span> <code>Option</code> enumeracija</h4>
<ul>
<li>ƒåest sluƒçaj da vrednost mo≈æe biti ne≈°to ili ni≈°ta.</li>
<li>Npr. ako funkcija vraƒáa prvi element iz liste koja nije prazna dobiƒáemo prvi
element, meƒëutim ako je lista prazna povratna vrednost je ni≈°ta.</li>
<li>Ovaj koncept se u razliƒçitim jezicima razliƒçito implementira. ƒåesto se koristi
specijalna vrednost <code>null</code> (ili <code>nil</code>, <code>none</code> i sl.) i sve varijable mogu biti <code>null</code>
ili <code>non-null</code>. Problem je ≈°to programer ne defini≈°e moguƒánost ove vrednosti
kroz tip pa samim tim kompajler nema moguƒánost da proveri da li kod ispravno
obraƒëuje ovu moguƒánost.</li>

</ul>

</section>
<section>

<p>
U prezentaciji iz 2009 godine pod nazivom <i>Null References: The Billion Dollar
Mistake</i> Tony Hoare, koji je prvi uveo <code>null</code> vrednost kao koncept je napisao
sledeƒáe:
</p>

<blockquote>
<p>
I call it my billion-dollar mistake. At that time, I was designing the first
comprehensive type system for references in an object-oriented language. My goal
was to ensure that all use of references should be absolutely safe, with
checking performed automatically by the compiler. But I couldn‚Äôt resist the
temptation to put in a null reference, simply because it was so easy to
implement. This has led to innumerable errors, vulnerabilities, and system
crashes, which have probably caused a billion dollars of pain and damage in the
last forty years.
</p>
</blockquote>

</section>
<section>

<p>
<code>Option</code> je generiƒçki <code>enum</code> tip u Rust-u.
</p>
<div class="org-src-container">

<pre><code class="rust" >enum Option&lt;T&gt; {
    None,
    Some(T),
}
</code></pre>
</div>

<p>
Primeri upotrebe:
</p>
<div class="org-src-container">

<pre><code class="rust" >let some_number = Some(5);           // tip je Option&lt;i32&gt;
let some_string = Some("a string");  // tip je Option&lt;&amp;str&gt;

let absent_number: Option&lt;i32&gt; = None;    // nemoguƒá inference
</code></pre>
</div>

</section>
<section id="slide-8-2-2">
<h4 id="8-2-2"><span class="section-number-4">8.2.2.</span> Za≈°to je <code>Option&lt;T&gt;</code> bolji od <code>null</code>?</h4>
<div class="org-src-container">

<pre><code class="rust" >let x: i8 = 5;
let y: Option&lt;i8&gt; = Some(5);

let sum = x + y;
</code></pre>
</div>

<pre class="example" id="org0a16cbe">
$ cargo run
   Compiling enums v0.1.0 (file:///projects/enums)
error[E0277]: cannot add `Option&lt;i8&gt;` to `i8`
 --&gt; src/main.rs:5:17
  |
5 |     let sum = x + y;
  |                 ^ no implementation for `i8 + Option&lt;i8&gt;`
  |
  = help: the trait `Add&lt;Option&lt;i8&gt;&gt;` is not implemented for `i8`

For more information about this error, try `rustc --explain E0277`.
error: could not compile `enums` due to previous error
</pre>

</section>
<section id="slide-8-2-3">
<h4 id="8-2-3"><span class="section-number-4">8.2.3.</span> Kako obraƒëivati <code>Option&lt;T&gt;</code> podatke?</h4>
<ul>
<li>Moramo eksplicitno obraditi vrednost <code>Option&lt;T&gt;</code> i moguƒánost da vrednost bude
<code>None</code>.</li>
<li><code>Option&lt;T&gt;</code> tip ima <a href="https://doc.rust-lang.org/stable/std/option/enum.Option.html">bogat API</a> koji je potrebno znati jer je ovaj tip vrlo ƒçesto
u upotrebi.</li>

</ul>

<div class="org-src-container">

<pre><code class="rust" >let x = Some(2);
let y = None;
assert_eq!(x.or(y), Some(2));

let x = None;
let y = Some(100);
assert_eq!(x.or(y), Some(100));
</code></pre>
</div>

<ul>
<li>ƒåesto koristimo jeziƒçke konstrukcije koje omoguƒáavaju obradu obe varijante.</li>

</ul>

</section>
<section id="slide-8-3">
<h3 id="8-3"><span class="section-number-3">8.3.</span> <code>match</code> konstrukcija za kontrolu toka</h3>
<div class="outline-text-3" id="text-8-3">
</div>
</section>
<section id="slide-8-3-1">
<h4 id="8-3-1"><span class="section-number-4">8.3.1.</span> <code>match</code> izraz</h4>
<ul>
<li>Moƒáan izraz kontrole toka baziran na podudaranju obrazaca (<i>Pattern Matching</i>).</li>
<li>Obrazac mo≈æe biti literal, naziv varijable, d≈æoker (<i>wildcards</i>) itd.</li>
<li><code>match</code> izraz ƒáe izvr≈°iti podudaranje uz iscrpljivanje svih moguƒánost. Ukoliko
neka moguƒánost nije obraƒëena kompajler ƒáe prijaviti gre≈°ku.</li>

</ul>

</section>
<section id="slide-8-3-2">
<h4 id="8-3-2"><span class="section-number-4">8.3.2.</span> <code>match</code> kao ma≈°ina za sortiranje novƒçiƒáa</h4>
<p>
Za poƒçetak mo≈æemo <code>match</code> izraz posmatrati kao automat za sortiranje novƒçiƒáa.
</p>

<div class="org-src-container">

<pre><code class="rust" >enum Coin {
    Penny,
    Nickel,
    Dime,
    Quarter,
}

fn value_in_cents(coin: Coin) -&gt; u8 {
    match coin {
        Coin::Penny =&gt; 1,
        Coin::Nickel =&gt; 5,
        Coin::Dime =&gt; 10,
        Coin::Quarter =&gt; 25,
    }
}
</code></pre>
</div>

<ul>
<li><code>match</code> poƒçinje sa izrazom proizvoljnog tipa.</li>
<li>U telu se nalaze &ldquo;ruke&rdquo; (<i>arms</i>) gde svaka ruka ima levu stranu koja predstavlja
obrazac za podudaranje i desnu stranu (posle <code>=&gt;</code>) koja predstavlja kod koji se
evaluira u sluƒçaju podudaranja. Ruke su razdvojene zarezima.</li>
<li>Ruke se podudaraju u redosledu navoƒëenja.</li>
<li>Povratna vrednost celog <code>match</code> izraza biƒáe vrednost evaluiranog koda ruke ƒçije
je podudaranje uspelo</li>

</ul>

</section>
<section>

<p>
Mo≈æemo na desnoj strani koristiti proizvoljan izraz pa i blok koda.
</p>
<div class="org-src-container">

<pre><code class="rust" >fn value_in_cents(coin: Coin) -&gt; u8 {
    match coin {
        Coin::Penny =&gt; {
            println!("Lucky penny!");
            1
        }
        Coin::Nickel =&gt; 5,
        Coin::Dime =&gt; 10,
        Coin::Quarter =&gt; 25,
    }
}
</code></pre>
</div>

</section>
<section id="slide-8-3-3">
<h4 id="8-3-3"><span class="section-number-4">8.3.3.</span> Povezivanje imena pri podudaranju (<i>binding</i>)</h4>
<div class="org-src-container">

<pre><code class="rust" >#[derive(Debug)]
enum UsState {
    Alabama,
    Alaska,
    Arizona,
    // --snip--
}

enum Coin {
    Penny,
    Nickel,
    Dime,
    Quarter(UsState),
}

fn value_in_cents(coin: Coin) -&gt; u8 {
    match coin {
        Coin::Penny =&gt; 1,
        Coin::Nickel =&gt; 5,
        Coin::Dime =&gt; 10,
        Coin::Quarter(state) =&gt; {
            println!("State quarter from {:?}!", state);
            25
        }
    }
}
</code></pre>
</div>

</section>
<section id="slide-8-3-4">
<h4 id="8-3-4"><span class="section-number-4">8.3.4.</span> <code>match</code> je iscrpan</h4>
<div class="org-src-container">

<pre><code class="rust" >fn value_in_cents(coin: Coin) -&gt; u8 {
    match coin {
        Coin::Penny =&gt; 1,
        Coin::Nickel =&gt; 5,
        Coin::Dime =&gt; 10,
        Coin::Quarter(UsState::Alabama) | Coin::Quarter(UsState::Alaska) =&gt; 25
    }
}
</code></pre>
</div>

<pre class="example" id="org1e66579">
$ cargo run
   Compiling match_test v0.1.0 (/home/igor/NTP/match_test)
error[E0004]: non-exhaustive patterns: `Quarter(Arizona)` not covered
  --&gt; src/main.rs:21:11
   |
13 | / enum Coin {
14 | |     Penny,
15 | |     Nickel,
16 | |     Dime,
17 | |     Quarter(UsState),
   | |     ------- not covered
18 | | }
   | |_- `Coin` defined here
...
21 |       match coin {
   |             ^^^^ pattern `Quarter(Arizona)` not covered
   |
   = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms
   = note: the matched value is of type `Coin`
</pre>

</section>
<section id="slide-8-3-5">
<h4 id="8-3-5"><span class="section-number-4">8.3.5.</span> Podudaranje sa <code>Option&lt;T&gt;</code> tipom</h4>
<div class="org-src-container">

<pre><code class="rust" >fn plus_one(x: Option&lt;i32&gt;) -&gt; Option&lt;i32&gt; {
    match x {
        None =&gt; None,
        Some(i) =&gt; Some(i + 1),
    }
}

let five = Some(5);
let six = plus_one(five);
let none = plus_one(None);
</code></pre>
</div>

</section>
<section>

<p>
Po≈°to je <code>match</code> iscrpan ne mo≈æemo zaboraviti da obradimo <code>None</code> sluƒçaj.
</p>

<div class="org-src-container">

<pre><code class="rust" >fn plus_one(x: Option&lt;i32&gt;) -&gt; Option&lt;i32&gt; {
    match x {
        Some(i) =&gt; Some(i + 1),
    }
}
</code></pre>
</div>

<pre class="example" id="org279ccb2">
$ cargo run
   Compiling enums v0.1.0 (file:///projects/enums)
error[E0004]: non-exhaustive patterns: `None` not covered
   --&gt; src/main.rs:3:15
    |
3   |         match x {
    |               ^ pattern `None` not covered
    |
    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms
    = note: the matched value is of type `Option&lt;i32&gt;`

For more information about this error, try `rustc --explain E0004`.
error: could not compile `enums` due to previous error
</pre>

</section>
<section id="slide-8-3-6">
<h4 id="8-3-6"><span class="section-number-4">8.3.6.</span> Podrazumevana obrada preostalih sluƒçajeva</h4>
<ul>
<li>≈Ωelimo na specifiƒçan naƒçin obradimo samo nekoliko sluƒçajeva dok za sve ostale
radimo podrazumevanu obradu.</li>

</ul>

<div class="org-src-container">

<pre><code class="rust" >let dice_roll = 9;
match dice_roll {
    3 =&gt; add_fancy_hat(),
    7 =&gt; remove_fancy_hat(),
    other =&gt; move_player(other),
}

fn add_fancy_hat() {}
fn remove_fancy_hat() {}
fn move_player(num_spaces: u8) {}
</code></pre>
</div>

<ul>
<li>Rust ƒáe nas upozoriti ako dodamo ruku posle one koja obraƒëuje sve sluƒçajeve
jer ta se ruka nikada neƒáe upotrebiti.</li>

</ul>

</section>
<section>

<p>
Ako ≈æelimo da obradimo sve sluƒçajeve ali nas vrednost ne interesuje mo≈æemo
koristiti <code>_</code>.
</p>

<div class="org-src-container">

<pre><code class="rust" >let dice_roll = 9;
match dice_roll {
    3 =&gt; add_fancy_hat(),
    7 =&gt; remove_fancy_hat(),
    _ =&gt; reroll(),
}

fn add_fancy_hat() {}
fn remove_fancy_hat() {}
fn reroll() {}
</code></pre>
</div>
</section>
<section id="slide-8-4">
<h3 id="8-4"><span class="section-number-3">8.4.</span> <code>if let</code> kontrola toka</h3>
<p>
<code>if let</code> nam omoguƒáava kombinaciju <code>if</code> i <code>let</code> iskaze u manje op≈°iran iskaz za obradu
samo jednog sluƒçaja poklapanja i ignorisanje ostalih.
</p>

<div class="org-src-container">

<pre><code class="rust" >let config_max = Some(3u8);
match config_max {
    Some(max) =&gt; println!("The maximum is configured to be {}", max),
    _ =&gt; (),
}
</code></pre>
</div>

<p>
Ovo mo≈æemo konciznije iskazati sa:
</p>

<div class="org-src-container">

<pre><code class="rust" >let config_max = Some(3u8);
if let Some(max) = config_max {
    println!("The maximum is configured to be {}", max);
}
</code></pre>
</div>

<ul>
<li>Gubimo iscrpnost <code>match</code> izraza.</li>
<li>Sintaksni ≈°eƒáer u situacijama kada ≈æelimo da ignori≈°emo ostale moguƒánosti.</li>

</ul>

</section>
<section>

<div class="note" id="org9bf0693">
<p>
Obrasci za podudaranje <a href="https://doc.rust-lang.org/book/ch18-02-refutability.html">mogu imati dve forme</a>: poni≈°tiv (<i>refutable</i>) i neponi≈°tiv
(<i>irrefutable</i>). Obrazac koji uvek mora uspeti (npr. <code>let x = 5;</code>) je neponi≈°tiv.
Obrazac koji ne mora da uspe uvek je poni≈°tiv (npr. <code>if let Some(x) = a_value</code>
neƒáe uspeti za <code>a_value==None</code>).
</p>

<p>
Parametri funkcija, <code>let</code> iskazi i <code>for</code> petlje prihvataju samo neponi≈°tive obrasce
jer program ne mo≈æe uraditi ni≈°ta smisleno ukoliko podudaranje ne uspe.
</p>

<p>
<code>if let</code> i <code>while let</code> prihvataju i poni≈°tive i neponi≈°tive obrasce ali ƒáe nas
kompajler upozoriti ukoliko koristimo neponi≈°tive.
</p>

</div>

</section>
<section>
<p>
Mo≈æemo koristiti i <code>else</code> granu. Sledeƒáe je ekvivalentno.
</p>

<div class="org-src-container">

<pre><code class="rust" >let mut count = 0;
match coin {
    Coin::Quarter(state) =&gt; println!("State quarter from {:?}!", state),
    _ =&gt; count += 1,
}
</code></pre>
</div>

<div class="org-src-container">

<pre><code class="rust" >let mut count = 0;
if let Coin::Quarter(state) = coin {
    println!("State quarter from {:?}!", state);
} else {
    count += 1;
}
</code></pre>
</div>

</section>
</section>
<section>
<section id="slide-9">
<h2 id="9"><span class="section-number-2">9.</span> Moduli</h2>
</section>
</section>
<section>
<section id="slide-10">
<h2 id="10"><span class="section-number-2">10.</span> Kolekcije</h2>
</section>
</section>
<section>
<section id="slide-11">
<h2 id="11"><span class="section-number-2">11.</span> Obrada gre≈°aka</h2>
</section>
</section>
<section>
<section id="slide-12">
<h2 id="12"><span class="section-number-2">12.</span> Generiƒçki tipovi, osobine (<i>Traits</i>) i ≈æivotni vek (<i>Lifetimes</i>)</h2>
<div class="outline-text-2" id="text-12">
</div>
</section>
<section id="slide-12-1">
<h3 id="12-1"><span class="section-number-3">12.1.</span> Generiƒçki tipovi (<i>generics</i>)</h3>
<div class="outline-text-3" id="text-12-1">
</div>
</section>
<section id="slide-12-1-1">
<h4 id="12-1-1"><span class="section-number-4">12.1.1.</span> Generiƒçki tipovi (<i>generics</i>)</h4>
<ul>
<li>Mehanizam za eliminaciju dupliranja koda.</li>
<li>Generiƒçki tipovi su apstraktne zamene za konkretne tipove u druge osobine u
vreme izvr≈°avanja.</li>
<li>Omoguƒáavaju nam da na apstraktan naƒçin iska≈æemo osobine tipova i njihove veze
sa drugim tipovima bez znanja o tome koji ƒáe se konkretni tipovi naƒái na
njihovom mestu u vreme kompajliranja i izvr≈°avanja koda.</li>
<li>Na primer funkcije mogu primiti generiƒçke parametre. Takoƒëe, slo≈æeni tipovi
mogu biti parametrizovani generiƒçkim tipovima (primer je <code>Option&lt;T&gt;</code>).</li>

</ul>

</section>
<section id="slide-12-1-2">
<h4 id="12-1-2"><span class="section-number-4">12.1.2.</span> Uklanjanje duplog koda upotrebom funkcija</h4>
<div class="org-src-container">

<pre><code class="rust" >fn main() {
    let number_list = vec![34, 50, 25, 100, 65];

    let mut largest = number_list[0];

    for number in number_list {
        if number &gt; largest {
            largest = number;
        }
    }

    println!("The largest number is {}", largest);
}
</code></pre>
</div>

</section>
<section>

<div class="org-src-container">

<pre><code class="rust" >fn main() {
    let number_list = vec![34, 50, 25, 100, 65];

    let mut largest = number_list[0];

    for number in number_list {
        if number &gt; largest {
            largest = number;
        }
    }

    println!("The largest number is {}", largest);

    let number_list = vec![102, 34, 6000, 89, 54, 2, 43, 8];

    let mut largest = number_list[0];

    for number in number_list {
        if number &gt; largest {
            largest = number;
        }
    }

    println!("The largest number is {}", largest);
}
</code></pre>
</div>

</section>
<section>

<div class="org-src-container">

<pre><code class="rust" >fn largest(list: &amp;[i32]) -&gt; i32 {
    let mut largest = list[0];

    for &amp;item in list {
        if item &gt; largest {
            largest = item;
        }
    }

    largest
}

fn main() {
    let number_list = vec![34, 50, 25, 100, 65];

    let result = largest(&amp;number_list);
    println!("The largest number is {}", result);

    let number_list = vec![102, 34, 6000, 89, 54, 2, 43, 8];

    let result = largest(&amp;number_list);
    println!("The largest number is {}", result);
}
</code></pre>
</div>


</section>
<section>

<p>
Postupak eliminacije duplog koda je podrazumevao sledeƒáe:
</p>

<ol>
<li>Identifikacija duplog koda.</li>
<li>Ekstrakcija koda u funkciju, definisanje parametara i povratne vrednosti.</li>
<li>Zamena instanci duplog koda sa pozivom funkcije.</li>

</ol>

</section>
<section id="slide-12-1-3">
<h4 id="12-1-3"><span class="section-number-4">12.1.3.</span> Uklanjanje duplog koda upotrebom generiƒçkih funkcija</h4>
<p>
Imamo funkciju za pronala≈æenje najveƒáeg elementa u listi sa razliƒçitim tipovima.
</p>
<div class="org-src-container">

<pre><code class="rust" >fn largest_i32(list: &amp;[i32]) -&gt; i32 {
    let mut largest = list[0];
    for &amp;item in list {
        if item &gt; largest {
            largest = item;
        }
    }
    largest
}

fn largest_char(list: &amp;[char]) -&gt; char {
    let mut largest = list[0];
    for &amp;item in list {
        if item &gt; largest {
            largest = item;
        }
    }
    largest
}

fn main() {
    let number_list = vec![34, 50, 25, 100, 65];
    let result = largest_i32(&amp;number_list);
    println!("The largest number is {}", result);
    let char_list = vec!['y', 'm', 'a', 'q'];
    let result = largest_char(&amp;char_list);
    println!("The largest char is {}", result);
}
</code></pre>
</div>

</section>
<section>

<p>
Funkcije su gotovo identiƒçne. Razlika je samo u tipu. Pi≈°emo generiƒçku funkciju
tako ≈°to defini≈°emo generiƒçki tip unutar <code>&lt;&gt;</code> posle naziva funkcije:
</p>

<div class="org-src-container">

<pre><code class="rust" >fn largest&lt;T&gt;(list: &amp;[T]) -&gt; T {
</code></pre>
</div>

<p>
<code>T</code> je generiƒçki tip i u vreme kompajliranja biƒáe zamenjen sa konkretnim tipom.
</p>

</section>
<section>

<p>
Sada je na≈° kod sledeƒái:
</p>

<div class="org-src-container">

<pre><code class="rust" >fn largest&lt;T&gt;(list: &amp;[T]) -&gt; T {
    let mut largest = list[0];

    for &amp;item in list {
        if item &gt; largest {
            largest = item;
        }
    }

    largest
}

fn main() {
    let number_list = vec![34, 50, 25, 100, 65];

    let result = largest(&amp;number_list);
    println!("The largest number is {}", result);

    let char_list = vec!['y', 'm', 'a', 'q'];

    let result = largest(&amp;char_list);
    println!("The largest char is {}", result);
}
</code></pre>
</div>

</section>
<section>

<p>
Ali se ne kompajlira.
</p>

<div class="org-src-container">

<pre><code class="rust" >$ cargo run
   Compiling chapter10 v0.1.0 (file:///projects/chapter10)
error[E0369]: binary operation `&gt;` cannot be applied to type `T`
 --&gt; src/main.rs:5:17
  |
5 |         if item &gt; largest {
  |            ---- ^ ------- T
  |            |
  |            T
  |
help: consider restricting type parameter `T`
  |
1 | fn largest&lt;T: std::cmp::PartialOrd&gt;(list: &amp;[T]) -&gt; T {
  |             ++++++++++++++++++++++

For more information about this error, try `rustc --explain E0369`.
error: could not compile `chapter10` due to previous error
</code></pre>
</div>

<p>
Tip <code>T</code> mo≈æe biti bilo koji tip pa i tip koji ne defini≈°e operaciju <code>&gt;</code> koja se
koristi u kodu. Dakle, moramo ograniƒçiti koji tipovi su moguƒái.
</p>

<p>
Videƒáemo kako se ovo radi u nastavku u priƒçi o osobinama (<i>Traits</i>).
</p>

</section>
<section id="slide-12-1-4">
<h4 id="12-1-4"><span class="section-number-4">12.1.4.</span> Generiƒçki tipovi u strukturama</h4>
<div class="org-src-container">

<pre><code class="rust" >struct Point&lt;T&gt; {
    x: T,
    y: T,
}

fn main() {
    let integer = Point { x: 5, y: 10 };
    let float = Point { x: 1.0, y: 4.0 };
}
</code></pre>
</div>

</section>
<section>

<p>
Tipovi oba polja moraju biti isti.
</p>

<div class="org-src-container">

<pre><code class="rust" >struct Point&lt;T&gt; {
    x: T,
    y: T,
}

fn main() {
    let wont_work = Point { x: 5, y: 4.0 };
}
</code></pre>
</div>

<pre class="example" id="orga8dadea">
$ cargo run
   Compiling chapter10 v0.1.0 (file:///projects/chapter10)
error[E0308]: mismatched types
 --&gt; src/main.rs:7:38
  |
7 |     let wont_work = Point { x: 5, y: 4.0 };
  |                                      ^^^ expected integer, found floating-point number

For more information about this error, try `rustc --explain E0308`.
error: could not compile `chapter10` due to previous error
</pre>

</section>
<section>

<p>
Ako ≈æelimo da polja imaju razliƒçite tipove onda moramo imati razliƒçite generiƒçke tipove.
</p>

<div class="org-src-container">

<pre><code class="rust" >struct Point&lt;T, U&gt; {
    x: T,
    y: U,
}

fn main() {
    let both_integer = Point { x: 5, y: 10 };
    let both_float = Point { x: 1.0, y: 4.0 };
    let integer_and_float = Point { x: 5, y: 4.0 };
}
</code></pre>
</div>

</section>
<section id="slide-12-1-5">
<h4 id="12-1-5"><span class="section-number-4">12.1.5.</span> Generiƒçki tipovi u enumeracijama</h4>
<div class="org-src-container">

<pre><code class="rust" >enum Option&lt;T&gt; {
    Some(T),
    None,
}
</code></pre>
</div>

</section>
<section>

<div class="org-src-container">

<pre><code class="rust" >enum Result&lt;T, E&gt; {
    Ok(T),
    Err(E),
}
</code></pre>
</div>

</section>
<section id="slide-12-1-6">
<h4 id="12-1-6"><span class="section-number-4">12.1.6.</span> Definicije metoda</h4>
<div class="org-src-container">

<pre><code class="rust" >struct Point&lt;T&gt; {
    x: T,
    y: T,
}

impl&lt;T&gt; Point&lt;T&gt; {
    fn x(&amp;self) -&gt; &amp;T {
        &amp;self.x
    }
}

fn main() {
    let p = Point { x: 5, y: 10 };

    println!("p.x = {}", p.x());
}
</code></pre>
</div>

<p>
Po≈°to smo naveli <code>&lt;T&gt;</code> iza kljuƒçne reƒçi <code>impl</code> Rust dalje zna da je tip <code>T</code> generiƒçki
a ne konkretni tip tako da je metoda <code>x</code> za <code>Point&lt;T&gt;</code> definisana nad svim tipovima
<code>T</code>.
</p>

</section>
<section>

<p>
Mogli smo npr. metodu definisati samo za odreƒëeni <code>Point</code> tip.
</p>

<div class="org-src-container">

<pre><code class="rust" >impl Point&lt;f32&gt; {
    fn distance_from_origin(&amp;self) -&gt; f32 {
        (self.x.powi(2) + self.y.powi(2)).sqrt()
    }
}
</code></pre>
</div>

<p>
Ovaj <code>impl</code> blok defini≈°e metodu <code>distance_from_origin</code> ali samo za <code>Point&lt;f32&gt;</code> dok
ostali <code>Point</code> tipovi neƒáe imati ovu metodu.
</p>

</section>
<section id="slide-12-1-7">
<h4 id="12-1-7"><span class="section-number-4">12.1.7.</span> Generiƒçki tipovi u metodama i <code>impl</code> blokovima</h4>
<p>
Generiƒçki tipovi u strukturama i metodama ne moraju biti isti. Na primer, mo≈æemo
kreirati metodu <code>mixup</code> koja uzima dve instance <code>Point</code> i vraƒáa novi <code>Point</code> tip gde
ƒáe prvo polje imati isti tip kao prva taƒçka a drugo polje kao druga taƒçka.
</p>

<div class="org-src-container">

<pre><code class="rust" >struct Point&lt;X1, Y1&gt; {
    x: X1,
    y: Y1,
}

impl&lt;X1, Y1&gt; Point&lt;X1, Y1&gt; {
    fn mixup&lt;X2, Y2&gt;(self, other: Point&lt;X2, Y2&gt;) -&gt; Point&lt;X1, Y2&gt; {
        Point {
            x: self.x,
            y: other.y,
        }
    }
}

fn main() {
    let p1 = Point { x: 5, y: 10.4 };
    let p2 = Point { x: "Hello", y: 'c' };
    let p3 = p1.mixup(p2);
    println!("p3.x = {}, p3.y = {}", p3.x, p3.y);
}
</code></pre>
</div>

<ul>
<li>Generiƒçki tipovi <code>X2</code> i <code>Y2</code> su navedeni samo u metodi jer su relevantni samo u
njenom kontekstu.</li>

</ul>

</section>
<section id="slide-12-1-8">
<h4 id="12-1-8"><span class="section-number-4">12.1.8.</span> Performanse</h4>
<p>
Upotreba generiƒçkog koda ne dovodi do degradacije performansi. Rust koristi
tehniku monomorfizacije (<i>Monomorphization</i>) kod koje ƒáe kompajler instancirati
konkretan kod za svaki tip posebno.
</p>

<p>
To bi znaƒçilo sledeƒáe. Ako imamo kod:
</p>

<div class="org-src-container">

<pre><code class="rust" >let integer = Some(5);
let float = Some(5.0)
</code></pre>
</div>

<p>
Kompajler ƒáe proizvesti kod ekvivalentan sledeƒáem:
</p>
<div class="org-src-container">

<pre><code class="rust" >enum Option_i32 {
    Some(i32),
    None,
}

enum Option_f64 {
    Some(f64),
    None,
}

fn main() {
    let integer = Option_i32::Some(5);
    let float = Option_f64::Some(5.0);
}
</code></pre>
</div>
</section>
<section id="slide-12-2">
<h3 id="12-2"><span class="section-number-3">12.2.</span> Osobine (<i>Traits</i>) - definisanje zajedniƒçkog pona≈°anja</h3>
<div class="outline-text-3" id="text-12-2">
</div>
</section>
<section id="slide-12-2-1">
<h4 id="12-2-1"><span class="section-number-4">12.2.1.</span> <i>Traits</i></h4>
<ul>
<li><i>Trait</i> defini≈°e funkcionalnost koju tip mo≈æe deliti sa drugim tipovima.</li>
<li>U drugim jezicima sliƒçan koncept naziva se interfejs.</li>
<li>Mo≈æemo koristiti <i>ograniƒçenja kroz osobine</i> (<i>Trait bounds</i>) da defini≈°emo da
generiƒçki tip mora zadovoljiti odreƒëena ograniƒçenja.</li>

</ul>

</section>
<section id="slide-12-2-2">
<h4 id="12-2-2"><span class="section-number-4">12.2.2.</span> Definisanje osobina</h4>
<ul>
<li>Primer definisanja media agregator biblioteke koja mo≈æe da prikaze sa≈æetak
podataka koji se mo≈æe ƒçuvati u <code>NewsArticle</code> ili <code>Tweet</code> instanci.</li>
<li>Defini≈°emo <code>Summary</code> osobinu da opi≈°emo ovu funkcionalnost.</li>

</ul>

<div class="org-src-container">

<pre><code class="rust" >pub trait Summary {
    fn summarize(&amp;self) -&gt; String;
}
</code></pre>
</div>

</section>
<section id="slide-12-2-3">
<h4 id="12-2-3"><span class="section-number-4">12.2.3.</span> Implementacija osobina</h4>
<div class="org-src-container">

<pre><code class="rust" >pub struct NewsArticle {
    pub headline: String,
    pub location: String,
    pub author: String,
    pub content: String,
}

impl Summary for NewsArticle {
    fn summarize(&amp;self) -&gt; String {
        format!("{}, by {} ({})", self.headline, self.author, self.location)
    }
}

pub struct Tweet {
    pub username: String,
    pub content: String,
    pub reply: bool,
    pub retweet: bool,
}

impl Summary for Tweet {
    fn summarize(&amp;self) -&gt; String {
        format!("{}: {}", self.username, self.content)
    }
}
</code></pre>
</div>

</section>
<section>

<p>
Metode osobina se pozivaju kao i obiƒçne metode. Jedina razlika je u tome ≈°to
metode osobina moraju biti dostupne u opsegu (ukljuƒçiti ih sa <code>use</code>).
</p>

<div class="org-src-container">

<pre><code class="rust" >use aggregator::{Summary, Tweet};

fn main() {
    let tweet = Tweet {
        username: String::from("horse_ebooks"),
        content: String::from(
            "of course, as you probably already know, people",
        ),
        reply: false,
        retweet: false,
    };

    println!("1 new tweet: {}", tweet.summarize());
}
</code></pre>
</div>

</section>
<section>

<div class="note" id="org5a7db08">
<p>
Ograniƒçenje u upotrebi osobina je da mo≈æemo implementirati osobinu nad tipom
jedino ako je bar jedno od njih lokalno za na≈° sanduk. Ovo pravilo je deo skupa
pravila koji se nazivaju <i>coherence</i>. Konkretno ovo pravilo zove se <i>orphan rule</i> i
spreƒçava nekompatibilne implementacije osobina nad tipovima od strane vi≈°e
sanduka.
</p>

<p>
Bez ovog pravila moglo bi se desiti da dva razliƒçita sanduka implementiraju istu
osobinu nad istim tipom na razliƒçite naƒçine i kompajler ne bi znao koju verziju
da koristi.
</p>

</div>
</section>
<section id="slide-12-2-4">
<h4 id="12-2-4"><span class="section-number-4">12.2.4.</span> Podrazumevana implementacija</h4>
<p>
Osobina mo≈æe imati podrazumevanu implementaciju metoda.
</p>

<div class="org-src-container">

<pre><code class="rust" >pub trait Summary {
    fn summarize(&amp;self) -&gt; String {
        String::from("(Read more...)")
    }
}
</code></pre>
</div>

<p>
Da bi koristili podrazumevanu implementaciju mo≈æemo navesti prazno telo u <code>impl</code>
bloku:
</p>

<div class="org-src-container">

<pre><code class="rust" >impl Summary for NewsArticle {}
</code></pre>
</div>

</section>
<section>

<p>
I zatim mo≈æemo pozvati <code>summarize</code> metodu:
</p>

<div class="org-src-container">

<pre><code class="rust" >let article = NewsArticle {
        headline: String::from("Penguins win the Stanley Cup Championship!"),
        location: String::from("Pittsburgh, PA, USA"),
        author: String::from("Iceburgh"),
        content: String::from(
            "The Pittsburgh Penguins once again are the best \
             hockey team in the NHL.",
        ),
    };

    println!("New article available! {}", article.summarize());
</code></pre>
</div>

</section>
<section>

<ul>
<li>Podrazumevana implementacija mo≈æe biti redefinisana prilikom implementacije.</li>
<li>Takoƒëe, podrazumevane metode mogu pozivati druge metode.</li>

</ul>

<div class="org-src-container">

<pre><code class="rust" >pub trait Summary {
    fn summarize_author(&amp;self) -&gt; String;

    fn summarize(&amp;self) -&gt; String {
        format!("(Read more from {}...)", self.summarize_author())
    }
}
</code></pre>
</div>

<p>
Sada je potrebno i dovoljno da prilikom implementacije defini≈°emo
<code>summarize_author</code> metodu:
</p>

<div class="org-src-container">

<pre><code class="rust" >impl Summary for Tweet {
    fn summarize_author(&amp;self) -&gt; String {
        format!("@{}", self.username)
    }
}
</code></pre>
</div>
</section>
<section id="slide-12-2-5">
<h4 id="12-2-5"><span class="section-number-4">12.2.5.</span> Osobine kao parametri</h4>
<ul>
<li>Sada mo≈æemo koristiti osobine da defini≈°emo funkcije koje rade nad parametrima
razliƒçitog tipa.</li>

</ul>

<div class="org-src-container">

<pre><code class="rust" >pub fn notify(item: &amp;impl Summary) {
    println!("Breaking news! {}", item.summarize());
}
</code></pre>
</div>

<p>
Sada funkcija <code>notify</code> radi nad svim tipovima koji implementiraju <code>Summary</code>
</p>

</section>
<section>

<p>
Prethodna upotreba <code>impl</code> kod parametra je sintaksni ≈°eƒáer za op≈°ti oblik
navoƒëenja ograniƒçenja kroz osobine.
</p>

<div class="org-src-container">

<pre><code class="rust" >pub fn notify&lt;T: Summary&gt;(item: &amp;T) {
    println!("Breaking news! {}", item.summarize());
}
</code></pre>
</div>

<p>
Ograniƒçenja kroz osobine (<i>Trait bounds</i>) stavljamo posle dvotaƒçke kod navoƒëenja
generiƒçkog tipa. Kompajler ƒáe verifikovati da sve ≈°to koristimo nad vrednostima
ovog tipa unutar funkcije je zaista definisano osobinama navedenim u zaglavlju.
</p>

</section>
<section>

<p>
<code>impl Trait</code> sintakse je konciznija kod jednostavnih primera ali je puna sintaksa
bolja kod slo≈æenijih primera.
</p>

<p>
Na primer:
</p>

<div class="org-src-container">

<pre><code class="rust" >pub fn notify(item1: &amp;impl Summary, item2: &amp;impl Summary) {
</code></pre>
</div>

<p>
bi u punoj sintaksi bilo:
</p>

<div class="org-src-container">

<pre><code class="rust" >pub fn notify&lt;T: Summary&gt;(item1: &amp;T, item2: &amp;T) {
</code></pre>
</div>

</section>
<section id="slide-12-2-6">
<h4 id="12-2-6"><span class="section-number-4">12.2.6.</span> Vi≈°estruke osobine kod ograniƒçenja</h4>
<p>
Mo≈æemo definisati i vi≈°e ograniƒçenja upotrebom <code>+</code> sintakse. Na primer, ako
parametar mora da implementira <code>Summary</code> i <code>Display</code>:
</p>
<div class="org-src-container">

<pre><code class="rust" >pub fn notify(item: &amp;(impl Summary + Display)) {
</code></pre>
</div>

<p>
ili u punoj sintaksi:
</p>

<div class="org-src-container">

<pre><code class="rust" >pub fn notify&lt;T: Summary + Display&gt;(item: &amp;T) {
</code></pre>
</div>

</section>
<section id="slide-12-2-7">
<h4 id="12-2-7"><span class="section-number-4">12.2.7.</span> <code>where</code> klauzula u ograniƒçenjima</h4>
<ul>
<li>Ukoliko imamo vi≈°e ograniƒçenja osnovna sintaksa mo≈æe da smanji ƒçitkost.</li>

</ul>

<div class="org-src-container">

<pre><code class="rust" >fn some_function&lt;T: Display + Clone, U: Clone + Debug&gt;(t: &amp;T, u: &amp;U) -&gt; i32 {
</code></pre>
</div>

<ul>
<li><code>where</code> klauzula izme≈°ta definisanje ograniƒçenja posle zaglavlja funkcije ƒçime
se posti≈æe bolja ƒçitkost:</li>

</ul>

<div class="org-src-container">

<pre><code class="rust" >fn some_function&lt;T, U&gt;(t: &amp;T, u: &amp;U) -&gt; i32
    where T: Display + Clone,
          U: Clone + Debug
{
</code></pre>
</div>

</section>
<section id="slide-12-2-8">
<h4 id="12-2-8"><span class="section-number-4">12.2.8.</span> <code>impl Trait</code> kao povratna vrednost funkcije</h4>
<div class="org-src-container">

<pre><code class="rust" >fn returns_summarizable() -&gt; impl Summary {
    Tweet {
        username: String::from("horse_ebooks"),
        content: String::from(
            "of course, as you probably already know, people",
        ),
        reply: false,
        retweet: false,
    }
}
</code></pre>
</div>

<p>
Posebno znaƒçajno u kontekstu zatvorenja (<i>closures</i>) i iteratora gde je konkretan
tip previ≈°e slo≈æen za pisanje ili je poznat samo kompajleru.
</p>

<div class="note" id="org3190239">
<p>
<code>impl Trait</code> sintaksa za povratne vrednosti je moguƒáa samo ako funkcija vraƒáa
jedan tip koji implementira datu osobinu. Na primer, ova funkcija neƒáe raditi
ako funkcija mo≈æe vratiti <code>NewsArticle</code> ili <code>Tweet</code>.
</p>

</div>

</section>
<section id="slide-12-2-9">
<h4 id="12-2-9"><span class="section-number-4">12.2.9.</span> Popravka <code>largest</code> generiƒçke funkcije</h4>
<p>
Na prethodnim sladovima imali smo funkciju <code>largest</code>. Sada mo≈æemo da zavr≈°imo
njenu definiciju.
</p>

<p>
Gre≈°ka je bila sledeƒáa:
</p>
<pre class="example" id="orgc6f11cd">
$ cargo run
   Compiling chapter10 v0.1.0 (file:///projects/chapter10)
error[E0369]: binary operation `&gt;` cannot be applied to type `T`
 --&gt; src/main.rs:5:17
  |
5 |         if item &gt; largest {
  |            ---- ^ ------- T
  |            |
  |            T
  |
help: consider restricting type parameter `T`
  |
1 | fn largest&lt;T: std::cmp::PartialOrd&gt;(list: &amp;[T]) -&gt; T {
  |             ++++++++++++++++++++++

For more information about this error, try `rustc --explain E0369`.
error: could not compile `chapter10` due to previous error
</pre>

</section>
<section>

<p>
Dakle, moramo ograniƒçiti tipove na one koji podr≈æavaju poreƒënje. Ova osobina se
u standardnoj biblioteci zove <code>std::cmp::PartialOrd</code>, pa ƒáemo prepraviti zaglavlje
funkcije na sledeƒái naƒçin:
</p>

<div class="org-src-container">

<pre><code class="rust" >fn largest&lt;T: PartialOrd&gt;(list: &amp;[T]) -&gt; T {
</code></pre>
</div>

</section>
<section>

<p>
Meƒëutim, sada imamo jo≈° jednu gre≈°ku:
</p>
<pre class="example" id="org15bd7d3">
$ cargo run
   Compiling chapter10 v0.1.0 (file:///projects/chapter10)
error[E0508]: cannot move out of type `[T]`, a non-copy slice
 --&gt; src/main.rs:2:23
  |
2 |     let mut largest = list[0];
  |                       ^^^^^^^
  |                       |
  |                       cannot move out of here
  |                       move occurs because `list[_]` has type `T`, which does not implement the `Copy` trait
  |                       help: consider borrowing here: `&amp;list[0]`

error[E0507]: cannot move out of a shared reference
 --&gt; src/main.rs:4:18
  |
4 |     for &amp;item in list {
  |         -----    ^^^^
  |         ||
  |         |data moved here
  |         |move occurs because `item` has type `T`, which does not implement the `Copy` trait
  |         help: consider removing the `&amp;`: `item`

Some errors have detailed explanations: E0507, E0508.
For more information about an error, try `rustc --explain E0507`.
error: could not compile `chapter10` due to 2 previous errors
</pre>

</section>
<section>

<p>
Uvodimo dodatno ograniƒçenje da generiƒçki tip mora biti i <code>Copy</code>. Tako da je puno
re≈°enje sledeƒáe:
</p>

<div class="org-src-container">

<pre><code class="rust" >fn largest&lt;T: PartialOrd + Copy&gt;(list: &amp;[T]) -&gt; T {
    let mut largest = list[0];

    for &amp;item in list {
        if item &gt; largest {
            largest = item;
        }
    }

    largest
}

fn main() {
    let number_list = vec![34, 50, 25, 100, 65];

    let result = largest(&amp;number_list);
    println!("The largest number is {}", result);

    let char_list = vec!['y', 'm', 'a', 'q'];

    let result = largest(&amp;char_list);
    println!("The largest char is {}", result);
}
</code></pre>
</div>

</section>
<section id="slide-12-2-10">
<h4 id="12-2-10"><span class="section-number-4">12.2.10.</span> Upotreba osobina ograniƒçenja za uslovnu implementaciju metoda</h4>
<p>
Ako ≈æelimo da implementiramo metodu samo nad tipovima koji implementiraju
odreƒëene osobine.
</p>
<div class="org-src-container">

<pre><code class="rust" >use std::fmt::Display;

struct Pair&lt;T&gt; {
    x: T,
    y: T,
}

impl&lt;T&gt; Pair&lt;T&gt; {
    fn new(x: T, y: T) -&gt; Self {
        Self { x, y }
    }
}

impl&lt;T: Display + PartialOrd&gt; Pair&lt;T&gt; {
    fn cmp_display(&amp;self) {
        if self.x &gt;= self.y {
            println!("The largest member is x = {}", self.x);
        } else {
            println!("The largest member is y = {}", self.y);
        }
    }
}
</code></pre>
</div>

</section>
<section id="slide-12-3">
<h3 id="12-3"><span class="section-number-3">12.3.</span> Validacija referenci kroz ≈æivotni vek (<i>Lifetimes</i>)</h3>

</section>
</section>
<section>
<section id="slide-13">
<h2 id="13"><span class="section-number-2">13.</span> Literatura</h2>
<ul>
<li>Steve Klabnik and Carol Nichols: <a href="https://doc.rust-lang.org/book/">The Rust Programming Language</a>, no starch press.</li>
<li>Slice is NOT reference, <a href="https://github.com/rust-lang/book/issues/3070">https://github.com/rust-lang/book/issues/3070</a></li>
<li><a href="https://rust-lang.github.io/rfcs/0505-api-comment-conventions.html">RFC 505: API documentation conventions</a></li>

</ul>
</section>
</section>
</div>
</div>
<script src="../../reveal.js/js/reveal.js"></script>
<script>
// Full list of configuration options available here:
// https://github.com/hakimel/reveal.js#configuration
Reveal.initialize({

controls: true,
progress: true,
history: false,
center: true,
slideNumber: 'c/t',
rollingLinks: false,
keyboard: true,
mouseWheel: false,
fragmentInURL: true,
hashOneBasedIndex: false,
pdfSeparateFragments: true,
overview: true,
width: 1400,
height: 1000,
minScale: 0.30,
maxScale: 4.00,

theme: Reveal.getQueryHash().theme, // available themes are in /css/theme
transition: Reveal.getQueryHash().transition || 'slide', // see README of reveal.js for options
transitionSpeed: 'default',

// Optional libraries used to extend reveal.js
dependencies: [
{src: '../../reveal.js/../reveal-plugins/menu/menu.js'},
{src: '../../reveal.js/../reveal-plugins/chalkboard/chalkboard.js'},
 { src: '../../reveal.js/plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } },
 { src: '../../reveal.js/plugin/search/search.js', async: true, condition: function() { return !!document.body.classList; } }]

,keyboard: {67: function() { RevealChalkboard.toggleNotesCanvas() },	66: function() { RevealChalkboard.toggleChalkboard() },	46: function() { RevealChalkboard.clear() },	8: function() { RevealChalkboard.reset() },	68: function() { RevealChalkboard.download() },	},});
</script>
</body>
</html>
