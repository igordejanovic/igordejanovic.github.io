<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<title>Programski jezik Rust</title>
<meta name="author" content="Igor Dejanović"/>
<style type="text/css">
.underline { text-decoration: underline; }
</style>
<link rel="stylesheet" href="../../reveal.js/css/reveal.css"/>

<link rel="stylesheet" href="../../reveal.js/css/theme/simple.css" id="theme"/>

<link rel="stylesheet" href="../../reveal-slides.css"/>

<link rel="stylesheet" href="../../highlight-styles/docco.css"/>
<link rel="stylesheet" href=""/>

<!-- If the query includes 'print-pdf', include the PDF print sheet -->
<script>
    if( window.location.search.match( /print-pdf/gi ) ) {
        var link = document.createElement( 'link' );
        link.rel = 'stylesheet';
        link.type = 'text/css';
        link.href = '../../reveal.js/css/print/pdf.css';
        document.getElementsByTagName( 'head' )[0].appendChild( link );
    }
</script>
<base target="_blank">
</head>
<body>
<div class="reveal">
<div class="slides">
<section id="sec-title-slide">
<h1 class="title">Programski jezik Rust</h1>
<h2 class="subtitle">Bazirano na verziji 1.58.1. U izradi.</h2>
<h2 class="author">Prof. dr Igor Dejanović (<a href="mailto:igord at uns ac rs">igord at uns ac rs</a>)</h2>
<p class="date">Kreirano 2022-05-15 Sun 13:50, pritisni ESC za mapu, m za meni, Ctrl+Shift+F za pretragu</p>
</section>

<section>
<section id="slide-1">
<h2 id="1"><span class="section-number-2">1.</span> Uvod</h2>
<ul>
<li>Jezik opšte namene, kompajliran i statički tipiziran sa inferencom tipova</li>
<li>Sistemsko programiranje ali sa osobinama višeg nivoa apstrakcije kao što su
funkcionalno programiranje</li>
<li>2010, Graydon Hoare, Mozilla Research</li>
<li>Performanse i sigurnost</li>
<li>Ne koristi <i>garbage collector</i> ali obezbeđuje memorijsku sigurnost kroz <i>borrow
checker</i></li>
<li>Sintaksno sličan C++. Uticaj i OCaml-a, Haskell-a i Erlang-a.</li>
<li>Koristi se u velikim firmama: Amazon, Facebook, Google, Microsoft&#x2026;</li>
<li>Od 2016 godine na SO upitniku konstantno prvi u kategoriji <i>&ldquo;most loved
programming languages&rdquo;</i></li>

</ul>
</section>
</section>
<section>
<section id="slide-2">
<h2 id="2"><span class="section-number-2">2.</span> Instalacija i podešavanje</h2>
<div class="outline-text-2" id="text-2">
</div>
</section>
<section id="slide-2-1">
<h3 id="2-1"><span class="section-number-3">2.1.</span> Instalacija</h3>
<ul>
<li>Rust stiže sa alatom za upravljanje lanca alata <code>rustup</code></li>

</ul>

<div class="org-src-container">

<pre><code class="sh" >$ curl --proto '=https' --tlsv1.2 https://sh.rustup.rs -sSf | sh
</code></pre>
</div>

<ul>
<li>Provera instalacije</li>

</ul>

<div class="org-src-container">

<pre><code class="sh" >~&gt; rustc --version
rustc 1.58.1 (db9d1b20b 2022-01-20)
</code></pre>
</div>

</section>
<section id="slide-2-2">
<h3 id="2-2"><span class="section-number-3">2.2.</span> Pregled instalacije</h3>
<div class="org-src-container">

<pre><code class="sh" >~&gt; rustup show
Default host: x86_64-unknown-linux-gnu
rustup home:  /home/igor/.rustup

installed toolchains
--------------------

stable-x86_64-unknown-linux-gnu (default)
nightly-x86_64-unknown-linux-gnu

active toolchain
----------------

stable-x86_64-unknown-linux-gnu (default)
rustc 1.58.1 (db9d1b20b 2022-01-20)
</code></pre>
</div>

</section>
<section id="slide-2-3">
<h3 id="2-3"><span class="section-number-3">2.3.</span> Ažuriranje</h3>
<p>
Za ažuriranje instalacije na najnoviju verziju
</p>

<div class="org-src-container">

<pre><code class="sh" >rustup update
</code></pre>
</div>

</section>
<section id="slide-2-4">
<h3 id="2-4"><span class="section-number-3">2.4.</span> Dokumentacija</h3>
<p>
Rust stiže sa veoma dobrom dokumentacijom i knjigama koje su dostupne direktno
iz instalacije.
</p>

<div class="org-src-container">

<pre><code class="sh" >rustup doc
</code></pre>
</div>

</section>
</section>
<section>
<section id="slide-3">
<h2 id="3"><span class="section-number-2">3.</span> Početak</h2>
<div class="outline-text-2" id="text-3">
</div>
</section>
<section id="slide-3-1">
<h3 id="3-1"><span class="section-number-3">3.1.</span> Hello, World!</h3>
<div class="org-src-container">

<pre><code class="sh" >$ mkdir hello_world
$ cd hello_world
</code></pre>
</div>

<p>
File <code>main.rs</code>:
</p>
<div class="org-src-container">

<pre><code class="rust" >fn main() {
    println!("Hello, world!");
}
</code></pre>
</div>

</section>
<section id="slide-3-2">
<h3 id="3-2"><span class="section-number-3">3.2.</span> Kompajliranje i pokretanje</h3>
<div class="org-src-container">

<pre><code class="sh" >$ rustc main.rs
$ ./main
Hello, world!
</code></pre>
</div>
</section>
<section id="slide-3-3">
<h3 id="3-3"><span class="section-number-3">3.3.</span> Hello, Cargo!</h3>
<ul>
<li>Alat za razrešavanje zavisnosti i upravljanje projektom.</li>

</ul>

<div class="org-src-container">

<pre><code class="sh" >~&gt; cargo --version
cargo 1.58.0 (f01b232bc 2022-01-19)
</code></pre>
</div>

<ul>
<li>Kreiranje projekta sa <code>cargo</code> alatom:</li>

</ul>

<div class="org-src-container">

<pre><code class="sh" >$ cargo new hello_cargo
$ cd hello_cargo
</code></pre>
</div>

</section>
<section id="slide-3-4">
<h3 id="3-4"><span class="section-number-3">3.4.</span> Sadržaj kreiranog projekta</h3>
<p>
Fajl <code>cargo.toml</code> čuva konfiguraciju projekta. Format je <a href="https://toml.io/en/">TOML</a> (<i>Tom’s Obvious,
Minimal Language</i>):
</p>

<div class="org-src-container">

<pre><code class="toml" >[package]
name = "hello_cargo"
version = "0.1.0"
edition = "2021"

[dependencies]
</code></pre>
</div>

<p>
Fajl <code>src/main.rs</code>:
</p>
<div class="org-src-container">

<pre><code class="rust" >fn main() {
    println!("Hello, world!");
}
</code></pre>
</div>
</section>
<section id="slide-3-5">
<h3 id="3-5"><span class="section-number-3">3.5.</span> Pokretanje</h3>
<div class="org-src-container">

<pre><code class="rust" >$ cargo build
   Compiling hello_cargo v0.1.0 (file:///projects/hello_cargo)
    Finished dev [unoptimized + debuginfo] target(s) in 2.85 secs
</code></pre>
</div>

<p>
Izvršni fajl se može naći na lokaciji <code>target/debug/hello_cargo</code>:
</p>

<div class="org-src-container">

<pre><code class="sh" >$ ./target/debug/hello_cargo
Hello, world!
</code></pre>
</div>

<p>
Ali <code>cargo</code> omgućava i jednostavniji način pokretanja:
</p>
<div class="org-src-container">

<pre><code class="sh" >$ cargo run
    Finished dev [unoptimized + debuginfo] target(s) in 0.0 secs
     Running `target/debug/hello_cargo`
Hello, world!
</code></pre>
</div>

</section>
<section id="slide-3-6">
<h3 id="3-6"><span class="section-number-3">3.6.</span> Provera</h3>
<p>
Takođe je moguće brzo proveriti da li se kod kompajlira:
</p>

<div class="org-src-container">

<pre><code class="sh" >$ cargo check
   Checking hello_cargo v0.1.0 (file:///projects/hello_cargo)
    Finished dev [unoptimized + debuginfo] target(s) in 0.32 secs
</code></pre>
</div>

</section>
<section id="slide-3-7">
<h3 id="3-7"><span class="section-number-3">3.7.</span> Izgradnja finalne verzije</h3>
<ul>
<li>U toku razvoja koristimo izgradnju za degabovanje koja se brže završi ali je
izvršni kod neoptimalan.</li>

<li><p>
Za finalnu verziju je potrebno izgradnju obaviti na sledeći način:
</p>

<div class="org-src-container">

<pre><code class="rust" >    cargo build --release
</code></pre>
</div></li>

<li>Ovo će obaviti dodatne optimizacije koje će duže trajati ali će krajnji kod
biti optimizovan.</li>

</ul>

</section>
<section id="slide-3-8">
<h3 id="3-8"><span class="section-number-3">3.8.</span> Cargo kao konvencija</h3>
<p>
Praktično svi Rust projekti koriste Cargo tako da je unifikovan način izgradnje
projekata. Uglavnom se svodi na:
</p>

<div class="org-src-container">

<pre><code class="sh" >$ git clone example.org/someproject
$ cd someproject
$ cargo build
</code></pre>
</div>

</section>
</section>
<section>
<section id="slide-4">
<h2 id="4"><span class="section-number-2">4.</span> Igra pogađanja brojeva</h2>
<div class="outline-text-2" id="text-4">
</div>
</section>
<section id="slide-4-1">
<h3 id="4-1"><span class="section-number-3">4.1.</span> Podešavanje projekta</h3>
<div class="org-src-container">

<pre><code class="rust" >$ cargo new guessing_game
$ cd guessing_game
</code></pre>
</div>

<p>
Fajl <code>Cargo.toml</code>:
</p>
<div class="org-src-container">

<pre><code class="toml" >[package]
name = "guessing_game"
version = "0.1.0"
edition = "2021"

[dependencies]
</code></pre>
</div>

<p>
Fajl <code>src/main.rs</code>:
</p>
<div class="org-src-container">

<pre><code class="rust" >fn main() {
    println!("Hello, world!");
}
</code></pre>
</div>

</section>
<section>

<div class="org-src-container">

<pre><code class="sh" >$ cargo run
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
    Finished dev [unoptimized + debuginfo] target(s) in 1.50s
     Running `target/debug/guessing_game`
Hello, world!
</code></pre>
</div>

</section>
<section id="slide-4-2">
<h3 id="4-2"><span class="section-number-3">4.2.</span> Preuzimanje broja sa standardnog ulaza</h3>
<div class="org-src-container">

<pre><code class="rust" >use std::io;

fn main() {
    println!("Guess the number!");

    println!("Please input your guess.");

    let mut guess = String::new();

    io::stdin()
        .read_line(&amp;mut guess)
        .expect("Failed to read line");

    println!("You guessed: {}", guess);
}
</code></pre>
</div>

</section>
<section id="slide-4-3">
<h3 id="4-3"><span class="section-number-3">4.3.</span> Promenjivost (<i>mutability</i>)</h3>
<ul>
<li>Varijable su podrazumevano nepromenjive (<i>immutable</i>).</li>
<li><p>
Ukoliko želimo varijablu čija vrednost može da se menja koristimo ključnu reč
<code>mut</code>.
</p>

<div class="org-src-container">

<pre><code class="rust" >  let apples = 5; // immutable
  let mut bananas = 5; // mutable
</code></pre>
</div></li>

<li><p>
Isto važi i za parametre funkcija:
</p>

<div class="org-src-container">

<pre><code class="rust" >  io::stdin()
      .read_line(&amp;mut guess)
</code></pre>
</div></li>

</ul>

</section>
<section id="slide-4-4">
<h3 id="4-4"><span class="section-number-3">4.4.</span> Obrada mogućih grešaka upotrebom <code>Result</code> tipa</h3>
<p>
<code>read_line</code> može da završi neuspešno. Zato vraća <code>io::Result</code> tip koji predstavlja
enumeraciju (<i>enum</i>) tip i ima dve vrednosti: <code>Ok</code> i <code>Err</code>.
</p>

<div class="org-src-container">

<pre><code class="rust" >io::stdin()
    .read_line(&amp;mut guess)
    .expect("Failed to read line");
</code></pre>
</div>

<p>
<code>expect</code> implementiran na <code>Ok</code> varijanti će vratiti vrednost koja je sadržana unutar
varijante dok implementacija nad <code>Err</code> varijanti prekida izvršavanje programa.
</p>

</section>
<section id="slide-4-5">
<h3 id="4-5"><span class="section-number-3">4.5.</span> Pokretanje</h3>
<div class="org-src-container">

<pre><code class="rust" >$ cargo run
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
    Finished dev [unoptimized + debuginfo] target(s) in 6.44s
     Running `target/debug/guessing_game`
Guess the number!
Please input your guess.
6
You guessed: 6
</code></pre>
</div>

</section>
<section id="slide-4-6">
<h3 id="4-6"><span class="section-number-3">4.6.</span> Generisanje slučajnog broja</h3>
<p>
Koristimo <code>rand</code> paket (sanduk - <i>crate</i> u terminologiji Cargo-a).
</p>

<p>
Sekcija <code>[dependencies]</code> u fajlu <code>Cargo.toml</code>:
</p>
<div class="org-src-container">

<pre><code class="toml" >[dependencies]
rand = "0.8.3"
</code></pre>
</div>

<div class="org-src-container">

<pre><code class="sh" >$ cargo build
    Updating crates.io index
  Downloaded rand v0.8.3
  Downloaded libc v0.2.86
  ...
   Compiling rand_chacha v0.3.0
   Compiling rand v0.8.3
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
    Finished dev [unoptimized + debuginfo] target(s) in 2.53s
</code></pre>
</div>

<p>
Cargo koristi <a href="https://semver.org/">Semantic Versioning</a>. Rust paketi se preuzimaju sa sajta <a href="https://crates.io/">crates.io</a>
i keširaju lokalno.
</p>

</section>
<section id="slide-4-7">
<h3 id="4-7"><span class="section-number-3">4.7.</span> Ponovljivost izgradnje - <i>Cargo.lock</i></h3>
<ul>
<li>Prvi put kada se pokrene <code>cargo build</code> kreira se fajl <code>Cargo.lock</code> sa
informacijama o verzijama svih sanduka koji su instalirani.</li>
<li>Svako sledeće pokretanje izgradnje koristi iste verzije.</li>
<li><code>Cargo.lock</code> je potrebno čuvati u sistemu kontrole verzija (npr. <code>git</code>) da bi se
osigurala ponovljivost.</li>

</ul>

</section>
<section id="slide-4-8">
<h3 id="4-8"><span class="section-number-3">4.8.</span> Ažuriranje sanduka</h3>
<ul>
<li><p>
Ažuriranje na nove verzije sanduka se obavlja sa:
</p>

<div class="org-src-container">

<pre><code class="sh" >  $ cargo update
    Updating crates.io index
    Updating rand v0.8.3 -&gt; v0.8.4
</code></pre>
</div></li>
<li>Poštuje se semantičko verzioniranje tj. automatski se ažurira na sledeću
verziju koja je manja od naredne glavne (<i>major</i>) verzije.</li>
<li>Ako prelazimo na novu glavnu verziju to moramo uraditi izmenom verzije u
<code>Cargo.toml</code> fajlu.</li>

</ul>

</section>
<section id="slide-4-9">
<h3 id="4-9"><span class="section-number-3">4.9.</span> Generisanje slučajnog broja</h3>
<p>
Fajl <code>src/main.rs</code>:
</p>
<div class="org-src-container">

<pre><code class="rust" >use std::io;
use rand::Rng;

fn main() {
    println!("Guess the number!");

    let secret_number = rand::thread_rng().gen_range(1..101);

    println!("The secret number is: {}", secret_number);

    println!("Please input your guess.");

    let mut guess = String::new();

    io::stdin()
        .read_line(&amp;mut guess)
        .expect("Failed to read line");

    println!("You guessed: {}", guess);
}
</code></pre>
</div>

<p>
U <code>gen_range</code> koristimo izraz opsega (<i>range expression</i>). Interval je zatvoren na
donjoj granici i otvoren na gornjoj. Za interval zatvoren i od gore možemo
pisati <code>1..=100</code>.
</p>

</section>
<section id="slide-4-10">
<h3 id="4-10"><span class="section-number-3">4.10.</span> Dokumentacija za lokalne sanduke</h3>
<p>
Da bi znali koje metode i funkcije su nam dostupne možemo koristiti ugrađenu
dokumentaciju za sanduke projekta. Dokumentaciju dobijamo sa:
</p>

<div class="org-src-container">

<pre><code class="sh" >cargo doc --open
</code></pre>
</div>


</section>
<section id="slide-4-11">
<h3 id="4-11"><span class="section-number-3">4.11.</span> Pokretanje programa</h3>
<div class="org-src-container">

<pre><code class="sh" >$ cargo run
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
    Finished dev [unoptimized + debuginfo] target(s) in 2.53s
     Running `target/debug/guessing_game`
Guess the number!
The secret number is: 7
Please input your guess.
4
You guessed: 4
</code></pre>
</div>

</section>
<section id="slide-4-12">
<h3 id="4-12"><span class="section-number-3">4.12.</span> Poređenje tajnog broja sa zadatim</h3>
<p>
Fajl <code>src/main.rs</code>
</p>
<div class="org-src-container">

<pre><code class="rust" >use rand::Rng;
use std::cmp::Ordering;
use std::io;

fn main() {
    // --snip--

    println!("You guessed: {}", guess);

    match guess.cmp(&amp;secret_number) {
        Ordering::Less =&gt; println!("Too small!"),
        Ordering::Greater =&gt; println!("Too big!"),
        Ordering::Equal =&gt; println!("You win!"),
    }
}
</code></pre>
</div>
<ul>
<li>Koristimo <code>std::cmp::Ordering</code> enum koji ima varijante <code>Less</code>, <code>Greater</code> i <code>Equal</code></li>
<li><code>match</code> izraz poredi zadatu vrednost sa vrednostima zadatim u telu i izvršava
granu koja se podudara. Grane <code>match</code> izraza se u Rust terminologiji zovu &ldquo;ruke&rdquo; (<i>arms</i>).</li>

</ul>

</section>
<section id="slide-4-13">
<h3 id="4-13"><span class="section-number-3">4.13.</span> Popravka tipova</h3>
<p>
Kod sa prethodnog slajda nije ispravan:
</p>
<div class="org-src-container">

<pre><code class="sh" >$ cargo build
   Compiling libc v0.2.86
   ...
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
error[E0308]: mismatched types
  --&gt; src/main.rs:22:21
   |
22 |     match guess.cmp(&amp;secret_number) {
   |                     ^^^^^^^^^^^^^^ expected struct `String`, found integer
   |
   = note: expected reference `&amp;String`
              found reference `&amp;{integer}`

error[E0283]: type annotations needed for `{integer}`
   --&gt; src/main.rs:8:44
    |
8   |     let secret_number = rand::thread_rng().gen_range(1..101);
    |         -------------                      ^^^^^^^^^ cannot infer type for type `{integer}`
    |         |
    |         consider giving `secret_number` a type
    |
    = note: multiple `impl`s satisfying `{integer}: SampleUniform` found in the `rand` crate:
            - impl SampleUniform for i128;
            - impl SampleUniform for i16;
            - impl SampleUniform for i32;
            - impl SampleUniform for i64;
            and 8 more
...
</code></pre>
</div>

</section>
<section>

<p>
Osnova greške je neslaganje tipova. Sa ulaza prihvatamo <code>String</code> dok nam je tajni
broj <code>integer</code>.
</p>

</section>
<section id="slide-4-14">
<h3 id="4-14"><span class="section-number-3">4.14.</span> Konverzija stringa u broj</h3>
<p>
Problem rešavamo konverzijom stringa sa ulaza u brojni tip.
</p>

<div class="org-src-container">

<pre><code class="rust" >// --snip--

    let mut guess = String::new();

    io::stdin()
        .read_line(&amp;mut guess)
        .expect("Failed to read line");

    let guess: u32 = guess.trim().parse().expect("Please type a number!");

    println!("You guessed: {}", guess);

    match guess.cmp(&amp;secret_number) {
        Ordering::Less =&gt; println!("Too small!"),
        Ordering::Greater =&gt; println!("Too big!"),
        Ordering::Equal =&gt; println!("You win!"),
    }
</code></pre>
</div>

</section>
<section>

<p>
Sada se program komapajlira.
</p>

<div class="org-src-container">

<pre><code class="sh" >$ cargo run
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
    Finished dev [unoptimized + debuginfo] target(s) in 0.43s
     Running `target/debug/guessing_game`
Guess the number!
The secret number is: 58
Please input your guess.
  76
You guessed: 76
Too big!
</code></pre>
</div>

</section>
<section id="slide-4-15">
<h3 id="4-15"><span class="section-number-3">4.15.</span> Omogućavanje višestrukog pogađanja - upotreba petlje</h3>
<p>
Fajl <code>src/main.rs</code>:
</p>
<div class="org-src-container">

<pre><code class="rust" >// --snip--

    println!("The secret number is: {}", secret_number);

    loop {
        println!("Please input your guess.");

        // --snip--

        match guess.cmp(&amp;secret_number) {
            Ordering::Less =&gt; println!("Too small!"),
            Ordering::Greater =&gt; println!("Too big!"),
            Ordering::Equal =&gt; println!("You win!"),
        }
    }
}
</code></pre>
</div>


</section>
<section id="slide-4-16">
<h3 id="4-16"><span class="section-number-3">4.16.</span> Prekid rada</h3>
<p>
Problem je kako prekinuti program kada korisnik pogodi broj?
</p>

<div class="org-src-container">

<pre><code class="rust" >// --snip--

        match guess.cmp(&amp;secret_number) {
            Ordering::Less =&gt; println!("Too small!"),
            Ordering::Greater =&gt; println!("Too big!"),
            Ordering::Equal =&gt; {
                println!("You win!");
                break;
            }
        }
    }
}
</code></pre>
</div>

</section>
<section id="slide-4-17">
<h3 id="4-17"><span class="section-number-3">4.17.</span> Rukovanje neispravnim ulazom</h3>
<div class="org-src-container">

<pre><code class="rust" >// --snip--

        io::stdin()
            .read_line(&amp;mut guess)
            .expect("Failed to read line");

        let guess: u32 = match guess.trim().parse() {
            Ok(num) =&gt; num,
            Err(_) =&gt; continue,
        };

        println!("You guessed: {}", guess);

        // --snip--
</code></pre>
</div>

<p>
Potrebno je još obrisati liniju koja prikazuje generisani broj.
</p>

</section>
<section id="slide-4-18">
<h3 id="4-18"><span class="section-number-3">4.18.</span> Finalni kod</h3>
<div class="org-src-container">

<pre><code class="rust" >use rand::Rng;
use std::cmp::Ordering;
use std::io;

fn main() {
    println!("Guess the number!");
    let secret_number = rand::thread_rng().gen_range(1..101);

    loop {
        println!("Please input your guess.");
        let mut guess = String::new();
        io::stdin()
            .read_line(&amp;mut guess)
            .expect("Failed to read line");
        let guess: u32 = match guess.trim().parse() {
            Ok(num) =&gt; num,
            Err(_) =&gt; continue,
        };
        println!("You guessed: {}", guess);
        match guess.cmp(&amp;secret_number) {
            Ordering::Less =&gt; println!("Too small!"),
            Ordering::Greater =&gt; println!("Too big!"),
            Ordering::Equal =&gt; {
                println!("You win!");
                break;
            }
        }
    }
}
</code></pre>
</div>

</section>
</section>
<section>
<section id="slide-5">
<h2 id="5"><span class="section-number-2">5.</span> Osnovni programski koncepti</h2>
<div class="outline-text-2" id="text-5">
</div>
</section>
<section id="slide-5-1">
<h3 id="5-1"><span class="section-number-3">5.1.</span> Varijable i promenjivost (<i>mutability</i>)</h3>
<div class="outline-text-3" id="text-5-1">
</div>
</section>
<section id="slide-5-1-1">
<h4 id="5-1-1"><span class="section-number-4">5.1.1.</span> Varijable i promenjivost (<i>mutability</i>)</h4>
<ul>
<li>Varijable su podrazumevano nepromenjive.</li>
<li><p>
Jednom kada dobiju vrednost (<i>binding</i>) ta vrednost se ne može promeniti
</p>

<div class="org-src-container">

<pre><code class="rust" >    fn main() {
        let x = 5;
        println!("The value of x is: {}", x);
        x = 6;     // greška
        println!("The value of x is: {}", x);
    }
</code></pre>
</div>

</section>
<section>

<div class="org-src-container">

<pre><code class="sh" >    $ cargo run
    Compiling variables v0.1.0 (file:///projects/variables)
    error[E0384]: cannot assign twice to immutable variable `x`
    --&gt; src/main.rs:4:5
    |
    2 |     let x = 5;
    |         -
    |         |
    |         first assignment to `x`
    |         help: consider making this binding mutable: `mut x`
    3 |     println!("The value of x is: {}", x);
    4 |     x = 6;
    |     ^^^^^ cannot assign twice to immutable variable

    For more information about this error, try `rustc --explain E0384`.
    error: could not compile `variables` due to previous error
</code></pre>
</div></li>

</ul>
</section>
<section id="slide-5-1-2">
<h4 id="5-1-2"><span class="section-number-4">5.1.2.</span> <code>mut</code> ključna reč</h4>
<div class="org-src-container">

<pre><code class="rust" >fn main() {
    let mut x = 5;
    println!("The value of x is: {}", x);
    x = 6;
    println!("The value of x is: {}", x);
}
</code></pre>
</div>
</section>
<section id="slide-5-2">
<h3 id="5-2"><span class="section-number-3">5.2.</span> Konstante - <code>const</code></h3>
<ul>
<li>Slično kao nepromenjive varijable sa sledećim razlikama:
<ul>
<li>Uvek su nepromenjive</li>
<li>Mogu se inicijalizovati samo konstantnim izrazom (poznatim u vreme kompajliranja)</li>
<li>Validne za celokupno vreme izvršavanja programa u opsegu važenja gde su
definisane (<i>scope</i>)</li>
<li>Mora se eksplicitno definisati tip</li>

</ul></li>
<li>Kompajler će konstante &ldquo;ubaciti&rdquo; na mestu upotrebe</li>
<li><p>
Po konvenciji imena konstanti se pišu velikim slovima
</p>

<div class="org-src-container">

<pre><code class="rust" >    const THREE_HOURS_IN_SECONDS: u32 = 60 * 60 * 3;
</code></pre>
</div></li>

</ul>

</section>
<section id="slide-5-3">
<h3 id="5-3"><span class="section-number-3">5.3.</span> Tipovi podataka</h3>
<div class="outline-text-3" id="text-5-3">
</div>
</section>
<section id="slide-5-3-1">
<h4 id="5-3-1"><span class="section-number-4">5.3.1.</span> Tipovi podataka</h4>
<ul>
<li>Svaka vrednost u Rust-u ima tip. Tipovi moraju biti poznati u vreme
kompajliranja (statički tipiziran jezik).</li>
<li><p>
Kompajler će probati da odredi tipove (<i>type inference</i>). Ako nije moguće
zahteva se da definišemo tip eksplicitno.
</p>

<p>
Npr:
</p>
<div class="org-src-container">

<pre><code class="rust" >    let guess: u32 = "42".parse().expect("Not a number!");
</code></pre>
</div>
<p>
Ovde nije moguće odrediti tip jer <code>str::parse</code> funkcija može vratiti različite
brojne tipove (funkcija je generička) a ne postoji način da se tip automatski
odredi.
</p>

<p>
Signatura je:
</p>
<div class="org-src-container">

<pre><code class="rust" >    pub fn parse&lt;F&gt;(&amp;self) -&gt; Result&lt;F, &lt;F as FromStr&gt;::Err&gt;
    where
        F: FromStr
</code></pre>
</div></li>

</ul>
</section>
<section id="slide-5-3-2">
<h4 id="5-3-2"><span class="section-number-4">5.3.2.</span> <i>Integer</i> tipovi</h4>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">Dužina</th>
<th scope="col" class="org-left">Signed</th>
<th scope="col" class="org-left">Unsigned</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">8-bit</td>
<td class="org-left">i8</td>
<td class="org-left">u8</td>
</tr>

<tr>
<td class="org-left">16-bit</td>
<td class="org-left">i16</td>
<td class="org-left">u16</td>
</tr>

<tr>
<td class="org-left">32-bit</td>
<td class="org-left">i32</td>
<td class="org-left">u32</td>
</tr>

<tr>
<td class="org-left">64-bit</td>
<td class="org-left">i64</td>
<td class="org-left">u64</td>
</tr>

<tr>
<td class="org-left">128-bit</td>
<td class="org-left">i128</td>
<td class="org-left">u128</td>
</tr>

<tr>
<td class="org-left">arch</td>
<td class="org-left">isize</td>
<td class="org-left">usize</td>
</tr>
</tbody>
</table>

</section>
<section id="slide-5-3-3">
<h4 id="5-3-3"><span class="section-number-4">5.3.3.</span> Literali brojeva</h4>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">Literali</th>
<th scope="col" class="org-left">Primeri</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">Decimal</td>
<td class="org-left">98_222</td>
</tr>

<tr>
<td class="org-left">Hex</td>
<td class="org-left">0xff</td>
</tr>

<tr>
<td class="org-left">Octal</td>
<td class="org-left">0o77</td>
</tr>

<tr>
<td class="org-left">Binary</td>
<td class="org-left">0b1111_0000</td>
</tr>

<tr>
<td class="org-left">Byte (u8 only)</td>
<td class="org-left">b&rsquo;A&rsquo;</td>
</tr>
</tbody>
</table>

</section>
<section id="slide-5-3-4">
<h4 id="5-3-4"><span class="section-number-4">5.3.4.</span> <i>Floating-Point</i> tipovi</h4>
<div class="org-src-container">

<pre><code class="rust" >fn main() {
    let x = 2.0; // f64

    let y: f32 = 3.0; // f32
}
</code></pre>
</div>

<p>
IEEE-754 standard
</p>

</section>
<section id="slide-5-3-5">
<h4 id="5-3-5"><span class="section-number-4">5.3.5.</span> Operacije nad brojevima</h4>
<div class="org-src-container">

<pre><code class="rust" >fn main() {
    // addition
    let sum = 5 + 10;

    // subtraction
    let difference = 95.5 - 4.3;

    // multiplication
    let product = 4 * 30;

    // division
    let quotient = 56.7 / 32.2;
    let floored = 2 / 3; // Results in 0

    // remainder
    let remainder = 43 % 5;
}
</code></pre>
</div>

</section>
<section id="slide-5-3-6">
<h4 id="5-3-6"><span class="section-number-4">5.3.6.</span> <i>Boolean</i> tip</h4>
<div class="org-src-container">

<pre><code class="rust" >fn main() {
    let t = true;

    let f: bool = false; // with explicit type annotation
}
</code></pre>
</div>

</section>
<section id="slide-5-3-7">
<h4 id="5-3-7"><span class="section-number-4">5.3.7.</span> Tip karaktera</h4>
<div class="org-src-container">

<pre><code class="rust" >fn main() {
    let c = 'z';
    let z = 'ℤ';
    let heart_eyed_cat = '😻';
}
</code></pre>
</div>

</section>
<section id="slide-5-3-8">
<h4 id="5-3-8"><span class="section-number-4">5.3.8.</span> Torke (<i>tuples</i>)</h4>
<div class="org-src-container">

<pre><code class="rust" >fn main() {
    let tup: (i32, f64, u8) = (500, 6.4, 1);
}
</code></pre>
</div>

<ul>
<li>Raspakivanje torki (<i>destructuring</i>):</li>

</ul>
<div class="org-src-container">

<pre><code class="rust" >fn main() {
    let tup = (500, 6.4, 1);

    let (x, y, z) = tup;

    println!("The value of y is: {}", y);
}
</code></pre>
</div>

</section>
<section>

<p>
Pristup elementima torke:
</p>
<div class="org-src-container">

<pre><code class="rust" >fn main() {
    let x: (i32, f64, u8) = (500, 6.4, 1);

    let five_hundred = x.0;

    let six_point_four = x.1;

    let one = x.2;
}
</code></pre>
</div>

</section>
<section id="slide-5-3-9">
<h4 id="5-3-9"><span class="section-number-4">5.3.9.</span> Nizovni tip</h4>
<ul>
<li>Svaki element nizovnog tipa mora imati isti tip</li>
<li><p>
Dimenzija niza je nepromenjiva (alociran je na steku)
</p>
<div class="org-src-container">

<pre><code class="rust" >    fn main() {
        let a = [1, 2, 3, 4, 5];
    }
</code></pre>
</div></li>

<li><p>
Tip se može eksplitino definisati na sledeći način (niz dužine <code>5</code> tipa <code>i32</code>):
</p>
<div class="org-src-container">

<pre><code class="rust" >    let a: [i32; 5] = [1, 2, 3, 4, 5];
</code></pre>
</div></li>

<li><p>
Inicijalizacija svih elemenata na istu vrednost se obavlja na sledeći način:
</p>
<div class="org-src-container">

<pre><code class="rust" >  let a = [3; 5];
</code></pre>
</div>
<p>
Gde je vrednost svakog elementa <code>3</code> a dužina niza <code>5</code>.
</p></li>

</ul>

</section>
<section>

<p>
Indeksni pristup:
</p>

<div class="org-src-container">

<pre><code class="rust" >fn main() {
    let a = [1, 2, 3, 4, 5];

    let first = a[0];
    let second = a[1];
}
</code></pre>
</div>

</section>
<section id="slide-5-4">
<h3 id="5-4"><span class="section-number-3">5.4.</span> Funkcije</h3>
<div class="outline-text-3" id="text-5-4">
</div>
</section>
<section id="slide-5-4-1">
<h4 id="5-4-1"><span class="section-number-4">5.4.1.</span> Funkcije</h4>
<div class="org-src-container">

<pre><code class="rust" >fn main() {
    println!("Hello, world!");

    another_function();
}

fn another_function() {
    println!("Another function.");
}
</code></pre>
</div>
<ul>
<li>Za imenovanje funkcija kao i varijabli koristi se <i>snake_case</i>.</li>

</ul>
</section>
<section id="slide-5-4-2">
<h4 id="5-4-2"><span class="section-number-4">5.4.2.</span> Funkcije - parametri</h4>
<div class="org-src-container">

<pre><code class="rust" >fn main() {
    print_labeled_measurement(5, 'h');
}

fn print_labeled_measurement(value: i32, unit_label: char) {
    println!("The measurement is: {}{}", value, unit_label);
}
</code></pre>
</div>

</section>
<section id="slide-5-4-3">
<h4 id="5-4-3"><span class="section-number-4">5.4.3.</span> Iskazi i izrazi</h4>
<ul>
<li>Rust je jezik baziran na izrazima (<i>expression-based</i>)</li>
<li>Iskazi (<i>statements</i>) su jezičke konstrukcije koje nemaju povratnu vrednost.
Izrazi (<i>expressions</i>) se evaluiraju u određeni rezultat, tj. imaju vrednost.</li>
<li><p>
Primer: <code>let</code> je iskaz tj. nema povratnu vrednost. Ovo možete pisati:
</p>
<div class="org-src-container">

<pre><code class="rust" >  let y = 6;
</code></pre>
</div>
<p>
Ali ovo ne:
</p>
<div class="org-src-container">

<pre><code class="rust" >  let x = (let y = 6);
</code></pre>
</div></li>

</ul>

</section>
<section>

<p>
Blok koda je takođe izraz. Šta je vrednost u koju se evaluira?
</p>

<div class="org-src-container">

<pre><code class="rust" >{
    let x = 3;
    x + 1
}
</code></pre>
</div>

<p>
Vrednost bloka je vrednost poslednjeg izraza, tj. <code>x+1</code>. Primetite da tu ne
koristimo <code>;</code> jer terminacija ovim karakterom pretvara izraz u iskaz.
</p>

</section>
<section>

<p>
Zbog ovoga je sasvim legalno da pišemo:
</p>

<div class="org-src-container">

<pre><code class="rust" >fn main() {
    let y = {
        let x = 3;
        x + 1
    };

    println!("The value of y is: {}", y);
}
</code></pre>
</div>

<pre class="example">
The value of y is: 4
</pre>
</section>
<section id="slide-5-4-4">
<h4 id="5-4-4"><span class="section-number-4">5.4.4.</span> Povratne vrednosti funkcija</h4>
<p>
Vrednost funkcije je vrednost bloka koji predstavlja telo funkcije, dakle
poslednjeg izraza unutar tela funkcije.
</p>

<div class="org-src-container">

<pre><code class="rust" >fn five() -&gt; i32 {
    5
}

fn main() {
    let x = five();

    println!("The value of x is: {}", x);
}
</code></pre>
</div>

<pre class="example">
The value of x is: 5
</pre>


</section>
<section>

<p>
Ili na primer:
</p>
<div class="org-src-container">

<pre><code class="rust" >fn main() {
    let x = plus_one(5);

    println!("The value of x is: {}", x);
}

fn plus_one(x: i32) -&gt; i32 {
    x + 1
}
</code></pre>
</div>

<pre class="example">
The value of x is: 6
</pre>


</section>
<section>

<p>
Ukoliko izraz <code>x+1</code> terminiramo sa <code>;</code> kod se neće kompajlirati jer funkcija
deklariše da vraća tip <code>i32</code> dok sada vraća <code>()</code> (tzv. <i>unit type</i>) odnosno nema
povratnu vrednost jer je poslednja instrukcija iskaz.
</p>

<div class="org-src-container">

<pre><code class="rust" >fn main() {
    let x = plus_one(5);

    println!("The value of x is: {}", x);
}

fn plus_one(x: i32) -&gt; i32 {
    x + 1;
}
</code></pre>
</div>

<pre class="example" id="org953438a">
error[E0308]: mismatched types
 --&gt; src/main.rs:8:24
  |
8 | fn plus_one(x: i32) -&gt; i32 {
  |    --------            ^^^ expected `i32`, found `()`
  |    |
  |    implicitly returns `()` as its body has no tail or `return` expression
9 |     x + 1;
  |          - help: consider removing this semicolon

For more information about this error, try `rustc --explain E0308`.
error: could not compile `cargo4UyKF0` due to previous error
</pre>



</section>
<section id="slide-5-5">
<h3 id="5-5"><span class="section-number-3">5.5.</span> Komentari</h3>
<p>
Komentari se pišu posle <code>//</code>. Ne postoji sintaksa za blok komentar kao npr. u
C/C++. Ovo bi bili validni komentari:
</p>
<div class="org-src-container">

<pre><code class="rust" >// So we’re doing something complicated here, long enough that we need
// multiple lines of comments to do it! Whew! Hopefully, this comment will
// explain what’s going on.

fn main() {
    let lucky_number = 7; // I’m feeling lucky today
}
...
fn main() {
    // I’m feeling lucky today
    let lucky_number = 7;
}
</code></pre>
</div>

</section>
<section>

<p>
Postoje i komentari za dokumentaciju koji predstavljaju posebnu sintaksu za
komentare koji su deo API dokumentacije. Oni se pišu posle <code>///</code>. Na primer:
</p>
<div class="org-src-container">

<pre><code class="rust" >/// Adds one to the number given.
///
/// # Examples
///
/// ```
/// let arg = 5;
/// let answer = my_crate::add_one(arg);
///
/// assert_eq!(6, answer);
/// ```
pub fn add_one(x: i32) -&gt; i32 {
    x + 1
}
</code></pre>
</div>
</section>
<section id="slide-5-6">
<h3 id="5-6"><span class="section-number-3">5.6.</span> Kontrola toka</h3>
<div class="outline-text-3" id="text-5-6">
</div>
</section>
<section id="slide-5-6-1">
<h4 id="5-6-1"><span class="section-number-4">5.6.1.</span> <code>if</code> izrazi</h4>
<div class="org-src-container">

<pre><code class="rust" >fn main() {
    let number = 3;

    if number &lt; 5 {
        println!("condition was true");
    } else {
        println!("condition was false");
    }
}
</code></pre>
</div>

</section>
<section id="slide-5-6-2">
<h4 id="5-6-2"><span class="section-number-4">5.6.2.</span> <code>if-else</code></h4>
<div class="org-src-container">

<pre><code class="rust" >fn main() {
    let number = 6;

    if number % 4 == 0 {
        println!("number is divisible by 4");
    } else if number % 3 == 0 {
        println!("number is divisible by 3");
    } else if number % 2 == 0 {
        println!("number is divisible by 2");
    } else {
        println!("number is not divisible by 4, 3, or 2");
    }
}
</code></pre>
</div>
</section>
<section id="slide-5-6-3">
<h4 id="5-6-3"><span class="section-number-4">5.6.3.</span> <code>if</code> u <code>let</code> iskazima</h4>
<p>
<code>if</code> je izraz pa se može koristiti gde god možemo pisati i bilo koji drugi izraz.
</p>

<div class="org-src-container">

<pre><code class="rust" >fn main() {
    let condition = true;
    let number = if condition { 5 } else { 6 };

    println!("The value of number is: {}", number);
}
</code></pre>
</div>

<pre class="example">
The value of number is: 5
</pre>


</section>
<section>

<p>
Ali se grane moraju slagati po tipu. Ovo je pogrešno jer je prva grana tipa
<code>i32</code> dok je <code>else</code> grana tipa <code>str</code>.
</p>

<div class="org-src-container">

<pre><code class="rust" >fn main() {
    let condition = true;

    let number = if condition { 5 } else { "six" };

    println!("The value of number is: {}", number);
}
</code></pre>
</div>
</section>
<section id="slide-5-6-4">
<h4 id="5-6-4"><span class="section-number-4">5.6.4.</span> Petlje</h4>
<p>
Rust ima tri tipa petlje:
</p>
<ul>
<li><code>loop</code> - za beskontačne petlje</li>
<li><code>while</code> - uslovna petlja</li>
<li><code>for</code> - petlja za iteraciju kroz iteratore</li>

</ul>

</section>
<section id="slide-5-6-5">
<h4 id="5-6-5"><span class="section-number-4">5.6.5.</span> <code>loop</code></h4>
<div class="org-src-container">

<pre><code class="rust" >fn main() {
    loop {
        println!("again!");
    }
}
</code></pre>
</div>

</section>
<section id="slide-5-6-6">
<h4 id="5-6-6"><span class="section-number-4">5.6.6.</span> <code>loop</code> labele</h4>
<p>
Ukoliko imamo ugnježdene <code>loop</code> iskaze možemo koristiti labele prilikom izlaska sa
<code>break</code> instrukcijom.
</p>

<div class="org-src-container">

<pre><code class="rust" >fn main() {
    let mut count = 0;
    'counting_up: loop {
        println!("count = {}", count);
        let mut remaining = 10;

        loop {
            println!("remaining = {}", remaining);
            if remaining == 9 {
                break;
            }
            if count == 2 {
                break 'counting_up;
            }
            remaining -= 1;
        }

        count += 1;
    }
    println!("End count = {}", count);
}
</code></pre>
</div>

</section>
<section id="slide-5-6-7">
<h4 id="5-6-7"><span class="section-number-4">5.6.7.</span> <code>loop</code> kao izraz</h4>
<p>
<code>loop</code> može imati povratnu vrednost. Povratna vrednost se definiše kao parametar
<code>break</code> instrukcije.
</p>

<div class="org-src-container">

<pre><code class="rust" >fn main() {
    let mut counter = 0;

    let result = loop {
        counter += 1;

        if counter == 10 {
            break counter * 2;
        }
    };

    println!("The result is {}", result);
}
</code></pre>
</div>
</section>
<section id="slide-5-6-8">
<h4 id="5-6-8"><span class="section-number-4">5.6.8.</span> <code>while</code></h4>
<div class="org-src-container">

<pre><code class="rust" >fn main() {
    let mut number = 3;

    while number != 0 {
        println!("{}!", number);

        number -= 1;
    }

    println!("LIFTOFF!!!");
}
</code></pre>
</div>
</section>
<section id="slide-5-6-9">
<h4 id="5-6-9"><span class="section-number-4">5.6.9.</span> <code>for</code></h4>
<p>
Iteraciju kroz uređenu kolekciju, kao što je niz, možemo obaviti sa <code>while</code> petljom.
</p>
<div class="org-src-container">

<pre><code class="rust" >fn main() {
    let a = [10, 20, 30, 40, 50];
    let mut index = 0;

    while index &lt; 5 {
        println!("the value is: {}", a[index]);

        index += 1;
    }
}
</code></pre>
</div>

</section>
<section>
<p>
Ali je za tu namenu prirodnije i sigurnije koristiti <code>for</code> petlju. Takođe će se
program brže izvršavati.
</p>

<div class="org-src-container">

<pre><code class="rust" >fn main() {
    let a = [10, 20, 30, 40, 50];

    for element in a {
        println!("the value is: {}", element);
    }
}
</code></pre>
</div>

</section>
<section>
<p>
<code>for</code> petlje su najčešći oblik petlji u upotrebi u Rust-u. Koriste se npr. i u
situaciji kada je potrebno izvršiti petlju određeni broj puta.
</p>

<div class="org-src-container">

<pre><code class="rust" >fn main() {
    for number in (1..4).rev() {
        println!("{}!", number);
    }
    println!("LIFTOFF!!!");
}
</code></pre>
</div>

<pre class="example">
3!
2!
1!
LIFTOFF!!!
</pre>

</section>
</section>
<section>
<section id="slide-6">
<h2 id="6"><span class="section-number-2">6.</span> Vlasništvo i pozamljivanje (<i>Ownership and borrowing</i>)</h2>
</section>
</section>
<section>
<section id="slide-7">
<h2 id="7"><span class="section-number-2">7.</span> Strukture</h2>
</section>
</section>
<section>
<section id="slide-8">
<h2 id="8"><span class="section-number-2">8.</span> Enumeracije i podudaranje obrazaca (<i>Pattern Matching</i>)</h2>
</section>
</section>
<section>
<section id="slide-9">
<h2 id="9"><span class="section-number-2">9.</span> Moduli</h2>
</section>
</section>
<section>
<section id="slide-10">
<h2 id="10"><span class="section-number-2">10.</span> Kolekcije</h2>
</section>
</section>
<section>
<section id="slide-11">
<h2 id="11"><span class="section-number-2">11.</span> Obrada grešaka</h2>
</section>
</section>
<section>
<section id="slide-12">
<h2 id="12"><span class="section-number-2">12.</span> Generički tipovi, osobine (<i>Traits</i>) i životni vek (<i>Lifetimes</i>)</h2>
</section>
</section>
<section>
<section id="slide-13">
<h2 id="13"><span class="section-number-2">13.</span> Literatura</h2>
<ul>
<li>Steve Klabnik and Carol Nichols: <a href="https://doc.rust-lang.org/book/">The Rust Programming Language</a>, no starch press.</li>

</ul>
</section>
</section>
</div>
</div>
<script src="../../reveal.js/js/reveal.js"></script>
<script>
// Full list of configuration options available here:
// https://github.com/hakimel/reveal.js#configuration
Reveal.initialize({

controls: true,
progress: true,
history: false,
center: true,
slideNumber: 'c/t',
rollingLinks: false,
keyboard: true,
mouseWheel: false,
fragmentInURL: true,
hashOneBasedIndex: false,
pdfSeparateFragments: true,
overview: true,
width: 1400,
height: 1000,
minScale: 0.30,
maxScale: 4.00,

theme: Reveal.getQueryHash().theme, // available themes are in /css/theme
transition: Reveal.getQueryHash().transition || 'slide', // see README of reveal.js for options
transitionSpeed: 'default',

// Optional libraries used to extend reveal.js
dependencies: [
{src: '../../reveal.js/../reveal-plugins/menu/menu.js'},
{src: '../../reveal.js/../reveal-plugins/chalkboard/chalkboard.js'},
 { src: '../../reveal.js/plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } },
 { src: '../../reveal.js/plugin/search/search.js', async: true, condition: function() { return !!document.body.classList; } }]

,keyboard: {67: function() { RevealChalkboard.toggleNotesCanvas() },	66: function() { RevealChalkboard.toggleChalkboard() },	46: function() { RevealChalkboard.clear() },	8: function() { RevealChalkboard.reset() },	68: function() { RevealChalkboard.download() },	},});
</script>
</body>
</html>
