#+TITLE: Programski jezik Go
#+SUBTITLE: U izradi. Bazirano na Go verziji 1.12.4 i [[https://tour.golang.org/][A Tour of Go]]
#+EXPORT_FILE_NAME: index.html
#+SETUPFILE: ../../courses-startup.org

* Uvod
** Osnovne osobine
   
- Statički tipiziran, kompajliran programski jezik
- Google: Robert Griesemer, Rob Pike, i Ken Thompson
- Sličan C-u ali sa /memory safety/, /garbage collection/ i direktnom podrškom
  za konkurentno programiranje ([[https://en.wikipedia.org/wiki/Communicating_sequential_processes][Communicating Sequential Processes (CSP)]])
- Efikasnost, jednostavnost i čitkost
- Akcenat na mrežnom i /multi-core/ softveru
- Razvoj započet 2007, javno dostupan od 2009

#+attr_html: :class footer :style clear: both;
https://en.wikipedia.org/wiki/Go_(programming_language)

* Instalacija i podešavanja
** Instalacija
   
- Koristiti instaler za OS
- ...ili raspakovati tarball/zip i podesiti =PATH= varijablu na =go/bin= folder
- Na primer:

  #+BEGIN_SRC bash
  wget https://dl.google.com/go/go$VERSION.$OS-$ARCH.tar.gz
  mkdir -p ~/install/go
  tar -C ~/install/go -xzf go$VERSION.$OS-$ARCH.tar.gz
  #+END_SRC
  
- gde je =VERSION= - tekuća verzija (trenutno 1.12.4), =OS= - operativni sistem
  (npr. =linux=) a =ARCH= - arhitektura (npr. =amd64=)
- podesiti =PATH=:

  #+BEGIN_SRC bash
  export PATH=$PATH:~/install/go/
  #+END_SRC
  
** /Workspace/ direktorijum
   
- Direktorijum za Go kod
- Podrazumevano =$HOME/go=
- Ukoliko želite da promenite morate podesiti =GOPATH= varijablu
 
** Testiranje instalacije

  #+BEGIN_SRC bash
  $ go version
  go version go1.12.4 linux/amd64
  #+END_SRC
   
- Napraviti =src/hello= u /workspace/ direktorijumu (dakle =~/go/src/hello=)
- Napraviti fajl =hello.go= sa sadržajem:

  #+BEGIN_SRC go
  package main

  import "fmt"

  func main() {
	  fmt.Printf("Здраво, свете!\n")
  }
  #+END_SRC
  
- Preći u projektni folder, pokrenuti =build= i zatim startovati program:

  #+BEGIN_SRC bash
  $ cd ~/go/src/hello
  $ go build
  $ ./hello
  Здраво, свете!
  #+END_SRC

* Kako pisati Go kod?
** Uvod
   
   Go alati podrazumevaju određene konvencije u organizaciji foldera i
   programskog koda.
   
   Bazirano na [[https://golang.org/doc/code.html][How to Write Go Code]]
   
** /Workspaces/
   
   - Obično se sav Go kod smešta na jedno mesto koje zovemo /workspace/
   - Na ovom mestu se nalazi veći broj repozitorijuma pod sistemima za kontrolu
     verzija (npr. =git=).
   - Svaki repozitorijum se sastoji od jednog ili više paketa
   - Svaki paket se sastoji od jednog ili više Go fajlova u jednom direktorijumu
   - Putanja (/path/) do direktorijuma paketa određuje njegov /import path/

** /Workspaces/
   
  #+BEGIN_SRC
  bin/
      hello                          # command executable
      outyet                         # command executable
  src/
      github.com/golang/example/
          .git/                      # Git repository metadata
    hello/
        hello.go               # command source
    outyet/
        main.go                # command source
        main_test.go           # test source
    stringutil/
        reverse.go             # package source
        reverse_test.go        # test source
      golang.org/x/image/
          .git/                      # Git repository metadata
    bmp/
        reader.go              # package source
        writer.go              # package source
      ... (many more repositories and packages omitted) ...
  #+END_SRC

   
** =GOPATH=

- Podrazumevano =$HOME/go= na Unix-like sistemima ili =%USERPOFILE%\go= na
  Windows-u.
- =go env GOPATH= komanda daje informaciju o tekućoj lokaciji tj. sadržaj
  =GOPATH= varijable ili podrazumevanu lokaciju ukoliko nije podešena.
- Da bi instalirani Go programi bili dostupni:
  #+BEGIN_SRC bash
  $ export PATH=$PATH:$(go env GOPATH)/bin
  #+END_SRC
  
** Import putanja (/import path/)
   
- Kratke putanje za standardnu biblioteku. Na primer: =fmt=, =net/http=
- Putanja je relativna u odnosu na =$GOPATH/src=
- Mora biti jedinstvena
- Dobra praksa je upotreba domena VCS hosting sajtova. Na primer:
  #+BEGIN_SRC
  $GOPATH/src/github.com/user
  #+END_SRC
  
** Prvi Go program
   
   #+BEGIN_SRC shell
   $ mkdir $GOPATH/src/github.com/user/hello
   #+END_SRC
   
   - Fajl =hello.go=
   #+BEGIN_SRC go
    package main

    import "fmt"

    func main() {
      fmt.Printf("Здраво, свете!\n")
    }
   #+END_SRC
   
   #+BEGIN_SRC shell
   $ go install github.com/user/hello
   # ili
   $ cd $GOPATH/src/github.com/user/hello
   $ go install
   #+END_SRC
   
   - =hello= program će biti instaliran u =$GOPATH/bin/=

   #+BEGIN_SRC shell
   $ $GOPATH/bin/hello
   Здраво, свете!
   # ili samo
   $ hello
   Здраво, свете!
   #+END_SRC
   
   #+REVEAL: split
   
   - Sledeći korak je da promenu zabeležimo u sistemu za kontrolu verzija:
   #+BEGIN_SRC shell
   $ cd $GOPATH/src/github.com/user/hello
   $ git init
   Initialized empty Git repository in /home/user/work/src/github.com/user/hello/.git/
   $ git add hello.go
   $ git commit -m "initial commit"
   [master (root-commit) 0b4507d] initial commit
   1 file changed, 1 insertion(+)
     create mode 100644 hello.go
   #+END_SRC

** Prva Go biblioteka
   
   #+BEGIN_SRC bash
   $ mkdir $GOPATH/src/github.com/user/stringutil
   #+END_SRC
   
   #+BEGIN_SRC go
   // Package stringutil contains utility functions for working with strings.
   package stringutil

   // Reverse returns its argument string reversed rune-wise left to right.
   func Reverse(s string) string {
     r := []rune(s)
     for i, j := 0, len(r)-1; i < len(r)/2; i, j = i+1, j-1 {
       r[i], r[j] = r[j], r[i]
     }
     return string(r)
   }
   #+END_SRC
   
   - Provera ispravnosti biblioteke
   #+BEGIN_SRC shell
   $ go build github.com/user/stringutil
   # ili ako smo već u folderu stringutil
   $ go build
   #+END_SRC
   
   #+REVEAL: split
    
   - Modifikovati program =hello.go=
   
   #+BEGIN_SRC go
   package main

   import (
     "fmt"

     "github.com/user/stringutil"
   )

   func main() {
     fmt.Println(stringutil.Reverse("!етевс ,овардЗ"))
   }
   #+END_SRC
   
   #+BEGIN_SRC shell
   $ go install github.com/user/hello
   $ hello
   Здраво, свете!
   #+END_SRC


   #+BEGIN_SRC
   bin/
     hello                 # command executable
   src/
       github.com/user/
           hello/
               hello.go      # command source
           stringutil/
               reverse.go    # package source
   #+END_SRC


   
** Imenovanje paketa
   
   - Prvi iskaz u svakom Go fajlu mora biti:
     #+BEGIN_SRC go
     package name
     #+END_SRC
   - ...gde je =name= ime paketa koje se koristi pri /import/-u
   - Svi fajlovi koji pripadaju istom paketu moraju koristiti isto ime
   - Go konvencija je da je ime paketa poslednji element import putanje. Primer:
     ukoliko se paket importuje sa =crypto/rot13= tada njegovo ime treba da bude
     =rot13=
   - Izvršne komande moraju biti u paketu =main=
   - Ne zahteva se da ime paketa bude jedinstveno kod svih paketa koji se
     importuju ali se zahteva da putanja bude
     
** Promena imena pri /import/-u paketa
   
  #+BEGIN_SRC
  Import declaration          Local name of Sin

  import   "lib/math"         math.Sin
  import m "lib/math"         m.Sin
  import . "lib/math"         Sin
  #+END_SRC
  
  - Import paketa bez upotrebe (zbog /side-effect/-a)
  
  #+BEGIN_SRC
  import _ "lib/math"
  #+END_SRC

  
  #+attr_html: :class footer :style clear: both;
  https://golang.org/ref/spec#Import_declarations

** Testiranje
   
   - /Lightweight/ test okvir u paketu =testing= + =go test= komanda
   - Jedinični test se piše u fajlu koji se završava na =_test.go= i koji sadrži
     funkcije oblika =TestXXX= sa signaturom =func (t *testing.T)=
   - =go test= poziva sve funkcije i ako ona pozove =t.Error= ili =t.Fail= test
     se smatra neuspešnim
     
   #+REVEAL: split

   - Fajl =$GOPATH/src/github.com/user/stringutil/reverse_test.go=
   #+BEGIN_SRC go
   package stringutil

   import "testing"

   func TestReverse(t *testing.T) {
     cases := []struct {
       in, want string
     }{
       {"Hello, world", "dlrow ,olleH"},
       {"Hello, 世界", "界世 ,olleH"},
       {"", ""},
     }
     for _, c := range cases {
       got := Reverse(c.in)
       if got != c.want {
         t.Errorf("Reverse(%q) == %q, want %q", c.in, got, c.want)
       }
     }
   }
   #+END_SRC
   
   #+BEGIN_SRC shell
   $ go test github.com/user/stringutil
   ok  	github.com/user/stringutil 0.165s
   # ili samo
   $ go test
   ok  	github.com/user/stringutil 0.165s
   #+END_SRC
   
** Udaljeni paketi (/Remote packages/)
   
   - Import putanja može biti u obliku URL-a do repozitorijuma za kontrolu
     verzija (npr. Git ili Mercurial)
   - =go get= alat će preuzeti kod iz udaljenog repozitorijuma ako nije dostupan
     u lokalnom radnom prostoru (/workspace/)
   - Zavisni paketi dostupni preko udaljenih repozitorijuma se takođe automatski
     preuzimaju
   - Za više informacija videti =go help importpath=


* Go Tour
  
  Interaktivno učenje Go jezika:
  
  - https://tour.golang.org/
  - https://github.com/golang/tour

  Pokretanje lokalno:

  #+BEGIN_SRC
  $ go get golang.org/x/tour
  $ tour
  #+END_SRC

* Paketi, varijable, funkcije
** Paketi
   
   - Svaki Go program se sastoji od paketa
   - Program počinje izvršavanje u paketu =main= i funkciji =func main()=
   #+BEGIN_SRC go
   package main

   import (
     "fmt"
     "math/rand"
   )

   func main() {
     fmt.Println("My favorite number is", rand.Intn(10))
   }
   #+END_SRC
   
   - Paket se referencira po poslednjoj komponenti import putanje (u prethodnom
     primeru =rand=).
     
** =Import= iskaz
   
   - Navođenje paketa koji se koriste u posmatranom fajlu
   - Može se navesti više paketa unutar zagrada (tzv. /factored import/)
   #+BEGIN_SRC go
   package main

   import (
     "fmt"
     "math"
   )

   func main() {
     fmt.Printf("Now you have %g problems.\n", math.Sqrt(7))
   }
   #+END_SRC
   
** Eksportovana imena
   
   Ime je eksportovano iz paketa (odnosno može se importovati u drugim paketima)
   ako počinje velikim slovom.
   
   #+BEGIN_SRC go
   package main

   import (
     "fmt"
     "math"
   )

   func main() {
     fmt.Println(math.pi)  // <-- treba math.Pi
   }
   #+END_SRC
   
   Imenima koji počinju malim slovom ne može se pristupiti izvan paketa u kome
   su definisani.

** Funkcije

   - Funkcije mogu imati nula ili više argumenata
   #+BEGIN_SRC go
   package main

   import "fmt"

   func add(x int, y int) int {
     return x + y
   }

   func main() {
     fmt.Println(add(42, 13))
   }
   #+END_SRC
   
   - Ili kraće
   #+BEGIN_SRC go
   package main

   import "fmt"

   func add(x, y int) int {
     return x + y
   }

   func main() {
     fmt.Println(add(42, 13))
   }
   #+END_SRC


   

** Višestruke povratne vrednosti
   
   - Funkcije mogu vratiti proizvoljan broj rezultata
   #+BEGIN_SRC go
   package main

   import "fmt"

   func swap(x, y string) (string, string) {
     return y, x
   }

   func main() {
     a, b := swap("hello", "world")
     fmt.Println(a, b)
   }
   #+END_SRC

** Imenovane povratne vrednosti
  
   - Povratne vrednosti mogu biti imenovane i u tom slučaju može se koristiti
     =return= iskaz bez argumenata (tzv. /naked return/)
     
   #+BEGIN_SRC go
   package main

   import "fmt"

   func split(sum int) (x, y int) {
     x = sum * 4 / 9
     y = sum - x
     return
   }

   func main() {
     fmt.Println(split(17))
   }
   #+END_SRC

** Varijable
   
   - =var= iskaz definiše varijable. Tip se navodi na kraju
   - =var= iskaz se može koristiti na nivou paketa ili funkcije
 
   #+BEGIN_SRC go
   package main

   import "fmt"

   var c, python, java bool

   func main() {
     var i int
     fmt.Println(i, c, python, java)
   }
   #+END_SRC

** Varijable sa inicijalizatorima
   
   - =var= iskaz može imati inicijalizatore, jedan po varijabli
   - Ako se koristi inicijalizator, tip može da se izostavi jer može da se
     odredi na osnovu inicijalizatora
     
   #+BEGIN_SRC go
   package main

   import "fmt"

   var i, j int = 1, 2

   func main() {
     var c, python, java = true, false, "no!"
     fmt.Println(i, j, c, python, java)
   }
   #+END_SRC

** Kratka deklaracija varijabli
   
   - Unutar funkcija, kraći oblik deklaracije baziran na ~:=~ dodeli može da se
     koristi
     
   #+BEGIN_SRC go
   package main

   import "fmt"

   func main() {
     var i, j int = 1, 2
     k := 3
     c, python, java := true, false, "no!"

     fmt.Println(i, j, k, c, python, java)
   }
   #+END_SRC

   - Ovo nije moguće koristiti van funkcije jer svaki iskaz mora početi sa
     ključnom rečju

** Osnovni tipovi
   
   - Osnovni tipovi u Go-u su:

   #+BEGIN_SRC
   bool

   string

   int  int8  int16  int32  int64
   uint uint8 uint16 uint32 uint64 uintptr

   byte // alias for uint8

   rune // alias for int32
        // represents a Unicode code point

   float32 float64

   complex64 complex128
   #+END_SRC
   
   #+REVEAL: split

   #+BEGIN_SRC go
   package main

   import (
     "fmt"
     "math/cmplx"
   )

   var (
     ToBe   bool       = false
     MaxInt uint64     = 1<<64 - 1
     z      complex128 = cmplx.Sqrt(-5 + 12i)
   )

   func main() {
     fmt.Printf("Type: %T Value: %v\n", ToBe, ToBe)
     fmt.Printf("Type: %T Value: %v\n", MaxInt, MaxInt)
     fmt.Printf("Type: %T Value: %v\n", z, z)
   }
   #+END_SRC
   
   #+BEGIN_SRC
   Type: bool Value: false
   Type: uint64 Value: 18446744073709551615
   Type: complex128 Value: (2+3i)
   #+END_SRC

** Nulte vrednosti
   
   - Varijable deklarisane bez inicijalizatora se inicijalizuju na podrazumevane
     nulte vrednosti:
     - =0= za numeričke tipove
     - =false= za =boolean= tip
     - =""= (prazan string) za =string= tip
 
   #+BEGIN_SRC go
   package main

   import "fmt"

   func main() {
     var i int
     var f float64
     var b bool
     var s string
     fmt.Printf("%v %v %v %q\n", i, f, b, s)
   }
   #+END_SRC
   
   #+BEGIN_SRC
   0 0 false ""
   #+END_SRC

** Konverzija tipova
   
   - Izraz oblika =T(v)= konvertuje vrednost =v= u tip =T=
   - Na primer:
   #+BEGIN_SRC go
   var i int = 42
   var f float64 = float64(i)
   var u uint = uint(f)
   #+END_SRC
   
   - ... ili jednostavnije:
   #+BEGIN_SRC go
   i := 42
   f := float64(i)
   u := uint(f)
   #+END_SRC
   
   - Za razliku od C-a u Go-u dodela između različitih tipova zahteva
     eksplicitnu konverziju
   
   #+BEGIN_SRC go
   package main

   import (
     "fmt"
     "math"
   )

   func main() {
     var x, y int = 3, 4
     var f float64 = math.Sqrt(float64(x*x + y*y))
     var z uint = uint(f)
     fmt.Println(x, y, z)
   }
   #+END_SRC

** Inferencija tipova (/Type inference/)
   
   - Kada je desna strana iskaza dodele (bilo ~:=~ bilo  ~var =~) tipizirana,
     leva strana će biti istog tipa
     
   #+BEGIN_SRC go
   var i int
   j := i // j is an int
   #+END_SRC
   
   - Ali ako je na desnoj strani netipizirana numerička konstanta, tip zavisi od
     preciznosti konstante:

   #+BEGIN_SRC go
   i := 42           // int
   f := 3.142        // float64
   g := 0.867 + 0.5i // complex128
   #+END_SRC

** Konstante
   
   - Deklarisane kao varijable ali upotrebom ključne reči =const=
   - Mogu biti osnovnih tipova
   - Ne mogu se definisati upotrebom ~:=~
   
   #+BEGIN_SRC go
   package main

   import "fmt"

   const Pi = 3.14

   func main() {
     const World = "世界"
     fmt.Println("Hello", World)
     fmt.Println("Happy", Pi, "Day")

     const Truth = true
     fmt.Println("Go rules?", Truth)
   }
   #+END_SRC
   
** Numeričke konstante

   - Vrednosti proizvoljne preciznosti (/arbitrary-precision/)
   - Kod netipiziranih konstanti tip se određuje na osnovu konteksta
   #+BEGIN_SRC go
   package main

   import "fmt"

   const (
     // Create a huge number by shifting a 1 bit left 100 places.
     // In other words, the binary number that is 1 followed by 100 zeroes.
     Big = 1 << 100
     // Shift it right again 99 places, so we end up with 1<<1, or 2.
     Small = Big >> 99
   )

   func needInt(x int) int { return x*10 + 1 }
   func needFloat(x float64) float64 {
     return x * 0.1
   }

   func main() {
     fmt.Println(needInt(Small))
     fmt.Println(needFloat(Small))
     fmt.Println(needFloat(Big))
     fmt.Println(needInt(Big))  // <-- constant overflow
   }
   #+END_SRC
   
   #+REVEAL: split
   
   #+BEGIN_SRC go
   const Huge = 1e1000
   
   # Sledeća linija ne može da se kompajlira
   # Greška je 'constant 1.00000e+1000 overflows float64'
   fmt.Println(Huge)
   
   # Ali ovo radi bez problema jer se kalkulacija obavlja od strane kompajlera
   # u vreme kompajliranja
   fmt.Println(Huge / 1e999)
   #+END_SRC
   
   #+attr_html: :class footer :style clear: both;
   https://blog.golang.org/constants
   
** Enumerisane konstante (=iota=)

   - Kada nam je potrebna enumeracija
   
   #+BEGIN_SRC go
   const (
       CategoryBooks = iota // 0
       CategoryHealth       // 1
       CategoryClothing     // 2
   )
   #+END_SRC
   
   - ili u kombinaciji sa tipom (da bi kompajler mogao da spreči greške sa
     tipovima)
     
   #+BEGIN_SRC go
   type Stereotype int

   const (
       TypicalNoob Stereotype = iota // 0
       TypicalHipster                // 1
       TypicalUnixWizard             // 2
       TypicalStartupFounder         // 3
   )
   #+END_SRC
   
   #+attr_html: :class footer :style clear: both;
   https://splice.com/blog/iota-elegant-constants-golang/

   
   #+REVEAL: split
   
   - Ako želimo da preskočimo vrednosti
   
   #+BEGIN_SRC go
   type AudioOutput int

   const (
       OutMute AudioOutput = iota // 0
       OutMono                    // 1
       OutStereo                  // 2
       _
       _
       OutSurround                // 5
   )
   #+END_SRC
   
   - Možemo kreirati i izraze sa =iota=
   
   #+BEGIN_SRC go
   type Allergen int

   const (
       IgEggs Allergen = 1 << iota // 1 << 0 which is 00000001
       IgChocolate                 // 1 << 1 which is 00000010
       IgNuts                      // 1 << 2 which is 00000100
       IgStrawberries              // 1 << 3 which is 00001000
       IgShellfish                 // 1 << 4 which is 00010000
   )
   #+END_SRC


   
   


   #+attr_html: :class footer :style clear: both;
   https://splice.com/blog/iota-elegant-constants-golang/

* Iskazi kontrole toka: =for=, =if=, =else=, =switch= i =defer=
** =For= iskaz
   
   - Go ima samo jedan iskaz za petlje -- =for=
   - Tri komponente:
     - /init iskaz/ -- izvršava se pre prve iteracije
     - /uslov/ -- evaluira se pre svake iteracije i u zavisnosti od rezultata
       ciklus se izvršava ili se petlja prekida
     - /post iskaz/ -- izvršava se na kraju svake iteracije
     
   #+BEGIN_SRC go
   package main

   import "fmt"

   func main() {
     sum := 0
     for i := 0; i < 10; i++ {
       sum += i
     }
     fmt.Println(sum)
   }
   #+END_SRC
   
   - Zagrade =()= se ne navode kao u nekim drugim jezicima ali je navođenje ={}=
     za telo petlje obavezno
   - Varijable kreirane u /init/ iskazu su dostupne samo unutar petlje
     
   #+REVEAL: split

   - /init/ i /post/ iskazi su opcioni
   
   #+BEGIN_SRC go
   package main

   import "fmt"

   func main() {
     sum := 1
     for ; sum < 1000; {
       sum += sum
     }
     fmt.Println(sum)
   }
   #+END_SRC
   
** =for= je =while= u Go-u
   
   - Kada nemamo /init/ i /post/ iskaz možemo izostaviti =;= i dobijamo
     ekvivalent =while= petlje u drugim jezicima
     
   #+BEGIN_SRC go
   package main

   import "fmt"

   func main() {
     sum := 1
     for sum < 1000 {
       sum += sum
     }
     fmt.Println(sum)
   }
   #+END_SRC
   
** "Beskonačna" petlja
   
   - Ako se izostavi i uslov dobijamo beskonačnu petlju
   
   #+BEGIN_SRC go
   package main

   func main() {
     for {
     }
   }
   #+END_SRC
   
** Uslovi -- =if= iskaz

   - Kao i kod =for= i kod =if= iskaza zagrade nije potrebno navoditi
   
   #+BEGIN_SRC go
   package main

   import (
     "fmt"
     "math"
   )

   func sqrt(x float64) string {
     if x < 0 {
       return sqrt(-x) + "i"
     }
     return fmt.Sprint(math.Sqrt(x))
   }

   func main() {
     fmt.Println(sqrt(2), sqrt(-4))
   }
   #+END_SRC

** =if= sa kratkim iskazom
   
   - Kao i =for= i =if= može da ima kratak iskaz (najčešće ~:=~) koji se
     izvršava pre uslova
   - Varijable deklarisane u ovom iskazu su dostupne samo unutar =if= iskaza
 
   #+BEGIN_SRC go
   package main

   import (
     "fmt"
     "math"
   )

   func pow(x, n, lim float64) float64 {
     if v := math.Pow(x, n); v < lim {
       return v
     }
     return lim
   }

   func main() {
     fmt.Println(
       pow(3, 2, 10),
       pow(3, 3, 20),
     )
   }
   #+END_SRC

** =if= i =else=
   
   - Varijable deklarisane u =if= kratkom iskazu su dostupne i u opcionom =else=
     bloku
     
   #+BEGIN_SRC go
   package main

   import (
     "fmt"
     "math"
   )

   func pow(x, n, lim float64) float64 {
     if v := math.Pow(x, n); v < lim {
       return v
     } else {
       fmt.Printf("%g >= %g\n", v, lim)
     }
     // can't use v here, though
     return lim
   }

   func main() {
     fmt.Println(
       pow(3, 2, 10),
       pow(3, 3, 20),
     )
   }
   #+END_SRC
   
   #+BEGIN_SRC
   27 >= 20
   9 20
   #+END_SRC

** =switch= iskaz
   
   - Kraći način pisanja sekvence =if/else= iskaza. Izvršava prvi =case= blok
     gde je vrednost jednaka vrednošću izraza uslova
   - Može imati kratak iskaz kao i =if=
 
   #+BEGIN_SRC go
   package main

   import (
     "fmt"
     "runtime"
   )

   func main() {
     fmt.Print("Go runs on ")
     switch os := runtime.GOOS; os {
     case "darwin":
       fmt.Println("OS X.")
     case "linux":
       fmt.Println("Linux.")
     default:
       // freebsd, openbsd,
       // plan9, windows...
       fmt.Printf("%s.\n", os)
     }
   }
   #+END_SRC
   
   - Za razliku od drugih jezika izvršava se samo jedan =case= blok (nema
     "propadanja"). Takođe =case= prihvata izraz koji ne mora biti konstanta i
     čija vrenost ne mora biti numerička

** Evaluacija =switch= iskaza
   
   - Evaluacija =case= blokova ide od vrha prema dnu dok se ne nađe prvi blok
     čija vrednost je jednaka zadatom uslovu
   
   - =f()= se ne poziva ako je ~i==0~

   #+BEGIN_SRC go
    switch i {
    case 0:
    case f():
    }
   #+END_SRC
   
   #+BEGIN_SRC go
   package main

   import (
     "fmt"
     "time"
   )

   func main() {
     fmt.Println("When's Saturday?")
     today := time.Now().Weekday()
     switch time.Saturday {
     case today + 0:
       fmt.Println("Today.")
     case today + 1:
       fmt.Println("Tomorrow.")
     case today + 2:
       fmt.Println("In two days.")
     default:
       fmt.Println("Too far away.")
     }
   }
   #+END_SRC

** =switch= bez uslova
   
   - Ekvivalentno sa =switch true=
   - Ćistiji način pisanja dugih if-then-else lanaca
   
   #+BEGIN_SRC go
   package main

   import (
     "fmt"
     "time"
   )

   func main() {
     t := time.Now()
     switch {
     case t.Hour() < 12:
       fmt.Println("Good morning!")
     case t.Hour() < 17:
       fmt.Println("Good afternoon.")
     default:
       fmt.Println("Good evening.")
     }
   }
   #+END_SRC

** =defer= iskaz
   
   - Odlaže izvršavanje funkcije dok se ne vratimo iz funkcije u kojoj se
     nalazimo
   - Parametri funkcije se evaluiraju na mestu poziva =defer= ali se ciljna
     funkcija ne poziva do povratka
     
   #+BEGIN_SRC go
   package main

   import "fmt"

   func main() {
     defer fmt.Println("world")

     fmt.Println("hello")
   }
   #+END_SRC
   
   #+BEGIN_SRC
   hello
   world
   #+END_SRC

** Stekovanje =defer= poziva
   
   - =defer= pozivi se smeštaju na stek i po povratku funcije se izvršavaju u
     LIFO redosledu
     
   #+BEGIN_SRC go
   package main

   import "fmt"

   func main() {
     fmt.Println("counting")

     for i := 0; i < 10; i++ {
       defer fmt.Println(i)
     }

     fmt.Println("done")
   }
   #+END_SRC
   
   #+BEGIN_SRC
   counting
   done
   9
   8
   ...
   #+END_SRC

   - Više detalja možete naći u [[https://blog.golang.org/defer-panic-and-recover][ovom blog post-u]]

* TODO =struct=, =slice= i =map=
* TODO Metode i interfejsi
* TODO Konkurencija
* Reference
  
  - [[https://golang.org/doc/][Go Documentation]]
  - [[https://tour.golang.org/][A Tour of Go]]
  - [[https://golang.org/doc/code.html][How to Write Go Code]]
  - [[https://github.com/golang/go/wiki][The Go Wiki]]
  - [[https://splice.com/blog/iota-elegant-constants-golang/][iota: Elegant Constants in Golang]]
  - [[https://golang.org/doc/effective_go.html][Effective Go]]



