<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<title>Programski jezik Go</title>
<meta name="author" content="Igor Dejanović"/>
<style type="text/css">
.underline { text-decoration: underline; }
</style>
<link rel="stylesheet" href="../../reveal.js/css/reveal.css"/>

<link rel="stylesheet" href="../../reveal.js/css/theme/simple.css" id="theme"/>

<link rel="stylesheet" href="../../reveal-slides.css"/>

<link rel="stylesheet" href="../../highlight-styles/docco.css"/>
<link rel="stylesheet" href=""/>
<!-- If the query includes 'print-pdf', include the PDF print sheet -->
<script>
    if( window.location.search.match( /print-pdf/gi ) ) {
        var link = document.createElement( 'link' );
        link.rel = 'stylesheet';
        link.type = 'text/css';
        link.href = '../../reveal.js/css/print/pdf.css';
        document.getElementsByTagName( 'head' )[0].appendChild( link );
    }
</script>
</head>
<body>
<div class="reveal">
<div class="slides">
<section id="sec-title-slide">
<h1 class="title">Programski jezik Go</h1>
<h2 class="subtitle">U izradi. Bazirano na Go verziji 1.12.4 i <a href="https://tour.golang.org/">A Tour of Go</a></h2>
<h2 class="author">Prof. dr Igor Dejanović (<a href="mailto:igord at uns ac rs">igord at uns ac rs</a>)</h2>
<p class="date">Kreirano 2019-05-14 Tue 20:42, pritisni ESC za mapu</p>
</section>

<section>
<section id="slide-orgea06351">
<h2 id="orgea06351">Uvod</h2>
<div class="outline-text-2" id="text-orgea06351">
</div>
</section>
<section id="slide-orge64a10f">
<h3 id="orge64a10f">Osnovne osobine</h3>
<ul>
<li>Statički tipiziran, kompajliran programski jezik</li>
<li>Google: Robert Griesemer, Rob Pike, i Ken Thompson</li>
<li>Sličan C-u ali sa <i>memory safety</i>, <i>garbage collection</i> i direktnom podrškom
za konkurentno programiranje (<a href="https://en.wikipedia.org/wiki/Communicating_sequential_processes">Communicating Sequential Processes (CSP)</a>)</li>
<li>Efikasnost, jednostavnost i čitkost</li>
<li>Akcenat na mrežnom i <i>multi-core</i> softveru</li>
<li>Razvoj započet 2007, javno dostupan od 2009</li>

</ul>

<p class="footer" style="clear: both;">
<a href="https://en.wikipedia.org/wiki/Go_(programming_language)" class="footer" style="clear: both;">https://en.wikipedia.org/wiki/Go_(programming_language)</a>
</p>

</section>
</section>
<section>
<section id="slide-orga835e69">
<h2 id="orga835e69">Instalacija i podešavanja</h2>
<div class="outline-text-2" id="text-orga835e69">
</div>
</section>
<section id="slide-org2e03f1d">
<h3 id="org2e03f1d">Instalacija</h3>
<ul>
<li>Koristiti instaler za OS</li>
<li>&#x2026;ili raspakovati tarball/zip i podesiti <code>PATH</code> varijablu na <code>go/bin</code> folder</li>
<li><p>
Na primer:
</p>

<div class="org-src-container">

<pre><code class=" bash" >wget https://dl.google.com/go/go$VERSION.$OS-$ARCH.tar.gz
mkdir -p ~/install/go
tar -C ~/install/go -xzf go$VERSION.$OS-$ARCH.tar.gz
</code></pre>
</div></li>

<li>gde je <code>VERSION</code> - tekuća verzija (trenutno 1.12.4), <code>OS</code> - operativni sistem
(npr. <code>linux</code>) a <code>ARCH</code> - arhitektura (npr. <code>amd64</code>)</li>
<li><p>
podesiti <code>PATH</code>:
</p>

<div class="org-src-container">

<pre><code class=" bash" >export PATH=$PATH:~/install/go/
</code></pre>
</div></li>

</ul>

</section>
<section id="slide-org618cd8a">
<h3 id="org618cd8a"><i>Workspace</i> direktorijum</h3>
<ul>
<li>Direktorijum za Go kod</li>
<li>Podrazumevano <code>$HOME/go</code></li>
<li>Ukoliko želite da promenite morate podesiti <code>GOPATH</code> varijablu</li>

</ul>

</section>
<section id="slide-org48531ef">
<h3 id="org48531ef">Testiranje instalacije</h3>
<div class="org-src-container">

<pre><code class=" bash" >$ go version
go version go1.12.4 linux/amd64
</code></pre>
</div>

<ul>
<li>Napraviti <code>src/hello</code> u <i>workspace</i> direktorijumu (dakle <code>~/go/src/hello</code>)</li>
<li><p>
Napraviti fajl <code>hello.go</code> sa sadržajem:
</p>

<div class="org-src-container">

<pre><code class=" go" >package main

import "fmt"

func main() {
  fmt.Printf("Здраво, свете!\n")
}
</code></pre>
</div></li>

<li><p>
Preći u projektni folder, pokrenuti <code>build</code> i zatim startovati program:
</p>

<div class="org-src-container">

<pre><code class=" bash" >$ cd ~/go/src/hello
$ go build
$ ./hello
Здраво, свете!
</code></pre>
</div></li>

</ul>

</section>
</section>
<section>
<section id="slide-org8440de0">
<h2 id="org8440de0">Kako pisati Go kod?</h2>
<div class="outline-text-2" id="text-org8440de0">
</div>
</section>
<section id="slide-orga8e8be2">
<h3 id="orga8e8be2">Uvod</h3>
<p>
Go alati podrazumevaju određene konvencije u organizaciji foldera i
programskog koda.
</p>

<p>
Bazirano na <a href="https://golang.org/doc/code.html">How to Write Go Code</a>
</p>

</section>
<section id="slide-org8ecb5cb">
<h3 id="org8ecb5cb"><i>Workspaces</i></h3>
<ul>
<li>Obično se sav Go kod smešta na jedno mesto koje zovemo <i>workspace</i></li>
<li>Na ovom mestu se nalazi veći broj repozitorijuma pod sistemima za kontrolu
verzija (npr. <code>git</code>).</li>
<li>Svaki repozitorijum se sastoji od jednog ili više paketa</li>
<li>Svaki paket se sastoji od jednog ili više Go fajlova u jednom direktorijumu</li>
<li>Putanja (<i>path</i>) do direktorijuma paketa određuje njegov <i>import path</i></li>

</ul>

</section>
<section id="slide-orgf3fcdec">
<h3 id="orgf3fcdec"><i>Workspaces</i></h3>
<pre  class="example">
bin/
    hello                          # command executable
    outyet                         # command executable
src/
    github.com/golang/example/
        .git/                      # Git repository metadata
  hello/
      hello.go               # command source
  outyet/
      main.go                # command source
      main_test.go           # test source
  stringutil/
      reverse.go             # package source
      reverse_test.go        # test source
    golang.org/x/image/
        .git/                      # Git repository metadata
  bmp/
      reader.go              # package source
      writer.go              # package source
    ... (many more repositories and packages omitted) ...
</pre>


</section>
<section id="slide-org82ca524">
<h3 id="org82ca524"><code>GOPATH</code></h3>
<ul>
<li>Podrazumevano <code>$HOME/go</code> na Unix-like sistemima ili <code>%USERPOFILE%\go</code> na
Windows-u.</li>
<li><code>go env GOPATH</code> komanda daje informaciju o tekućoj lokaciji tj. sadržaj
<code>GOPATH</code> varijable ili podrazumevanu lokaciju ukoliko nije podešena.</li>
<li><p>
Da bi instalirani Go programi bili dostupni:
</p>
<div class="org-src-container">

<pre><code class=" bash" >$ export PATH=$PATH:$(go env GOPATH)/bin
</code></pre>
</div></li>

</ul>

</section>
<section id="slide-org89fcd9a">
<h3 id="org89fcd9a">Import putanja (<i>import path</i>)</h3>
<ul>
<li>Kratke putanje za standardnu biblioteku. Na primer: <code>fmt</code>, <code>net/http</code></li>
<li>Putanja je relativna u odnosu na <code>$GOPATH/src</code></li>
<li>Mora biti jedinstvena</li>
<li><p>
Dobra praksa je upotreba domena VCS hosting sajtova. Na primer:
</p>
<pre  class="example">
$GOPATH/src/github.com/user
</pre></li>

</ul>

</section>
<section id="slide-org249fe51">
<h3 id="org249fe51">Prvi Go program</h3>
<div class="org-src-container">

<pre><code class=" shell" >$ mkdir $GOPATH/src/github.com/user/hello
</code></pre>
</div>

<ul>
<li>Fajl <code>hello.go</code></li>

</ul>
<div class="org-src-container">

<pre><code class=" go" >package main

import "fmt"

func main() {
  fmt.Printf("Здраво, свете!\n")
}
</code></pre>
</div>

<div class="org-src-container">

<pre><code class=" shell" >$ go install github.com/user/hello
# ili
$ cd $GOPATH/src/github.com/user/hello
$ go install
</code></pre>
</div>

<ul>
<li><code>hello</code> program će biti instaliran u <code>$GOPATH/bin/</code></li>

</ul>

<div class="org-src-container">

<pre><code class=" shell" >$ $GOPATH/bin/hello
Здраво, свете!
# ili samo
$ hello
Здраво, свете!
</code></pre>
</div>

</section>
<section>

<ul>
<li>Sledeći korak je da promenu zabeležimo u sistemu za kontrolu verzija:</li>

</ul>
<div class="org-src-container">

<pre><code class=" shell" >$ cd $GOPATH/src/github.com/user/hello
$ git init
Initialized empty Git repository in /home/user/work/src/github.com/user/hello/.git/
$ git add hello.go
$ git commit -m "initial commit"
[master (root-commit) 0b4507d] initial commit
1 file changed, 1 insertion(+)
  create mode 100644 hello.go
</code></pre>
</div>

</section>
<section id="slide-orge1975b1">
<h3 id="orge1975b1">Prva Go biblioteka</h3>
<div class="org-src-container">

<pre><code class=" bash" >$ mkdir $GOPATH/src/github.com/user/stringutil
</code></pre>
</div>

<div class="org-src-container">

<pre><code class=" go" >// Package stringutil contains utility functions for working with strings.
package stringutil

// Reverse returns its argument string reversed rune-wise left to right.
func Reverse(s string) string {
  r := []rune(s)
  for i, j := 0, len(r)-1; i &lt; len(r)/2; i, j = i+1, j-1 {
    r[i], r[j] = r[j], r[i]
  }
  return string(r)
}
</code></pre>
</div>

<ul>
<li>Provera ispravnosti biblioteke</li>

</ul>
<div class="org-src-container">

<pre><code class=" shell" >$ go build github.com/user/stringutil
# ili ako smo već u folderu stringutil
$ go build
</code></pre>
</div>

</section>
<section>

<ul>
<li>Modifikovati program <code>hello.go</code></li>

</ul>

<div class="org-src-container">

<pre><code class=" go" >package main

import (
  "fmt"

  "github.com/user/stringutil"
)

func main() {
  fmt.Println(stringutil.Reverse("!етевс ,овардЗ"))
}
</code></pre>
</div>

<div class="org-src-container">

<pre><code class=" shell" >$ go install github.com/user/hello
$ hello
Здраво, свете!
</code></pre>
</div>


<pre  class="example">
bin/
  hello                 # command executable
src/
    github.com/user/
        hello/
            hello.go      # command source
        stringutil/
            reverse.go    # package source
</pre>



</section>
<section id="slide-orgf4bb8bb">
<h3 id="orgf4bb8bb">Imenovanje paketa</h3>
<ul>
<li><p>
Prvi iskaz u svakom Go fajlu mora biti:
</p>
<div class="org-src-container">

<pre><code class=" go" >package name
</code></pre>
</div></li>
<li>&#x2026;gde je <code>name</code> ime paketa koje se koristi pri <i>import</i>-u</li>
<li>Svi fajlovi koji pripadaju istom paketu moraju koristiti isto ime</li>
<li>Go konvencija je da je ime paketa poslednji element import putanje. Primer:
ukoliko se paket importuje sa <code>crypto/rot13</code> tada njegovo ime treba da bude
<code>rot13</code></li>
<li>Izvršne komande moraju biti u paketu <code>main</code></li>
<li>Ne zahteva se da ime paketa bude jedinstveno kod svih paketa koji se
importuju ali se zahteva da putanja bude</li>

</ul>

</section>
<section id="slide-orgdabbee6">
<h3 id="orgdabbee6">Promena imena pri <i>import</i>-u paketa</h3>
<pre  class="example">
Import declaration          Local name of Sin

import   "lib/math"         math.Sin
import m "lib/math"         m.Sin
import . "lib/math"         Sin
</pre>

<ul>
<li>Import paketa bez upotrebe (zbog <i>side-effect</i>-a)</li>

</ul>

<pre  class="example">
import _ "lib/math"
</pre>


<p class="footer" style="clear: both;">
<a href="https://golang.org/ref/spec#Import_declarations" class="footer" style="clear: both;">https://golang.org/ref/spec#Import_declarations</a>
</p>

</section>
<section id="slide-orgd3ff81b">
<h3 id="orgd3ff81b">Testiranje</h3>
<ul>
<li><i>Lightweight</i> test okvir u paketu <code>testing</code> + <code>go test</code> komanda</li>
<li>Jedinični test se piše u fajlu koji se završava na <code>_test.go</code> i koji sadrži
funkcije oblika <code>TestXXX</code> sa signaturom <code>func (t *testing.T)</code></li>
<li><code>go test</code> poziva sve funkcije i ako ona pozove <code>t.Error</code> ili <code>t.Fail</code> test
se smatra neuspešnim</li>

</ul>

</section>
<section>

<ul>
<li>Fajl <code>$GOPATH/src/github.com/user/stringutil/reverse_test.go</code></li>

</ul>
<div class="org-src-container">

<pre><code class=" go" >package stringutil

import "testing"

func TestReverse(t *testing.T) {
  cases := []struct {
    in, want string
  }{
    {"Hello, world", "dlrow ,olleH"},
    {"Hello, 世界", "界世 ,olleH"},
    {"", ""},
  }
  for _, c := range cases {
    got := Reverse(c.in)
    if got != c.want {
      t.Errorf("Reverse(%q) == %q, want %q", c.in, got, c.want)
    }
  }
}
</code></pre>
</div>

<div class="org-src-container">

<pre><code class=" shell" >$ go test github.com/user/stringutil
ok  	github.com/user/stringutil 0.165s
# ili samo
$ go test
ok  	github.com/user/stringutil 0.165s
</code></pre>
</div>

</section>
<section id="slide-orgd8ec295">
<h3 id="orgd8ec295">Udaljeni paketi (<i>Remote packages</i>)</h3>
<ul>
<li>Import putanja može biti u obliku URL-a do repozitorijuma za kontrolu
verzija (npr. Git ili Mercurial)</li>
<li><code>go get</code> alat će preuzeti kod iz udaljenog repozitorijuma ako nije dostupan
u lokalnom radnom prostoru (<i>workspace</i>)</li>
<li>Zavisni paketi dostupni preko udaljenih repozitorijuma se takođe automatski
preuzimaju</li>
<li>Za više informacija videti <code>go help importpath</code></li>

</ul>

</section>
</section>
<section>
<section id="slide-org5322197">
<h2 id="org5322197">Go Tour</h2>
<p>
Interaktivno učenje Go jezika:
</p>

<ul>
<li><a href="https://tour.golang.org/">https://tour.golang.org/</a></li>
<li><a href="https://github.com/golang/tour">https://github.com/golang/tour</a></li>

</ul>

<p>
Pokretanje lokalno:
</p>

<pre  class="example">
$ go get golang.org/x/tour
$ tour
</pre>

</section>
</section>
<section>
<section id="slide-org28f3696">
<h2 id="org28f3696">Paketi, varijable, funkcije</h2>
<div class="outline-text-2" id="text-org28f3696">
</div>
</section>
<section id="slide-orge0fb40a">
<h3 id="orge0fb40a">Paketi</h3>
<ul>
<li>Svaki Go program se sastoji od paketa</li>
<li>Program počinje izvršavanje u paketu <code>main</code> i funkciji <code>func main()</code></li>

</ul>
<div class="org-src-container">

<pre><code class=" go" >package main

import (
  "fmt"
  "math/rand"
)

func main() {
  fmt.Println("My favorite number is", rand.Intn(10))
}
</code></pre>
</div>

<ul>
<li>Paket se referencira po poslednjoj komponenti import putanje (u prethodnom
primeru <code>rand</code>).</li>

</ul>

</section>
<section id="slide-org05dbd6c">
<h3 id="org05dbd6c"><code>Import</code> iskaz</h3>
<ul>
<li>Navođenje paketa koji se koriste u posmatranom fajlu</li>
<li>Može se navesti više paketa unutar zagrada (tzv. <i>factored import</i>)</li>

</ul>
<div class="org-src-container">

<pre><code class=" go" >package main

import (
  "fmt"
  "math"
)

func main() {
  fmt.Printf("Now you have %g problems.\n", math.Sqrt(7))
}
</code></pre>
</div>

</section>
<section id="slide-org0b37f3d">
<h3 id="org0b37f3d">Eksportovana imena</h3>
<p>
Ime je eksportovano iz paketa (odnosno može se importovati u drugim paketima)
ako počinje velikim slovom.
</p>

<div class="org-src-container">

<pre><code class=" go" >package main

import (
  "fmt"
  "math"
)

func main() {
  fmt.Println(math.pi)  // &lt;-- treba math.Pi
}
</code></pre>
</div>

<p>
Imenima koji počinju malim slovom ne može se pristupiti izvan paketa u kome
su definisani.
</p>

</section>
<section id="slide-org4699ca4">
<h3 id="org4699ca4">Funkcije</h3>
<ul>
<li>Funkcije mogu imati nula ili više argumenata</li>

</ul>
<div class="org-src-container">

<pre><code class=" go" >package main

import "fmt"

func add(x int, y int) int {
  return x + y
}

func main() {
  fmt.Println(add(42, 13))
}
</code></pre>
</div>

<ul>
<li>Ili kraće</li>

</ul>
<div class="org-src-container">

<pre><code class=" go" >package main

import "fmt"

func add(x, y int) int {
  return x + y
}

func main() {
  fmt.Println(add(42, 13))
}
</code></pre>
</div>




</section>
<section id="slide-org586b939">
<h3 id="org586b939">Višestruke povratne vrednosti</h3>
<ul>
<li>Funkcije mogu vratiti proizvoljan broj rezultata</li>

</ul>
<div class="org-src-container">

<pre><code class=" go" >package main

import "fmt"

func swap(x, y string) (string, string) {
  return y, x
}

func main() {
  a, b := swap("hello", "world")
  fmt.Println(a, b)
}
</code></pre>
</div>

</section>
<section id="slide-orge3fb2ab">
<h3 id="orge3fb2ab">Imenovane povratne vrednosti</h3>
<ul>
<li>Povratne vrednosti mogu biti imenovane i u tom slučaju može se koristiti
<code>return</code> iskaz bez argumenata (tzv. <i>naked return</i>)</li>

</ul>

<div class="org-src-container">

<pre><code class=" go" >package main

import "fmt"

func split(sum int) (x, y int) {
  x = sum * 4 / 9
  y = sum - x
  return
}

func main() {
  fmt.Println(split(17))
}
</code></pre>
</div>

</section>
<section id="slide-org08797f3">
<h3 id="org08797f3">Varijable</h3>
<ul>
<li><code>var</code> iskaz definiše varijable. Tip se navodi na kraju</li>
<li><code>var</code> iskaz se može koristiti na nivou paketa ili funkcije</li>

</ul>

<div class="org-src-container">

<pre><code class=" go" >package main

import "fmt"

var c, python, java bool

func main() {
  var i int
  fmt.Println(i, c, python, java)
}
</code></pre>
</div>

</section>
<section id="slide-orgcdd78dc">
<h3 id="orgcdd78dc">Varijable sa inicijalizatorima</h3>
<ul>
<li><code>var</code> iskaz može imati inicijalizatore, jedan po varijabli</li>
<li>Ako se koristi inicijalizator, tip može da se izostavi jer može da se
odredi na osnovu inicijalizatora</li>

</ul>

<div class="org-src-container">

<pre><code class=" go" >package main

import "fmt"

var i, j int = 1, 2

func main() {
  var c, python, java = true, false, "no!"
  fmt.Println(i, j, c, python, java)
}
</code></pre>
</div>

</section>
<section id="slide-org5b19593">
<h3 id="org5b19593">Kratka deklaracija varijabli</h3>
<ul>
<li>Unutar funkcija, kraći oblik deklaracije baziran na <code>:=</code> dodeli može da se
koristi</li>

</ul>

<div class="org-src-container">

<pre><code class=" go" >package main

import "fmt"

func main() {
  var i, j int = 1, 2
  k := 3
  c, python, java := true, false, "no!"

  fmt.Println(i, j, k, c, python, java)
}
</code></pre>
</div>

<ul>
<li>Ovo nije moguće koristiti van funkcije jer svaki iskaz mora početi sa
ključnom rečju</li>

</ul>

</section>
<section id="slide-org035a4e9">
<h3 id="org035a4e9">Osnovni tipovi</h3>
<ul>
<li>Osnovni tipovi u Go-u su:</li>

</ul>

<pre  class="example">
bool

string

int  int8  int16  int32  int64
uint uint8 uint16 uint32 uint64 uintptr

byte // alias for uint8

rune // alias for int32
     // represents a Unicode code point

float32 float64

complex64 complex128
</pre>

</section>
<section>

<div class="org-src-container">

<pre><code class=" go" >package main

import (
  "fmt"
  "math/cmplx"
)

var (
  ToBe   bool       = false
  MaxInt uint64     = 1&lt;&lt;64 - 1
  z      complex128 = cmplx.Sqrt(-5 + 12i)
)

func main() {
  fmt.Printf("Type: %T Value: %v\n", ToBe, ToBe)
  fmt.Printf("Type: %T Value: %v\n", MaxInt, MaxInt)
  fmt.Printf("Type: %T Value: %v\n", z, z)
}
</code></pre>
</div>

<pre  class="example">
Type: bool Value: false
Type: uint64 Value: 18446744073709551615
Type: complex128 Value: (2+3i)
</pre>

</section>
<section id="slide-orgcf6b487">
<h3 id="orgcf6b487">Nulte vrednosti</h3>
<ul>
<li>Varijable deklarisane bez inicijalizatora se inicijalizuju na podrazumevane
nulte vrednosti:
<ul>
<li><code>0</code> za numeričke tipove</li>
<li><code>false</code> za <code>boolean</code> tip</li>
<li><code>""</code> (prazan string) za <code>string</code> tip</li>

</ul></li>

</ul>

<div class="org-src-container">

<pre><code class=" go" >package main

import "fmt"

func main() {
  var i int
  var f float64
  var b bool
  var s string
  fmt.Printf("%v %v %v %q\n", i, f, b, s)
}
</code></pre>
</div>

<pre  class="example">
0 0 false ""
</pre>

</section>
<section id="slide-org7ff2932">
<h3 id="org7ff2932">Konverzija tipova</h3>
<ul>
<li>Izraz oblika <code>T(v)</code> konvertuje vrednost <code>v</code> u tip <code>T</code></li>
<li>Na primer:</li>

</ul>
<div class="org-src-container">

<pre><code class=" go" >var i int = 42
var f float64 = float64(i)
var u uint = uint(f)
</code></pre>
</div>

<ul>
<li>&#x2026; ili jednostavnije:</li>

</ul>
<div class="org-src-container">

<pre><code class=" go" >i := 42
f := float64(i)
u := uint(f)
</code></pre>
</div>

<ul>
<li>Za razliku od C-a u Go-u dodela između različitih tipova zahteva
eksplicitnu konverziju</li>

</ul>

<div class="org-src-container">

<pre><code class=" go" >package main

import (
  "fmt"
  "math"
)

func main() {
  var x, y int = 3, 4
  var f float64 = math.Sqrt(float64(x*x + y*y))
  var z uint = uint(f)
  fmt.Println(x, y, z)
}
</code></pre>
</div>

</section>
<section id="slide-orgb450bad">
<h3 id="orgb450bad">Inferencija tipova (<i>Type inference</i>)</h3>
<ul>
<li>Kada je desna strana iskaza dodele (bilo <code>:=</code> bilo  <code>var =</code>) tipizirana,
leva strana će biti istog tipa</li>

</ul>

<div class="org-src-container">

<pre><code class=" go" >var i int
j := i // j is an int
</code></pre>
</div>

<ul>
<li>Ali ako je na desnoj strani netipizirana numerička konstanta, tip zavisi od
preciznosti konstante:</li>

</ul>

<div class="org-src-container">

<pre><code class=" go" >i := 42           // int
f := 3.142        // float64
g := 0.867 + 0.5i // complex128
</code></pre>
</div>

</section>
<section id="slide-org02ce787">
<h3 id="org02ce787">Konstante</h3>
<ul>
<li>Deklarisane kao varijable ali upotrebom ključne reči <code>const</code></li>
<li>Mogu biti osnovnih tipova</li>
<li>Ne mogu se definisati upotrebom <code>:=</code></li>

</ul>

<div class="org-src-container">

<pre><code class=" go" >package main

import "fmt"

const Pi = 3.14

func main() {
  const World = "世界"
  fmt.Println("Hello", World)
  fmt.Println("Happy", Pi, "Day")

  const Truth = true
  fmt.Println("Go rules?", Truth)
}
</code></pre>
</div>

</section>
<section id="slide-org802955a">
<h3 id="org802955a">Numeričke konstante</h3>
<ul>
<li>Vrednosti proizvoljne preciznosti (<i>arbitrary-precision</i>)</li>
<li>Kod netipiziranih konstanti tip se određuje na osnovu konteksta</li>

</ul>
<div class="org-src-container">

<pre><code class=" go" >package main

import "fmt"

const (
  // Create a huge number by shifting a 1 bit left 100 places.
  // In other words, the binary number that is 1 followed by 100 zeroes.
  Big = 1 &lt;&lt; 100
  // Shift it right again 99 places, so we end up with 1&lt;&lt;1, or 2.
  Small = Big &gt;&gt; 99
)

func needInt(x int) int { return x*10 + 1 }
func needFloat(x float64) float64 {
  return x * 0.1
}

func main() {
  fmt.Println(needInt(Small))
  fmt.Println(needFloat(Small))
  fmt.Println(needFloat(Big))
  fmt.Println(needInt(Big))  // &lt;-- constant overflow
}
</code></pre>
</div>

</section>
<section>

<div class="org-src-container">

<pre><code class=" go" >const Huge = 1e1000

# Sledeća linija ne može da se kompajlira
# Greška je 'constant 1.00000e+1000 overflows float64'
fmt.Println(Huge)

# Ali ovo radi bez problema jer se kalkulacija obavlja od strane kompajlera
# u vreme kompajliranja
fmt.Println(Huge / 1e999)
</code></pre>
</div>

<p class="footer" style="clear: both;">
<a href="https://blog.golang.org/constants" class="footer" style="clear: both;">https://blog.golang.org/constants</a>
</p>

</section>
<section id="slide-orgdc54622">
<h3 id="orgdc54622">Enumerisane konstante (<code>iota</code>)</h3>
<ul>
<li>Kada nam je potrebna enumeracija</li>

</ul>

<div class="org-src-container">

<pre><code class=" go" >const (
    CategoryBooks = iota // 0
    CategoryHealth       // 1
    CategoryClothing     // 2
)
</code></pre>
</div>

<ul>
<li>ili u kombinaciji sa tipom (da bi kompajler mogao da spreči greške sa
tipovima)</li>

</ul>

<div class="org-src-container">

<pre><code class=" go" >type Stereotype int

const (
    TypicalNoob Stereotype = iota // 0
    TypicalHipster                // 1
    TypicalUnixWizard             // 2
    TypicalStartupFounder         // 3
)
</code></pre>
</div>

<p class="footer" style="clear: both;">
<a href="https://splice.com/blog/iota-elegant-constants-golang/" class="footer" style="clear: both;">https://splice.com/blog/iota-elegant-constants-golang/</a>
</p>


</section>
<section>

<ul>
<li>Ako želimo da preskočimo vrednosti</li>

</ul>

<div class="org-src-container">

<pre><code class=" go" >type AudioOutput int

const (
    OutMute AudioOutput = iota // 0
    OutMono                    // 1
    OutStereo                  // 2
    _
    _
    OutSurround                // 5
)
</code></pre>
</div>

<ul>
<li>Možemo kreirati i izraze sa <code>iota</code></li>

</ul>

<div class="org-src-container">

<pre><code class=" go" >type Allergen int

const (
    IgEggs Allergen = 1 &lt;&lt; iota // 1 &lt;&lt; 0 which is 00000001
    IgChocolate                 // 1 &lt;&lt; 1 which is 00000010
    IgNuts                      // 1 &lt;&lt; 2 which is 00000100
    IgStrawberries              // 1 &lt;&lt; 3 which is 00001000
    IgShellfish                 // 1 &lt;&lt; 4 which is 00010000
)
</code></pre>
</div>






<p class="footer" style="clear: both;">
<a href="https://splice.com/blog/iota-elegant-constants-golang/" class="footer" style="clear: both;">https://splice.com/blog/iota-elegant-constants-golang/</a>
</p>

</section>
</section>
<section>
<section id="slide-org7a6fea5">
<h2 id="org7a6fea5">Iskazi kontrole toka: <code>for</code>, <code>if</code>, <code>else</code>, <code>switch</code> i <code>defer</code></h2>
<div class="outline-text-2" id="text-org7a6fea5">
</div>
</section>
<section id="slide-orge8fa3bb">
<h3 id="orge8fa3bb"><code>For</code> iskaz</h3>
<ul>
<li>Go ima samo jedan iskaz za petlje &#x2013; <code>for</code></li>
<li>Tri komponente:
<ul>
<li><i>init iskaz</i> &#x2013; izvršava se pre prve iteracije</li>
<li><i>uslov</i> &#x2013; evaluira se pre svake iteracije i u zavisnosti od rezultata
ciklus se izvršava ili se petlja prekida</li>
<li><i>post iskaz</i> &#x2013; izvršava se na kraju svake iteracije</li>

</ul></li>

</ul>

<div class="org-src-container">

<pre><code class=" go" >package main

import "fmt"

func main() {
  sum := 0
  for i := 0; i &lt; 10; i++ {
    sum += i
  }
  fmt.Println(sum)
}
</code></pre>
</div>

<ul>
<li>Zagrade <code>()</code> se ne navode kao u nekim drugim jezicima ali je navođenje <code>{}</code>
za telo petlje obavezno</li>
<li>Varijable kreirane u <i>init</i> iskazu su dostupne samo unutar petlje</li>

</ul>

</section>
<section>

<ul>
<li><i>init</i> i <i>post</i> iskazi su opcioni</li>

</ul>

<div class="org-src-container">

<pre><code class=" go" >package main

import "fmt"

func main() {
  sum := 1
  for ; sum &lt; 1000; {
    sum += sum
  }
  fmt.Println(sum)
}
</code></pre>
</div>

</section>
<section id="slide-org3cb02fc">
<h3 id="org3cb02fc"><code>for</code> je <code>while</code> u Go-u</h3>
<ul>
<li>Kada nemamo <i>init</i> i <i>post</i> iskaz možemo izostaviti <code>;</code> i dobijamo
ekvivalent <code>while</code> petlje u drugim jezicima</li>

</ul>

<div class="org-src-container">

<pre><code class=" go" >package main

import "fmt"

func main() {
  sum := 1
  for sum &lt; 1000 {
    sum += sum
  }
  fmt.Println(sum)
}
</code></pre>
</div>

</section>
<section id="slide-org955931e">
<h3 id="org955931e">"Beskonačna" petlja</h3>
<ul>
<li>Ako se izostavi i uslov dobijamo beskonačnu petlju</li>

</ul>

<div class="org-src-container">

<pre><code class=" go" >package main

func main() {
  for {
  }
}
</code></pre>
</div>

</section>
<section id="slide-org74b3077">
<h3 id="org74b3077">Uslovi &#x2013; <code>if</code> iskaz</h3>
<ul>
<li>Kao i kod <code>for</code> i kod <code>if</code> iskaza zagrade nije potrebno navoditi</li>

</ul>

<div class="org-src-container">

<pre><code class=" go" >package main

import (
  "fmt"
  "math"
)

func sqrt(x float64) string {
  if x &lt; 0 {
    return sqrt(-x) + "i"
  }
  return fmt.Sprint(math.Sqrt(x))
}

func main() {
  fmt.Println(sqrt(2), sqrt(-4))
}
</code></pre>
</div>

</section>
<section id="slide-orgcefd55a">
<h3 id="orgcefd55a"><code>if</code> sa kratkim iskazom</h3>
<ul>
<li>Kao i <code>for</code> i <code>if</code> može da ima kratak iskaz (najčešće <code>:=</code>) koji se
izvršava pre uslova</li>
<li>Varijable deklarisane u ovom iskazu su dostupne samo unutar <code>if</code> iskaza</li>

</ul>

<div class="org-src-container">

<pre><code class=" go" >package main

import (
  "fmt"
  "math"
)

func pow(x, n, lim float64) float64 {
  if v := math.Pow(x, n); v &lt; lim {
    return v
  }
  return lim
}

func main() {
  fmt.Println(
    pow(3, 2, 10),
    pow(3, 3, 20),
  )
}
</code></pre>
</div>

</section>
<section id="slide-org5747d99">
<h3 id="org5747d99"><code>if</code> i <code>else</code></h3>
<ul>
<li>Varijable deklarisane u <code>if</code> kratkom iskazu su dostupne i u opcionom <code>else</code>
bloku</li>

</ul>

<div class="org-src-container">

<pre><code class=" go" >package main

import (
  "fmt"
  "math"
)

func pow(x, n, lim float64) float64 {
  if v := math.Pow(x, n); v &lt; lim {
    return v
  } else {
    fmt.Printf("%g &gt;= %g\n", v, lim)
  }
  // can't use v here, though
  return lim
}

func main() {
  fmt.Println(
    pow(3, 2, 10),
    pow(3, 3, 20),
  )
}
</code></pre>
</div>

<pre  class="example">
27 &gt;= 20
9 20
</pre>

</section>
<section id="slide-org08520ef">
<h3 id="org08520ef"><code>switch</code> iskaz</h3>
<ul>
<li>Kraći način pisanja sekvence <code>if/else</code> iskaza. Izvršava prvi <code>case</code> blok
gde je vrednost jednaka vrednošću izraza uslova</li>
<li>Može imati kratak iskaz kao i <code>if</code></li>

</ul>

<div class="org-src-container">

<pre><code class=" go" >package main

import (
  "fmt"
  "runtime"
)

func main() {
  fmt.Print("Go runs on ")
  switch os := runtime.GOOS; os {
  case "darwin":
    fmt.Println("OS X.")
  case "linux":
    fmt.Println("Linux.")
  default:
    // freebsd, openbsd,
    // plan9, windows...
    fmt.Printf("%s.\n", os)
  }
}
</code></pre>
</div>

<ul>
<li>Za razliku od drugih jezika izvršava se samo jedan <code>case</code> blok (nema
"propadanja"). Takođe <code>case</code> prihvata izraz koji ne mora biti konstanta i
čija vrenost ne mora biti numerička</li>

</ul>

</section>
<section id="slide-org8a96811">
<h3 id="org8a96811">Evaluacija <code>switch</code> iskaza</h3>
<ul>
<li>Evaluacija <code>case</code> blokova ide od vrha prema dnu dok se ne nađe prvi blok
čija vrednost je jednaka zadatom uslovu</li>

<li><code>f()</code> se ne poziva ako je <code>i==0</code></li>

</ul>

<div class="org-src-container">

<pre><code class=" go" >switch i {
case 0:
case f():
}
</code></pre>
</div>

<div class="org-src-container">

<pre><code class=" go" >package main

import (
  "fmt"
  "time"
)

func main() {
  fmt.Println("When's Saturday?")
  today := time.Now().Weekday()
  switch time.Saturday {
  case today + 0:
    fmt.Println("Today.")
  case today + 1:
    fmt.Println("Tomorrow.")
  case today + 2:
    fmt.Println("In two days.")
  default:
    fmt.Println("Too far away.")
  }
}
</code></pre>
</div>

</section>
<section id="slide-org1866e53">
<h3 id="org1866e53"><code>switch</code> bez uslova</h3>
<ul>
<li>Ekvivalentno sa <code>switch true</code></li>
<li>Ćistiji način pisanja dugih if-then-else lanaca</li>

</ul>

<div class="org-src-container">

<pre><code class=" go" >package main

import (
  "fmt"
  "time"
)

func main() {
  t := time.Now()
  switch {
  case t.Hour() &lt; 12:
    fmt.Println("Good morning!")
  case t.Hour() &lt; 17:
    fmt.Println("Good afternoon.")
  default:
    fmt.Println("Good evening.")
  }
}
</code></pre>
</div>

</section>
<section id="slide-orgd1a404d">
<h3 id="orgd1a404d"><code>defer</code> iskaz</h3>
<ul>
<li>Odlaže izvršavanje funkcije dok se ne vratimo iz funkcije u kojoj se
nalazimo</li>
<li>Parametri funkcije se evaluiraju na mestu poziva <code>defer</code> ali se ciljna
funkcija ne poziva do povratka</li>

</ul>

<div class="org-src-container">

<pre><code class=" go" >package main

import "fmt"

func main() {
  defer fmt.Println("world")

  fmt.Println("hello")
}
</code></pre>
</div>

<pre  class="example">
hello
world
</pre>

</section>
<section id="slide-org4990b1b">
<h3 id="org4990b1b">Stekovanje <code>defer</code> poziva</h3>
<ul>
<li><code>defer</code> pozivi se smeštaju na stek i po povratku funcije se izvršavaju u
LIFO redosledu</li>

</ul>

<div class="org-src-container">

<pre><code class=" go" >package main

import "fmt"

func main() {
  fmt.Println("counting")

  for i := 0; i &lt; 10; i++ {
    defer fmt.Println(i)
  }

  fmt.Println("done")
}
</code></pre>
</div>

<pre  class="example">
counting
done
9
8
...
</pre>

<ul>
<li>Više detalja možete naći u <a href="https://blog.golang.org/defer-panic-and-recover">ovom blog post-u</a></li>

</ul>

</section>
</section>
<section>
<section id="slide-org0af3ed7">
<h2 id="org0af3ed7"><code>struct</code>, <code>slice</code> i <code>map</code></h2>
<div class="outline-text-2" id="text-org0af3ed7">
</div>
</section>
<section id="slide-orgdd9ceff">
<h3 id="orgdd9ceff">Pokazivači (<code>Pointers</code>)</h3>
<ul>
<li>Memorijska adresa vrednosti varijable</li>
<li><code>*T</code> je pokazivač na vrednost tipa <code>T</code></li>
<li><p>
<code>&amp;</code> operator vraća pokazivač na zadati argument/vrednost
</p>

<div class="org-src-container">

<pre><code class=" go" >i := 42
p = &amp;i  // p je pokazivač na vrednost 42
</code></pre>
</div></li>

<li><p>
<code>*</code> operator označava vrednost na koju pokazivač pokazuje
</p>

<div class="org-src-container">

<pre><code class=" go" >fmt.Println(*p) // čitanje i vrednosti kroz pokazivač p
*p = 21         // postavljanje i vrednosti kroz pokazivač p
</code></pre>
</div>

<ul>
<li>Ovo se još naziva i <i>dereferenciranje</i> ili <i>indirekcija</i></li>
<li>Za razliku od jezika C, Go nema pokazivačku aritmetiku</li>

</ul></li>

</ul>

</section>
<section>

<div class="org-src-container">

<pre><code class=" go" >package main

import "fmt"

func main() {
  i, j := 42, 2701

  p := &amp;i         // point to i
  fmt.Println(*p) // read i through the pointer
  *p = 21         // set i through the pointer
  fmt.Println(i)  // see the new value of i

  p = &amp;j         // point to j
  *p = *p / 37   // divide j through the pointer
  fmt.Println(j) // see the new value of j
}
</code></pre>
</div>

</section>
<section id="slide-org0735095">
<h3 id="org0735095">Strukture (<code>struct</code>)</h3>
<ul>
<li>Kolekcija polja</li>

</ul>

<div class="org-src-container">

<pre><code class=" go" >package main

import "fmt"

type Vertex struct {
  X int
  Y int
}

func main() {
  fmt.Println(Vertex{1, 2})
}
</code></pre>
</div>

</section>
<section>

<ul>
<li>Poljima se pristupa upotrebom <code>.</code> operatora</li>

</ul>

<div class="org-src-container">

<pre><code class=" go" >package main

import "fmt"

type Vertex struct {
  X int
  Y int
}

func main() {
  v := Vertex{1, 2}
  v.X = 4
  fmt.Println(v.X)
}
</code></pre>
</div>

</section>
<section id="slide-org769601b">
<h3 id="org769601b">Pokazivači na strukture</h3>
<ul>
<li>Poljima strukture se može pristupiti preko pokazivača na strukturu</li>
<li>Sintaksno, ako imamo pokazivač <code>p</code> na strukturu, polju <code>X</code> bi mogli
pristupiti sa <code>(*p).X</code></li>
<li><p>
Pošto je ovakva sintaksa teža za korišćenje uvedena je prečica <code>p.X</code> tj.
nije potrebno eksplicitno dereferenciranje
</p>

<div class="org-src-container">

<pre><code class=" go" >package main

import "fmt"

type Vertex struct {
  X int
  Y int
}

func main() {
  v := Vertex{1, 2}
  p := &amp;v
  p.X = 1e9
  fmt.Println(v)
}
</code></pre>
</div></li>

</ul>

</section>
<section id="slide-orgd8ae4cd">
<h3 id="orgd8ae4cd"><code>struct</code> literali</h3>
<ul>
<li>Kreiranje strukture listanjem vrednosti njenih polja</li>
<li>Moguće je koristiti sintaksu <code>Name:</code> za postavljanje vrednosti polja i u
tom slučaju redosled je irelevantan</li>
<li>Ukoliko se koristi operator <code>&amp;</code> vraća se pokazivač na strukturu</li>

</ul>

<div class="org-src-container">

<pre><code class=" go" >package main

import "fmt"

type Vertex struct {
  X, Y int
}

var (
  v1 = Vertex{1, 2}  // has type Vertex
  v2 = Vertex{X: 1}  // Y:0 is implicit
  v3 = Vertex{}      // X:0 and Y:0
  p  = &amp;Vertex{1, 2} // has type *Vertex
)

func main() {
  fmt.Println(v1, p, v2, v3)
}
</code></pre>
</div>

</section>
<section id="slide-org6de47d4">
<h3 id="org6de47d4">Nizovi (<code>Arrays</code>)</h3>
<ul>
<li><code>[n]T</code> &#x2013; niz od <code>n</code> elemenata tipa <code>T</code></li>
<li><code>var a [10]int</code> &#x2013; niz od 10 elemenata tipa <code>int</code></li>
<li>Nizovi su fiksne veličine</li>

</ul>

<div class="org-src-container">

<pre><code class=" go" >package main

import "fmt"

func main() {
  var a [2]string
  a[0] = "Hello"
  a[1] = "World"
  fmt.Println(a[0], a[1])
  fmt.Println(a)

  primes := [6]int{2, 3, 5, 7, 11, 13}
  fmt.Println(primes)
}
</code></pre>
</div>

</section>
<section id="slide-orga1f7abe">
<h3 id="orga1f7abe">Isečci (<code>Slices</code>)</h3>
<ul>
<li>Niz je fiksne dužine</li>
<li>Isečak je "prozor" na niz koji ima dinamičku veličinu</li>
<li><code>[]T</code> &#x2013; isečak tipa <code>T</code></li>
<li><p>
Isečak se formira iznad niza na sledeći način:
</p>

<div class="org-src-container">

<pre><code class=" go" >a[low : high]
</code></pre>
</div></li>

<li><p>
Ovo formira polu-otvoren interval elemenata uključujući prvi ali
isključujući poslednji
</p>

<div class="org-src-container">

<pre><code class=" go" >package main

import "fmt"

func main() {
  primes := [6]int{2, 3, 5, 7, 11, 13}

  var s []int = primes[1:4]
  fmt.Println(s)
}
</code></pre>
</div></li>

</ul>

</section>
<section id="slide-orgf97294d">
<h3 id="orgf97294d">Isečci kao pokazivači</h3>
<ul>
<li>Isečci se ponašaju kao pokazivači na nizove ispod njih</li>
<li>Izmena elementa kroz isečak menja elemente niza</li>

</ul>

<div class="org-src-container">

<pre><code class=" go" >package main

import "fmt"

func main() {
  names := [4]string{
    "John",
    "Paul",
    "George",
    "Ringo",
  }
  fmt.Println(names)

  a := names[0:2]
  b := names[1:3]
  fmt.Println(a, b)

  b[0] = "XXX"
  fmt.Println(a, b)
  fmt.Println(names)
}
</code></pre>
</div>

<pre  class="example">
[John Paul George Ringo]
[John Paul] [Paul George]
[John XXX] [XXX George]
[John XXX George Ringo]
</pre>

</section>
<section id="slide-org7cb9f40">
<h3 id="org7cb9f40">Literali za isečke</h3>
<div class="org-src-container">

<pre><code class=" go" >[3]bool{true, true, false}
</code></pre>
</div>

<div class="org-src-container">

<pre><code class=" go" >[]bool{true, true, false}
</code></pre>
</div>

<div class="org-src-container">

<pre><code class=" go" >package main

import "fmt"

func main() {
  q := []int{2, 3, 5, 7, 11, 13}
  fmt.Println(q)

  r := []bool{true, false, true, true, false, true}
  fmt.Println(r)

  s := []struct {
    i int
    b bool
  }{
    {2, true},
    {3, false},
    {5, true},
    {7, true},
    {11, false},
    {13, true},
  }
  fmt.Println(s)
}
</code></pre>
</div>

</section>
<section id="slide-orgb794b86">
<h3 id="orgb794b86">Podrazumevane granice intervala</h3>
<ul>
<li>Kada se kreira isečak niza moguće je izostaviti bilo koju granicu.</li>
<li>Podrazumevana donja granica je <code>0</code></li>
<li>Podrazumevana gornja granica je dužina niza</li>
<li><p>
Ekvivalentni izrazi:
</p>

<div class="org-src-container">

<pre><code class=" go" >a[0:10]
a[:10]
a[0:]
a[:]
</code></pre>
</div></li>

</ul>

</section>
<section>

<div class="org-src-container">

<pre><code class=" go" >package main

import "fmt"

func main() {
  s := []int{2, 3, 5, 7, 11, 13}

  s = s[1:4]
  fmt.Println(s)

  s = s[:2]
  fmt.Println(s)

  s = s[1:]
  fmt.Println(s)
}
</code></pre>
</div>

<pre  class="example">
[3 5 7]
[3 5]
[5]
</pre>

</section>
<section id="slide-org495f8dd">
<h3 id="org495f8dd">Dužina i kapacitet isečka</h3>
<ul>
<li>Isečak ima <i>dužinu</i> i <i>kapacitet</i></li>
<li>Dužina je broj elemenata isečka. Kapacitet je broj elemenata počevši od
prvog elementa isečka do poslednjeg elementa potpornog niza.</li>
<li>dužina i kapacitet isečka <code>s</code>: <code>len(s)</code>, <code>cap(s)</code></li>
<li>Dužina isečka se može povećati ponovnim isecanjem (<i>reslicing</i>) u skladu sa
kapacitetom</li>

</ul>

</section>
<section>

<div class="org-src-container">

<pre><code class=" go" >package main

import "fmt"

func main() {
  s := []int{2, 3, 5, 7, 11, 13}
  printSlice(s)

  // Slice the slice to give it zero length.
  s = s[:0]
  printSlice(s)

  // Extend its length.
  s = s[:4]
  printSlice(s)

  // Drop its first two values.
  s = s[2:]
  printSlice(s)
}

func printSlice(s []int) {
  fmt.Printf("len=%d cap=%d %v\n", len(s), cap(s), s)
}
</code></pre>
</div>

<pre  class="example">
len=6 cap=6 [2 3 5 7 11 13]
len=0 cap=6 []
len=4 cap=6 [2 3 5 7]
len=2 cap=4 [5 7]
</pre>


</section>
<section id="slide-org2c3b6ee">
<h3 id="org2c3b6ee">Prazni (<i>nil</i>) isečci</h3>
<ul>
<li><i>Nula</i> vrednost za isečak je <code>nil</code></li>
<li>Ovakav isečak ima dužinu i kapacitet <code>0</code> i nema potporni niz</li>

</ul>

<div class="org-src-container">

<pre><code class=" go" >package main

import "fmt"

func main() {
  var s []int
  fmt.Println(s, len(s), cap(s))
  if s == nil {
    fmt.Println("nil!")
  }
}
</code></pre>
</div>

<pre  class="example">
[] 0 0
nil!
</pre>

</section>
<section id="slide-orga14e89a">
<h3 id="orga14e89a">Kreiranje isečaka sa <code>make</code></h3>
<ul>
<li><p>
<code>make</code> funkcija alocira niz sa nultim vrednostima i vraća njegov isečak
</p>

<div class="org-src-container">

<pre><code class=" go" >a := make([]int, 5)  // len(a)=5
</code></pre>
</div></li>

<li><p>
moguće je definisati i kapacitet
</p>

<div class="org-src-container">

<pre><code class=" go" > b := make([]int, 0, 5) // len(b)=0, cap(b)=5

b = b[:cap(b)] // len(b)=5, cap(b)=5
b = b[1:]      // len(b)=4, cap(b)=4
</code></pre>
</div></li>

</ul>

</section>
<section>

<div class="org-src-container">

<pre><code class=" go" >package main

import "fmt"

func main() {
  a := make([]int, 5)
  printSlice("a", a)

  b := make([]int, 0, 5)
  printSlice("b", b)

  c := b[:2]
  printSlice("c", c)

  d := c[2:5]
  printSlice("d", d)
}

func printSlice(s string, x []int) {
  fmt.Printf("%s len=%d cap=%d %v\n",
    s, len(x), cap(x), x)
}
</code></pre>
</div>

<pre  class="example">
a len=5 cap=5 [0 0 0 0 0]
b len=0 cap=5 []
c len=2 cap=5 [0 0]
d len=3 cap=3 [0 0 0]
</pre>

</section>
<section id="slide-org23fd423">
<h3 id="org23fd423">Isečak isečaka</h3>
<ul>
<li>Isečak može da sadrži bilo koji tip, uključujući i druge isečke</li>

</ul>

<div class="org-src-container">

<pre><code class=" go" >package main

import (
  "fmt"
  "strings"
)

func main() {
  // Create a tic-tac-toe board.
  board := [][]string{
    []string{"_", "_", "_"},
    []string{"_", "_", "_"},
    []string{"_", "_", "_"},
  }

  // The players take turns.
  board[0][0] = "X"
  board[2][2] = "O"
  board[1][2] = "X"
  board[1][0] = "O"
  board[0][2] = "X"

  for i := 0; i &lt; len(board); i++ {
    fmt.Printf("%s\n", strings.Join(board[i], " "))
  }
}
</code></pre>
</div>

</section>
<section id="slide-org8bae869">
<h3 id="org8bae869">Dodavanje na isečak</h3>
<div class="org-src-container">

<pre><code class=" go" >func append(s []T, vs ...T) []T
</code></pre>
</div>

<ul>
<li>Prvi parametar je isečak, ostali su vrednosti koje se dodaju</li>
<li>Povratna vrednost je novi isečak koji sadrži nove elemente</li>
<li>Ako potporni niz nema dovoljan kapacitet alocira se novi</li>

</ul>

</section>
<section>

<div class="org-src-container">

<pre><code class=" go" >package main

import "fmt"

func main() {
  var s []int
  printSlice(s)

  // append works on nil slices.
  s = append(s, 0)
  printSlice(s)

  // The slice grows as needed.
  s = append(s, 1)
  printSlice(s)

  // We can add more than one element at a time.
  s = append(s, 2, 3, 4)
  printSlice(s)
}

func printSlice(s []int) {
  fmt.Printf("len=%d cap=%d %v\n", len(s), cap(s), s)
}
</code></pre>
</div>

<pre  class="example">
len=0 cap=0 []
len=1 cap=1 [0]
len=2 cap=2 [0 1]
len=5 cap=6 [0 1 2 3 4]
</pre>

</section>
<section id="slide-orgddce3af">
<h3 id="orgddce3af"><code>range</code></h3>
<ul>
<li><code>range</code> forma <code>for</code> petlje iterira kroz elemente isečaka ili mape</li>

</ul>

<div class="org-src-container">

<pre><code class=" go" >package main

import "fmt"

var pow = []int{1, 2, 4, 8, 16, 32, 64, 128}

func main() {
  for i, v := range pow {
    fmt.Printf("2**%d = %d\n", i, v)
  }
}
</code></pre>
</div>

</section>
<section>

<ul>
<li><p>
Ukoliko ne koristite indeks pri iteraciji moguće ga je ignorisati
upotrebom specijalnog imena <code>_</code>
</p>

<div class="org-src-container">

<pre><code class=" go" >for i, _ := range pow
for _, value := range pow
</code></pre>
</div></li>

<li><p>
Ako vam treba samo indeks možete izostaviti drugu varijablu:
</p>

<div class="org-src-container">

<pre><code class=" go" >for i := range pow
</code></pre>
</div>

<div class="org-src-container">

<pre><code class=" go" >package main

import "fmt"

func main() {
  pow := make([]int, 10)
  for i := range pow {
    pow[i] = 1 &lt;&lt; uint(i) // == 2**i
  }
  for _, value := range pow {
    fmt.Printf("%d\n", value)
  }
}
</code></pre>
</div></li>

</ul>

</section>
<section id="slide-orgd2e87d9">
<h3 id="orgd2e87d9">Mape</h3>
<ul>
<li>Mapiranje ključeva na vrednosti &#x2013; asocijativni niz</li>
<li>Nula vrednost je <code>nil</code></li>
<li><code>nil</code> mapa nema ključeve niti se ključevi mogu dodati</li>
<li><code>make</code> funkcija vraća inicijalizovanu mapu spremnu za upotrebu</li>

</ul>

<div class="org-src-container">

<pre><code class=" go" >package main

import "fmt"

type Vertex struct {
  Lat, Long float64
}

var m map[string]Vertex

func main() {
  m = make(map[string]Vertex)
  m["Bell Labs"] = Vertex{
    40.68433, -74.39967,
  }
  fmt.Println(m["Bell Labs"])
}
</code></pre>
</div>

</section>
<section id="slide-org9505a96">
<h3 id="org9505a96">Literali za mape</h3>
<div class="org-src-container">

<pre><code class=" go" >package main

import "fmt"

type Vertex struct {
  Lat, Long float64
}

var m = map[string]Vertex{
  "Bell Labs": Vertex{
    40.68433, -74.39967,
  },
  "Google": Vertex{
    37.42202, -122.08408,
  },
}

func main() {
  fmt.Println(m)
}
</code></pre>
</div>

</section>
<section>

<ul>
<li>Ime tipa literala se može izostaviti:</li>

</ul>

<div class="org-src-container">

<pre><code class=" go" >package main

import "fmt"

type Vertex struct {
  Lat, Long float64
}

var m = map[string]Vertex{
  "Bell Labs": {40.68433, -74.39967},
  "Google":    {37.42202, -122.08408},
}

func main() {
  fmt.Println(m)
}
</code></pre>
</div>

</section>
<section id="slide-orgbb13279">
<h3 id="orgbb13279">Izmena vrednosti mapa</h3>
<ul>
<li>postavljanje vrednosti</li>

</ul>
<div class="org-src-container">

<pre><code class=" go" >m[key] = elem
</code></pre>
</div>

<ul>
<li>čitanje vrednosti</li>

</ul>
<div class="org-src-container">

<pre><code class=" go" >elem = m[key]
</code></pre>
</div>

<ul>
<li>brisanje</li>

</ul>
<div class="org-src-container">

<pre><code class=" go" >delete(m, key)
</code></pre>
</div>

<ul>
<li>čitanje i provera da li element postoji</li>

</ul>
<div class="org-src-container">

<pre><code class=" go" >elem, ok = m[key]
</code></pre>
</div>
<p>
Ako element postoji <code>ok</code> će imati vrednost <code>true</code> inače <code>false</code>
</p>

</section>
<section>

<div class="org-src-container">

<pre><code class=" go" >package main

import "fmt"

func main() {
  m := make(map[string]int)

  m["Answer"] = 42
  fmt.Println("The value:", m["Answer"])

  m["Answer"] = 48
  fmt.Println("The value:", m["Answer"])

  delete(m, "Answer")
  fmt.Println("The value:", m["Answer"])

  v, ok := m["Answer"]
  fmt.Println("The value:", v, "Present?", ok)
}
</code></pre>
</div>

</section>
<section id="slide-org4053065">
<h3 id="org4053065">Funkcije kao vrednosti</h3>
<ul>
<li>Funkcije se u Go-u vrednosti takođe.</li>
<li>Mogu se čuvati kao varijable, prosleđivati kao parametri funkcije ili
dobijati nazad kao povratne vrednosti</li>

</ul>

<div class="org-src-container">

<pre><code class=" go" >package main

import (
  "fmt"
  "math"
)

func compute(fn func(float64, float64) float64) float64 {
  return fn(3, 4)
}

func main() {
  hypot := func(x, y float64) float64 {
    return math.Sqrt(x*x + y*y)
  }
  fmt.Println(hypot(5, 12))

  fmt.Println(compute(hypot))
  fmt.Println(compute(math.Pow))
}
</code></pre>
</div>

<pre  class="example">
13
5
81
</pre>

</section>
<section id="slide-orgddbf45a">
<h3 id="orgddbf45a">Zatvorenja (<i>Closures</i>)</h3>
<ul>
<li>Go funkcije mogu biti <i>zatvorenja</i> u smislu da funkcija može da referencira
vrednosti koje se nalaze izvan nje na mestu njenog kreiranja čak i kada se
pozove sa drugog mesta. Kažemo da su referencirane vrednosti "vezane" za
funkciju (<i>bounded</i>)</li>

</ul>

<div class="org-src-container">

<pre><code class=" go" >package main

import "fmt"

func adder() func(int) int {
  sum := 0
  return func(x int) int {
    sum += x
    return sum
  }
}

func main() {
  pos, neg := adder(), adder()
  for i := 0; i &lt; 10; i++ {
    fmt.Println(
      pos(i),
      neg(-2*i),
    )
  }
}
</code></pre>
</div>

</section>
</section>
<section>
<section id="slide-orgbd0b8d2">
<h2 id="orgbd0b8d2"><span class="todo TODO">TODO</span> Metode i interfejsi</h2>
<div class="outline-text-2" id="text-orgbd0b8d2">
</div>
</section>
<section id="slide-org9bc3faf">
<h3 id="org9bc3faf">Metode i interfejsi</h3>
<ul>
<li>Go nema klase ali se mogu definisati metode nad tipovima</li>
<li>Metoda je funkcija koja ima specijalni <i>receiver</i> parametar</li>

</ul>
<div class="org-src-container">

<pre><code class=" go" >package main

import "fmt"

func adder() func(int) int {
  sum := 0
  return func(x int) int {
    sum += x
    return sum
  }
}

func main() {
  pos, neg := adder(), adder()
  for i := 0; i &lt; 10; i++ {
    fmt.Println(
      pos(i),
      neg(-2*i),
    )
  }
}
</code></pre>
</div>

</section>
<section id="slide-org92d9315">
<h3 id="org92d9315">Metode su funkcije</h3>
<ul>
<li>Metode se u osnovi ponašaju kao obične funkcije</li>

</ul>

<div class="org-src-container">

<pre><code class=" go" >package main

import (
  "fmt"
  "math"
)

type Vertex struct {
  X, Y float64
}

func Abs(v Vertex) float64 {
  return math.Sqrt(v.X*v.X + v.Y*v.Y)
}

func main() {
  v := Vertex{3, 4}
  fmt.Println(Abs(v))
}
</code></pre>
</div>

</section>
<section>

<ul>
<li>Metode se ne moraju definisati samo nad strukturama. Na primer:</li>

</ul>

<div class="org-src-container">

<pre><code class=" go" >package main

import (
  "fmt"
  "math"
)

type MyFloat float64

func (f MyFloat) Abs() float64 {
  if f &lt; 0 {
    return float64(-f)
  }
  return float64(f)
}

func main() {
  f := MyFloat(-math.Sqrt2)
  fmt.Println(f.Abs())
}
</code></pre>
</div>

</section>
</section>
<section>
<section id="slide-orgfcb7f87">
<h2 id="orgfcb7f87"><span class="todo TODO">TODO</span> Konkurencija</h2>
</section>
</section>
<section>
<section id="slide-orgc5a5cf1">
<h2 id="orgc5a5cf1">Reference</h2>
<ul>
<li><a href="https://golang.org/doc/">Go Documentation</a></li>
<li><a href="https://tour.golang.org/">A Tour of Go</a></li>
<li><a href="https://golang.org/doc/code.html">How to Write Go Code</a></li>
<li><a href="https://github.com/golang/go/wiki">The Go Wiki</a></li>
<li><a href="https://splice.com/blog/iota-elegant-constants-golang/">iota: Elegant Constants in Golang</a></li>
<li><a href="https://golang.org/doc/effective_go.html">Effective Go</a></li>

</ul>
</section>
</section>
</div>
</div>
<script src="../../reveal.js/lib/js/head.min.js"></script>
<script src="../../reveal.js/js/reveal.js"></script>
<script>
// Full list of configuration options available here:
// https://github.com/hakimel/reveal.js#configuration
Reveal.initialize({

controls: true,
progress: true,
history: false,
center: true,
slideNumber: 'h/v',
rollingLinks: false,
keyboard: true,
mouseWheel: false,
fragmentInURL: true,
pdfSeparateFragments: true,

overview: true,
width: 1400,
height: 1000,
minScale: 0.30,
maxScale: 4.00,

theme: Reveal.getQueryHash().theme, // available themes are in /css/theme
transition: Reveal.getQueryHash().transition || 'convex', // see README of reveal.js for options
transitionSpeed: 'default',

// Optional libraries used to extend on reveal.js
dependencies: [
 { src: '../../reveal.js/plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } }]
});
</script>
</body>
</html>
