<!DOCTYPE html>
<html>
  <head>
    <title>Napredne tehnike programiranja</title>
    <meta charset="utf-8">
    <link rel="stylesheet" href="../remarkslides.css">
    
    <!-- google analytics -->
    <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
      ga('create', 'UA-68681917-1', 'auto');
      ga('send', 'pageview');
    </script>
  </head>
  <body>
    <textarea id="source">

class: center, middle

# Napredne tehnike programiranja
## Napredni Python


.author[[Igor Dejanović](http://igordejanovic.net/)]

.small[[Fakultet tehničkih nauka u Novom Sadu](http://ftn.uns.ac.rs/)</br> [Katedra za informatiku](http://informatika.ftn.uns.ac.rs/)]


.small[Slajdovi u izradi]


.created[28.02.2017 u 20:50]


---

name: sadrzaj

# Sadržaj

- [Specijalne metode](#specijalne-metode)
- [Properties](#properties)
- [Descriptors](#descriptors)
- [functools](#functools)
- [itertools](#itertools)
- [collections](#collections)



---
name: specijalne-metode
class: center, middle
layout: false

# Specijalne metode

---
layout: true

.section[[Specijalne metode](#sadrzaj)]

---

## Specijalne metode

- Često se zovu i *magične* metode.
- Posebno se tretiraju od strane Python interpretera. Imaju posebnu semantiku.
- Format naziva je `__xxx__`.
- Neki od primera:
  - `__init__`
  - `__str__`
  - `__eq__`
  - `...`
- Implementacija *protokola*


---
## Iterabilni objekti

- Moguće ih je koristiti u npr. `for` pelji.
```
for i in iterabilni_objekat:
    ...
```
- Poziv ugrađene funkcije `iter` nad iterabilnim objektom vraća iterator
  objekat.
- Kada je potrebna iteracija Python poziva `__iter__` metodu nad našim objektom.
  Ova funkcija treba da vrati iterator objekat.
- Iterator objekti implementiraju tzv. `iterator` protokol.
  - `__next__` metoda -- sledeći element ili izuzetak `StopIteration` ukoliko
    smo stigli do kraja.

---

## Iterabilni objekti - primer

- Primer `TextXMetaModel` klasa [textX](https://github.com/igordejanovic/textX)
  projekta.

```python
def __iter__(self):
    """
    Iterate over all classes in the current namespace and imported
    namespaces.
    """

    # Current namespace
    for name in self._current_namespace:
        yield self._current_namespace[name]

    # Imported namespaces
    for namespace in \
            self._imported_namespaces[self._namespace_stack[-1]]:
        for name in namespace:
            # yield class
            yield namespace[name]
```

- U ovom slučaju `__iter__` metoda je generator (vraća elemente sa `yield`).

---
## Provera pripadnosti kolekciji

- Operator `in` služi za testiranje pripadnosti:

```python
if a in neka_kolekcija:
   ...
```

- Ukoliko želimo da omogućimo `in` test sa našim objektima potrebno je
  definisati specijalnu metodu `__contains__`:

```python
def __contains__(self, name):
    """
    Check if given name is contained in the current namespace.
    The name can be fully qualified.
    """
    try:
        self[name]
        return True
    except KeyError:
        return False
```

---
## Pristup elementu kolekcije po ključu

- Specijalna metoda `__getitem__` omogućava upotrebu operatora `[]`.

```python
>>> a = [1, 2, 3]
>>> a.__getitem__(2)
3
>>> b = { "foo": 45, "bar": 34}
>>> b.__getitem__(34)
---------------------------------------------------------------------------
KeyError                                  Traceback (most recent call last)
...
KeyError: 34
>>> b.__getitem__("foo")
45

```

---
## Pristup elementu kolekcije po ključu - primer

```python
def __getitem__(self, name):
    """
    Search for and return class and peg_rule with the given name.
    Returns:
        TextXClass, ParsingExpression
    """
    if "." in name:
        # Name is fully qualified
        namespace, name = name.rsplit('.', 1)
        return self.namespaces[namespace][name]
    else:
        # If not fully qualified search in the current namespace
        # and after that in the imported_namespaces
        if name in self._current_namespace:
            return self._current_namespace[name]

        for namespace in \
                self._imported_namespaces[self._namespace_stack[-1]]:
            if name in namespace:
                return namespace[name]

        raise KeyError("{} metaclass does not exists in the metamodel "
                        .format(name))
```

---
## Pristup atributu objekta

- Dve specijalne metode: `__getattr__` i `__getattribute__`

```python
obj.neki_atribut
```

---
## `__getattr__`

- Poziva se ukoliko standardnim mehanizmima nije pronađen atribut objekta. Kao
  parametar prima ime atributa i vraća njegovu vrednost ukoliko postoji ili
  podiže izuzetak `AttributeError` ukoliko atribut ne postoji.
  
```python
class A:
    def __init__(self):
        self.additional = {'foo': 5, 'bar': 7.4}
        # .a će biti pronađeno standardnim mehanizmom
        self.a = 3

    def __getattr__(self, key):
        if key in self.additional:
            return self.additional[key]
        else:
            raise AttributeError

if __name__ == '__main__':
    a = A()
    print(a.a)
    print(a.foo)
    print(a.bla)
```

---
## Postavljanje vrednosti i brisanje atributa

- `object.__setattr__(self, name, value)` - kada se pozove `object.name = value`
  - Obratiti pažnju na rekurziju! Ne raditi u telu metode `self.name = value`
    već `self.__dict__[name] = value`.

- `object.__delattr__(self, name)` - kada se pozove `del object.name`

---
## `__getattribute__`

- Specijalna metoda nižeg nivoa.
- Podrazumevana implementacija obavlja podrazumevanu pretragu:
  - Prvo se proverava `__dict__` rečnik instance a zatim klasa prateći MRO lanac.
  - Ukoliko se atribut ne pronađe poziva se `__getattr__`
- Ovu metodu je retko potrebno redefinisati.
- Paziti prilikom pisanja na beskonačanu rekurziju! Najbolje je pozvati
  na kraju nadimplementaciju `object.__getattribute__(self, name)`

---
## Operatori

- Svi operatori u Python-u su definisani specijalnim metodama. Na primer:
  - `-` - `__sub__`
  - `+` - `__add__`
  - `*` - `__mul__`
  - `+=` - `__iadd__` - (za *mutable* objekte)
  - ...
  
  
---
## Poređenje objekata

- Ukoliko želimo da instance naše klase mogu da se porede (npr. da bi mogli da
  sortiramo niz objekata) potrebno je implementirati specijalne metode:
  - `__eq__` za operator jednakosti `==`
  - `__ne__` za operator nejednakosti `!=`
  - `__lt__` za operator *manje* - `<`
  - `__le__` za operator *manje ili jednako* - `<=`
  - `__gt__` za operator *veće* - `>`
  - `__ge__` za operator *veće ili jednako* - `>=`
- Nije potrebno ručno definisati sve operatore jer su prirodno međuzavisni.
  Python u sklopu modula `functools` nudi dekorator `total_ordering` (videti u
  sekciji `functools`) koji automatski kreira nedostajuće operatore poređenja.
  

---
name: properties
class: center, middle
layout: false

# *Properties*

---
layout: true

.section[[Properties](#sadrzaj)]

---

## *Properties*

- Tzv. kalkulisani ili izvedeni atributi.
- Generalizacija *getter* i *setter* mehanizma.
- Sintaksa ostaje kao kod direktnog pristupa atributu.

---

## *Properties* - primer

```python

class ...:
...
    @property
    def full_file_name(self):
        return os.path.join(self.file_path, self.file_name)

    @full_file_name.setter
    def full_file_name(self, filename):
        path_name, file_name = os.path.split(filename)
        self.file_path = path_name
        self.file_name = file_name
        model_name, __ = os.path.splitext(file_name)
        self.name = model_name
```

*Property* atributima se pristupa kao običnim atributima:
```python
obj.full_file_name = '/neka/putanja/neko_ime.ext'
```

- Objekat čuva atribute `file_path` i `file_name`.
- Atribut `full_file_name` je izveden.


---
name: descriptors
class: center, middle
layout: false

# Deskriptori

---
layout: true

.section[[Descriptors](#sadrzaj)]

---

## *Descriptors*

- Generalizacija prilagođavanja pristupu atributima objekata.
- Npr. *properties* iz prethodne sekcije su implementirani mehanizmom
  deskriptora.
- Ukoliko interpreter pronađe atribut na nivou klase i taj atribut je objekat
  koji ima neku od metoda `__get__`, `__set__`, `__del__` tada će ovim metodama
  biti prosleđeno dobavljanje, postavljanje ili brisanje atributa respektivno.
  
---
## Problem sa *properties*

.medium[
```python
class Movie(object):
    def __init__(self, title, rating, runtime, budget, gross):
        self._budget = None

        self.title = title
        self.rating = rating
        self.runtime = runtime
        self.gross = gross
        self.budget = budget
        
    @property
    def budget(self):
        return self._budget
    
    @budget.setter
    def budget(self, value):
        if value < 0:
            raise ValueError("Negative value not allowed: %s" % value)
        self._budget = value
        
    def profit(self):
        return self.gross - self.budget

    
m = Movie('Casablanca', 97, 102, 964000, 1300000)
print m.budget       # calls m.budget(), returns result
try:
    m.budget = -100  # calls budget.setter(-100), and raises ValueError
except ValueError:
    print "Woops. Not allowed"
```
]


.footer.small[
Chris Beaumont: [Python Descriptors Demystified](http://nbviewer.jupyter.org/urls/gist.github.com/ChrisBeaumont/5758381/raw/descriptor_writeup.ipynb)
]

---
# Rešenje upotrebom deskriptora (1)

```python
from weakref import WeakKeyDictionary

class NonNegative(object):
    """A descriptor that forbids negative values"""
    def __init__(self, default):
        self.default = default
        self.data = WeakKeyDictionary()
        
    def __get__(self, instance, owner):
        # we get here when someone calls x.d, and d is a NonNegative instance
        # instance = x
        # owner = type(x)
        return self.data.get(instance, self.default)
    
    def __set__(self, instance, value):
        # we get here when someone calls x.d = val, and d is a NonNegative instance
        # instance = x
        # value = val
        if value < 0:
            raise ValueError("Negative value not allowed: %s" % value)
        self.data[instance] = value
```

.footer.small[
Chris Beaumont: [Python Descriptors Demystified](http://nbviewer.jupyter.org/urls/gist.github.com/ChrisBeaumont/5758381/raw/descriptor_writeup.ipynb)
]

---
# Rešenje upotrebom deskriptora (2)

.medium[
```python
class Movie(object):
    
    #always put descriptors at the class-level
    rating = NonNegative(0)
    runtime = NonNegative(0)
    budget = NonNegative(0)
    gross = NonNegative(0)
    
    def __init__(self, title, rating, runtime, budget, gross):
        self.title = title
        self.rating = rating
        self.runtime = runtime
        self.budget = budget
        self.gross = gross
    
    def profit(self):
        return self.gross - self.budget
    
    
m = Movie('Casablanca', 97, 102, 964000, 1300000)
print m.budget  # calls Movie.budget.__get__(m, Movie)
m.rating = 100  # calls Movie.budget.__set__(m, 100)
try:
    m.rating = -1   # calls Movie.budget.__set__(m, -100)
except ValueError:
    print "Woops, negative value"
```
]

.footer.small[
Chris Beaumont: [Python Descriptors Demystified](http://nbviewer.jupyter.org/urls/gist.github.com/ChrisBeaumont/5758381/raw/descriptor_writeup.ipynb)
]

---
layout: false
name: pregled
class: center, middle

# `functools` modul
## Podrška za funkcije višeg reda.

---
layout: true

.section[[functools](#sadrzaj)]

---
## `partial`

- Delimična (parcijalna) primena funkcije.
- Određeni parametri se *zamrzavaju*. Nova funkcija prihvata manji broj
  parametara.
  
```python
>>> from functools import partial
>>> basetwo = partial(int, base=2)
>>> basetwo.__doc__ = 'Konverzija stringa broja u bazi 2 u int.'
>>> basetwo('10010')
18

>>> stepen = lambda a, b: a ** b
>>> kvadrat = partial(stepen, b=2)
>>> kvadrat(5)
25
>>> kub = partial(stepen, b=3)
>>> kub(5)
125

>>> from operator import mul
>>> dvaputa = partial(mul, 2)
>>> dvaputa(10)
20
>>> triputa = partial(mul, 3)
>>> triputa(5)
15
```

---
## `reduce`

- Primena date funkcije koja prima dva parametra na iterabilnu kolekciju s leva
  na desno tako što se kao prvi parametar koristi rezultat prethodne evaluacije
  dok se kao drugi parametar koristi sledeći element kolekcije.
  
```python
reduce(lambda x, y: x+y, [1, 2, 3, 4, 5])
```
izračunava
```
(((1+2)+3)+4)+5)
```

- Postoji i kao ugrađena (*build-in*) funkcija u Python 2.
---
## `reduce` ekvivalentan Python kod

```python
def reduce(function, iterable, initializer=None):
    it = iter(iterable)
    if initializer is None:
        try:
            initializer = next(it)
        except StopIteration:
            raise TypeError('reduce() of empty sequence with no initial value')
    accum_value = initializer
    for x in it:
        accum_value = function(accum_value, x)
    return accum_value
```

---
## Primer: množenje niza elemenata

```python
niz = range(1, 10)
```

`for` petlja:
```python
proizvod = 1
for elem in niz:
    proizvod *= elem
```

`reduce`:
```python
proizvod = reduce(lambda x, y: x*y, niz)
```

---
## Kreiranje funkcije za množenje niza elemenata

Kompozicija funkcija `partial` + `reduce` (funkcionalno):
```python
from functools import reduce, partial
amul = partial(reduce, lambda x, y: x*y)
# ili upotrebom mul operatora
from operator import mul
amul = partial(reduce, mul)
```

Sa `for` petljom (imperativno):
```
def amul(niz):
  proizvod = 1
  for elem in niz:
      proizvod *= elem
  return proizvod
```

Oba primera kreiraju funkciju `amul` koja množi elemente prosleđenog iterabilnog
objekta:
```python
amul(range(1, 100))
```

---
## `total_ordering`

- "Dopuna" specijalnih metoda za poređenje. Koristi se kao dekorator klase.
- Klasa treba da definiše jednu od `__lt__`, `__le__`, `__gt__`, ili `__ge__()`
  metoda uz `__eq__`.

```python
@total_ordering
class Student:
    def __eq__(self, other):
        return ((self.lastname.lower(), self.firstname.lower()) ==
                (other.lastname.lower(), other.firstname.lower()))
    def __lt__(self, other):
        return ((self.lastname.lower(), self.firstname.lower()) <
                (other.lastname.lower(), other.firstname.lower()))
```


.footer.small[
https://docs.python.org/2/library/functools.html
]

---
## `update_wrapper` i `wraps`

- Kod dekoracije funkcija ažurira dekorisanu funkciju da spolja "izgleda" kao
  originalna.
  
```python
```


---
name: itertools
class: center, middle
layout: false

# `itertools` modul
## Pomoćne funkcije za iteraciju

---
layout: true

.section[[itertools](#sadrzaj)]

---

## `chain`

- Iteracije kroz više iterabilnih objekata prema zadatom redosledu.
- Tretiranje niza sekvenci kao jedne sekvence.

Ekvivalentno sa sledećim Python kodom:
```python
def chain(*iterables):
    for it in iterables:
        for element in it:
            yield element
```

Upotreba:

```python
a = [1, 2, 3]
b = 'abc'
for i in chain(a, b):
    print(i)
```

---
## `cycle`

- Beskonačna iteracija kroz zadati iterabilni objekat *u krug*.

Ekvivalentno sa:

```python
def cycle(iterable):
    # cycle('ABCD') --> A B C D A B C D A B C D ...
    saved = []
    for element in iterable:
        yield element
        saved.append(element)
    while saved:
        for element in saved:
              yield element
```

---
## `ifilter`

- Kreira iterator koji filtrira i vraća samo one elemente zadatog iterabilnog
  objekta koji zadovoljavaju određeni predikat.
  
Ekvivalentno sa:
```python
def ifilter(predicate, iterable):
    # ifilter(lambda x: x%2, range(10)) --> 1 3 5 7 9
    if predicate is None:
        predicate = bool
    for x in iterable:
        if predicate(x):
            yield x
```

---
## `imap`

- Kreira iterator koji vraća vrednost zadate funkcije gde se parametri uzimaju
  iz zadatih iterabilnih objekata.

Ekvivalentno sa:

```python
def imap(function, *iterables):
    # imap(pow, (2,3,10), (5,2,3)) --> 32 9 1000
    iterables = map(iter, iterables)
    while True:
        args = [next(it) for it in iterables]
        if function is None:
            yield tuple(args)
        else:
            yield function(*args)
```

---
## `izip`

---
## `groupby`

---
## `dropwhile`

---
## `takewhile`

---
## `tee`


---
name: collections
class: center, middle
layout: false

# collections
## High-performance container datatypes

---
layout: true

.section[[collections](#sadrzaj)]

---
## OrderedDict


---
## namedtuple

---
## deque

---
## Counter

---
## defaultdict




    </textarea>
    <script src="../remark-latest.min.js"></script>
    <script>
        // https://github.com/gnab/remark/issues/72
        remark.macros.scale = function (percentage) {
            var url = this;
            return '<div class="center"><img src="'
                 + url + '" style="width: ' + percentage + '" /></div>';
        };
        var slideshow = remark.create({
                    highlightLanguage: 'python',
                    // highlightStyle: 'obsidian',
                    highlightStyle: 'github',
                    highlightLines: true
                });
    </script>
    
  </body>
</html>
